# Phase 41.2: Internal Plasma Core - Research

**Researched:** 2026-01-18
**Status:** Complete

---

## Executive Summary

Implementing animated internal plasma requires **FBM (Fractal Brownian Motion)** noise combined with **domain warping** for organic cloud-like movement. The recommended approach uses **drei's shaderMaterial** helper with either **gl-Noise** or **LYGIA** shader libraries for noise functions, animated via Three.js time uniforms.

---

## Standard Stack

### Noise Library: gl-Noise (Recommended)

**Why**: NPM package, TypeScript support, easy Three.js integration, well-documented.

```bash
npm install gl-noise
```

**Integration Pattern:**
```javascript
import { Perlin, Simplex, Common } from "gl-noise"
import { patchShaders } from "gl-noise"

// Patch shaders to include noise functions
const chunks = [[Perlin, Simplex], null]  // [vertex chunks, fragment chunks]
const [patchedVS, patchedFS] = await patchShaders(
  [vertexShader, fragmentShader],
  chunks
)
```

**Available Functions:**
- `gln_perlin(vec2/vec3)` - Classic Perlin noise
- `gln_simplex(vec2/vec3)` - Simplex noise (faster, fewer artifacts)
- `gln_fbm(vec2/vec3)` - Built-in FBM helper

### Alternative: LYGIA Shader Library

**Why**: Comprehensive, production-proven, used by Patricio Gonzalez Vivo (Book of Shaders author).

```glsl
// Include via resolve-lygia or CDN
#include "lygia/generative/pnoise.glsl"
#include "lygia/generative/snoise.glsl"
#include "lygia/generative/fbm.glsl"
```

**Integration with resolve-lygia:**
```javascript
import { resolveLygia } from 'resolve-lygia'

const shader = resolveLygia(/* glsl */`
  #include "lygia/generative/snoise.glsl"
  void main() {
    float n = snoise(vec3(vUv * 4.0, uTime * 0.1));
    gl_FragColor = vec4(vec3(n * 0.5 + 0.5), 1.0);
  }
`)
```

### Shader Material: drei shaderMaterial

**Why**: Declarative, React-friendly, automatic uniform handling, TypeScript support.

```tsx
import { shaderMaterial } from '@react-three/drei'
import { extend, useFrame } from '@react-three/fiber'
import * as THREE from 'three'

const PlasmaMaterial = shaderMaterial(
  // Uniforms
  {
    uTime: 0,
    uEnergy: 0.5,
    uColor: new THREE.Color(0.5, 0.0, 0.8),  // Purple base
  },
  // Vertex Shader
  /*glsl*/`
    varying vec2 vUv;
    varying vec3 vNormal;
    varying vec3 vViewPosition;

    void main() {
      vUv = uv;
      vNormal = normalize(normalMatrix * normal);
      vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
      vViewPosition = -mvPosition.xyz;
      gl_Position = projectionMatrix * mvPosition;
    }
  `,
  // Fragment Shader
  /*glsl*/`
    uniform float uTime;
    uniform float uEnergy;
    uniform vec3 uColor;

    varying vec2 vUv;
    varying vec3 vNormal;
    varying vec3 vViewPosition;

    // Noise functions injected here by gl-noise or inline

    void main() {
      // Plasma implementation here
      gl_FragColor = vec4(uColor, 1.0);
    }
  `
)

extend({ PlasmaMaterial })

// Usage in component
function PlasmaRing({ energy }) {
  const materialRef = useRef()

  useFrame((state) => {
    materialRef.current.uTime = state.clock.elapsedTime
    materialRef.current.uEnergy = energy
  })

  return (
    <mesh>
      <torusGeometry args={[1, 0.35, 96, 64]} />
      <plasmaMaterial ref={materialRef} transparent />
    </mesh>
  )
}
```

---

## Core Techniques

### 1. Fractal Brownian Motion (FBM)

**What**: Layered noise at increasing frequencies, creating organic complexity.

**Key Parameters:**
| Parameter | Default | Effect |
|-----------|---------|--------|
| `octaves` | 4-6 | Detail layers (more = finer detail, slower) |
| `lacunarity` | 2.0 | Frequency multiplier per octave |
| `gain` | 0.5 | Amplitude reduction per octave (persistence) |

**GLSL Implementation:**
```glsl
float fbm(vec3 p) {
    float value = 0.0;
    float amplitude = 0.5;
    float frequency = 1.0;

    for (int i = 0; i < 6; i++) {
        value += amplitude * snoise(p * frequency);
        frequency *= 2.0;      // lacunarity
        amplitude *= 0.5;      // gain/persistence
    }

    return value;
}
```

### 2. Domain Warping

**What**: Feed noise output back as input offset, creating flowing cloud-like distortion.

**Pattern** (from Book of Shaders):
```glsl
// Simple warping
vec3 warpedPos = p + fbm(p);
float n = fbm(warpedPos);

// Double warping for more complexity
vec3 q = vec3(
    fbm(p + vec3(0.0, 0.0, 0.0)),
    fbm(p + vec3(5.2, 1.3, 0.0)),
    fbm(p + vec3(0.0, 0.0, 0.0))
);
float n = fbm(p + q);

// Triple warping for maximum organic feel (expensive!)
vec3 r = vec3(
    fbm(p + 4.0 * q + vec3(1.7, 9.2, 0.0)),
    fbm(p + 4.0 * q + vec3(8.3, 2.8, 0.0)),
    fbm(p + 4.0 * q + vec3(0.0, 0.0, 0.0))
);
float n = fbm(p + 4.0 * r);
```

### 3. Time-Based Animation

**Pattern**: Offset position by time in consistent direction for flow effect.

```glsl
// Slow churning flow
vec3 animatedPos = vec3(
    vUv.x,
    vUv.y,
    uTime * 0.05  // Very slow for hypnotic feel
);

// Spiral/swirl motion
float angle = uTime * 0.1;
vec2 rotatedUV = mat2(cos(angle), -sin(angle), sin(angle), cos(angle)) * (vUv - 0.5) + 0.5;
```

### 4. Fresnel-Based Depth Illusion

**What**: Make plasma appear "inside" glass by fading at grazing angles.

```glsl
// Calculate fresnel term
vec3 viewDir = normalize(vViewPosition);
float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 3.0);

// Plasma more visible when looking straight at surface
// Fades at edges (where glass rim lighting dominates)
float plasmaVisibility = 1.0 - fresnel;

// Combine with plasma
vec3 finalColor = mix(glassColor, plasmaColor, plasmaVisibility * plasmaIntensity);
```

### 5. Energy-Driven Parameters

**Mapping energy (0-1) to visual properties:**

```glsl
uniform float uEnergy;  // 0.0 = dormant, 0.5 = active, 1.0 = max

// Speed: slow churning → rapid movement
float flowSpeed = mix(0.02, 0.15, uEnergy);

// Color temperature: dark purple → bright violet/white
vec3 dormantColor = vec3(0.1, 0.0, 0.15);   // Near-black purple
vec3 activeColor = vec3(0.5, 0.0, 0.8);     // Vibrant purple
vec3 maxColor = vec3(0.8, 0.6, 1.0);        // Bright violet-white

vec3 plasmaColor = uEnergy < 0.5
    ? mix(dormantColor, activeColor, uEnergy * 2.0)
    : mix(activeColor, maxColor, (uEnergy - 0.5) * 2.0);

// Intensity: subtle → intense
float intensity = mix(0.2, 1.0, uEnergy);

// FBM octaves could also vary (fewer when dormant for performance)
```

---

## Integration with Existing Shader

The current `RingMesh.tsx` uses a glassmorphism shader via `createRingShader()`. The plasma effect should be **integrated into the existing shader**, not replace it.

**Approach:**
1. Add plasma noise calculation to fragment shader
2. Blend plasma with existing glass color based on fresnel (depth illusion)
3. Add `uTime` uniform for animation
4. Energy uniform already exists (`energyLevel`)

**Shader Architecture:**
```
┌─────────────────────────────────────────┐
│           Fragment Shader               │
├─────────────────────────────────────────┤
│  1. Calculate UV / position             │
│  2. Generate plasma via FBM + warping   │
│  3. Calculate fresnel for glass         │
│  4. Blend: glass rim + internal plasma  │
│  5. Apply energy-based color/intensity  │
│  6. Output final color                  │
└─────────────────────────────────────────┘
```

---

## Don't Hand-Roll

| Component | Use Instead | Why |
|-----------|-------------|-----|
| Noise functions | gl-Noise, LYGIA, or verified gist | Complex math, easy to introduce artifacts |
| Permutation tables | Library defaults | Needs specific values for smooth gradients |
| FBM helper | Library or Book of Shaders reference | Parameter tuning is tricky |

**Verified Noise Function Sources:**
1. [Patricio Gonzalez Vivo's Gist](https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83) - Classic implementations
2. [gl-Noise npm package](https://github.com/FarazzShaworki/gl-noise) - Modern, typed
3. [LYGIA Shader Library](https://lygia.xyz/) - Comprehensive, production-ready

---

## Common Pitfalls

### Performance

| Issue | Solution |
|-------|----------|
| Too many FBM octaves | Start with 4, max 6 for mobile |
| Domain warping expensive | Use single warp, not triple |
| Shader compilation time | Avoid dynamic loops if possible |
| Frame rate drops | Reduce octaves at low energy (when less visible) |

**Performance Budget:**
- Target: 60fps on M1 Mac, 30fps on mobile
- Max octaves: 6 desktop, 4 mobile
- Single domain warp preferred

### Visual Quality

| Issue | Solution |
|-------|----------|
| Noise looks tiled/repeating | Increase frequency, use 3D noise with time as Z |
| Harsh edges | Smooth interpolation, fresnel blending |
| Doesn't look "inside" | Stronger fresnel fade at edges |
| Movement too fast/slow | Start very slow (0.02-0.05), tune from there |
| Plasma dominates glass | Reduce intensity, increase fresnel fade |

### Output Ranges

| Noise Type | Output Range | Normalization |
|------------|--------------|---------------|
| Simplex | ~[-1, 1] | `n * 0.5 + 0.5` |
| Classic Perlin | ~[-2.3, 2.3] | `n * 0.2 + 0.5` or clamp |
| FBM | Varies by octaves | Test and adjust |

---

## Reference Implementation Sketch

```glsl
// Fragment shader addition for plasma

// Simplex noise function (from gl-Noise or inline)
float snoise(vec3 v);

// FBM with domain warping
float plasma(vec3 p, float time, float energy) {
    // Animate position
    vec3 animP = p + vec3(0.0, 0.0, time * mix(0.02, 0.15, energy));

    // Domain warp for organic feel
    vec3 warp = vec3(
        snoise(animP * 2.0),
        snoise(animP * 2.0 + vec3(5.2, 1.3, 0.0)),
        snoise(animP * 2.0 + vec3(9.7, 4.1, 0.0))
    );

    // FBM on warped coordinates
    float value = 0.0;
    float amp = 0.5;
    float freq = 1.0;
    vec3 q = animP + warp * 0.5;

    for (int i = 0; i < 5; i++) {
        value += amp * snoise(q * freq);
        freq *= 2.0;
        amp *= 0.5;
    }

    return value * 0.5 + 0.5;  // Normalize to 0-1
}

void main() {
    // ... existing glass calculations ...

    // Calculate plasma
    vec3 plasmaPos = vec3(vUv, 0.0);
    float plasmaValue = plasma(plasmaPos, uTime, uEnergy);

    // Energy-driven color
    vec3 dormantColor = vec3(0.1, 0.0, 0.15);
    vec3 activeColor = vec3(0.5, 0.0, 0.8);
    vec3 maxColor = vec3(0.8, 0.6, 1.0);

    vec3 plasmaColor = uEnergy < 0.5
        ? mix(dormantColor, activeColor, uEnergy * 2.0)
        : mix(activeColor, maxColor, (uEnergy - 0.5) * 2.0);

    // Fresnel-based depth: plasma fades at grazing angles
    float plasmaVisibility = (1.0 - fresnel) * plasmaValue * mix(0.2, 1.0, uEnergy);

    // Blend plasma with glass
    vec3 finalColor = mix(glassColor, plasmaColor, plasmaVisibility);

    gl_FragColor = vec4(finalColor, glassAlpha);
}
```

---

## Verification Checklist

- [x] Noise library options identified (gl-Noise, LYGIA)
- [x] FBM technique documented with parameters
- [x] Domain warping pattern captured
- [x] Time animation approach defined
- [x] Fresnel depth illusion technique found
- [x] Energy mapping for color/speed documented
- [x] Integration approach with existing shader planned
- [x] Performance pitfalls identified
- [x] Don't hand-roll list complete
- [x] Reference implementation sketched

---

## Sources

- [The Book of Shaders - FBM](https://thebookofshaders.com/13/)
- [Patricio Gonzalez Vivo's Noise Gist](https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83)
- [gl-Noise GitHub](https://github.com/FarazzShaworki/gl-noise)
- [LYGIA Shader Library](https://lygia.xyz/)
- [drei shaderMaterial](https://github.com/pmndrs/drei)
- [Three.js ShaderMaterial Docs](https://threejs.org/docs/#api/en/materials/ShaderMaterial)

---

*Phase: 41.2-internal-plasma-core*
*Research completed: 2026-01-18*
