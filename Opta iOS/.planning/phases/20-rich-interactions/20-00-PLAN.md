# Plan 20-00: WebGL & Shader Foundation

**Phase:** 20 - Rich Interactions
**Feature:** WebGL Infrastructure for Premium Visual Effects
**Scope:** Medium (2-3 days)
**Dependencies:** None (foundation plan)

---

## Summary

Install Three.js / react-three-fiber and create the shader utility layer for premium visual effects. Implements SweepGradient shader for neon borders and glass effect shader (blur + noise + specular with rotating light source) based on Gemini "Neon Luminal Glassmorphism" research.

---

## Why This Matters

- **Premium differentiation** - Shader-based effects impossible with CSS alone
- **"Traveling Neon" border** - Requires SweepGradient shader, not CSS gradients
- **Optical glass simulation** - Progressive blur + noise + specular highlights
- **120fps performance** - GPU-accelerated rendering
- **Foundation for Phase 21** - Visualization effects build on this

---

## Gemini Research Context

From Premium App UI/UX Investigation:
- "The 'traveling neon' effect requires WebGL SweepGradient shader - CSS gradients are too static"
- "Glass Implementation Stack: Backdrop → Blur Pass → Noise Overlay → Specular Highlight"
- "Specular highlights need rotating light source for premium feel"
- "Neon 'Halation' Effect: core color (bright white/purple) + corona (saturated hue, exponential fade)"

---

## Implementation Tasks

### Task 1: Install Three.js and react-three-fiber
**File:** `package.json`

**Actions:**
1. Install core packages: `npm install three @react-three/fiber @react-three/drei`
2. Install TypeScript types: `npm install -D @types/three`
3. Verify installation and TypeScript integration

**Verification:** Packages installed, no type errors on import

---

### Task 2: Create shader utility directory structure
**File:** `src/lib/shaders/`

**Actions:**
1. Create `src/lib/shaders/` directory
2. Create `src/lib/shaders/index.ts` barrel export
3. Create `src/lib/shaders/types.ts` for shader uniform types
4. Create `src/lib/shaders/utils.ts` for common shader utilities

**Directory structure:**
```
src/lib/shaders/
├── index.ts              # Barrel exports
├── types.ts              # TypeScript types for uniforms
├── utils.ts              # Common shader utilities
├── glass.glsl            # Glass effect fragment shader
├── neonBorder.glsl       # Neon border fragment shader
├── noise.glsl            # Noise generation utilities
├── chromaticAberration.glsl  # Chromatic aberration effect
└── ChromaticShader.ts    # TypeScript wrapper
```

**Verification:** Directory structure created, TypeScript compiles

---

### Task 3: Create noise generation shader
**File:** `src/lib/shaders/noise.glsl`

**Actions:**
1. Implement Simplex noise function for grain texture
2. Create reusable noise uniform declarations
3. Document noise parameters

**Shader code:**
```glsl
// src/lib/shaders/noise.glsl
// Simplex 2D noise for grain texture
vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }

float snoise(vec2 v) {
  const vec4 C = vec4(0.211324865405187, 0.366025403784439,
           -0.577350269189626, 0.024390243902439);
  vec2 i  = floor(v + dot(v, C.yy));
  vec2 x0 = v -   i + dot(i, C.xx);
  vec2 i1;
  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;
  i = mod(i, 289.0);
  vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))
    + i.x + vec3(0.0, i1.x, 1.0));
  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),
    dot(x12.zw,x12.zw)), 0.0);
  m = m*m;
  m = m*m;
  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;
  m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
  vec3 g;
  g.x = a0.x * x0.x + h.x * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}
```

**Verification:** Noise function produces smooth gradient, no artifacts

---

### Task 4: Create glass effect shader
**File:** `src/lib/shaders/glass.glsl`, `src/lib/shaders/GlassShader.ts`

**Actions:**
1. Implement 4-layer glass effect per Gemini spec
2. Add uniforms for blur amount, noise intensity, specular position
3. Create animatable specular highlight with rotating light source
4. Support progressive blur (fades at edges)

**Glass layers (per Gemini):**
```
Layer 1: Backdrop (sampled from texture)
Layer 2: Blur Pass (Gaussian, animatable 0-20px)
Layer 3: Noise Overlay (Soft Light blend, prevents banding)
Layer 4: Specular Highlight (rotating conical gradient)
```

**TypeScript wrapper:**
```typescript
// src/lib/shaders/GlassShader.ts
import { ShaderMaterial, Vector2, Color } from 'three';
import glassFragmentShader from './glass.glsl?raw';

export interface GlassUniforms {
  uBackdrop: { value: THREE.Texture | null };
  uBlurAmount: { value: number };
  uNoiseIntensity: { value: number };
  uSpecularPosition: { value: Vector2 };
  uSpecularColor: { value: Color };
  uTime: { value: number };
  uResolution: { value: Vector2 };
}

export function createGlassShader(): ShaderMaterial {
  return new ShaderMaterial({
    uniforms: {
      uBackdrop: { value: null },
      uBlurAmount: { value: 12.0 },
      uNoiseIntensity: { value: 0.03 },
      uSpecularPosition: { value: new Vector2(0.3, 0.2) },
      uSpecularColor: { value: new Color(1, 1, 1) },
      uTime: { value: 0 },
      uResolution: { value: new Vector2(1, 1) },
    },
    fragmentShader: glassFragmentShader,
    transparent: true,
  });
}
```

**Verification:** Glass effect renders with all 4 layers, specular rotates with time

---

### Task 5: Create neon border shader (SweepGradient)
**File:** `src/lib/shaders/neonBorder.glsl`, `src/lib/shaders/NeonBorderShader.ts`

**Actions:**
1. Implement SweepGradient (conic gradient) shader
2. Add animatable rotation for "traveling light" effect
3. Implement neon halation (core + corona exponential fade)
4. Support rounded rectangle SDF for border shape

**Shader code pattern:**
```glsl
// Neon border with traveling light effect
uniform float uTime;
uniform float uBorderRadius;
uniform float uBorderWidth;
uniform vec3 uNeonColor;
uniform float uGlowIntensity;

// Signed distance function for rounded rectangle
float sdRoundedRect(vec2 p, vec2 size, float radius) {
  vec2 q = abs(p) - size + radius;
  return min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - radius;
}

void main() {
  vec2 uv = vUv * 2.0 - 1.0;

  // Calculate distance to border
  float dist = sdRoundedRect(uv, vec2(0.9, 0.9), uBorderRadius);

  // Traveling light angle (sweep gradient)
  float angle = atan(uv.y, uv.x);
  float sweep = fract(angle / (2.0 * PI) + uTime * 0.3);

  // Neon glow with halation
  float border = smoothstep(uBorderWidth, 0.0, abs(dist));
  float glow = exp(-abs(dist) * 8.0) * uGlowIntensity;

  // Combine: core color + corona
  vec3 core = vec3(1.0) * border * sweep;
  vec3 corona = uNeonColor * glow * sweep;

  gl_FragColor = vec4(core + corona, border + glow * 0.5);
}
```

**TypeScript wrapper:**
```typescript
// src/lib/shaders/NeonBorderShader.ts
export interface NeonBorderUniforms {
  uTime: { value: number };
  uBorderRadius: { value: number };
  uBorderWidth: { value: number };
  uNeonColor: { value: Color };
  uGlowIntensity: { value: number };
}

export function createNeonBorderShader(): ShaderMaterial {
  // Implementation
}
```

**Verification:** Border animates with traveling light, glow fades exponentially

---

### Task 6: Create chromatic aberration shader
**File:** `src/lib/shaders/chromaticAberration.glsl`, `src/lib/shaders/ChromaticShader.ts`

**Actions:**
1. Implement RGB channel separation shader
2. Add animatable offset amount for loading states
3. Support radial and linear aberration patterns
4. Create smooth pulse animation for loading feedback

**Shader code pattern:**
```glsl
// Chromatic aberration effect for loading/transition states
uniform sampler2D uTexture;
uniform float uTime;
uniform float uIntensity;      // 0-1 aberration strength
uniform float uAnimationPhase; // 0-1 for pulsing effect
uniform vec2 uCenter;          // Center point for radial mode

varying vec2 vUv;

void main() {
  // Calculate offset based on distance from center (radial mode)
  vec2 dir = vUv - uCenter;
  float dist = length(dir);

  // Pulsing intensity for loading states
  float pulse = sin(uTime * 3.0) * 0.5 + 0.5;
  float intensity = uIntensity * (0.5 + pulse * 0.5) * uAnimationPhase;

  // RGB channel offsets (subtle separation)
  float rOffset = intensity * 0.01;
  float gOffset = 0.0;
  float bOffset = -intensity * 0.01;

  // Sample each channel at slightly different positions
  vec2 rUv = vUv + dir * rOffset;
  vec2 gUv = vUv + dir * gOffset;
  vec2 bUv = vUv + dir * bOffset;

  float r = texture2D(uTexture, rUv).r;
  float g = texture2D(uTexture, gUv).g;
  float b = texture2D(uTexture, bUv).b;

  gl_FragColor = vec4(r, g, b, 1.0);
}
```

**TypeScript wrapper:**
```typescript
// src/lib/shaders/ChromaticShader.ts
import { ShaderMaterial, Vector2 } from 'three';
import chromaticFragmentShader from './chromaticAberration.glsl?raw';

export interface ChromaticAberrationUniforms {
  uTexture: { value: THREE.Texture | null };
  uTime: { value: number };
  uIntensity: { value: number };
  uAnimationPhase: { value: number }; // 0 = off, 1 = full effect
  uCenter: { value: Vector2 };
}

export function createChromaticShader(): ShaderMaterial {
  return new ShaderMaterial({
    uniforms: {
      uTexture: { value: null },
      uTime: { value: 0 },
      uIntensity: { value: 0.5 },
      uAnimationPhase: { value: 0 }, // Animate 0→1 on load start, 1→0 on load end
      uCenter: { value: new Vector2(0.5, 0.5) },
    },
    fragmentShader: chromaticFragmentShader,
    transparent: true,
  });
}

// Preset configurations for common use cases
export const chromaticPresets = {
  loading: { intensity: 0.6, animated: true },
  transition: { intensity: 0.3, animated: false },
  subtle: { intensity: 0.15, animated: false },
  intense: { intensity: 0.8, animated: true },
};
```

**Use cases:**
- **Loading states** - Pulsing chromatic aberration while fetching data
- **Page transitions** - Brief aberration flash on route change
- **Focus states** - Subtle aberration on active/focused elements
- **Error states** - Stronger red-shifted aberration on errors

**Verification:** Chromatic effect pulses during loading, smooth animation

---

### Task 7: Create ChromaticLoader React component
**File:** `src/components/effects/ChromaticLoader.tsx`

**Actions:**
1. Create React component for loading states with chromatic aberration
2. Accept loading state and content to wrap
3. Support different intensity presets
4. Integrate with Framer Motion for smooth phase transitions

**Component interface:**
```typescript
interface ChromaticLoaderProps {
  children: React.ReactNode;
  isLoading: boolean;
  preset?: 'loading' | 'transition' | 'subtle' | 'intense';
  className?: string;
}

export function ChromaticLoader({
  children,
  isLoading,
  preset = 'loading',
  className,
}: ChromaticLoaderProps) {
  const prefersReducedMotion = useReducedMotion();
  // Implementation: animate uAnimationPhase 0→1 when isLoading becomes true
  // Wrap children with chromatic aberration effect canvas
}
```

**Verification:** Loading state triggers chromatic aberration, respects reduced motion

---

### Task 8: Create GlassPanel React component
**File:** `src/components/effects/GlassPanel.tsx`

**Actions:**
1. Create React component using react-three-fiber
2. Accept children and render behind WebGL canvas
3. Support size, blur, and specular props
4. Animate specular position based on mouse or time

**Component interface:**
```typescript
interface GlassPanelProps {
  children: React.ReactNode;
  className?: string;
  blurAmount?: number;       // 0-20
  noiseIntensity?: number;   // 0-0.1
  specularEnabled?: boolean;
  animateSpecular?: boolean; // Rotate specular with time
}

export function GlassPanel({
  children,
  className,
  blurAmount = 12,
  noiseIntensity = 0.03,
  specularEnabled = true,
  animateSpecular = true,
}: GlassPanelProps) {
  // Implementation using Canvas from @react-three/fiber
}
```

**Verification:** Component renders children with glass effect behind them

---

### Task 9: Create NeonBorder React component
**File:** `src/components/effects/NeonBorder.tsx`

**Actions:**
1. Create React component wrapping WebGL border
2. Support color, intensity, animation speed props
3. Integrate with Framer Motion for enter/exit
4. Respect prefers-reduced-motion

**Component interface:**
```typescript
interface NeonBorderProps {
  children: React.ReactNode;
  className?: string;
  color?: string;           // CSS color, converted to Three.js Color
  intensity?: number;       // 0-1 glow strength
  animationSpeed?: number;  // Rotation speed multiplier
  borderRadius?: number;    // CSS-style border radius
  borderWidth?: number;     // Border thickness
  active?: boolean;         // Show/hide animation
}

export function NeonBorder({
  children,
  className,
  color = '#8b5cf6',
  intensity = 0.8,
  animationSpeed = 1,
  borderRadius = 12,
  borderWidth = 2,
  active = true,
}: NeonBorderProps) {
  const prefersReducedMotion = useReducedMotion();
  // Implementation
}
```

**Verification:** Neon border wraps children, animates, respects reduced motion

---

### Task 10: Create barrel exports and documentation
**File:** `src/components/effects/index.ts`, `src/lib/shaders/index.ts`

**Actions:**
1. Export GlassPanel and NeonBorder components
2. Export shader creation functions
3. Add JSDoc documentation
4. Create example usage in comments

**Verification:** Clean imports work, documentation accurate

---

### Task 11: Performance testing and optimization
**File:** Various

**Actions:**
1. Test 120fps on Apple Silicon (target)
2. Test 60fps on integrated graphics (minimum)
3. Add fallback for WebGL context loss
4. Profile GPU memory usage
5. Ensure no memory leaks on unmount

**Performance targets (per Gemini):**
- 120fps animation (no drops during scroll)
- <16ms interaction latency
- WebGL context recovery on loss

**Verification:** Meets performance targets, no memory leaks

---

## Verification Checklist

- [ ] Three.js and @react-three/fiber installed successfully
- [ ] TypeScript compiles with shader imports
- [ ] Noise shader produces smooth grain texture
- [ ] Glass shader renders all 4 layers correctly
- [ ] Specular highlight rotates with time
- [ ] Progressive blur fades at edges
- [ ] Neon border shader produces "traveling light" effect
- [ ] Neon glow has halation (exponential fade)
- [ ] **Chromatic aberration shader produces RGB separation**
- [ ] **Chromatic effect pulses during loading states**
- [ ] **ChromaticLoader component triggers on isLoading**
- [ ] GlassPanel component renders children correctly
- [ ] NeonBorder component wraps content correctly
- [ ] Animations respect prefers-reduced-motion
- [ ] 120fps on Apple Silicon
- [ ] 60fps on integrated graphics
- [ ] WebGL context loss handled gracefully
- [ ] `npm run build` passes with no errors

---

## Files Created/Modified

| File | Action |
|------|--------|
| `package.json` | Add three, @react-three/fiber, @react-three/drei |
| `src/lib/shaders/index.ts` | Create |
| `src/lib/shaders/types.ts` | Create |
| `src/lib/shaders/utils.ts` | Create |
| `src/lib/shaders/noise.glsl` | Create |
| `src/lib/shaders/glass.glsl` | Create |
| `src/lib/shaders/GlassShader.ts` | Create |
| `src/lib/shaders/neonBorder.glsl` | Create |
| `src/lib/shaders/NeonBorderShader.ts` | Create |
| `src/lib/shaders/chromaticAberration.glsl` | Create |
| `src/lib/shaders/ChromaticShader.ts` | Create |
| `src/components/effects/GlassPanel.tsx` | Create |
| `src/components/effects/NeonBorder.tsx` | Create |
| `src/components/effects/ChromaticLoader.tsx` | Create |
| `src/components/effects/index.ts` | Create |
| `vite.config.ts` | Add GLSL import support if needed |

---

## Dependencies

```bash
npm install three @react-three/fiber @react-three/drei
npm install -D @types/three
# Optional for GLSL imports:
npm install -D vite-plugin-glsl
```

---

## Research Reference

From Gemini Premium App UI/UX Investigation:
- "Glass Implementation Stack: Backdrop → Blur Pass → Noise Overlay → Specular Highlight"
- "Specular highlights need rotating light source - CSS is too static"
- "Neon 'Halation' Effect: core color + corona (saturated hue, exponential fade)"
- "SweepGradient on RoundedRect stroke for traveling neon border"
- "Performance targets: 120fps, <16ms interaction, 0 frame drops"

---

*Plan created: 2026-01-17*
*Ready for execution: yes*
*Foundation plan - execute before feature plans*
