# Plan 20-01: Premium Animation System

**Phase:** 20 - Rich Interactions
**Feature:** Physics-Based Animation Infrastructure
**Scope:** Medium (2-3 days)
**Dependencies:** 20-00 (WebGL Foundation - for shader integration)

---

## Summary

Configure comprehensive physics-based animation system with variable spring presets, shared element transitions, blur-back effects, staggered entry animations, and micro-interaction hover effects. Integrates with WebGL shaders from 20-00 for complex effects while using Framer Motion for simpler animations.

---

## Why This Matters

- **Premium feel** - Linear = robotic, Spring = premium
- **Apple-level polish** - Variable springs by context match iOS expectations
- **Visual continuity** - Shared element transitions prevent jarring cuts
- **Depth perception** - Blur-back creates spatial hierarchy
- **Delight** - Micro-interactions reward user engagement

---

## Gemini Research Context

From Premium App UI/UX Investigation:
- "Linear animations feel robotic; configure mass, stiffness, damping instead"
- "Elements have 'weight' - flick and bounce with momentum"
- "Subtle overshoot = hallmark of premium iOS interfaces"
- "Blur-Back: Content scales to 0.95 + blur increases when overlay opens"
- "Staggered Entry: Items cascade in with 10-20ms delay"
- "Interruptible springs: Retarget from current velocity on interrupt"
- "Haptics sync with spring animation (thud when velocity = 0)"

---

## Implementation Tasks

### Task 1: Create spring preset configuration
**File:** `src/lib/animation/springs.ts`

**Actions:**
1. Define typed spring preset configurations
2. Create presets: snappy, bouncy, smooth, gentle
3. Add context-specific presets (button, modal, content, sidebar)
4. Document when to use each preset

**Code pattern:**
```typescript
// src/lib/animation/springs.ts
import type { SpringOptions } from 'framer-motion';

/**
 * Spring presets based on context and perceived "weight"
 *
 * Snappy: Small elements, immediate feedback (buttons, toggles)
 * Bouncy: Big reveals, celebration moments (modals, score cards)
 * Smooth: Content transitions (page changes, list updates)
 * Gentle: Subtle effects (hover states, micro-interactions)
 */
export const springs = {
  // Core presets
  snappy: { type: 'spring', stiffness: 500, damping: 30, mass: 1 } as const,
  bouncy: { type: 'spring', stiffness: 300, damping: 20, mass: 1 } as const,
  smooth: { type: 'spring', stiffness: 200, damping: 25, mass: 1 } as const,
  gentle: { type: 'spring', stiffness: 150, damping: 20, mass: 0.8 } as const,

  // Context-specific presets
  button: { type: 'spring', stiffness: 600, damping: 35, mass: 0.8 } as const,
  modal: { type: 'spring', stiffness: 400, damping: 30, mass: 1.2 } as const,
  content: { type: 'spring', stiffness: 250, damping: 30, mass: 1 } as const,
  sidebar: { type: 'spring', stiffness: 350, damping: 35, mass: 1 } as const,
  tooltip: { type: 'spring', stiffness: 500, damping: 25, mass: 0.5 } as const,

  // Rubber band effect (overscroll, drag limits)
  rubberBand: { type: 'spring', stiffness: 800, damping: 40, mass: 0.5 } as const,
} as const;

export type SpringPreset = keyof typeof springs;

// Helper to get spring by name
export function getSpring(preset: SpringPreset): SpringOptions {
  return springs[preset];
}

// Reduced motion variant (instant)
export const instantTransition = { type: 'tween', duration: 0 } as const;

// Helper that respects reduced motion
export function getSpringOrInstant(
  preset: SpringPreset,
  prefersReducedMotion: boolean
): SpringOptions {
  return prefersReducedMotion ? instantTransition : springs[preset];
}
```

**Verification:** Presets export correctly, types compile, springs feel distinct

---

### Task 2: Create shared element transition system
**File:** `src/lib/animation/transitions.ts`, `src/hooks/useSharedElement.ts`

**Actions:**
1. Create shared element ID registry
2. Implement useSharedElement hook for marking elements
3. Handle position/size interpolation between states
4. Support crossfade for content that doesn't share geometry

**Code pattern:**
```typescript
// src/hooks/useSharedElement.ts
import { useLayoutEffect, useRef, useState } from 'react';
import { useMotionValue, useSpring, MotionValue } from 'framer-motion';

interface SharedElementState {
  x: MotionValue<number>;
  y: MotionValue<number>;
  width: MotionValue<number>;
  height: MotionValue<number>;
}

const sharedElements = new Map<string, DOMRect>();

export function useSharedElement(id: string) {
  const ref = useRef<HTMLDivElement>(null);
  const [state, setState] = useState<SharedElementState | null>(null);

  useLayoutEffect(() => {
    if (!ref.current) return;

    const currentRect = ref.current.getBoundingClientRect();
    const previousRect = sharedElements.get(id);

    if (previousRect) {
      // Animate from previous position to current
      setState({
        x: useSpring(previousRect.x - currentRect.x, springs.smooth),
        y: useSpring(previousRect.y - currentRect.y, springs.smooth),
        width: useSpring(previousRect.width / currentRect.width, springs.smooth),
        height: useSpring(previousRect.height / currentRect.height, springs.smooth),
      });
    }

    // Store current position for next transition
    sharedElements.set(id, currentRect);

    return () => {
      // Cleanup after animation completes
    };
  }, [id]);

  return { ref, ...state };
}
```

**Verification:** Element morphs smoothly between two positions in different routes

---

### Task 3: Create blur-back effect component
**File:** `src/components/effects/BlurBack.tsx`

**Actions:**
1. Create context for blur-back state management
2. Implement blur + scale effect on background content
3. Support variable depth (different blur amounts)
4. Integrate with modal/overlay systems

**Code pattern:**
```typescript
// src/components/effects/BlurBack.tsx
import { motion, AnimatePresence } from 'framer-motion';
import { createContext, useContext, useState } from 'react';
import { springs } from '@/lib/animation/springs';
import { useReducedMotion } from '@/hooks/useReducedMotion';

interface BlurBackContextValue {
  isBlurred: boolean;
  blurAmount: number;
  setBlurBack: (active: boolean, amount?: number) => void;
}

const BlurBackContext = createContext<BlurBackContextValue | null>(null);

export function BlurBackProvider({ children }: { children: React.ReactNode }) {
  const [isBlurred, setIsBlurred] = useState(false);
  const [blurAmount, setBlurAmount] = useState(8);

  const setBlurBack = (active: boolean, amount = 8) => {
    setIsBlurred(active);
    setBlurAmount(amount);
  };

  return (
    <BlurBackContext.Provider value={{ isBlurred, blurAmount, setBlurBack }}>
      {children}
    </BlurBackContext.Provider>
  );
}

export function useBlurBack() {
  const context = useContext(BlurBackContext);
  if (!context) throw new Error('useBlurBack must be used within BlurBackProvider');
  return context;
}

// Wrapper component that applies blur effect
export function BlurBackContent({ children }: { children: React.ReactNode }) {
  const { isBlurred, blurAmount } = useBlurBack();
  const prefersReducedMotion = useReducedMotion();

  return (
    <motion.div
      animate={{
        scale: isBlurred ? 0.95 : 1,
        filter: isBlurred ? `blur(${blurAmount}px)` : 'blur(0px)',
      }}
      transition={prefersReducedMotion ? { duration: 0 } : springs.modal}
      style={{ transformOrigin: 'center center' }}
    >
      {children}
    </motion.div>
  );
}
```

**Usage in modal:**
```tsx
function Modal({ open, children }) {
  const { setBlurBack } = useBlurBack();

  useEffect(() => {
    setBlurBack(open, 12); // Deeper blur for modal
    return () => setBlurBack(false);
  }, [open]);

  return <AnimatePresence>{open && children}</AnimatePresence>;
}
```

**Verification:** Background scales and blurs when modal opens, different blur depths work

---

### Task 4: Create staggered entry animation utility
**File:** `src/lib/animation/stagger.ts`, `src/components/effects/StaggeredList.tsx`

**Actions:**
1. Create stagger configuration presets
2. Implement StaggeredList component
3. Support custom stagger delay (default 20ms)
4. Handle dynamic list updates

**Code pattern:**
```typescript
// src/lib/animation/stagger.ts
export const staggerConfig = {
  fast: { staggerChildren: 0.02, delayChildren: 0 },
  normal: { staggerChildren: 0.04, delayChildren: 0.05 },
  slow: { staggerChildren: 0.08, delayChildren: 0.1 },
} as const;

export const itemVariants = {
  hidden: { opacity: 0, y: 12 },
  visible: { opacity: 1, y: 0 },
  exit: { opacity: 0, y: -8 },
};

// src/components/effects/StaggeredList.tsx
import { motion, AnimatePresence, Variants } from 'framer-motion';
import { staggerConfig, itemVariants } from '@/lib/animation/stagger';
import { useReducedMotion } from '@/hooks/useReducedMotion';

interface StaggeredListProps<T> {
  items: T[];
  renderItem: (item: T, index: number) => React.ReactNode;
  keyExtractor: (item: T) => string;
  stagger?: keyof typeof staggerConfig;
  className?: string;
}

export function StaggeredList<T>({
  items,
  renderItem,
  keyExtractor,
  stagger = 'normal',
  className,
}: StaggeredListProps<T>) {
  const prefersReducedMotion = useReducedMotion();

  const containerVariants: Variants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: prefersReducedMotion
        ? { duration: 0 }
        : staggerConfig[stagger],
    },
  };

  return (
    <motion.div
      className={className}
      variants={containerVariants}
      initial="hidden"
      animate="visible"
    >
      <AnimatePresence mode="popLayout">
        {items.map((item, index) => (
          <motion.div
            key={keyExtractor(item)}
            variants={prefersReducedMotion ? {} : itemVariants}
            layout
          >
            {renderItem(item, index)}
          </motion.div>
        ))}
      </AnimatePresence>
    </motion.div>
  );
}
```

**Verification:** List items cascade in sequence, updates animate correctly

---

### Task 5: Create micro-interaction hover effects
**File:** `src/components/effects/MicroInteraction.tsx`, `src/hooks/useMicroInteraction.ts`

**Actions:**
1. Implement subtle position shift on hover direction
2. Track mouse position within element
3. Apply transform based on hover position
4. Keep effects subtle (max 2-4px movement)

**Code pattern:**
```typescript
// src/hooks/useMicroInteraction.ts
import { useState, useRef, useCallback } from 'react';
import { useMotionValue, useSpring, useTransform } from 'framer-motion';
import { springs } from '@/lib/animation/springs';

interface UseMicroInteractionOptions {
  intensity?: number; // Max pixel movement (default: 3)
  enabled?: boolean;
}

export function useMicroInteraction(options: UseMicroInteractionOptions = {}) {
  const { intensity = 3, enabled = true } = options;
  const ref = useRef<HTMLDivElement>(null);

  const mouseX = useMotionValue(0);
  const mouseY = useMotionValue(0);

  const springX = useSpring(mouseX, springs.gentle);
  const springY = useSpring(mouseY, springs.gentle);

  // Transform to subtle movement (-intensity to +intensity)
  const x = useTransform(springX, [-1, 1], [-intensity, intensity]);
  const y = useTransform(springY, [-1, 1], [-intensity, intensity]);

  const handleMouseMove = useCallback((e: React.MouseEvent) => {
    if (!enabled || !ref.current) return;

    const rect = ref.current.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;

    // Normalize to -1 to 1
    mouseX.set((e.clientX - centerX) / (rect.width / 2));
    mouseY.set((e.clientY - centerY) / (rect.height / 2));
  }, [enabled, mouseX, mouseY]);

  const handleMouseLeave = useCallback(() => {
    mouseX.set(0);
    mouseY.set(0);
  }, [mouseX, mouseY]);

  return {
    ref,
    style: { x, y },
    handlers: {
      onMouseMove: handleMouseMove,
      onMouseLeave: handleMouseLeave,
    },
  };
}

// Wrapper component
export function MicroInteraction({
  children,
  intensity = 3,
  className,
}: {
  children: React.ReactNode;
  intensity?: number;
  className?: string;
}) {
  const { ref, style, handlers } = useMicroInteraction({ intensity });
  const prefersReducedMotion = useReducedMotion();

  if (prefersReducedMotion) {
    return <div className={className}>{children}</div>;
  }

  return (
    <motion.div
      ref={ref}
      style={style}
      className={className}
      {...handlers}
    >
      {children}
    </motion.div>
  );
}
```

**Verification:** Elements subtly shift toward mouse position, effect is subtle not jarring

---

### Task 6: Create haptic sync utility
**File:** `src/lib/animation/haptics.ts`

**Actions:**
1. Create utility to fire haptic when spring settles
2. Detect spring velocity approaching zero
3. Integrate with Tauri haptics API (from 20-04)
4. Queue haptic for perfect timing

**Code pattern:**
```typescript
// src/lib/animation/haptics.ts
import { MotionValue, useMotionValueEvent } from 'framer-motion';

type HapticType = 'selection' | 'success' | 'warning' | 'error';

// Will be implemented fully in 20-04, this is the interface
interface HapticAPI {
  trigger: (type: HapticType) => Promise<void>;
}

let hapticAPI: HapticAPI | null = null;

export function setHapticAPI(api: HapticAPI) {
  hapticAPI = api;
}

/**
 * Fire haptic when spring velocity reaches zero (settled)
 * Per Gemini: "thud when velocity = 0"
 */
export function useHapticOnSettle(
  motionValue: MotionValue<number>,
  hapticType: HapticType = 'selection',
  options: { threshold?: number; enabled?: boolean } = {}
) {
  const { threshold = 0.01, enabled = true } = options;

  useMotionValueEvent(motionValue, 'velocityChange', (velocity) => {
    if (!enabled || !hapticAPI) return;

    // Check if velocity is near zero (spring settled)
    if (Math.abs(velocity) < threshold) {
      hapticAPI.trigger(hapticType);
    }
  });
}

// Higher-level hook for common patterns
export function useHapticSpring(
  initialValue: number,
  springConfig: SpringOptions,
  hapticType: HapticType = 'selection'
) {
  const motionValue = useSpring(initialValue, springConfig);
  useHapticOnSettle(motionValue, hapticType);
  return motionValue;
}
```

**Verification:** Haptic fires at spring settle (will fully test in 20-04)

---

### Task 7: Create chromatic aberration loading integration
**File:** `src/lib/animation/chromaticLoading.ts`, `src/hooks/useChromaticLoading.ts`

**Actions:**
1. Create hook to coordinate chromatic aberration with loading states
2. Integrate with ChromaticLoader component from 20-00
3. Support async operation wrapping with automatic effect
4. Coordinate with blur-back for combined loading effects

**Code pattern:**
```typescript
// src/hooks/useChromaticLoading.ts
import { useState, useCallback } from 'react';
import { useMotionValue, animate } from 'framer-motion';
import { chromaticPresets } from '@/lib/shaders/ChromaticShader';
import { useReducedMotion } from '@/hooks/useReducedMotion';

interface UseChromaticLoadingOptions {
  preset?: keyof typeof chromaticPresets;
  onStart?: () => void;
  onEnd?: () => void;
}

export function useChromaticLoading(options: UseChromaticLoadingOptions = {}) {
  const { preset = 'loading', onStart, onEnd } = options;
  const [isLoading, setIsLoading] = useState(false);
  const prefersReducedMotion = useReducedMotion();

  // Animation phase for shader (0 = off, 1 = full effect)
  const animationPhase = useMotionValue(0);

  const startLoading = useCallback(() => {
    setIsLoading(true);
    onStart?.();

    if (!prefersReducedMotion) {
      animate(animationPhase, 1, { duration: 0.3 });
    }
  }, [animationPhase, onStart, prefersReducedMotion]);

  const stopLoading = useCallback(() => {
    if (!prefersReducedMotion) {
      animate(animationPhase, 0, { duration: 0.2 }).then(() => {
        setIsLoading(false);
        onEnd?.();
      });
    } else {
      setIsLoading(false);
      onEnd?.();
    }
  }, [animationPhase, onEnd, prefersReducedMotion]);

  // Wrapper for async operations
  const withChromatic = useCallback(async <T>(operation: () => Promise<T>): Promise<T> => {
    startLoading();
    try {
      return await operation();
    } finally {
      stopLoading();
    }
  }, [startLoading, stopLoading]);

  return {
    isLoading,
    animationPhase,
    startLoading,
    stopLoading,
    withChromatic,
    preset: chromaticPresets[preset],
  };
}

// Combined loading effect (chromatic + blur-back)
export function usePremiumLoading() {
  const chromatic = useChromaticLoading();
  const { setBlurBack } = useBlurBack();

  const startPremiumLoading = useCallback(() => {
    chromatic.startLoading();
    setBlurBack(true, 4); // Subtle blur during loading
  }, [chromatic, setBlurBack]);

  const stopPremiumLoading = useCallback(() => {
    chromatic.stopLoading();
    setBlurBack(false);
  }, [chromatic, setBlurBack]);

  return {
    ...chromatic,
    startLoading: startPremiumLoading,
    stopLoading: stopPremiumLoading,
  };
}
```

**Use cases:**
- **Data fetching** - Wrap API calls with `withChromatic(fetchData)`
- **Optimization running** - Show chromatic during system optimization
- **Page transitions** - Brief chromatic flash on route change
- **Form submission** - Loading state while saving

**Verification:** Chromatic effect activates during async operations, combines with blur-back

---

### Task 8: Create animation barrel exports and documentation
**File:** `src/lib/animation/index.ts`, `src/components/effects/index.ts`

**Actions:**
1. Export all animation utilities
2. Export all effect components
3. Add comprehensive JSDoc documentation
4. Create usage examples

**Verification:** Clean imports work, documentation is comprehensive

---

### Task 9: Integration testing and performance verification
**File:** Test files and manual testing

**Actions:**
1. Test all springs feel appropriate for their context
2. Verify blur-back integrates with existing modals
3. Verify stagger works with dynamic lists
4. Confirm 120fps maintained during animations
5. Test reduced motion fallbacks
6. Verify chromatic aberration loading effect works smoothly

**Performance targets:**
- 120fps during all animations
- No janky interruptions
- Smooth spring retargeting
- Chromatic effect doesn't cause frame drops

**Verification:** All animations smooth, performance targets met

---

## Verification Checklist

- [ ] Spring presets feel distinct (snappy vs bouncy vs smooth)
- [ ] Shared element transitions morph smoothly
- [ ] Blur-back effect works with variable depths
- [ ] Content scales to 0.95 when blurred
- [ ] Staggered list cascades items on entry
- [ ] Dynamic list updates animate correctly
- [ ] Micro-interactions shift subtly toward mouse
- [ ] Effects are subtle, not jarring
- [ ] Haptic sync fires at spring settle (placeholder for 20-04)
- [ ] **Chromatic aberration activates during loading states**
- [ ] **withChromatic() wraps async operations correctly**
- [ ] **usePremiumLoading() combines chromatic + blur-back**
- [ ] All animations respect prefers-reduced-motion
- [ ] 120fps maintained during animations
- [ ] Springs are interruptible (retarget smoothly)
- [ ] `npm run build` passes with no errors

---

## Files Created/Modified

| File | Action |
|------|--------|
| `src/lib/animation/springs.ts` | Create |
| `src/lib/animation/stagger.ts` | Create |
| `src/lib/animation/haptics.ts` | Create |
| `src/lib/animation/chromaticLoading.ts` | Create |
| `src/lib/animation/index.ts` | Create |
| `src/hooks/useSharedElement.ts` | Create |
| `src/hooks/useMicroInteraction.ts` | Create |
| `src/hooks/useChromaticLoading.ts` | Create |
| `src/components/effects/BlurBack.tsx` | Create |
| `src/components/effects/StaggeredList.tsx` | Create |
| `src/components/effects/MicroInteraction.tsx` | Create |
| `src/components/effects/index.ts` | Update (add new exports) |

---

## Research Reference

From Gemini Premium App UI/UX Investigation:
- "Configure mass, stiffness, damping instead of duration-based animations"
- "Elements have 'weight' - flick and bounce with momentum"
- "Blur-Back: Content scales to 0.95 + blur increases"
- "Staggered Entry: Items cascade in with 10-20ms delay"
- "Interruptible springs: Retarget from current velocity on interrupt"
- "Haptics sync with spring animation (thud when velocity = 0)"

---

*Plan created: 2026-01-17*
*Ready for execution: yes*
*Foundation plan - execute after 20-00*
