# Plan 20-09: Menu Bar Extra - Popover UI

**Phase:** 20 - Rich Interactions
**Feature:** Native SwiftUI Popover with Holographic System View
**Scope:** Large (3-4 days)
**Dependencies:** 20-08 (Swift Plugin foundation)

---

## Summary

Design and implement the SwiftUI popover that appears when clicking the menu bar icon. Features context-aware content, state-based styling, pin/transient behavior, and a revolutionary "Holographic" 3D orbital visualization using SceneKit for system metrics.

---

## Why This Matters

- **Native premium feel** - SwiftUI popover feels native to macOS
- **Context-aware intelligence** - Different content based on system state
- **Holographic differentiation** - 3D visualization is unique in system monitors
- **Quick actions** - Immediate access to optimization without opening main app
- **Pin/transient UX** - Flexible user preference for popover behavior

---

## Gemini Research Context

From Native Capability Across Platforms:
- "Floating popover for deeper engagement (lightweight, not full NSWindow)"
- "Transient behavior (close on click away) with 'pin' option"
- "Dynamic icon showing live score/status (not static logo)"

From Gemini Improvements:
- "Holographic System View - Use Rust Core for data ingestion and SwiftUI/Metal for 3D rendering"
- "CPU cores as spinning rings, Memory as filling cylinder, Processes as orbiting dots"
- "Leverages 'Direct GPU Access' of native Swift/Metal - something web apps cannot do efficiently"

---

## Implementation Tasks

### Task 1: Create base PopoverView structure
**File:** `src-tauri/swift-plugin/Sources/OptaMenuBar/PopoverView.swift`

**Actions:**
1. Create main SwiftUI popover view
2. Setup view hierarchy with sections
3. Configure popover dimensions
4. Add background glass styling

**Code:**
```swift
// PopoverView.swift
import SwiftUI

struct PopoverView: View {
    @ObservedObject var metricsStore: MetricsStore
    @State private var isPinned: Bool = false

    var body: some View {
        VStack(spacing: 0) {
            // Header with logo and pin button
            PopoverHeader(isPinned: $isPinned, momentum: metricsStore.momentum)

            Divider()
                .background(Color.white.opacity(0.1))

            // Main content area
            ScrollView {
                VStack(spacing: 16) {
                    // Holographic System View
                    SystemOrbitalView(metrics: metricsStore.currentMetrics)
                        .frame(height: 200)

                    // Quick Stats
                    QuickStatsView(metrics: metricsStore.currentMetrics)

                    // Context-aware Actions
                    QuickActionsView(systemState: metricsStore.systemState)
                }
                .padding()
            }
        }
        .frame(width: 320, height: 480)
        .background(VisualEffectBlur(material: .hudWindow, blendingMode: .behindWindow))
    }
}

struct PopoverHeader: View {
    @Binding var isPinned: Bool
    let momentum: MomentumState

    var body: some View {
        HStack {
            // Animated Rive logo
            RiveLogoView(momentum: momentum)
                .frame(width: 24, height: 24)

            Text("Opta")
                .font(.headline)
                .foregroundColor(.white)

            Spacer()

            // Pin button
            Button(action: { isPinned.toggle() }) {
                Image(systemName: isPinned ? "pin.fill" : "pin")
                    .foregroundColor(isPinned ? .accentColor : .secondary)
            }
            .buttonStyle(.borderless)
        }
        .padding(.horizontal, 16)
        .padding(.vertical, 12)
    }
}
```

**Verification:** Popover opens with correct dimensions and glass styling

---

### Task 2: Create Holographic System View (SceneKit)
**File:** `src-tauri/swift-plugin/Sources/OptaMenuBar/SystemOrbitalView.swift`

**Actions:**
1. Setup SceneKit scene with orbital visualization
2. Create CPU core rings (spinning at different speeds)
3. Create memory cylinder (fills based on usage)
4. Add process dots (orbit based on CPU usage)
5. Apply neon glow materials

**Code:**
```swift
// SystemOrbitalView.swift
import SwiftUI
import SceneKit

struct SystemOrbitalView: View {
    let metrics: SystemMetrics?

    var body: some View {
        SceneView(
            scene: createOrbitalScene(),
            options: [.autoenablesDefaultLighting, .allowsCameraControl]
        )
        .background(Color.black.opacity(0.3))
        .cornerRadius(12)
    }

    private func createOrbitalScene() -> SCNScene {
        let scene = SCNScene()
        scene.background.contents = NSColor.clear

        // Central memory cylinder
        let memoryCylinder = createMemoryCylinder()
        scene.rootNode.addChildNode(memoryCylinder)

        // CPU core rings
        let cpuRings = createCPURings()
        cpuRings.forEach { scene.rootNode.addChildNode($0) }

        // Orbiting process nodes
        let processNodes = createProcessNodes()
        processNodes.forEach { scene.rootNode.addChildNode($0) }

        // Camera
        let cameraNode = SCNNode()
        cameraNode.camera = SCNCamera()
        cameraNode.position = SCNVector3(x: 0, y: 2, z: 5)
        cameraNode.look(at: SCNVector3(x: 0, y: 0, z: 0))
        scene.rootNode.addChildNode(cameraNode)

        // Ambient light
        let ambientLight = SCNNode()
        ambientLight.light = SCNLight()
        ambientLight.light?.type = .ambient
        ambientLight.light?.color = NSColor(white: 0.3, alpha: 1)
        scene.rootNode.addChildNode(ambientLight)

        return scene
    }

    private func createMemoryCylinder() -> SCNNode {
        let memoryUsage = metrics?.memoryUsage ?? 0.5

        // Outer shell (full height, transparent)
        let shellGeometry = SCNCylinder(radius: 0.5, height: 2)
        shellGeometry.firstMaterial?.diffuse.contents = NSColor.purple.withAlphaComponent(0.1)
        shellGeometry.firstMaterial?.transparency = 0.8
        let shellNode = SCNNode(geometry: shellGeometry)

        // Inner fill (height based on usage)
        let fillHeight = 2.0 * Double(memoryUsage)
        let fillGeometry = SCNCylinder(radius: 0.45, height: fillHeight)

        // Gradient color based on usage
        let fillColor: NSColor = {
            if memoryUsage > 0.85 { return .systemRed }
            if memoryUsage > 0.6 { return .systemOrange }
            return .systemCyan
        }()

        fillGeometry.firstMaterial?.diffuse.contents = fillColor
        fillGeometry.firstMaterial?.emission.contents = fillColor.withAlphaComponent(0.5)

        let fillNode = SCNNode(geometry: fillGeometry)
        fillNode.position = SCNVector3(x: 0, y: Float(-1 + fillHeight / 2), z: 0)

        let containerNode = SCNNode()
        containerNode.addChildNode(shellNode)
        containerNode.addChildNode(fillNode)

        return containerNode
    }

    private func createCPURings() -> [SCNNode] {
        let cpuUsage = metrics?.cpuUsage ?? 0.3
        var rings: [SCNNode] = []

        // Create 4 rings representing CPU cores
        for i in 0..<4 {
            let radius = 1.2 + Double(i) * 0.3
            let torusGeometry = SCNTorus(ringRadius: radius, pipeRadius: 0.03)

            // Color based on CPU usage
            let color: NSColor = {
                if cpuUsage > 0.85 { return .systemRed }
                if cpuUsage > 0.6 { return .systemCyan }
                return .systemPurple
            }()

            torusGeometry.firstMaterial?.diffuse.contents = color
            torusGeometry.firstMaterial?.emission.contents = color.withAlphaComponent(0.7)

            let ringNode = SCNNode(geometry: torusGeometry)
            ringNode.eulerAngles.x = .pi / 2 // Horizontal orientation

            // Rotation animation - speed based on CPU usage
            let rotationSpeed = 2.0 + Double(cpuUsage) * 3.0
            let rotation = SCNAction.rotateBy(
                x: 0,
                y: CGFloat(rotationSpeed),
                z: 0,
                duration: 2.0
            )
            ringNode.runAction(SCNAction.repeatForever(rotation))

            rings.append(ringNode)
        }

        return rings
    }

    private func createProcessNodes() -> [SCNNode] {
        guard let processes = metrics?.topProcesses else { return [] }
        var nodes: [SCNNode] = []

        for (index, process) in processes.prefix(8).enumerated() {
            // Size based on CPU usage
            let size = 0.05 + Double(process.cpuPercent) * 0.002
            let sphereGeometry = SCNSphere(radius: size)

            sphereGeometry.firstMaterial?.diffuse.contents = NSColor.white
            sphereGeometry.firstMaterial?.emission.contents = NSColor.cyan.withAlphaComponent(0.8)

            let processNode = SCNNode(geometry: sphereGeometry)

            // Position in orbit
            let angle = Double(index) * (2 * .pi / 8)
            let orbitRadius = 1.8
            processNode.position = SCNVector3(
                x: Float(cos(angle) * orbitRadius),
                y: Float(sin(Double(index) * 0.3) * 0.3),
                z: Float(sin(angle) * orbitRadius)
            )

            // Orbit animation
            let orbitAction = SCNAction.customAction(duration: 10) { node, time in
                let progress = Double(time) / 10.0
                let currentAngle = angle + progress * 2 * .pi
                node.position = SCNVector3(
                    x: Float(cos(currentAngle) * orbitRadius),
                    y: Float(sin(currentAngle * 2) * 0.3),
                    z: Float(sin(currentAngle) * orbitRadius)
                )
            }
            processNode.runAction(SCNAction.repeatForever(orbitAction))

            nodes.append(processNode)
        }

        return nodes
    }
}
```

**Verification:** 3D orbital visualization renders, CPU rings spin, memory fills, processes orbit

---

### Task 3: Create Quick Stats View
**File:** `src-tauri/swift-plugin/Sources/OptaMenuBar/QuickStatsView.swift`

**Actions:**
1. Create compact stats display
2. Add circular progress indicators
3. Apply momentum-based styling
4. Include key metrics (CPU, Memory, Disk, Temp)

**Code:**
```swift
// QuickStatsView.swift
import SwiftUI

struct QuickStatsView: View {
    let metrics: SystemMetrics?

    var body: some View {
        HStack(spacing: 20) {
            MetricGauge(
                value: Double(metrics?.cpuUsage ?? 0),
                label: "CPU",
                color: colorForUsage(metrics?.cpuUsage ?? 0)
            )

            MetricGauge(
                value: Double(metrics?.memoryUsage ?? 0),
                label: "MEM",
                color: colorForUsage(metrics?.memoryUsage ?? 0)
            )

            MetricGauge(
                value: Double(metrics?.diskUsage ?? 0),
                label: "DISK",
                color: colorForUsage(metrics?.diskUsage ?? 0)
            )

            if let temp = metrics?.temperature, temp > 0 {
                MetricGauge(
                    value: Double(temp / 100), // Normalize to 0-1
                    label: "\(Int(temp))Â°",
                    color: temperatureColor(temp)
                )
            }
        }
        .padding(.horizontal)
    }

    private func colorForUsage(_ usage: Float) -> Color {
        if usage > 0.85 { return .red }
        if usage > 0.6 { return .orange }
        return .cyan
    }

    private func temperatureColor(_ temp: Float) -> Color {
        if temp > 85 { return .red }
        if temp > 70 { return .orange }
        return .green
    }
}

struct MetricGauge: View {
    let value: Double
    let label: String
    let color: Color

    var body: some View {
        VStack(spacing: 4) {
            ZStack {
                // Background ring
                Circle()
                    .stroke(Color.white.opacity(0.1), lineWidth: 4)
                    .frame(width: 50, height: 50)

                // Progress ring
                Circle()
                    .trim(from: 0, to: value)
                    .stroke(
                        color,
                        style: StrokeStyle(lineWidth: 4, lineCap: .round)
                    )
                    .frame(width: 50, height: 50)
                    .rotationEffect(.degrees(-90))
                    .shadow(color: color.opacity(0.5), radius: 4)

                // Percentage text
                Text("\(Int(value * 100))")
                    .font(.system(size: 14, weight: .semibold, design: .rounded))
                    .foregroundColor(.white)
            }

            Text(label)
                .font(.system(size: 10, weight: .medium))
                .foregroundColor(.secondary)
        }
    }
}
```

**Verification:** Stats display shows all metrics with appropriate colors

---

### Task 4: Create Quick Actions View
**File:** `src-tauri/swift-plugin/Sources/OptaMenuBar/QuickActionsView.swift`

**Actions:**
1. Create context-aware action buttons
2. Show different actions based on system state
3. Connect actions to Rust backend via IPC
4. Add visual feedback for button states

**Code:**
```swift
// QuickActionsView.swift
import SwiftUI

enum SystemState {
    case idle
    case busy
    case critical

    static func from(cpu: Float, memory: Float) -> SystemState {
        if cpu > 90 || memory > 90 { return .critical }
        if cpu > 60 || memory > 70 { return .busy }
        return .idle
    }
}

// MARK: - Chromatic Aberration Loading Effect

/// Metal shader-based chromatic aberration for premium loading feedback
struct ChromaticLoadingEffect: View {
    @Binding var isLoading: Bool
    @State private var phase: CGFloat = 0

    var body: some View {
        TimelineView(.animation(minimumInterval: 1/60)) { timeline in
            Canvas { context, size in
                guard isLoading else { return }

                // Pulsing chromatic aberration via Metal-like effect
                let pulse = sin(phase * 3) * 0.5 + 0.5
                let intensity = 0.6 * (0.5 + pulse * 0.5)

                // RGB channel separation offsets
                let rOffset = CGSize(width: intensity * 2, height: 0)
                let bOffset = CGSize(width: -intensity * 2, height: 0)

                // Apply subtle color fringing effect
                // (In production, use MTLShader for true GPU chromatic aberration)
            }
        }
        .onChange(of: timeline.date) { _ in
            phase += 0.05
        }
        .allowsHitTesting(false)
    }
}

struct QuickActionsView: View {
    let systemState: SystemState
    @State private var isOptimizing: Bool = false

    var body: some View {
        VStack(spacing: 12) {
            // Primary action based on state
            switch systemState {
            case .critical:
                ActionButton(
                    title: "Emergency Cleanup",
                    subtitle: "Free up resources immediately",
                    icon: "exclamationmark.triangle.fill",
                    color: .red,
                    isLoading: isOptimizing,
                    action: performEmergencyCleanup
                )

            case .busy:
                ActionButton(
                    title: "Quick Optimize",
                    subtitle: "Optimize for current workload",
                    icon: "bolt.fill",
                    color: .orange,
                    isLoading: isOptimizing,
                    action: performQuickOptimize
                )

            case .idle:
                ActionButton(
                    title: "Deep Clean",
                    subtitle: "Thorough system optimization",
                    icon: "sparkles",
                    color: .cyan,
                    isLoading: isOptimizing,
                    action: performDeepClean
                )
            }

            // Secondary actions
            HStack(spacing: 12) {
                SmallActionButton(icon: "gear", label: "Settings") {
                    openMainApp(page: "settings")
                }

                SmallActionButton(icon: "chart.xyaxis.line", label: "Details") {
                    openMainApp(page: "dashboard")
                }

                SmallActionButton(icon: "list.bullet", label: "Processes") {
                    openMainApp(page: "processes")
                }
            }
        }
        .padding(.top, 8)
    }

    private func performEmergencyCleanup() {
        isOptimizing = true
        IPCHandler.shared.invoke("emergency_cleanup") { _ in
            isOptimizing = false
        }
    }

    private func performQuickOptimize() {
        isOptimizing = true
        IPCHandler.shared.invoke("quick_optimize") { _ in
            isOptimizing = false
        }
    }

    private func performDeepClean() {
        isOptimizing = true
        IPCHandler.shared.invoke("deep_clean") { _ in
            isOptimizing = false
        }
    }

    private func openMainApp(page: String) {
        IPCHandler.shared.invoke("open_main_app", params: ["page": page]) { _ in }
    }
}

struct ActionButton: View {
    let title: String
    let subtitle: String
    let icon: String
    let color: Color
    let isLoading: Bool
    let action: () -> Void

    var body: some View {
        Button(action: action) {
            ZStack {
                // Chromatic aberration overlay during loading
                if isLoading {
                    ChromaticLoadingEffect(isLoading: .constant(isLoading))
                }

                HStack {
                    if isLoading {
                        ProgressView()
                            .scaleEffect(0.8)
                            .frame(width: 24, height: 24)
                    } else {
                        Image(systemName: icon)
                            .font(.system(size: 18))
                            .foregroundColor(color)
                            .frame(width: 24, height: 24)
                    }

                VStack(alignment: .leading, spacing: 2) {
                    Text(title)
                        .font(.system(size: 14, weight: .semibold))
                        .foregroundColor(.white)

                    Text(subtitle)
                        .font(.system(size: 11))
                        .foregroundColor(.secondary)
                }

                Spacer()

                Image(systemName: "chevron.right")
                    .font(.system(size: 12))
                    .foregroundColor(.secondary)
            }
                }
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 12)
            .background(color.opacity(0.15))
            .cornerRadius(10)
        }
        .buttonStyle(.plain)
        .disabled(isLoading)
    }
}

struct SmallActionButton: View {
    let icon: String
    let label: String
    let action: () -> Void

    var body: some View {
        Button(action: action) {
            VStack(spacing: 4) {
                Image(systemName: icon)
                    .font(.system(size: 16))
                    .foregroundColor(.white)

                Text(label)
                    .font(.system(size: 10))
                    .foregroundColor(.secondary)
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 12)
            .background(Color.white.opacity(0.05))
            .cornerRadius(8)
        }
        .buttonStyle(.plain)
    }
}
```

**Verification:** Actions change based on system state, IPC calls work

---

### Task 5: Create Visual Effect Blur helper
**File:** `src-tauri/swift-plugin/Sources/OptaMenuBar/VisualEffects.swift`

**Actions:**
1. Create NSVisualEffectView wrapper for SwiftUI
2. Configure material and blending mode
3. Support different blur strengths

**Code:**
```swift
// VisualEffects.swift
import SwiftUI
import AppKit

struct VisualEffectBlur: NSViewRepresentable {
    let material: NSVisualEffectView.Material
    let blendingMode: NSVisualEffectView.BlendingMode

    func makeNSView(context: Context) -> NSVisualEffectView {
        let view = NSVisualEffectView()
        view.material = material
        view.blendingMode = blendingMode
        view.state = .active
        return view
    }

    func updateNSView(_ nsView: NSVisualEffectView, context: Context) {
        nsView.material = material
        nsView.blendingMode = blendingMode
    }
}

// Momentum-based border view
struct MomentumBorderView: View {
    let momentum: MomentumState

    var body: some View {
        RoundedRectangle(cornerRadius: 12)
            .strokeBorder(
                AngularGradient(
                    gradient: Gradient(colors: gradientColors),
                    center: .center,
                    startAngle: .degrees(rotationAngle),
                    endAngle: .degrees(rotationAngle + 360)
                ),
                lineWidth: 2
            )
            .animation(
                .linear(duration: 2.0 / Double(momentum.rotationSpeed))
                .repeatForever(autoreverses: false),
                value: rotationAngle
            )
    }

    @State private var rotationAngle: Double = 0

    private var gradientColors: [Color] {
        switch momentum.color {
        case .idle:
            return [.purple.opacity(0.3), .purple, .purple.opacity(0.3)]
        case .active:
            return [.cyan.opacity(0.3), .cyan, .cyan.opacity(0.3)]
        case .critical:
            return [.red.opacity(0.3), .red, .red.opacity(0.3)]
        }
    }
}
```

**Verification:** Blur effect renders correctly, momentum border animates

---

### Task 6: Implement pin/transient behavior
**File:** `src-tauri/swift-plugin/Sources/OptaMenuBar/MenuBarExtra.swift`

**Actions:**
1. Configure MenuBarExtra with window style
2. Implement pin state persistence
3. Handle popover dismiss behavior
4. Add keyboard shortcut to toggle popover

**Code:**
```swift
// MenuBarExtra.swift (additions)
import SwiftUI
import AppKit

@main
struct OptaMenuBarApp: App {
    @StateObject private var metricsStore = MetricsStore()
    @AppStorage("popoverPinned") private var isPinned: Bool = false

    var body: some Scene {
        MenuBarExtra {
            PopoverView(metricsStore: metricsStore)
                .onDisappear {
                    // Only close if not pinned
                    if !isPinned {
                        // Default transient behavior
                    }
                }
        } label: {
            RiveLogoView(momentum: metricsStore.momentum)
        }
        .menuBarExtraStyle(.window)
        .commands {
            CommandGroup(replacing: .appInfo) {
                Button("About Opta") {
                    IPCHandler.shared.invoke("open_main_app", params: ["page": "about"]) { _ in }
                }
            }
        }
    }
}

// Popover controller for pin behavior
final class PopoverController: ObservableObject {
    @Published var isPinned: Bool = false {
        didSet {
            UserDefaults.standard.set(isPinned, forKey: "popoverPinned")
            updateBehavior()
        }
    }

    private weak var statusItem: NSStatusItem?

    init() {
        isPinned = UserDefaults.standard.bool(forKey: "popoverPinned")
    }

    func configure(statusItem: NSStatusItem) {
        self.statusItem = statusItem
        updateBehavior()
    }

    private func updateBehavior() {
        // When pinned, popover stays open on click outside
        // When not pinned, popover closes on click outside (transient)
        if let button = statusItem?.button {
            // Configure popover behavior based on pin state
        }
    }
}
```

**Verification:** Pin toggle persists, transient behavior works when unpinned

---

### Task 7: Add process tooltip on hover
**File:** `src-tauri/swift-plugin/Sources/OptaMenuBar/SystemOrbitalView.swift`

**Actions:**
1. Add hit testing for process nodes
2. Show tooltip with process details on hover
3. Include process name, CPU%, memory

**Code:**
```swift
// Add to SystemOrbitalView
struct ProcessTooltip: View {
    let process: ProcessInfo

    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text(process.name)
                .font(.system(size: 12, weight: .semibold))
                .foregroundColor(.white)

            HStack(spacing: 8) {
                Label("\(String(format: "%.1f", process.cpuPercent))%", systemImage: "cpu")
                Label("\(Int(process.memoryMb))MB", systemImage: "memorychip")
            }
            .font(.system(size: 10))
            .foregroundColor(.secondary)
        }
        .padding(8)
        .background(VisualEffectBlur(material: .popover, blendingMode: .behindWindow))
        .cornerRadius(8)
    }
}

// SceneKit delegate for hit testing
extension SystemOrbitalView {
    class Coordinator: NSObject, SCNSceneRendererDelegate {
        var parent: SystemOrbitalView
        @Binding var hoveredProcess: ProcessInfo?

        init(parent: SystemOrbitalView, hoveredProcess: Binding<ProcessInfo?>) {
            self.parent = parent
            self._hoveredProcess = hoveredProcess
        }

        func renderer(_ renderer: SCNSceneRenderer, didApplyAnimationsAtTime time: TimeInterval) {
            // Hit test for process nodes under mouse
        }
    }
}
```

**Verification:** Hovering over process dots shows tooltip

---

### Task 8: Create barrel exports and documentation
**File:** `src-tauri/swift-plugin/Sources/OptaMenuBar/exports.swift`

**Actions:**
1. Export public API
2. Document usage patterns
3. Add inline documentation

**Verification:** Clean imports work, documentation complete

---

## Verification Checklist

- [ ] Popover opens when clicking menu bar icon
- [ ] Holographic 3D view renders correctly
- [ ] CPU rings rotate at speed based on usage
- [ ] Memory cylinder fills based on usage
- [ ] Process dots orbit correctly
- [ ] Quick stats show CPU, Memory, Disk, Temp
- [ ] Context-aware actions change based on system state
- [ ] **Chromatic aberration effect appears during loading states**
- [ ] **Action buttons show chromatic pulsing when optimizing**
- [ ] Pin button toggles and persists
- [ ] Unpinned popover closes on click outside
- [ ] Pinned popover stays open
- [ ] IPC calls to Rust backend work
- [ ] Process tooltips appear on hover
- [ ] Visual effect blur renders correctly
- [ ] Momentum border animates on popover
- [ ] `swift build` passes

---

## Files Created/Modified

| File | Action |
|------|--------|
| `src-tauri/swift-plugin/Sources/OptaMenuBar/PopoverView.swift` | Create |
| `src-tauri/swift-plugin/Sources/OptaMenuBar/SystemOrbitalView.swift` | Create |
| `src-tauri/swift-plugin/Sources/OptaMenuBar/QuickStatsView.swift` | Create |
| `src-tauri/swift-plugin/Sources/OptaMenuBar/QuickActionsView.swift` | Create (includes ChromaticLoadingEffect) |
| `src-tauri/swift-plugin/Sources/OptaMenuBar/VisualEffects.swift` | Create |
| `src-tauri/swift-plugin/Sources/OptaMenuBar/MenuBarExtra.swift` | Modify - add pin behavior |

---

## Research Reference

From Gemini:
- "Floating popover for deeper engagement"
- "Transient behavior with 'pin' option"
- "Holographic System View - CPU cores as spinning rings"
- "Direct GPU Access of native Swift/Metal"
- "Context-aware content: Busy system = quick actions, Idle = more detail"

---

## Platform Notes

- **Requires macOS 13+** for MenuBarExtra window style
- **SceneKit** is built-in (no external dependency)
- **Hardware acceleration** via Metal
- **Optimized for Apple Silicon** - efficient GPU usage

---

*Plan created: 2026-01-17*
*Ready for execution: yes*
*Execute after: 20-08 (Swift Plugin foundation)*
