---
phase: 17-chess-integration
plan: 02
type: execute
wave: 2
depends_on: ["17-01"]
files_modified: [src/hooks/useChessGame.ts, src/hooks/useStockfish.ts]
autonomous: true
---

<objective>
Create core chess hooks for game logic and AI opponent.

Purpose: Encapsulate chess.js game management and Stockfish AI communication in reusable React hooks.
Output: useChessGame hook for game state; useStockfish hook for AI moves via Web Worker.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-chess-integration/17-RESEARCH.md
@.planning/phases/17-chess-integration/17-01-SUMMARY.md

@src/types/chess.ts
@src/hooks/useGames.ts
@src/hooks/useLlm.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useChessGame hook</name>
  <files>src/hooks/useChessGame.ts</files>
  <action>
Create a React hook that wraps chess.js for game state management. Follow patterns from 17-RESEARCH.md code examples and existing hooks (useGames.ts).

**CRITICAL from research - Don't hand-roll:**
- Move validation (chess.js handles all rules)
- Game state (derive from chess.js, single source of truth)
- Check/checkmate detection (use chess.js methods)

Interface:
```typescript
interface UseChessGameOptions {
  initialFen?: string;
  playerColor?: 'white' | 'black';
  onGameOver?: (result: ChessGameState['result']) => void;
  onMove?: (move: ChessMove) => void;
}

interface UseChessGameReturn {
  // State
  fen: string;
  history: ChessMove[];
  isGameOver: boolean;
  result: ChessGameState['result'];
  turn: 'w' | 'b';
  isCheck: boolean;

  // Actions
  makeMove: (move: { from: string; to: string; promotion?: string }) => ChessMove | null;
  undo: () => boolean;
  reset: () => void;
  loadFen: (fen: string) => boolean;

  // Utilities
  getLegalMoves: (square: string) => string[];
  isLegalMove: (from: string, to: string) => boolean;
}
```

Implementation notes:
- Use useState for fen and history (derived from chess.js after each move)
- Create Chess instance with useMemo (not useState to avoid serialization issues)
- chess.js is the source of truth - always derive state from game.fen()
- Handle pawn promotion (default to queen if not specified)
- Call onGameOver callback when game ends (checkmate, stalemate, draw)
- getLegalMoves uses chess.moves({ square, verbose: true })

Avoid pitfalls from research:
- FEN/State Desync: Always derive board position from game.fen()
- Don't maintain separate piece tracking
  </action>
  <verify>Hook can be imported without TypeScript errors; tsc --noEmit passes</verify>
  <done>useChessGame hook exports complete interface for chess game management</done>
</task>

<task type="auto">
  <name>Task 2: Create useStockfish hook</name>
  <files>src/hooks/useStockfish.ts</files>
  <action>
Create a React hook for Stockfish AI opponent communication via Web Worker. Follow patterns from 17-RESEARCH.md and useLlm.ts.

**CRITICAL from research:**
- Always use Web Worker (WASM blocks main thread)
- Clean up worker on unmount (memory leak pitfall)
- Use UCI protocol for communication

Interface:
```typescript
interface UseStockfishOptions {
  skillLevel?: number; // 0-20, default 10
  thinkTimeMs?: number; // default 1000
}

interface UseStockfishReturn {
  // State
  isReady: boolean;
  isThinking: boolean;

  // Actions
  getBestMove: (fen: string) => Promise<string>;
  setSkillLevel: (level: number) => void;
  setThinkTime: (ms: number) => void;

  // Cleanup (also called on unmount)
  destroy: () => void;
}
```

Implementation notes:
1. Create Web Worker on mount with stockfish.js WASM
2. Send 'uci' command, wait for 'uciok' to set isReady
3. Set skill level via: `setoption name Skill Level value ${level}`
4. Get move via: `position fen ${fen}` then `go movetime ${ms}`
5. Parse 'bestmove' response for move (e.g., 'e2e4')
6. Worker.terminate() in cleanup effect and destroy()

UCI Protocol flow:
```
-> uci
<- uciok
-> setoption name Skill Level value 10
-> position fen rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1
-> go movetime 1000
<- info depth 10 ... (ignore)
<- bestmove e2e4 ponder e7e5
```

Skill Level mapping (from research):
- 0-3: Beginner (obvious blunders)
- 4-8: Casual (club player)
- 9-13: Intermediate (strong amateur)
- 14-17: Advanced (expert)
- 18-20: Maximum (near-perfect)

Handle error cases:
- Worker fails to load: isReady stays false
- Invalid FEN: return null from getBestMove
- Worker terminated during thinking: resolve promise with null
  </action>
  <verify>Hook can be imported without TypeScript errors; tsc --noEmit passes</verify>
  <done>useStockfish hook exports complete interface for AI opponent via Web Worker</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] useChessGame hook properly wraps chess.js
- [ ] useStockfish hook uses Web Worker (not main thread)
- [ ] Both hooks follow existing project patterns
- [ ] Types from 17-01 are properly imported
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Hooks ready for ChessBoard and ChessPage components
- No memory leaks from Stockfish worker
</success_criteria>

<output>
After completion, create `.planning/phases/17-chess-integration/17-02-SUMMARY.md`
</output>
