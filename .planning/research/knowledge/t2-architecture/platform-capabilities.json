{
  "$schema": "knowledge-schema.json",
  "tier": 2,
  "tierName": "architecture",
  "domain": "general",
  "lastUpdated": "2026-01-18",
  "confidence": "high",
  "sources": [
    {
      "name": "Gemini Deep Research - App Native Capability Across Platforms",
      "type": "gemini-research",
      "date": "2026-01-18"
    }
  ],
  "entries": [
    {
      "id": "macos-grand-central-dispatch",
      "fact": "macOS Grand Central Dispatch (GCD) automatically manages thread pools and work distribution",
      "details": "GCD abstracts threading into dispatch queues. System manages optimal thread count based on CPU topology. Quality-of-Service (QoS) classes let apps indicate work priority for intelligent scheduling across P/E cores.",
      "confidence": "high",
      "source": "macOS Threading",
      "verificationRequired": false,
      "tags": ["macos", "gcd", "threading", "dispatch-queues"]
    },
    {
      "id": "windows-thread-scheduler",
      "fact": "Windows Thread Director evolved from basic scheduling to heterogeneous-aware with hybrid CPUs",
      "details": "Windows 11 Thread Director works with Intel Thread Director for E-core/P-core scheduling. Games and foreground apps get P-core priority. Background apps migrate to E-cores. Requires CPU hardware support.",
      "confidence": "high",
      "source": "Windows Threading",
      "verificationRequired": false,
      "tags": ["windows", "threading", "thread-director", "hybrid-cpu"]
    },
    {
      "id": "linux-completely-fair-scheduler",
      "fact": "Linux CFS provides fair CPU time allocation but can be tuned with process nice values and cgroups",
      "details": "CFS uses red-black tree for O(log n) scheduling. Nice values (-20 to +19) adjust priority. cgroups enable per-process resource limits. Real-time scheduling classes available for latency-critical workloads.",
      "confidence": "high",
      "source": "Linux Scheduling",
      "verificationRequired": false,
      "tags": ["linux", "cfs", "scheduler", "cgroups"]
    },
    {
      "id": "macos-metal-gpu-access",
      "fact": "Metal provides direct GPU access with minimal driver overhead on macOS",
      "details": "Metal command buffers encode GPU work efficiently. Supports compute shaders, ray tracing (M3+), and mesh shaders. Unified Memory means no explicit CPU-GPU data copies needed.",
      "confidence": "high",
      "source": "macOS GPU Access",
      "verificationRequired": false,
      "tags": ["macos", "metal", "gpu", "low-level-api"]
    },
    {
      "id": "windows-directx12-ultimate",
      "fact": "DirectX 12 Ultimate requires explicit resource management but enables maximum GPU performance",
      "details": "DX12 exposes low-level GPU control: explicit memory management, command lists, descriptor heaps. Requires more developer effort but eliminates driver overhead. Ray tracing, mesh shaders, VRS are DX12 Ultimate features.",
      "confidence": "high",
      "source": "Windows GPU Access",
      "verificationRequired": false,
      "tags": ["windows", "directx12", "gpu", "explicit-api"]
    },
    {
      "id": "vulkan-cross-platform",
      "fact": "Vulkan provides cross-platform low-level GPU access with consistent behavior across operating systems",
      "details": "Vulkan works on Windows, Linux, Android, and macOS (via MoltenVK translation). Single codebase targets multiple platforms. More verbose than DX12/Metal but highly portable.",
      "confidence": "high",
      "source": "Cross-Platform GPU",
      "verificationRequired": false,
      "tags": ["vulkan", "cross-platform", "gpu", "portable"]
    },
    {
      "id": "macos-app-nap",
      "fact": "macOS App Nap suspends background apps to near-zero CPU/power when not visible",
      "details": "Apps not visible and not playing audio enter App Nap. Timers coalesced, I/O deprioritized. Significantly extends battery life. Apps can opt-out for background processing needs.",
      "confidence": "high",
      "source": "macOS Power Management",
      "verificationRequired": false,
      "tags": ["macos", "app-nap", "power", "background"]
    },
    {
      "id": "windows-modern-standby",
      "fact": "Windows Modern Standby maintains network connectivity during sleep for instant-on and background sync",
      "details": "Replaces S3 sleep with connected standby. Apps can register for background access. Battery drain higher than traditional sleep but enables instant wake and push notifications.",
      "confidence": "high",
      "source": "Windows Power Management",
      "verificationRequired": false,
      "tags": ["windows", "modern-standby", "sleep", "background"]
    },
    {
      "id": "linux-systemd-services",
      "fact": "Linux systemd manages background services with dependency resolution and resource controls",
      "details": "Unit files define service behavior, dependencies, resource limits. Supports socket activation, timer-triggered execution, and automatic restart. cgroup integration enables per-service CPU/memory limits.",
      "confidence": "high",
      "source": "Linux Services",
      "verificationRequired": false,
      "tags": ["linux", "systemd", "services", "background"]
    },
    {
      "id": "macos-launchd-agents",
      "fact": "macOS launchd manages daemons and agents with sophisticated triggering conditions",
      "details": "Launch agents run in user context, launch daemons run system-wide. Can trigger on file changes, network availability, device connection, or scheduled intervals. Property list configuration.",
      "confidence": "high",
      "source": "macOS Background Execution",
      "verificationRequired": false,
      "tags": ["macos", "launchd", "daemons", "background"]
    },
    {
      "id": "ios-background-limits",
      "fact": "iOS severely restricts background execution to preserve battery and privacy",
      "details": "Only specific categories allowed: audio, location, VoIP, downloads, push notifications. Background app refresh is discretionary. Apps suspended after ~10 seconds unless whitelisted category.",
      "confidence": "high",
      "source": "iOS Background",
      "verificationRequired": false,
      "tags": ["ios", "background", "restrictions", "battery"]
    },
    {
      "id": "android-doze-app-standby",
      "fact": "Android Doze and App Standby bucket apps by usage to restrict background activity",
      "details": "Doze mode restricts network and CPU when device idle. App Standby buckets (Active, Working Set, Frequent, Rare, Restricted) determine allowed background work. Firebase Cloud Messaging high-priority messages bypass restrictions.",
      "confidence": "high",
      "source": "Android Background",
      "verificationRequired": false,
      "tags": ["android", "doze", "background", "battery"]
    },
    {
      "id": "macos-notarization-requirement",
      "fact": "macOS requires notarization for apps distributed outside App Store to run without Gatekeeper warnings",
      "details": "Apple scans submitted app for malware, issues ticket. Non-notarized apps show scary warning and require right-click > Open workaround. Developer ID signing still required for notarization.",
      "confidence": "high",
      "source": "macOS Security",
      "verificationRequired": false,
      "tags": ["macos", "notarization", "gatekeeper", "security"]
    },
    {
      "id": "windows-smartscreen-reputation",
      "fact": "Windows SmartScreen uses reputation-based blocking for downloaded executables",
      "details": "New executables with few downloads show warning. Reputation builds over time with more installs. EV code signing provides immediate reputation. Can be bypassed by users but provides initial protection.",
      "confidence": "high",
      "source": "Windows Security",
      "verificationRequired": false,
      "tags": ["windows", "smartscreen", "security", "downloads"]
    },
    {
      "id": "linux-apparmor-selinux",
      "fact": "Linux mandatory access control (SELinux, AppArmor) confines apps to declared permissions",
      "details": "SELinux (Red Hat) uses labels and policies. AppArmor (Ubuntu) uses path-based profiles. Both restrict file access, network, and capabilities beyond traditional Unix permissions.",
      "confidence": "high",
      "source": "Linux Security",
      "verificationRequired": false,
      "tags": ["linux", "selinux", "apparmor", "mac", "security"]
    },
    {
      "id": "macos-sandbox-entitlements",
      "fact": "macOS App Sandbox restricts file and resource access based on declared entitlements",
      "details": "Apps request specific entitlements: file access, network, hardware. System grants only declared capabilities. Container directories isolate app data. Required for Mac App Store, optional elsewhere.",
      "confidence": "high",
      "source": "macOS Sandboxing",
      "verificationRequired": false,
      "tags": ["macos", "sandbox", "entitlements", "security"]
    },
    {
      "id": "native-file-dialogs",
      "fact": "Native file dialogs provide consistent UX and sandbox-compatible file access across platforms",
      "details": "System dialogs handle permission prompts and access grants. Cross-platform frameworks (Electron, Tauri) should use native dialogs, not custom implementations, for both UX and security compliance.",
      "confidence": "high",
      "source": "Cross-Platform UX",
      "verificationRequired": false,
      "tags": ["file-dialog", "native", "sandbox", "cross-platform"]
    },
    {
      "id": "platform-specific-keyboards",
      "fact": "Platform keyboard conventions differ significantly and apps must adapt shortcuts accordingly",
      "details": "macOS uses Command, Windows uses Ctrl. Option vs Alt modifier behavior differs. macOS apps traditionally use menu bar, Windows uses ribbon or in-window menus. Proper adaptation is expected by users.",
      "confidence": "high",
      "source": "Platform UX",
      "verificationRequired": false,
      "tags": ["keyboard", "shortcuts", "platform", "ux"]
    },
    {
      "id": "native-notifications-importance",
      "fact": "Native notification systems provide consistent user experience and respect platform settings",
      "details": "macOS Notification Center, Windows Action Center, Linux desktop notifications all have different APIs but consistent UX. Using native APIs ensures proper grouping, Do Not Disturb respect, and user preference honoring.",
      "confidence": "high",
      "source": "Platform Notifications",
      "verificationRequired": false,
      "tags": ["notifications", "native", "platform", "ux"]
    },
    {
      "id": "drag-drop-platform-differences",
      "fact": "Drag and drop implementations vary significantly across platforms in capabilities and APIs",
      "details": "macOS supports rich drag types and promised file creation. Windows uses IDataObject with format negotiation. Linux uses X11 selections or Wayland data offers. Cross-platform apps often implement lowest common denominator.",
      "confidence": "high",
      "source": "Platform Drag-Drop",
      "verificationRequired": false,
      "tags": ["drag-drop", "platform", "native", "api"]
    },
    {
      "id": "accessibility-api-requirements",
      "fact": "Each platform has accessibility APIs that apps must implement for screen reader and assistive technology support",
      "details": "macOS uses NSAccessibility, Windows uses UI Automation, Linux uses AT-SPI. Proper implementation enables screen readers, voice control, and switch access. Often legally required for enterprise and government software.",
      "confidence": "high",
      "source": "Accessibility",
      "verificationRequired": false,
      "tags": ["accessibility", "a11y", "platform", "screen-reader"]
    },
    {
      "id": "tauri-native-advantages",
      "fact": "Tauri provides smaller bundle sizes and better platform integration than Electron",
      "details": "Tauri uses system WebView instead of bundling Chromium. Results in 3-10MB vs 150MB+ bundles. Rust backend enables true native performance and direct system API access. Better security model with command allowlisting.",
      "confidence": "high",
      "source": "App Frameworks",
      "verificationRequired": false,
      "tags": ["tauri", "electron", "native", "framework"]
    },
    {
      "id": "electron-ecosystem-maturity",
      "fact": "Electron has more mature ecosystem but sacrifices bundle size and native feel",
      "details": "Electron bundles full Chromium and Node.js. Large community, many libraries, proven at scale (VS Code, Slack, Discord). But large bundles, higher memory usage, and WebView-style UX may feel non-native.",
      "confidence": "high",
      "source": "App Frameworks",
      "verificationRequired": false,
      "tags": ["electron", "framework", "cross-platform", "chromium"]
    },
    {
      "id": "webview-vs-chromium-tradeoffs",
      "fact": "System WebView apps are smaller but face browser version inconsistencies across users",
      "details": "Tauri, WebView2 use system browser engine. Smaller bundles but behavior varies with user's browser version. Chromium bundling (Electron) ensures consistency but bloats size. Decision depends on target audience.",
      "confidence": "high",
      "source": "App Architecture",
      "verificationRequired": false,
      "tags": ["webview", "chromium", "bundle-size", "consistency"]
    }
  ]
}
