---
phase: 19-native-macos
plan: 02
type: execute
wave: 2
depends_on: ["19-01"]
files_modified: [OptaNative/SMC/, OptaNative/Modules/Sensors/, OptaNative/Utilities/ChipDetection.swift]
autonomous: true
---

<objective>
Integrate SMC (System Management Controller) module for hardware sensor access on Apple Silicon and Intel Macs.

Purpose: Enable reading CPU/GPU temperatures, fan speeds, and power consumption directly from hardware - the primary advantage of native macOS over Tauri.
Output: Working SMC bridge with chip-specific sensor key mappings.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-native-macos/19-RESEARCH.md
@.planning/phases/19-native-macos/19-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Port SMC C bridge from Stats</name>
  <files>OptaNative/SMC/SMC.h, OptaNative/SMC/SMC.c, OptaNative/SMC/SMCBridge.swift</files>
  <action>
Port the SMC communication code from Stats (https://github.com/exelban/stats/tree/master/SMC):

1. Create SMC.h with:
   - SMC key structures (SMCKeyData, SMCVal)
   - IOKit connection types
   - Function declarations for SMC communication

2. Create SMC.c with:
   - IOServiceGetMatchingService for "AppleSMC"
   - IOServiceOpen/IOServiceClose
   - SMC read/write functions using IOConnectCallStructMethod

3. Create SMCBridge.swift with:
   - Swift wrapper class `SMCService`
   - open() method to establish IOKit connection
   - close() method for cleanup
   - readKey(String) -> SMCValue?
   - readTemperature(String) -> Double?

Add bridging header to expose C functions to Swift.

CRITICAL: This requires IOKit access - will only work outside App Store sandbox.
Reference Stats implementation exactly - don't reinvent this complex code.
  </action>
  <verify>Build succeeds, SMCService().readKey("TC0C") returns value (Intel) or nil gracefully (Apple Silicon different keys)</verify>
  <done>SMC bridge compiles, connects to AppleSMC service, reads keys without crashing</done>
</task>

<task type="auto">
  <name>Task 2: Implement chip detection and sensor key mapping</name>
  <files>OptaNative/Utilities/ChipDetection.swift, OptaNative/Modules/Sensors/SensorKeys.swift</files>
  <action>
Create chip detection and key mapping:

1. ChipDetection.swift:
   - isAppleSilicon() -> Bool (check machine string for "arm64")
   - getChipGeneration() -> String (parse machdep.cpu.brand_string for M1/M2/M3/Intel)
   - Use sysctlbyname for both checks per research examples

2. SensorKeys.swift with per-chip mappings from research:
   - M1: E-cores (Tp09, Tp0T), P-cores (Tp01, Tp05, Tp0D, Tp0H, Tp0L, Tp0P, Tp0X, Tp0b), GPU (Tg05, Tg0D, Tg0L, Tg0T)
   - M2: E-cores (Tp1h, Tp1t, Tp1p, Tp1l), P-cores (Tp01, Tp05, Tp09, Tp0D, Tp0X, Tp0b, Tp0f, Tp0j), GPU (Tg0f, Tg0j)
   - M3: E-cores (Te05, Te0L, Te0P, Te0S), P-cores (Tf04, Tf09, Tf0A...), GPU (Tf14, Tf18...)
   - Intel: TC0D, TC0E, TC0F

   Provide functions:
   - cpuTemperatureKeys(chip: String) -> [String]
   - gpuTemperatureKeys(chip: String) -> [String]
   - fanKeys() -> [String]

PITFALL: Keys change every chip generation - never hardcode, always map via chip detection.
  </action>
  <verify>ChipDetection.getChipGeneration() returns correct chip on test Mac</verify>
  <done>Chip detection works, key mappings return appropriate arrays per chip</done>
</task>

<task type="auto">
  <name>Task 3: Create SensorReader service</name>
  <files>OptaNative/Modules/Sensors/SensorReader.swift</files>
  <action>
Create SensorReader class that combines SMC bridge with chip-aware key lookup:

```swift
final class SensorReader {
    private let smc = SMCService()
    private let chip: String

    init() {
        chip = ChipDetection.getChipGeneration()
        try? smc.open()
    }

    func getCPUTemperature() -> Double? {
        let keys = SensorKeys.cpuTemperatureKeys(chip: chip)
        let temps = keys.compactMap { smc.readTemperature($0) }
        guard !temps.isEmpty else { return nil }
        return temps.reduce(0, +) / Double(temps.count)
    }

    func getGPUTemperature() -> Double?
    func getFanSpeeds() -> [Int]
    // etc.
}
```

Handle gracefully when sensors aren't available (Apple Silicon missing some Intel sensors).
Always dispatch SMC reads to background queue - never block main thread.
  </action>
  <verify>SensorReader().getCPUTemperature() returns reasonable value (20-100°C) or nil</verify>
  <done>SensorReader provides CPU/GPU temps, handles missing sensors gracefully</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `xcodebuild -scheme OptaNative build` succeeds
- [ ] SMC module compiles with bridging header
- [ ] Chip detection returns correct chip family on test Mac
- [ ] Temperature readings return sensible values (not 0°C, not 255°C)
- [ ] No crashes on missing sensor keys
</verification>

<success_criteria>
- All tasks completed
- SMC communication working via IOKit
- Chip detection identifies M1/M2/M3/Intel correctly
- Temperature readings match system expectations
- Foundation ready for TelemetryService to use
</success_criteria>

<output>
After completion, create `.planning/phases/19-native-macos/19-02-SUMMARY.md`
</output>
