---
phase: 06-rich-text
plan: 01
title: Markdown Parsing and Rendering
subsystem: chat-ui
wave: 1
autonomous: true
tags: [markdown, swiftui, attributedstring, rich-text, text-rendering]

# Dependency graph
requires:
  - phase: 05-01
    provides: streamingMessages dictionary, MessageBubble streaming initializer
  - phase: 05-03
    provides: TypingCursor component, showTypingCursor parameter
provides:
  - MarkdownContent SwiftUI view component
  - Basic markdown rendering (bold, italic, links, inline code)
  - Bullet point list rendering
  - Integration with MessageBubble for both streaming and completed messages
affects: [06-02-code-blocks, 06-03-expandable]
---

# Phase 06-01: Markdown Parsing and Rendering

**Render basic markdown formatting in chat messages including bold, italic, inline code, links, and bullet points**

## Objective

Replace plain `Text(displayContent)` in MessageBubble with rich markdown rendering that supports streaming content. Use iOS 15+ AttributedString for inline formatting and custom SwiftUI views for structural elements like bullet lists.

## Execution Context

@.planning/phases/05-streaming-state/05-01-SUMMARY.md
@.planning/phases/05-streaming-state/05-03-SUMMARY.md
@Sources/ClawdbotKit/Chat/MessageBubble.swift
@Sources/ClawdbotKit/Design/ClawdbotColors.swift

## Context

**Current state:**
- MessageBubble renders plain `Text(displayContent)` at line 115
- Streaming content accumulates as raw string in ChatViewModel
- No markdown support exists
- Design tokens available for styling (clawdbotPurple, clawdbotBlue, etc.)

**Key decisions from exploration:**
- Use AttributedString for inline formatting (bold, italic, code)
- Custom @ViewBuilder for structural elements (bullet lists)
- Handle incomplete markdown gracefully during streaming
- Preserve existing textColor logic for sender-based styling

**Integration point:** MessageBubble.swift line 115, replace Text() with MarkdownContent view

## Tasks

### Task 1: Create MarkdownContent view component

Create `Sources/ClawdbotKit/Chat/MarkdownContent.swift`:

```swift
import SwiftUI

/// Renders markdown content with support for inline formatting and lists
public struct MarkdownContent: View {
    let content: String
    let baseTextColor: Color

    public init(content: String, textColor: Color = .clawdbotTextPrimary) {
        self.content = content
        self.baseTextColor = textColor
    }

    public var body: some View {
        // Parse content into blocks (paragraphs, bullet lists)
        // Render each block with appropriate formatting
    }
}
```

Components to implement:
- `parseBlocks(_ content: String) -> [ContentBlock]` - split into paragraphs and lists
- `ContentBlock` enum with cases: `.paragraph(String)`, `.bulletList([String])`
- `renderParagraph(_ text: String)` - AttributedString with inline formatting
- `renderBulletList(_ items: [String])` - VStack with bullet points

**Commit after completion:** `feat(06-01): add MarkdownContent view component`

### Task 2: Implement inline markdown formatting

Add to MarkdownContent:
- Bold: `**text**` or `__text__` → `.bold()` attribute
- Italic: `*text*` or `_text_` → `.italic()` attribute
- Inline code: `` `code` `` → monospace font + surface background
- Links: `[text](url)` → `.link` attribute with clawdbotPurple color

Use AttributedString's markdown initializer with fallback:
```swift
private func styledText(_ text: String) -> Text {
    if let attributed = try? AttributedString(markdown: text) {
        return Text(attributed)
    }
    return Text(text)  // Fallback for invalid/incomplete markdown
}
```

Inline code styling (custom, not supported by AttributedString):
- Parse `` `code` `` patterns manually
- Apply `.font(.system(.body, design: .monospaced))`
- Background: clawdbotSurface with 4pt corner radius

**Commit after completion:** `feat(06-01): implement inline markdown formatting`

### Task 3: Implement bullet list rendering

Add bullet list support:
- Detect lines starting with `- `, `* `, or `+ `
- Group consecutive bullet lines into list blocks
- Render with HStack: bullet circle + text

```swift
private func renderBulletItem(_ text: String) -> some View {
    HStack(alignment: .top, spacing: 8) {
        Circle()
            .fill(baseTextColor.opacity(0.6))
            .frame(width: 6, height: 6)
            .padding(.top, 7)  // Align with text baseline

        styledText(text)
            .foregroundColor(baseTextColor)
    }
}
```

List rendering:
```swift
VStack(alignment: .leading, spacing: 4) {
    ForEach(items.indices, id: \.self) { index in
        renderBulletItem(items[index])
    }
}
```

**Commit after completion:** `feat(06-01): implement bullet list rendering`

### Task 4: Integrate MarkdownContent into MessageBubble

Update MessageBubble.swift:
1. Import and use MarkdownContent instead of Text()
2. Pass textColor from existing computed property
3. Preserve TypingCursor integration

Replace line 115-122:
```swift
// Before:
HStack(spacing: 0) {
    Text(displayContent)
        .foregroundColor(textColor)

    if showTypingCursor {
        TypingCursor()
    }
}

// After:
HStack(alignment: .bottom, spacing: 0) {
    MarkdownContent(content: displayContent, textColor: textColor)

    if showTypingCursor {
        TypingCursor()
    }
}
```

Test both initializers:
- `MessageBubble(message:)` for completed messages
- `MessageBubble(streamingContent:sender:showTypingCursor:)` for streaming

**Commit after completion:** `feat(06-01): integrate MarkdownContent into MessageBubble`

### Task 5: Add streaming markdown resilience

Handle incomplete markdown during streaming:
- Unclosed bold/italic markers → render as plain text
- Incomplete links `[text](ur...` → render as plain text
- Open inline code → render with opening backtick visible
- Partial bullet lists → render available items

Add to MarkdownContent:
```swift
/// Validates and potentially repairs incomplete markdown
private func sanitizeForStreaming(_ content: String) -> String {
    // Count unclosed markers and handle gracefully
    // Don't break visible text when syntax is incomplete
}
```

Key behaviors:
- Never crash on malformed markdown
- Preserve all visible text content
- Update rendering as more content arrives

**Commit after completion:** `feat(06-01): add streaming markdown resilience`

### Task 6: Add unit tests for MarkdownContent

Create `Tests/ClawdbotKitTests/MarkdownContentTests.swift`:

Test cases:
1. Plain text renders unchanged
2. Bold text: `**bold**` renders with bold attribute
3. Italic text: `*italic*` renders with italic attribute
4. Inline code: `` `code` `` renders with monospace font
5. Links: `[text](url)` renders as tappable link
6. Bullet list: multiple `- item` lines render as list
7. Mixed content: paragraph with inline formatting + list
8. Incomplete bold: `**partial` renders as plain text
9. Incomplete link: `[text](ur` renders as plain text
10. Empty content: returns empty view

**Commit after completion:** `test(06-01): add MarkdownContent unit tests`

## Verification

```bash
cd apps/ios/ClawdbotKit
swift test --filter MarkdownContent
swift build
```

Expected: All tests pass, no warnings

## Success Criteria

- [ ] MarkdownContent view renders bold, italic, inline code, links
- [ ] Bullet point lists render with proper spacing and alignment
- [ ] Incomplete markdown during streaming doesn't crash
- [ ] MessageBubble uses MarkdownContent for both streaming and completed messages
- [ ] TypingCursor still appears correctly at end of streaming content
- [ ] 10+ new tests for markdown parsing
- [ ] All existing tests pass (115+)

## Output

Files created:
- `Sources/ClawdbotKit/Chat/MarkdownContent.swift`
- `Tests/ClawdbotKitTests/MarkdownContentTests.swift`

Files modified:
- `Sources/ClawdbotKit/Chat/MessageBubble.swift`

---
*Phase: 06-rich-text*
*Plan: 01 of 03*
*Wave: 1*
