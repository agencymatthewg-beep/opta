---
phase: 09-optimization-score
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [mcp-server/src/opta_mcp/scoring.py, src/types/scoring.ts, mcp-server/src/opta_mcp/server.py, src-tauri/src/scoring.rs, src-tauri/src/lib.rs]
autonomous: true
---

<objective>
Enhance the scoring algorithm with three-dimensional sub-scores and wow factor calculations.

Purpose: Transform the basic scoring system into a comprehensive, shareable metric that aligns with MUST_HAVE requirements. The new system provides Performance, Experience, and Competitive dimensions with detailed sub-scores, plus viral "wow factors" like money saved equivalents and percentile rankings.

Output: Enhanced Python scoring module, updated TypeScript types, Tauri command integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/MUST_HAVE.md

# Existing scoring to enhance:
@mcp-server/src/opta_mcp/scoring.py
@src/types/scoring.ts

# Hardware data sources:
@mcp-server/src/opta_mcp/server.py (get_telemetry)
@src/types/profile.ts (hardwareSignature)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define enhanced scoring types</name>
  <files>src/types/scoring.ts</files>
  <action>
Expand TypeScript scoring types to support three-dimensional sub-scores:

```typescript
// Sub-score structure for each dimension
export interface SubScores {
  primary: number;    // 0-100
  secondary: number;  // 0-100
  tertiary: number;   // 0-100
  weighted: number;   // Weighted average 0-100
}

// Three dimensions from MUST_HAVE
export interface DimensionScores {
  performance: {
    fpsGain: number;        // FPS Potential
    stability: number;      // No stutters
    loadTimes: number;      // Load Times
    weighted: number;
  };
  experience: {
    visualQuality: number;  // Visual Quality preservation
    thermalEfficiency: number;  // Thermal Efficiency
    responsiveness: number;     // System Responsiveness
    weighted: number;
  };
  competitive: {
    inputLag: number;       // Input Lag reduction
    networkLatency: number; // Network Latency
    interference: number;   // Background Interference
    weighted: number;
  };
}

// Wow factors for viral sharing
export interface WowFactors {
  moneySaved: {
    amount: number;        // Dollar amount
    equivalent: string;    // "RTX 4060 upgrade" or similar
    explanation: string;   // How this was calculated
  };
  percentileRank: {
    similar: number;       // Percentile in similar hardware tier
    global: number;        // Percentile globally
    tier: string;          // Hardware tier name
  };
  improvementSummary: {
    totalFpsGained: number;
    totalOptimizations: number;
    biggestGain: string;   // "Valorant: +23 FPS"
  };
}

// Hardware tier for comparisons
export interface HardwareTier {
  tier: 'budget' | 'midrange' | 'highend' | 'enthusiast';
  signature: string;       // "RTX 4070 + Ryzen 7" style
  priceRange: string;      // "$800-1200"
}

// Enhanced game score with dimensions
export interface EnhancedGameScore extends GameScore {
  dimensions: DimensionScores;
  wowFactors: WowFactors;
  hardwareTier: HardwareTier;
  version: 2;  // Schema version
}

// User's overall Opta Score
export interface OptaScore {
  overall: number;         // 0-100 composite
  dimensions: DimensionScores;
  wowFactors: WowFactors;
  hardwareTier: HardwareTier;
  gamesOptimized: number;
  lastCalculated: number;
  history: OptaScoreHistoryEntry[];
}

export interface OptaScoreHistoryEntry {
  score: number;
  timestamp: number;
  trigger: string;  // "game_optimized:valorant" or similar
}
```

Keep existing types for backwards compatibility, add new enhanced types.
  </action>
  <verify>npm run build passes with new types</verify>
  <done>Enhanced scoring types defined with dimensions, wow factors, and hardware tiers</done>
</task>

<task type="auto">
  <name>Task 2: Implement enhanced scoring algorithm</name>
  <files>mcp-server/src/opta_mcp/scoring.py</files>
  <action>
Enhance scoring.py with three-dimensional scoring:

1. Add dimension calculation functions:
```python
@dataclass
class DimensionScores:
    """Three-dimensional score breakdown."""
    performance: dict  # fpsGain, stability, loadTimes, weighted
    experience: dict   # visualQuality, thermalEfficiency, responsiveness, weighted
    competitive: dict  # inputLag, networkLatency, interference, weighted

def calculate_performance_dimension(benchmark_data: dict, history: list) -> dict:
    """
    Calculate Performance dimension (FPS Potential, Stability, Load Times).

    - FPS Potential: Based on benchmark FPS improvement
    - Stability: Based on frame time variance reduction
    - Load Times: Based on process optimization and memory management
    """
    pass

def calculate_experience_dimension(benchmark_data: dict, settings: dict) -> dict:
    """
    Calculate Experience dimension (Visual Quality, Thermal, Responsiveness).

    - Visual Quality: Inverse of graphics reductions (higher = kept more quality)
    - Thermal Efficiency: GPU temp reduction score
    - Responsiveness: System responsiveness based on CPU/memory headroom
    """
    pass

def calculate_competitive_dimension(benchmark_data: dict, history: list) -> dict:
    """
    Calculate Competitive dimension (Input Lag, Latency, Interference).

    - Input Lag: Based on priority optimizations
    - Network Latency: Placeholder (future implementation)
    - Interference: Based on background process management
    """
    pass
```

2. Add wow factor calculations:
```python
@dataclass
class WowFactors:
    money_saved: dict     # amount, equivalent, explanation
    percentile_rank: dict # similar, global, tier
    improvement_summary: dict

def calculate_money_saved(fps_gain: float, gpu_tier: str) -> dict:
    """
    Calculate equivalent GPU upgrade cost.

    Logic: Map FPS gain % to typical upgrade path costs.
    - 10-15% gain ≈ $150 (RAM upgrade)
    - 15-25% gain ≈ $250 (GPU tier up)
    - 25-40% gain ≈ $400 (major GPU upgrade)
    - 40%+ gain ≈ $600+ (flagship upgrade)
    """
    pass

def calculate_percentile_rank(score: int, hardware_tier: str) -> dict:
    """
    Calculate percentile ranking.

    For v1: Use statistical estimation based on score distribution.
    Future: Use actual community data when available.
    """
    pass

def detect_hardware_tier() -> dict:
    """
    Detect hardware tier from system info.

    Returns tier (budget/midrange/highend/enthusiast), signature, priceRange.
    """
    pass
```

3. Create enhanced calculate_score function:
```python
def calculate_enhanced_score(game_id: str, game_name: str = "Unknown") -> dict:
    """
    Calculate comprehensive score with all dimensions and wow factors.

    Returns EnhancedGameScore with:
    - Overall score (0-100)
    - Three dimension scores with sub-scores
    - Wow factors (money saved, percentile, summary)
    - Hardware tier info
    """
    # Get existing data
    history = get_optimization_history(game_id)
    benchmark = get_benchmark_pair(game_id)

    # Calculate dimensions
    performance = calculate_performance_dimension(benchmark, history)
    experience = calculate_experience_dimension(benchmark, {})
    competitive = calculate_competitive_dimension(benchmark, history)

    # Overall score is weighted average of dimension scores
    overall = (
        performance['weighted'] * 0.4 +
        experience['weighted'] * 0.35 +
        competitive['weighted'] * 0.25
    )

    # Calculate wow factors
    fps_gain = benchmark.get('improvement', {}).get('fps_increase', 0) if benchmark else 0
    hardware_tier = detect_hardware_tier()
    money_saved = calculate_money_saved(fps_gain, hardware_tier['tier'])
    percentile = calculate_percentile_rank(int(overall), hardware_tier['tier'])

    return {
        'game_id': game_id,
        'game_name': game_name,
        'score': int(overall),
        'dimensions': {
            'performance': performance,
            'experience': experience,
            'competitive': competitive
        },
        'wowFactors': {
            'moneySaved': money_saved,
            'percentileRank': percentile,
            'improvementSummary': {...}
        },
        'hardwareTier': hardware_tier,
        'version': 2,
        'calculated_at': time.time()
    }
```

4. Add global Opta Score calculation:
```python
def calculate_opta_score() -> dict:
    """
    Calculate user's overall Opta Score across all games.

    Aggregates individual game scores into one shareable metric.
    """
    all_scores = get_all_scores()
    if not all_scores:
        return None

    # Aggregate dimensions across games
    # Calculate composite wow factors
    # Return OptaScore structure
```

Keep existing `calculate_score` function for backwards compatibility, mark as deprecated.
  </action>
  <verify>Python: `python -c "from opta_mcp.scoring import calculate_enhanced_score, calculate_opta_score"`</verify>
  <done>Enhanced scoring algorithm with dimensions and wow factors implemented</done>
</task>

<task type="auto">
  <name>Task 3: Add MCP tools and Tauri commands</name>
  <files>mcp-server/src/opta_mcp/server.py, src-tauri/src/scoring.rs, src-tauri/src/lib.rs</files>
  <action>
1. Add new MCP tools in server.py:
```python
Tool(
    name="calculate_enhanced_score",
    description="Calculate comprehensive game score with dimensions and wow factors",
    inputSchema={
        "type": "object",
        "properties": {
            "game_id": {"type": "string"},
            "game_name": {"type": "string"}
        },
        "required": ["game_id"]
    }
),
Tool(
    name="calculate_opta_score",
    description="Calculate user's overall Opta Score across all games",
    inputSchema={"type": "object", "properties": {}}
),
Tool(
    name="get_hardware_tier",
    description="Detect and return current hardware tier information",
    inputSchema={"type": "object", "properties": {}}
)
```

2. Add handlers in handle_call_tool for new tools.

3. Create/update src-tauri/src/scoring.rs:
```rust
use crate::mcp::call_mcp_tool;
use serde_json::{json, Value};

#[tauri::command]
pub async fn calculate_enhanced_score(game_id: String, game_name: Option<String>) -> Result<Value, String> {
    call_mcp_tool("calculate_enhanced_score", json!({
        "game_id": game_id,
        "game_name": game_name.unwrap_or_default()
    })).await
}

#[tauri::command]
pub async fn calculate_opta_score() -> Result<Value, String> {
    call_mcp_tool("calculate_opta_score", json!({})).await
}

#[tauri::command]
pub async fn get_hardware_tier() -> Result<Value, String> {
    call_mcp_tool("get_hardware_tier", json!({})).await
}
```

4. Register commands in lib.rs:
```rust
.invoke_handler(tauri::generate_handler![
    // ... existing handlers
    scoring::calculate_enhanced_score,
    scoring::calculate_opta_score,
    scoring::get_hardware_tier,
])
```
  </action>
  <verify>cargo build passes, commands callable from frontend</verify>
  <done>MCP tools and Tauri commands added for enhanced scoring</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `cargo build` succeeds without errors
- [ ] Enhanced types properly defined in scoring.ts
- [ ] calculate_enhanced_score returns all dimensions and wow factors
- [ ] calculate_opta_score aggregates across all games
- [ ] Hardware tier detection works
- [ ] Tauri commands callable from frontend
</verification>

<success_criteria>
- All tasks completed
- Three dimensions implemented (Performance, Experience, Competitive)
- Each dimension has three sub-scores
- Wow factors calculate money saved and percentile rank
- Hardware tier auto-detection working
- Backwards compatibility maintained with v1 scores
- Score schema versioned (version: 2)
</success_criteria>

<output>
After completion, create `.planning/phases/09-optimization-score/09-01-SUMMARY.md`
</output>
