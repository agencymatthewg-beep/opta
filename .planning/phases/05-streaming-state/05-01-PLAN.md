---
phase: 05-streaming-state
plan: 01
name: Streaming Message Rendering
wave: 1
autonomous: true
scope: small
estimated-tasks: 4
subsystem: chat-ui

# Dependencies
requires:
  - phase: 04-01
    provides: ChatViewModel, MessageBubble, ChatView
  - phase: 03-01
    provides: StreamingChunk, StreamingMessageAssembler
  - phase: 03-04
    provides: ProtocolHandler streaming chunk handling
provides:
  - Real-time streaming message rendering in chat
  - StreamingMessageBubble component with live text updates
  - ChatViewModel streaming state management
affects: [05-02-thinking-state, 05-03-typing-indicator, 06-rich-text]
---

# Objective

Implement real-time streaming message rendering so bot responses appear character-by-character as chunks arrive from the WebSocket, providing immediate feedback during long responses.

# Execution Context

## Relevant Files
- `apps/ios/ClawdbotKit/Sources/ClawdbotKit/Chat/ChatViewModel.swift` - Add streaming state
- `apps/ios/ClawdbotKit/Sources/ClawdbotKit/Chat/MessageBubble.swift` - Extend or create streaming variant
- `apps/ios/ClawdbotKit/Sources/ClawdbotKit/Protocol/ProtocolHandler.swift` - Already emits chunks via delegate
- `apps/ios/ClawdbotKit/Sources/ClawdbotKit/Protocol/StreamingTypes.swift` - Existing chunk types

## Patterns to Follow
- **Observable View Model Wrapping Actor**: ChatViewModel already uses this pattern
- **Combine publishers for streaming**: ProtocolHandler already has incomingMessages publisher
- **Optimistic updates**: Existing pattern shows message immediately with status tracking

# Context

## Architecture Decision
The ProtocolHandler already:
1. Receives streaming chunks via `handleIncoming()`
2. Adds chunks to `StreamingMessageAssembler`
3. Calls delegate `didReceiveChunk()`
4. Creates completed message when `isFinal` chunk arrives

What's missing:
1. **ChatViewModel doesn't subscribe to streaming chunks** - only full messages
2. **No UI for in-progress streaming messages** - MessageBubble shows complete messages
3. **No streaming state tracking** - which messages are actively streaming

## Design
Add a new Combine publisher to ProtocolHandler for streaming chunks, then:
1. ChatViewModel subscribes to chunk publisher
2. Maintains `streamingMessages: [MessageID: String]` for partial content
3. MessageBubble shows streaming content with animation
4. When `isFinal` arrives, convert streaming to regular message

# Tasks

## Task 1: Add streaming chunk publisher to ProtocolHandler
**File:** `apps/ios/ClawdbotKit/Sources/ClawdbotKit/Protocol/ProtocolHandler.swift`

Add a PassthroughSubject for streaming chunks alongside existing publishers:
```swift
/// Publisher for streaming chunks (for real-time UI updates)
public nonisolated let streamingChunks = PassthroughSubject<StreamingChunk, Never>()
```

In `handleIncoming()` case `.streamingChunk`, add:
```swift
streamingChunks.send(chunk)
```

**Verification:** Unit test that subscribes to publisher and receives chunks.

## Task 2: Add streaming state to ChatViewModel
**File:** `apps/ios/ClawdbotKit/Sources/ClawdbotKit/Chat/ChatViewModel.swift`

Add properties:
```swift
/// Messages currently being streamed (messageID -> accumulated content)
public private(set) var streamingMessages: [String: String] = [:]
```

Subscribe to streaming chunks in `observeMessages()`:
```swift
protocolHandler.streamingChunks
    .receive(on: DispatchQueue.main)
    .sink { [weak self] chunk in
        self?.handleStreamingChunk(chunk)
    }
    .store(in: &cancellables)
```

Implement `handleStreamingChunk(_ chunk: StreamingChunk)`:
1. Append chunk.content to `streamingMessages[chunk.messageID.value]`
2. If `chunk.isFinal`, remove from streamingMessages (message will arrive via incomingMessages)

**Verification:** Unit test verifying streaming state updates.

## Task 3: Update MessageBubble for streaming content
**File:** `apps/ios/ClawdbotKit/Sources/ClawdbotKit/Chat/MessageBubble.swift`

Option A: Add streaming initializer
```swift
public init(streamingContent: String, sender: MessageSender)
```

Option B: Modify existing to accept optional streaming flag
```swift
public var isStreaming: Bool = false
```

Add visual indicator for streaming messages:
- Subtle pulsing animation while streaming
- No status icon (pending/delivered) during streaming

**Verification:** SwiftUI Preview showing streaming state.

## Task 4: Update ChatView to display streaming messages
**File:** `apps/ios/ClawdbotMobile/ClawdbotMobile/Views/ChatView.swift`

After rendering messages array, add streaming messages:
```swift
ForEach(Array(viewModel.streamingMessages.keys), id: \.self) { messageID in
    if let content = viewModel.streamingMessages[messageID] {
        MessageBubble(streamingContent: content, sender: .bot(name: "Clawdbot"))
    }
}
```

Ensure auto-scroll triggers when streaming content updates.

**Verification:** Manual test with mock streaming data or actual Clawdbot connection.

# Verification

```bash
# Run tests
cd apps/ios/ClawdbotKit
swift test

# Build app
cd ../ClawdbotMobile
xcodebuild -scheme ClawdbotMobile -destination 'platform=iOS Simulator,name=iPhone 16' build
```

# Success Criteria

- [ ] ProtocolHandler emits streaming chunks via Combine publisher
- [ ] ChatViewModel tracks streaming messages with accumulated content
- [ ] MessageBubble displays streaming content with visual indicator
- [ ] ChatView shows streaming messages in real-time
- [ ] Auto-scroll works during streaming
- [ ] All existing tests pass
- [ ] New tests for streaming functionality

# Output

Files created/modified:
- `apps/ios/ClawdbotKit/Sources/ClawdbotKit/Protocol/ProtocolHandler.swift` - Add streamingChunks publisher
- `apps/ios/ClawdbotKit/Sources/ClawdbotKit/Chat/ChatViewModel.swift` - Add streaming state
- `apps/ios/ClawdbotKit/Sources/ClawdbotKit/Chat/MessageBubble.swift` - Add streaming support
- `apps/ios/ClawdbotMobile/ClawdbotMobile/Views/ChatView.swift` - Display streaming messages
- `apps/ios/ClawdbotKit/Tests/ClawdbotKitTests/ChatViewModelTests.swift` - Add streaming tests
