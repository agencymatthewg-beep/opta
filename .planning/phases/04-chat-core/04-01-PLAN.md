---
phase: 04-chat-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/ios/ClawdbotKit/Sources/ClawdbotKit/Chat/ChatViewModel.swift
  - apps/ios/ClawdbotKit/Sources/ClawdbotKit/Chat/MessageBubble.swift
  - apps/ios/ClawdbotKit/Sources/ClawdbotKit/Chat/Chat.swift
  - apps/ios/Clawdbot iOS/Views/ChatView.swift
  - apps/ios/ClawdbotKit/Tests/ClawdbotKitTests/ChatViewModelTests.swift
autonomous: true
---

<objective>
Build the foundational chat UI with message list and bubble rendering.

Purpose: This is the first user-facing phase. Establishes the core chat interface pattern that all subsequent phases build upon.
Output: Working chat view displaying messages with proper sender differentiation, auto-scroll, and connection to ProtocolHandler.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 3 summary needed - ProtocolHandler provides the Combine publishers we observe
@.planning/phases/03-protocol/03-04-SUMMARY.md

# Research findings for SwiftUI patterns
@.planning/phases/04-chat-core/04-RESEARCH.md

# Existing ClawdbotKit structure
@apps/ios/ClawdbotKit/Sources/ClawdbotKit/Protocol/ProtocolHandler.swift
@apps/ios/ClawdbotKit/Sources/ClawdbotKit/Protocol/MessageTypes.swift
@apps/ios/ClawdbotKit/Sources/ClawdbotKit/Design/OptaColors.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ChatViewModel with @Observable</name>
  <files>apps/ios/ClawdbotKit/Sources/ClawdbotKit/Chat/ChatViewModel.swift</files>
  <action>
Create ChatViewModel as @MainActor @Observable class wrapping ProtocolHandler:

1. Properties (all private(set) for external read-only):
   - messages: [ChatMessage] = []
   - connectionState: ConnectionState (from ConnectionManager)
   - isLoading: Bool = false

2. Initialization:
   - Takes ProtocolHandler as dependency
   - Sets up Combine subscriptions in init

3. Combine observation:
   - Subscribe to protocolHandler.incomingMessages
   - CRITICAL: Use .receive(on: DispatchQueue.main) before sink
   - Append to messages array, handle duplicates by MessageID
   - Store cancellables in private Set<AnyCancellable>

4. Send method:
   - func send(_ text: String) async
   - Create ChatMessage with .user sender, .pending status
   - Optimistic append to messages BEFORE await send
   - Call await protocolHandler.send(envelope)

Use the patterns from 04-RESEARCH.md - this is the "Observable View Model Wrapping Actor" pattern.
  </action>
  <verify>swift build in ClawdbotKit directory compiles without errors</verify>
  <done>ChatViewModel compiles with @Observable, Combine subscriptions, and send method</done>
</task>

<task type="auto">
  <name>Task 2: Create MessageBubble view</name>
  <files>apps/ios/ClawdbotKit/Sources/ClawdbotKit/Chat/MessageBubble.swift</files>
  <action>
Create MessageBubble SwiftUI view for rendering individual chat messages:

1. Properties:
   - let message: ChatMessage
   - Compute alignment from message.sender (.user = trailing, .bot = leading)

2. Layout:
   - HStack with spacer on opposite side of sender
   - Text(message.content) as main content
   - Use .padding() for bubble interior
   - Use .background() with RoundedRectangle(cornerRadius: 16)

3. Colors (from OptaColors):
   - User messages: OptaColors.Brand.teal background, white text
   - Bot messages: OptaColors.Background.secondary background, OptaColors.Text.primary text

4. Status indicator (subtle):
   - For .user messages, show small icon based on message.status
   - .pending: clock icon (systemName: "clock")
   - .sent: checkmark
   - .delivered: double checkmark
   - .failed: exclamationmark.triangle (in OptaColors.Semantic.error)

5. Timestamp:
   - Show message.timestamp.formatted() in small caption below bubble
   - Use OptaColors.Text.tertiary

Keep bubbles compact - this is a clean/minimalistic interface per the vision.
  </action>
  <verify>swift build compiles MessageBubble view</verify>
  <done>MessageBubble renders with proper alignment, colors, and status for user vs bot messages</done>
</task>

<task type="auto">
  <name>Task 3: Create ChatView with message list</name>
  <files>apps/ios/Clawdbot iOS/Views/ChatView.swift</files>
  <action>
Create main ChatView in the iOS app target (not ClawdbotKit):

1. Properties:
   - @State private var viewModel: ChatViewModel
   - @State private var scrollPosition: MessageID?

2. Body structure:
   - NavigationStack (for future navigation)
   - ScrollView with LazyVStack(spacing: 8)
   - ForEach(viewModel.messages) with MessageBubble
   - Add .scrollTargetLayout() to LazyVStack
   - Add .scrollPosition(id: $scrollPosition, anchor: .bottom) to ScrollView

3. Auto-scroll on new messages:
   - .onChange(of: viewModel.messages.count) modifier
   - Inside: withAnimation { scrollPosition = viewModel.messages.last?.id }

4. Navigation bar:
   - .navigationTitle("Clawdbot")
   - .toolbarTitleDisplayMode(.inline)

5. Connection state indicator:
   - In toolbar, show connection status dot
   - Use connectionState from viewModel
   - Green for connected, yellow for connecting, red for disconnected

Initialize viewModel with a ProtocolHandler instance. For now, create a placeholder init - the actual connection wiring comes later.
  </action>
  <verify>xcodebuild -scheme "Clawdbot iOS" -destination 'platform=iOS Simulator,name=iPhone 15' build</verify>
  <done>ChatView builds and displays scrollable message list with auto-scroll behavior</done>
</task>

<task type="auto">
  <name>Task 4: Create Chat module exports</name>
  <files>apps/ios/ClawdbotKit/Sources/ClawdbotKit/Chat/Chat.swift</files>
  <action>
Create module export file following established pattern from Protocol.swift:

1. Add ClawdbotChat namespace enum (following project convention):
   ```swift
   public enum ClawdbotChat {
       public static let version = "1.0.0"
   }
   ```

2. Re-export public types:
   - ChatViewModel
   - MessageBubble

3. Add typealiases for convenience if helpful

This follows the same pattern as ClawdbotProtocol in Protocol.swift.
  </action>
  <verify>Import ClawdbotKit in Clawdbot iOS and access ChatViewModel</verify>
  <done>Chat module properly exports all public types</done>
</task>

<task type="auto">
  <name>Task 5: Add ChatViewModel tests</name>
  <files>apps/ios/ClawdbotKit/Tests/ClawdbotKitTests/ChatViewModelTests.swift</files>
  <action>
Create test file for ChatViewModel:

1. Test message sending:
   - Create mock ProtocolHandler or use real one with mock WebSocket
   - Call viewModel.send("test")
   - Assert message appears in viewModel.messages with .pending status

2. Test optimistic updates:
   - Send message, immediately check it's in array before any async completion

3. Test duplicate handling:
   - If same MessageID arrives twice, should not duplicate in array

4. Test MainActor safety:
   - All tests should run on MainActor (use @MainActor on test class)

Use XCTest following the existing test patterns in ClawdbotKitTests.
  </action>
  <verify>swift test --filter ChatViewModelTests</verify>
  <done>At least 3 tests pass covering send, optimistic updates, and duplicate handling</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] swift build succeeds in ClawdbotKit
- [ ] xcodebuild for "Clawdbot iOS" succeeds
- [ ] swift test passes for ChatViewModelTests
- [ ] ChatView displays in SwiftUI preview (if previews work)
</verification>

<success_criteria>

- All tasks completed with passing builds/tests
- ChatViewModel properly observes ProtocolHandler via Combine
- MessageBubble renders user vs bot messages distinctly
- ChatView displays scrollable message list
- Auto-scroll to bottom works on new messages
- Code follows established ClawdbotKit patterns (@MainActor, actors, Combine)
</success_criteria>

<output>
After completion, create `.planning/phases/04-chat-core/04-01-SUMMARY.md`
</output>
