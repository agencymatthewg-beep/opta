---
phase: 06.1-aesthetic-alignment
plan: 03
title: Animation Enhancements
subsystem: design
wave: 2
autonomous: true
tags: [animation, ignition, glow-pulse, stagger, accessibility, swiftui]

# Dependency graph
requires:
  - phase: 06.1-01
    provides: ClawdbotTypography, Sora font
  - phase: 06.1-02
    provides: ClawdbotGlowEffects, obsidian glass, ClawdbotGlassModifiers
provides:
  - Ignition animation modifier (wake from darkness)
  - Glow pulse animation modifier
  - Enhanced staggered entry with ignition
  - Reduced motion compliance
  - Animation application to Chat components
affects: [06-rich-text, 07-rich-visual]
---

# Phase 06.1-03: Animation Enhancements

**Implement ignition animation, glow pulse, enhanced staggered entry, and accessibility compliance for Reduce Motion**

## Objective

Add premium animations matching the Opta Life Manager aesthetic. Elements should "wake from darkness" (ignition), glow can pulse for activity indication, and list entries should cascade with delays. All animations must respect iOS Reduce Motion accessibility setting.

## Execution Context

@.planning/phases/06.1-aesthetic-alignment/06.1-01-PLAN.md
@.planning/phases/06.1-aesthetic-alignment/06.1-02-PLAN.md
@Sources/ClawdbotKit/Design/ClawdbotAnimations.swift
@apps/desktop/opta-native/DESIGN_SYSTEM.md

## Context

**Animation System (from DESIGN_SYSTEM.md v5.0):**

| Animation | Description | Duration | Properties |
|-----------|-------------|----------|------------|
| Ignition | Elements wake from darkness | 0.8s | opacity 0→1, scale 0.98→1, brightness 0.5→1 |
| Glow Pulse | Rhythmic glow breathing | 2s | box-shadow opacity oscillates |
| Stagger | Cascade entry | 50ms delay | per-item delay based on index |
| Ring Breathe | Dormant breathing | 4s dormant, 3s active | subtle scale/opacity |

**Current ClawdbotAnimations.swift state:**
- Has spring presets (clawdbotSpring, clawdbotSpringGentle, clawdbotSpringBounce)
- Has basic staggeredAppear modifier
- Missing ignition animation
- Missing glow pulse animation
- No Reduce Motion compliance

**Reduce Motion Requirements:**
- Check `UIAccessibility.isReduceMotionEnabled`
- Use instant transitions instead of animated
- Keep functional feedback, remove decorative motion

## Tasks

### Task 1: Add Reduce Motion compliance utilities

Modify `Sources/ClawdbotKit/Design/ClawdbotAnimations.swift`:

```swift
import SwiftUI
#if os(iOS)
import UIKit
#endif

// MARK: - Reduce Motion Support

public enum ClawdbotMotion {
    /// Check if reduce motion is enabled
    public static var isReduceMotionEnabled: Bool {
        #if os(iOS)
        return UIAccessibility.isReduceMotionEnabled
        #elseif os(macOS)
        return NSWorkspace.shared.accessibilityDisplayShouldReduceMotion
        #else
        return false
        #endif
    }

    /// Returns animation or nil if reduce motion is enabled
    public static func animation(_ animation: Animation) -> Animation? {
        isReduceMotionEnabled ? nil : animation
    }

    /// Returns animation or instant if reduce motion is enabled
    public static func safeAnimation(_ animation: Animation) -> Animation {
        isReduceMotionEnabled ? .linear(duration: 0) : animation
    }
}

// MARK: - Conditional Animation Modifier

public extension View {
    /// Apply animation only if reduce motion is disabled
    func clawdbotAnimation(_ animation: Animation) -> some View {
        self.animation(ClawdbotMotion.animation(animation), value: UUID())
    }

    /// Apply animation with reduce motion fallback
    func clawdbotAnimationSafe(_ animation: Animation) -> some View {
        self.animation(ClawdbotMotion.safeAnimation(animation), value: UUID())
    }
}
```

**Commit after completion:** `feat(06.1-03): add Reduce Motion compliance utilities`

### Task 2: Implement ignition animation modifier

Add to `ClawdbotAnimations.swift`:

```swift
// MARK: - Ignition Animation

/// Ignition state for wake-from-darkness effect
public struct IgnitionModifier: ViewModifier {
    let isVisible: Bool
    let delay: Double

    @State private var hasAppeared = false

    public func body(content: Content) -> some View {
        content
            .opacity(effectiveOpacity)
            .scaleEffect(effectiveScale)
            .brightness(effectiveBrightness)
            .onAppear {
                guard !ClawdbotMotion.isReduceMotionEnabled else {
                    hasAppeared = true
                    return
                }

                DispatchQueue.main.asyncAfter(deadline: .now() + delay) {
                    withAnimation(.easeOut(duration: 0.8)) {
                        hasAppeared = true
                    }
                }
            }
    }

    private var effectiveOpacity: Double {
        if ClawdbotMotion.isReduceMotionEnabled { return 1 }
        return (isVisible && hasAppeared) ? 1 : 0
    }

    private var effectiveScale: CGFloat {
        if ClawdbotMotion.isReduceMotionEnabled { return 1 }
        return (isVisible && hasAppeared) ? 1 : 0.98
    }

    private var effectiveBrightness: Double {
        if ClawdbotMotion.isReduceMotionEnabled { return 0 }
        return (isVisible && hasAppeared) ? 0 : -0.2
    }
}

public extension View {
    /// Ignition animation - elements wake from darkness
    /// Opacity 0→1, scale 0.98→1, brightness darkened→normal
    func ignition(isVisible: Bool = true, delay: Double = 0) -> some View {
        modifier(IgnitionModifier(isVisible: isVisible, delay: delay))
    }
}
```

**Commit after completion:** `feat(06.1-03): implement ignition animation modifier`

### Task 3: Implement glow pulse animation modifier

Add to `ClawdbotAnimations.swift`:

```swift
// MARK: - Glow Pulse Animation

/// Pulsing glow effect for activity indication
public struct GlowPulseModifier: ViewModifier {
    let color: Color
    let isActive: Bool

    @State private var glowPhase: CGFloat = 0

    public func body(content: Content) -> some View {
        content
            .shadow(
                color: color.opacity(isActive ? pulseOpacity : 0),
                radius: isActive ? pulseRadius : 0
            )
            .onAppear {
                guard isActive && !ClawdbotMotion.isReduceMotionEnabled else { return }
                startPulsing()
            }
            .onChange(of: isActive) { newValue in
                if newValue && !ClawdbotMotion.isReduceMotionEnabled {
                    startPulsing()
                }
            }
    }

    private var pulseOpacity: Double {
        0.3 + 0.2 * sin(glowPhase * .pi * 2)
    }

    private var pulseRadius: CGFloat {
        12 + 8 * sin(glowPhase * .pi * 2)
    }

    private func startPulsing() {
        withAnimation(.easeInOut(duration: 2).repeatForever(autoreverses: false)) {
            glowPhase = 1
        }
    }
}

public extension View {
    /// Glow pulse animation for activity indication
    /// 2s ease-in-out infinite cycle
    func glowPulse(color: Color = .clawdbotPurple, isActive: Bool = true) -> some View {
        modifier(GlowPulseModifier(color: color, isActive: isActive))
    }

    /// Purple glow pulse (most common)
    func glowPulsePurple(isActive: Bool = true) -> some View {
        glowPulse(color: .clawdbotPurple, isActive: isActive)
    }

    /// Cyan glow pulse
    func glowPulseCyan(isActive: Bool = true) -> some View {
        glowPulse(color: .clawdbotCyan, isActive: isActive)
    }

    /// Green glow pulse
    func glowPulseGreen(isActive: Bool = true) -> some View {
        glowPulse(color: .clawdbotGreen, isActive: isActive)
    }
}
```

**Commit after completion:** `feat(06.1-03): implement glow pulse animation modifier`

### Task 4: Enhance staggered entry with ignition

Add to `ClawdbotAnimations.swift`:

```swift
// MARK: - Staggered Ignition

/// Combined stagger delay + ignition animation
public struct StaggeredIgnitionModifier: ViewModifier {
    let index: Int
    let isVisible: Bool
    let baseDelay: Double
    let staggerInterval: Double

    public init(
        index: Int,
        isVisible: Bool = true,
        baseDelay: Double = 0,
        staggerInterval: Double = 0.05  // 50ms per item
    ) {
        self.index = index
        self.isVisible = isVisible
        self.baseDelay = baseDelay
        self.staggerInterval = staggerInterval
    }

    public func body(content: Content) -> some View {
        content
            .ignition(isVisible: isVisible, delay: baseDelay + Double(index) * staggerInterval)
    }
}

public extension View {
    /// Staggered ignition - combines cascade delay with wake-from-darkness
    /// Default: 50ms delay per item
    func staggeredIgnition(
        index: Int,
        isVisible: Bool = true,
        baseDelay: Double = 0,
        staggerInterval: Double = 0.05
    ) -> some View {
        modifier(StaggeredIgnitionModifier(
            index: index,
            isVisible: isVisible,
            baseDelay: baseDelay,
            staggerInterval: staggerInterval
        ))
    }
}

// MARK: - Enhanced Stagger Container

/// Container that manages staggered animation state for children
public struct StaggeredContainer<Content: View>: View {
    let content: Content
    @State private var isVisible = false

    public init(@ViewBuilder content: () -> Content) {
        self.content = content()
    }

    public var body: some View {
        content
            .environment(\.staggeredContainerIsVisible, isVisible)
            .onAppear {
                // Small delay to allow layout before animation
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                    isVisible = true
                }
            }
    }
}

// Environment key for stagger visibility
private struct StaggeredContainerIsVisibleKey: EnvironmentKey {
    static let defaultValue: Bool = true
}

extension EnvironmentValues {
    var staggeredContainerIsVisible: Bool {
        get { self[StaggeredContainerIsVisibleKey.self] }
        set { self[StaggeredContainerIsVisibleKey.self] = newValue }
    }
}
```

**Commit after completion:** `feat(06.1-03): enhance staggered entry with ignition`

### Task 5: Apply ignition to chat message list

Modify `Sources/ClawdbotKit/Chat/ChatView.swift` (or the relevant view that displays messages):

```swift
// In the message list ForEach:
ForEach(Array(viewModel.messages.enumerated()), id: \.element.id) { index, message in
    MessageBubble(message: message)
        .staggeredIgnition(index: index)
}

// Or if using ScrollView with LazyVStack:
LazyVStack(spacing: 8) {
    ForEach(Array(viewModel.messages.enumerated()), id: \.element.id) { index, message in
        MessageBubble(message: message)
            .ignition(isVisible: true, delay: Double(index) * 0.03)
    }
}
```

**Note**: Only apply stagger to newly appearing messages, not when scrolling through existing history. May need to track which messages have been displayed.

**Commit after completion:** `feat(06.1-03): apply ignition animation to chat message list`

### Task 6: Apply glow pulse to ThinkingIndicator

Modify `Sources/ClawdbotKit/Chat/ThinkingIndicator.swift`:

```swift
// Add glow pulse to the container
.glowPulsePurple(isActive: true)

// Or for the bouncing dots, add subtle glow:
Circle()
    .fill(Color.clawdbotPurple)
    .frame(width: 8, height: 8)
    .offset(y: animationPhase == index ? -8 : 0)
    .glowPurple(.sm)  // Subtle static glow on each dot
```

**Commit after completion:** `feat(06.1-03): apply glow pulse to ThinkingIndicator`

### Task 7: Add animation timing constants

Add to `ClawdbotAnimations.swift`:

```swift
// MARK: - Animation Timing Constants

public enum ClawdbotTiming {
    /// Fast feedback (150ms)
    public static let fast: Double = 0.15

    /// Normal interaction (200ms)
    public static let normal: Double = 0.2

    /// Deliberate action (300ms)
    public static let slow: Double = 0.3

    /// Emphasized transition (500ms)
    public static let slower: Double = 0.5

    /// Ignition wake-up (800ms)
    public static let ignition: Double = 0.8

    /// Glow pulse cycle (2s)
    public static let glowPulse: Double = 2.0

    /// Stagger interval (50ms)
    public static let staggerInterval: Double = 0.05

    /// Ring dormant breathe (4s)
    public static let ringDormant: Double = 4.0

    /// Ring active breathe (3s)
    public static let ringActive: Double = 3.0
}
```

**Commit after completion:** `feat(06.1-03): add animation timing constants`

### Task 8: Add animation unit tests

Create `Tests/ClawdbotKitTests/ClawdbotAnimationTests.swift`:

Test cases:
1. IgnitionModifier applies correct initial state
2. IgnitionModifier animates to visible state
3. GlowPulseModifier activates when isActive is true
4. StaggeredIgnition calculates correct delay
5. Reduce motion disables animations
6. Timing constants have correct values
7. Spring animations use correct parameters

**Commit after completion:** `test(06.1-03): add animation unit tests`

## Verification

```bash
cd apps/ios/ClawdbotKit
swift build
swift test --filter Animation
```

Test on device with Reduce Motion enabled:
1. Settings > Accessibility > Motion > Reduce Motion: ON
2. Launch app, verify animations are instant/minimal
3. Verify functional feedback still works

Expected: Build succeeds, all tests pass, Reduce Motion respected

## Success Criteria

- [ ] Ignition animation modifier works (wake from darkness effect)
- [ ] Glow pulse animation modifier works (2s breathing cycle)
- [ ] Staggered ignition combines delay + ignition
- [ ] Reduce Motion setting disables decorative animations
- [ ] Chat messages enter with ignition/stagger effect
- [ ] ThinkingIndicator has glow pulse
- [ ] Animation timing constants defined
- [ ] 7+ animation tests pass
- [ ] All existing 115+ tests still pass

## Output

Files created:
- `Tests/ClawdbotKitTests/ClawdbotAnimationTests.swift`

Files modified:
- `Sources/ClawdbotKit/Design/ClawdbotAnimations.swift` (major additions)
- `Sources/ClawdbotKit/Chat/ChatView.swift` (apply ignition)
- `Sources/ClawdbotKit/Chat/ThinkingIndicator.swift` (apply glow pulse)

---
*Phase: 06.1-aesthetic-alignment*
*Plan: 03 of 03*
*Wave: 2*
