---
phase: 03-protocol
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified: [apps/ios/ClawdbotKit/Sources/ClawdbotKit/Protocol/MessageQueue.swift, apps/ios/ClawdbotKit/Tests/ClawdbotKitTests/MessageQueueTests.swift]
autonomous: true
---

<objective>
Implement message queue with delivery confirmation tracking.

Purpose: Manage outgoing messages with queue ordering, delivery status tracking, and retry logic for failed sends. This ensures reliable message delivery even with network interruptions.
Output: `MessageQueue.swift` with OutgoingMessageQueue actor for reliable message delivery.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Plan 03-01 provides message types:
@.planning/phases/03-protocol/03-01-PLAN.md

# Connection layer for sending:
@apps/ios/ClawdbotKit/Sources/ClawdbotKit/Connection/ConnectionManager.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create message queue</name>
  <files>apps/ios/ClawdbotKit/Sources/ClawdbotKit/Protocol/MessageQueue.swift</files>
  <action>
Create message queue at `apps/ios/ClawdbotKit/Sources/ClawdbotKit/Protocol/MessageQueue.swift`:

```swift
//
//  MessageQueue.swift
//  ClawdbotKit
//
//  Outgoing message queue with delivery tracking and retry logic.
//

import Foundation
import Combine

/// Configuration for message queue retry behavior
public struct MessageQueueConfig: Sendable {
    /// Maximum retry attempts before marking as failed
    public let maxRetries: Int

    /// Base delay between retries (exponential backoff)
    public let baseRetryDelay: TimeInterval

    /// Maximum delay between retries
    public let maxRetryDelay: TimeInterval

    /// How long to wait for delivery confirmation
    public let deliveryTimeout: TimeInterval

    public static let `default` = MessageQueueConfig(
        maxRetries: 3,
        baseRetryDelay: 1.0,
        maxRetryDelay: 10.0,
        deliveryTimeout: 30.0
    )

    public init(
        maxRetries: Int,
        baseRetryDelay: TimeInterval,
        maxRetryDelay: TimeInterval,
        deliveryTimeout: TimeInterval
    ) {
        self.maxRetries = maxRetries
        self.baseRetryDelay = baseRetryDelay
        self.maxRetryDelay = maxRetryDelay
        self.deliveryTimeout = deliveryTimeout
    }
}

/// Entry in the outgoing queue
public struct QueuedMessage: Sendable, Identifiable {
    public let id: MessageID
    public let message: ChatMessage
    public var status: QueueStatus
    public var retryCount: Int
    public let queuedAt: Date
    public var lastAttempt: Date?

    public enum QueueStatus: String, Sendable {
        case queued          // Waiting to send
        case sending         // Currently being sent
        case awaitingAck     // Sent, waiting for server ack
        case delivered       // Server confirmed receipt
        case failed          // Exceeded retry attempts
    }

    public init(message: ChatMessage) {
        self.id = message.id
        self.message = message
        self.status = .queued
        self.retryCount = 0
        self.queuedAt = Date()
        self.lastAttempt = nil
    }
}

/// Delegate for queue events
public protocol MessageQueueDelegate: AnyObject, Sendable {
    /// Called when a message is ready to send
    func messageQueue(_ queue: OutgoingMessageQueue, shouldSend message: ChatMessage) async

    /// Called when a message delivery is confirmed
    func messageQueue(_ queue: OutgoingMessageQueue, didDeliver messageID: MessageID)

    /// Called when a message permanently fails
    func messageQueue(_ queue: OutgoingMessageQueue, didFail messageID: MessageID, error: Error?)
}

/// Error types for message queue
public enum MessageQueueError: Error, Sendable {
    case messageNotFound(MessageID)
    case alreadyDelivered(MessageID)
    case maxRetriesExceeded(MessageID)
    case queueFull
}

/// Actor managing outgoing message queue with delivery tracking
public actor OutgoingMessageQueue {

    // MARK: - Properties

    private var queue: [QueuedMessage] = []
    private var pendingAcks: [MessageID: QueuedMessage] = [:]
    private let config: MessageQueueConfig
    private var sequenceNumber: Int = 0

    public weak var delegate: MessageQueueDelegate?

    /// Publisher for queue state changes (for UI binding)
    public nonisolated let queuePublisher = CurrentValueSubject<[QueuedMessage], Never>([])

    // MARK: - Initialization

    public init(config: MessageQueueConfig = .default) {
        self.config = config
    }

    // MARK: - Queue Operations

    /// Add a message to the queue
    public func enqueue(_ message: ChatMessage) async {
        var queuedMessage = QueuedMessage(message: message)
        queuedMessage.status = .queued
        queue.append(queuedMessage)
        publishQueueState()

        // Trigger send
        await processQueue()
    }

    /// Get next sequence number
    public func nextSequence() -> Int {
        sequenceNumber += 1
        return sequenceNumber
    }

    /// Process queued messages
    public func processQueue() async {
        // Find messages ready to send
        for i in queue.indices {
            guard queue[i].status == .queued else { continue }

            queue[i].status = .sending
            queue[i].lastAttempt = Date()
            publishQueueState()

            // Delegate handles actual send
            await delegate?.messageQueue(self, shouldSend: queue[i].message)
        }
    }

    /// Mark message as sent (awaiting ack)
    public func markSent(_ messageID: MessageID) async {
        guard let index = queue.firstIndex(where: { $0.id == messageID }) else {
            return
        }

        queue[index].status = .awaitingAck
        pendingAcks[messageID] = queue[index]
        publishQueueState()

        // Start timeout timer
        let timeout = config.deliveryTimeout
        Task {
            try? await Task.sleep(nanoseconds: UInt64(timeout * 1_000_000_000))
            await self.handleTimeout(messageID: messageID)
        }
    }

    /// Handle delivery confirmation from server
    public func confirmDelivery(_ messageID: MessageID) async {
        // Remove from pending acks
        pendingAcks.removeValue(forKey: messageID)

        // Update status in queue
        if let index = queue.firstIndex(where: { $0.id == messageID }) {
            queue[index].status = .delivered
            publishQueueState()

            // Notify delegate
            delegate?.messageQueue(self, didDeliver: messageID)

            // Remove from queue after short delay (allows UI to show delivered state)
            Task {
                try? await Task.sleep(nanoseconds: 1_000_000_000)  // 1 second
                await self.removeDelivered(messageID)
            }
        }
    }

    /// Handle send failure (will retry or fail permanently)
    public func handleSendFailure(_ messageID: MessageID, error: Error?) async {
        guard let index = queue.firstIndex(where: { $0.id == messageID }) else {
            return
        }

        pendingAcks.removeValue(forKey: messageID)

        queue[index].retryCount += 1

        if queue[index].retryCount >= config.maxRetries {
            // Max retries exceeded
            queue[index].status = .failed
            publishQueueState()
            delegate?.messageQueue(self, didFail: messageID, error: error)
        } else {
            // Schedule retry with exponential backoff
            queue[index].status = .queued
            publishQueueState()

            let delay = calculateRetryDelay(attempt: queue[index].retryCount)
            Task {
                try? await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
                await self.processQueue()
            }
        }
    }

    // MARK: - Query

    /// Get all queued messages
    public func allMessages() -> [QueuedMessage] {
        queue
    }

    /// Get pending (not yet delivered) messages
    public func pendingMessages() -> [QueuedMessage] {
        queue.filter { $0.status != .delivered && $0.status != .failed }
    }

    /// Get message by ID
    public func message(for id: MessageID) -> QueuedMessage? {
        queue.first { $0.id == id }
    }

    /// Count of pending messages
    public func pendingCount() -> Int {
        pendingMessages().count
    }

    // MARK: - Private

    private func handleTimeout(messageID: MessageID) async {
        // Only handle timeout if still awaiting ack
        guard let pending = pendingAcks[messageID],
              pending.status == .awaitingAck else {
            return
        }

        await handleSendFailure(messageID, error: nil)
    }

    private func removeDelivered(_ messageID: MessageID) {
        queue.removeAll { $0.id == messageID && $0.status == .delivered }
        publishQueueState()
    }

    private func calculateRetryDelay(attempt: Int) -> TimeInterval {
        let delay = config.baseRetryDelay * pow(2.0, Double(attempt - 1))
        return min(delay, config.maxRetryDelay)
    }

    private func publishQueueState() {
        queuePublisher.send(queue)
    }

    // MARK: - Reset

    /// Clear all messages (e.g., on disconnect)
    public func clear() {
        queue.removeAll()
        pendingAcks.removeAll()
        publishQueueState()
    }

    /// Retry all failed messages
    public func retryFailed() async {
        for i in queue.indices where queue[i].status == .failed {
            queue[i].status = .queued
            queue[i].retryCount = 0
        }
        publishQueueState()
        await processQueue()
    }
}
```

Key design decisions:
- Actor for thread-safe queue management
- Delegate pattern for send triggering (decouples from transport)
- Exponential backoff for retries (same pattern as ConnectionManager)
- Combine publisher for SwiftUI queue status display
- Timeout handling for unacknowledged messages
  </action>
  <verify>cd apps/ios/ClawdbotKit && swift build</verify>
  <done>MessageQueue.swift compiles with queue management methods</done>
</task>

<task type="auto">
  <name>Task 2: Add message queue unit tests</name>
  <files>apps/ios/ClawdbotKit/Tests/ClawdbotKitTests/MessageQueueTests.swift</files>
  <action>
Create queue tests at `apps/ios/ClawdbotKit/Tests/ClawdbotKitTests/MessageQueueTests.swift`:

```swift
//
//  MessageQueueTests.swift
//  ClawdbotKit
//
//  Tests for outgoing message queue.
//

import XCTest
@testable import ClawdbotKit

/// Mock delegate for testing
final class MockQueueDelegate: MessageQueueDelegate, @unchecked Sendable {
    var sentMessages: [ChatMessage] = []
    var deliveredIDs: [MessageID] = []
    var failedIDs: [MessageID] = []

    func messageQueue(_ queue: OutgoingMessageQueue, shouldSend message: ChatMessage) async {
        sentMessages.append(message)
    }

    func messageQueue(_ queue: OutgoingMessageQueue, didDeliver messageID: MessageID) {
        deliveredIDs.append(messageID)
    }

    func messageQueue(_ queue: OutgoingMessageQueue, didFail messageID: MessageID, error: Error?) {
        failedIDs.append(messageID)
    }

    func reset() {
        sentMessages.removeAll()
        deliveredIDs.removeAll()
        failedIDs.removeAll()
    }
}

final class MessageQueueTests: XCTestCase {

    var queue: OutgoingMessageQueue!
    var delegate: MockQueueDelegate!

    override func setUp() async throws {
        delegate = MockQueueDelegate()
        queue = OutgoingMessageQueue(config: .default)
        await queue.setDelegate(delegate)
    }

    // MARK: - Config Tests

    func testDefaultConfig() {
        let config = MessageQueueConfig.default
        XCTAssertEqual(config.maxRetries, 3)
        XCTAssertEqual(config.baseRetryDelay, 1.0)
        XCTAssertEqual(config.maxRetryDelay, 10.0)
        XCTAssertEqual(config.deliveryTimeout, 30.0)
    }

    // MARK: - Enqueue Tests

    func testEnqueueTriggersDelegate() async {
        let message = ChatMessage(content: "Test", sender: .user)

        await queue.enqueue(message)

        // Allow async processing
        try? await Task.sleep(nanoseconds: 100_000_000)

        XCTAssertEqual(delegate.sentMessages.count, 1)
        XCTAssertEqual(delegate.sentMessages.first?.content, "Test")
    }

    func testEnqueueIncrementsSequence() async {
        let seq1 = await queue.nextSequence()
        let seq2 = await queue.nextSequence()
        let seq3 = await queue.nextSequence()

        XCTAssertEqual(seq1, 1)
        XCTAssertEqual(seq2, 2)
        XCTAssertEqual(seq3, 3)
    }

    // MARK: - Status Tests

    func testMarkSentUpdatesStatus() async {
        let message = ChatMessage(id: "msg-1", content: "Test", sender: .user)
        await queue.enqueue(message)
        try? await Task.sleep(nanoseconds: 100_000_000)

        await queue.markSent("msg-1")

        let queued = await queue.message(for: "msg-1")
        XCTAssertEqual(queued?.status, .awaitingAck)
    }

    func testConfirmDeliveryUpdatesStatus() async {
        let message = ChatMessage(id: "msg-1", content: "Test", sender: .user)
        await queue.enqueue(message)
        try? await Task.sleep(nanoseconds: 100_000_000)

        await queue.markSent("msg-1")
        await queue.confirmDelivery("msg-1")

        let queued = await queue.message(for: "msg-1")
        XCTAssertEqual(queued?.status, .delivered)
        XCTAssertTrue(delegate.deliveredIDs.contains("msg-1"))
    }

    // MARK: - Retry Tests

    func testRetryOnFailure() async {
        let fastConfig = MessageQueueConfig(
            maxRetries: 2,
            baseRetryDelay: 0.1,
            maxRetryDelay: 0.2,
            deliveryTimeout: 0.5
        )
        let testQueue = OutgoingMessageQueue(config: fastConfig)
        let testDelegate = MockQueueDelegate()
        await testQueue.setDelegate(testDelegate)

        let message = ChatMessage(id: "retry-msg", content: "Retry test", sender: .user)
        await testQueue.enqueue(message)
        try? await Task.sleep(nanoseconds: 100_000_000)

        // First send happens
        XCTAssertEqual(testDelegate.sentMessages.count, 1)

        // Simulate failure
        await testQueue.handleSendFailure("retry-msg", error: nil)
        try? await Task.sleep(nanoseconds: 200_000_000)  // Wait for retry delay

        // Should have retried
        XCTAssertEqual(testDelegate.sentMessages.count, 2)
    }

    func testMaxRetriesExceeded() async {
        let fastConfig = MessageQueueConfig(
            maxRetries: 1,
            baseRetryDelay: 0.01,
            maxRetryDelay: 0.02,
            deliveryTimeout: 0.5
        )
        let testQueue = OutgoingMessageQueue(config: fastConfig)
        let testDelegate = MockQueueDelegate()
        await testQueue.setDelegate(testDelegate)

        let message = ChatMessage(id: "fail-msg", content: "Fail test", sender: .user)
        await testQueue.enqueue(message)
        try? await Task.sleep(nanoseconds: 100_000_000)

        // Fail once (retry count = 1, equals maxRetries)
        await testQueue.handleSendFailure("fail-msg", error: nil)

        let queued = await testQueue.message(for: "fail-msg")
        XCTAssertEqual(queued?.status, .failed)
        XCTAssertTrue(testDelegate.failedIDs.contains("fail-msg"))
    }

    // MARK: - Query Tests

    func testPendingMessages() async {
        let msg1 = ChatMessage(id: "msg-1", content: "Test 1", sender: .user)
        let msg2 = ChatMessage(id: "msg-2", content: "Test 2", sender: .user)

        await queue.enqueue(msg1)
        await queue.enqueue(msg2)
        try? await Task.sleep(nanoseconds: 100_000_000)

        await queue.markSent("msg-1")
        await queue.confirmDelivery("msg-1")

        let pending = await queue.pendingMessages()
        XCTAssertEqual(pending.count, 1)
        XCTAssertEqual(pending.first?.id.value, "msg-2")
    }

    func testPendingCount() async {
        let msg1 = ChatMessage(content: "Test 1", sender: .user)
        let msg2 = ChatMessage(content: "Test 2", sender: .user)
        let msg3 = ChatMessage(content: "Test 3", sender: .user)

        await queue.enqueue(msg1)
        await queue.enqueue(msg2)
        await queue.enqueue(msg3)
        try? await Task.sleep(nanoseconds: 100_000_000)

        let count = await queue.pendingCount()
        XCTAssertEqual(count, 3)
    }

    // MARK: - Clear Tests

    func testClear() async {
        let message = ChatMessage(content: "Test", sender: .user)
        await queue.enqueue(message)
        try? await Task.sleep(nanoseconds: 100_000_000)

        await queue.clear()

        let all = await queue.allMessages()
        XCTAssertTrue(all.isEmpty)
    }

    func testRetryFailed() async {
        let fastConfig = MessageQueueConfig(
            maxRetries: 1,
            baseRetryDelay: 0.01,
            maxRetryDelay: 0.02,
            deliveryTimeout: 0.5
        )
        let testQueue = OutgoingMessageQueue(config: fastConfig)
        let testDelegate = MockQueueDelegate()
        await testQueue.setDelegate(testDelegate)

        let message = ChatMessage(id: "retry-all", content: "Test", sender: .user)
        await testQueue.enqueue(message)
        try? await Task.sleep(nanoseconds: 100_000_000)

        // Fail to mark as failed
        await testQueue.handleSendFailure("retry-all", error: nil)

        var queued = await testQueue.message(for: "retry-all")
        XCTAssertEqual(queued?.status, .failed)

        // Retry all failed
        testDelegate.reset()
        await testQueue.retryFailed()
        try? await Task.sleep(nanoseconds: 100_000_000)

        queued = await testQueue.message(for: "retry-all")
        XCTAssertNotEqual(queued?.status, .failed)
        XCTAssertEqual(testDelegate.sentMessages.count, 1)
    }
}

// MARK: - Helper Extension

extension OutgoingMessageQueue {
    /// Test helper to set delegate
    public func setDelegate(_ delegate: MessageQueueDelegate?) {
        self.delegate = delegate
    }
}
```
  </action>
  <verify>cd apps/ios/ClawdbotKit && swift test</verify>
  <done>All message queue tests pass</done>
</task>

<task type="checkpoint:commit">
  <files>apps/ios/ClawdbotKit/Sources/ClawdbotKit/Protocol/MessageQueue.swift</files>
  <message>feat(03-03): implement message queue with delivery confirmation</message>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] MessageQueue.swift exists with OutgoingMessageQueue actor
- [ ] Queue supports enqueue, send, delivery confirmation
- [ ] Retry logic with exponential backoff works
- [ ] ClawdbotKit compiles (`swift build`)
- [ ] All queue tests pass (`swift test`)
- [ ] Changes committed
</verification>

<success_criteria>
- OutgoingMessageQueue actor for thread-safe queue management
- MessageQueueConfig for retry parameters
- QueuedMessage tracking with status enum
- Delegate pattern for send triggering
- Exponential backoff retry logic
- Delivery confirmation handling
- Combine publisher for SwiftUI binding
- Timeout handling for unacknowledged messages
</success_criteria>

<output>
After completion, create `.planning/phases/03-protocol/03-03-SUMMARY.md`
</output>
