---
phase: 03-protocol
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [apps/ios/ClawdbotKit/Sources/ClawdbotKit/Protocol/MessageTypes.swift, apps/ios/ClawdbotKit/Sources/ClawdbotKit/Protocol/StreamingTypes.swift]
autonomous: true
---

<objective>
Define core Clawdbot message types as Codable Swift structs.

Purpose: Establish the data model for all Clawdbot communication. These types are the foundation that encoder/decoder and queue depend on.
Output: `MessageTypes.swift` with ChatMessage, ProtocolEnvelope, and related types. `StreamingTypes.swift` with streaming response types.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 2 provides connection infrastructure:
@.planning/phases/02-connection/02-01-SUMMARY.md

# Current placeholder:
@apps/ios/ClawdbotKit/Sources/ClawdbotKit/Protocol/Protocol.swift

# Existing WebSocket message types (raw layer):
@apps/ios/ClawdbotKit/Sources/ClawdbotKit/Connection/WebSocketMessage.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create core message types</name>
  <files>apps/ios/ClawdbotKit/Sources/ClawdbotKit/Protocol/MessageTypes.swift</files>
  <action>
Create message type definitions at `apps/ios/ClawdbotKit/Sources/ClawdbotKit/Protocol/MessageTypes.swift`:

```swift
//
//  MessageTypes.swift
//  ClawdbotKit
//
//  Core message types for Clawdbot protocol.
//

import Foundation

/// Unique message identifier
public struct MessageID: Hashable, Codable, Sendable, ExpressibleByStringLiteral {
    public let value: String

    public init(_ value: String) {
        self.value = value
    }

    public init(stringLiteral value: String) {
        self.value = value
    }

    public static func generate() -> MessageID {
        MessageID(UUID().uuidString.lowercased())
    }
}

/// Message delivery status
public enum MessageStatus: String, Codable, Sendable {
    case pending       // Queued locally, not sent
    case sent          // Sent to server, awaiting confirmation
    case delivered     // Server confirmed receipt
    case failed        // Send failed, may retry
}

/// Sender identification
public enum MessageSender: Codable, Sendable, Equatable {
    case user
    case bot(name: String)

    private enum CodingKeys: String, CodingKey {
        case type, name
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let type = try container.decode(String.self, forKey: .type)

        switch type {
        case "user":
            self = .user
        case "bot":
            let name = try container.decode(String.self, forKey: .name)
            self = .bot(name: name)
        default:
            throw DecodingError.dataCorruptedError(
                forKey: .type,
                in: container,
                debugDescription: "Unknown sender type: \(type)"
            )
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
        case .user:
            try container.encode("user", forKey: .type)
        case .bot(let name):
            try container.encode("bot", forKey: .type)
            try container.encode(name, forKey: .name)
        }
    }
}

/// A chat message in the Clawdbot protocol
public struct ChatMessage: Codable, Sendable, Identifiable {
    public let id: MessageID
    public let content: String
    public let sender: MessageSender
    public let timestamp: Date
    public var status: MessageStatus

    /// Thread ID for conversation grouping (optional)
    public let threadID: String?

    /// Reply to another message (optional)
    public let replyTo: MessageID?

    public init(
        id: MessageID = .generate(),
        content: String,
        sender: MessageSender,
        timestamp: Date = Date(),
        status: MessageStatus = .pending,
        threadID: String? = nil,
        replyTo: MessageID? = nil
    ) {
        self.id = id
        self.content = content
        self.sender = sender
        self.timestamp = timestamp
        self.status = status
        self.threadID = threadID
        self.replyTo = replyTo
    }
}

/// Protocol envelope wrapping messages with metadata
public struct ProtocolEnvelope<T: Codable & Sendable>: Codable, Sendable {
    /// Protocol version for compatibility
    public let version: String

    /// Message type identifier
    public let type: String

    /// Sequence number for ordering
    public let sequence: Int

    /// The wrapped payload
    public let payload: T

    /// Server timestamp (set by server, nil for outgoing)
    public let serverTimestamp: Date?

    public init(
        version: String = "1.0",
        type: String,
        sequence: Int,
        payload: T,
        serverTimestamp: Date? = nil
    ) {
        self.version = version
        self.type = type
        self.sequence = sequence
        self.payload = payload
        self.serverTimestamp = serverTimestamp
    }
}

/// Acknowledgment for message receipt
public struct MessageAck: Codable, Sendable {
    public let messageID: MessageID
    public let status: AckStatus
    public let serverTimestamp: Date

    public enum AckStatus: String, Codable, Sendable {
        case received
        case processed
        case error
    }

    public init(messageID: MessageID, status: AckStatus, serverTimestamp: Date = Date()) {
        self.messageID = messageID
        self.status = status
        self.serverTimestamp = serverTimestamp
    }
}
```

Key design decisions:
- MessageID as struct (not raw String) for type safety
- MessageSender enum distinguishes user from bots (supports multi-bot)
- ProtocolEnvelope is generic for different payload types
- All types are Codable + Sendable for async safety
  </action>
  <verify>cd apps/ios/ClawdbotKit && swift build</verify>
  <done>MessageTypes.swift compiles with ChatMessage, ProtocolEnvelope, MessageAck types</done>
</task>

<task type="auto">
  <name>Task 2: Create streaming response types</name>
  <files>apps/ios/ClawdbotKit/Sources/ClawdbotKit/Protocol/StreamingTypes.swift</files>
  <action>
Create streaming types at `apps/ios/ClawdbotKit/Sources/ClawdbotKit/Protocol/StreamingTypes.swift`:

```swift
//
//  StreamingTypes.swift
//  ClawdbotKit
//
//  Types for streaming responses and bot state indicators.
//

import Foundation

/// Bot's current processing state
public enum BotState: String, Codable, Sendable {
    case idle           // Not processing
    case thinking       // Processing request (before streaming)
    case typing         // Actively generating response
    case toolUse        // Using external tool
}

/// State update from bot
public struct BotStateUpdate: Codable, Sendable {
    public let state: BotState
    public let botName: String
    public let detail: String?      // e.g., "Searching web..." for toolUse
    public let timestamp: Date

    public init(
        state: BotState,
        botName: String,
        detail: String? = nil,
        timestamp: Date = Date()
    ) {
        self.state = state
        self.botName = botName
        self.detail = detail
        self.timestamp = timestamp
    }
}

/// A chunk of streaming response
public struct StreamingChunk: Codable, Sendable {
    /// ID of the message being streamed
    public let messageID: MessageID

    /// Chunk sequence number (for ordering)
    public let chunkIndex: Int

    /// The text content of this chunk
    public let content: String

    /// Is this the final chunk?
    public let isFinal: Bool

    public init(
        messageID: MessageID,
        chunkIndex: Int,
        content: String,
        isFinal: Bool = false
    ) {
        self.messageID = messageID
        self.chunkIndex = chunkIndex
        self.content = content
        self.isFinal = isFinal
    }
}

/// Aggregates streaming chunks into complete message
public actor StreamingMessageAssembler {
    private var chunks: [MessageID: [StreamingChunk]] = [:]

    /// Add a chunk to the assembler
    public func addChunk(_ chunk: StreamingChunk) {
        var messageChunks = chunks[chunk.messageID] ?? []
        messageChunks.append(chunk)
        chunks[chunk.messageID] = messageChunks
    }

    /// Get current accumulated content for a message
    public func currentContent(for messageID: MessageID) -> String {
        guard let messageChunks = chunks[messageID] else { return "" }
        return messageChunks
            .sorted { $0.chunkIndex < $1.chunkIndex }
            .map(\.content)
            .joined()
    }

    /// Check if message is complete
    public func isComplete(messageID: MessageID) -> Bool {
        guard let messageChunks = chunks[messageID] else { return false }
        return messageChunks.contains { $0.isFinal }
    }

    /// Complete and remove a message from the assembler
    public func complete(messageID: MessageID) -> String? {
        guard isComplete(messageID: messageID) else { return nil }
        let content = currentContent(for: messageID)
        chunks.removeValue(forKey: messageID)
        return content
    }

    /// Clear all pending streams
    public func reset() {
        chunks.removeAll()
    }
}
```

Key design decisions:
- BotState enum covers thinking/typing/toolUse states from requirements
- StreamingChunk uses chunk index for reordering (network may deliver out-of-order)
- StreamingMessageAssembler is an actor for thread-safe chunk aggregation
- isFinal flag signals stream completion
  </action>
  <verify>cd apps/ios/ClawdbotKit && swift build</verify>
  <done>StreamingTypes.swift compiles with BotState, StreamingChunk, StreamingMessageAssembler</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for message types</name>
  <files>apps/ios/ClawdbotKit/Tests/ClawdbotKitTests/MessageTypesTests.swift</files>
  <action>
Create unit tests at `apps/ios/ClawdbotKit/Tests/ClawdbotKitTests/MessageTypesTests.swift`:

```swift
//
//  MessageTypesTests.swift
//  ClawdbotKit
//
//  Tests for message type definitions.
//

import XCTest
@testable import ClawdbotKit

final class MessageTypesTests: XCTestCase {

    // MARK: - MessageID Tests

    func testMessageIDGeneration() {
        let id1 = MessageID.generate()
        let id2 = MessageID.generate()
        XCTAssertNotEqual(id1, id2, "Generated IDs should be unique")
    }

    func testMessageIDStringLiteral() {
        let id: MessageID = "test-id"
        XCTAssertEqual(id.value, "test-id")
    }

    func testMessageIDCodable() throws {
        let id = MessageID("test-123")
        let data = try JSONEncoder().encode(id)
        let decoded = try JSONDecoder().decode(MessageID.self, from: data)
        XCTAssertEqual(id, decoded)
    }

    // MARK: - MessageSender Tests

    func testMessageSenderUserCodable() throws {
        let sender = MessageSender.user
        let data = try JSONEncoder().encode(sender)
        let decoded = try JSONDecoder().decode(MessageSender.self, from: data)
        XCTAssertEqual(sender, decoded)
    }

    func testMessageSenderBotCodable() throws {
        let sender = MessageSender.bot(name: "Opta")
        let data = try JSONEncoder().encode(sender)
        let decoded = try JSONDecoder().decode(MessageSender.self, from: data)
        XCTAssertEqual(sender, decoded)
    }

    // MARK: - ChatMessage Tests

    func testChatMessageDefaults() {
        let message = ChatMessage(
            content: "Hello",
            sender: .user
        )
        XCTAssertEqual(message.status, .pending)
        XCTAssertNil(message.threadID)
        XCTAssertNil(message.replyTo)
    }

    func testChatMessageCodable() throws {
        let message = ChatMessage(
            id: "msg-123",
            content: "Test message",
            sender: .bot(name: "Opta"),
            timestamp: Date(timeIntervalSince1970: 1706644800),
            status: .delivered,
            threadID: "thread-1",
            replyTo: "msg-100"
        )

        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .iso8601
        let data = try encoder.encode(message)

        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601
        let decoded = try decoder.decode(ChatMessage.self, from: data)

        XCTAssertEqual(message.id, decoded.id)
        XCTAssertEqual(message.content, decoded.content)
        XCTAssertEqual(message.sender, decoded.sender)
        XCTAssertEqual(message.status, decoded.status)
        XCTAssertEqual(message.threadID, decoded.threadID)
        XCTAssertEqual(message.replyTo, decoded.replyTo)
    }

    // MARK: - ProtocolEnvelope Tests

    func testProtocolEnvelopeCodable() throws {
        let envelope = ProtocolEnvelope(
            version: "1.0",
            type: "chat.message",
            sequence: 42,
            payload: ChatMessage(content: "Test", sender: .user),
            serverTimestamp: nil
        )

        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .iso8601
        let data = try encoder.encode(envelope)

        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601
        let decoded = try decoder.decode(ProtocolEnvelope<ChatMessage>.self, from: data)

        XCTAssertEqual(envelope.version, decoded.version)
        XCTAssertEqual(envelope.type, decoded.type)
        XCTAssertEqual(envelope.sequence, decoded.sequence)
        XCTAssertEqual(envelope.payload.content, decoded.payload.content)
    }

    // MARK: - MessageAck Tests

    func testMessageAckCodable() throws {
        let ack = MessageAck(
            messageID: "msg-123",
            status: .received
        )

        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .iso8601
        let data = try encoder.encode(ack)

        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601
        let decoded = try decoder.decode(MessageAck.self, from: data)

        XCTAssertEqual(ack.messageID, decoded.messageID)
        XCTAssertEqual(ack.status, decoded.status)
    }
}

final class StreamingTypesTests: XCTestCase {

    // MARK: - BotState Tests

    func testBotStateCodable() throws {
        for state in [BotState.idle, .thinking, .typing, .toolUse] {
            let data = try JSONEncoder().encode(state)
            let decoded = try JSONDecoder().decode(BotState.self, from: data)
            XCTAssertEqual(state, decoded)
        }
    }

    // MARK: - StreamingChunk Tests

    func testStreamingChunkCodable() throws {
        let chunk = StreamingChunk(
            messageID: "msg-1",
            chunkIndex: 5,
            content: "Hello ",
            isFinal: false
        )

        let data = try JSONEncoder().encode(chunk)
        let decoded = try JSONDecoder().decode(StreamingChunk.self, from: data)

        XCTAssertEqual(chunk.messageID, decoded.messageID)
        XCTAssertEqual(chunk.chunkIndex, decoded.chunkIndex)
        XCTAssertEqual(chunk.content, decoded.content)
        XCTAssertEqual(chunk.isFinal, decoded.isFinal)
    }

    // MARK: - StreamingMessageAssembler Tests

    func testAssemblerAggregatesChunks() async {
        let assembler = StreamingMessageAssembler()
        let messageID: MessageID = "test-msg"

        await assembler.addChunk(StreamingChunk(messageID: messageID, chunkIndex: 0, content: "Hello "))
        await assembler.addChunk(StreamingChunk(messageID: messageID, chunkIndex: 1, content: "World"))

        let content = await assembler.currentContent(for: messageID)
        XCTAssertEqual(content, "Hello World")
    }

    func testAssemblerHandlesOutOfOrder() async {
        let assembler = StreamingMessageAssembler()
        let messageID: MessageID = "test-msg"

        // Add chunks out of order
        await assembler.addChunk(StreamingChunk(messageID: messageID, chunkIndex: 2, content: "!"))
        await assembler.addChunk(StreamingChunk(messageID: messageID, chunkIndex: 0, content: "Hello "))
        await assembler.addChunk(StreamingChunk(messageID: messageID, chunkIndex: 1, content: "World"))

        let content = await assembler.currentContent(for: messageID)
        XCTAssertEqual(content, "Hello World!")
    }

    func testAssemblerDetectsCompletion() async {
        let assembler = StreamingMessageAssembler()
        let messageID: MessageID = "test-msg"

        await assembler.addChunk(StreamingChunk(messageID: messageID, chunkIndex: 0, content: "Hi"))
        var isComplete = await assembler.isComplete(messageID: messageID)
        XCTAssertFalse(isComplete)

        await assembler.addChunk(StreamingChunk(messageID: messageID, chunkIndex: 1, content: "!", isFinal: true))
        isComplete = await assembler.isComplete(messageID: messageID)
        XCTAssertTrue(isComplete)
    }

    func testAssemblerComplete() async {
        let assembler = StreamingMessageAssembler()
        let messageID: MessageID = "test-msg"

        await assembler.addChunk(StreamingChunk(messageID: messageID, chunkIndex: 0, content: "Done", isFinal: true))

        let result = await assembler.complete(messageID: messageID)
        XCTAssertEqual(result, "Done")

        // Should be cleared
        let remaining = await assembler.currentContent(for: messageID)
        XCTAssertEqual(remaining, "")
    }
}
```
  </action>
  <verify>cd apps/ios/ClawdbotKit && swift test</verify>
  <done>All message type tests pass</done>
</task>

<task type="checkpoint:commit">
  <files>apps/ios/ClawdbotKit/Sources/ClawdbotKit/Protocol/</files>
  <message>feat(03-01): implement Clawdbot message type definitions</message>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] MessageTypes.swift exists with ChatMessage, ProtocolEnvelope, MessageAck
- [ ] StreamingTypes.swift exists with BotState, StreamingChunk, StreamingMessageAssembler
- [ ] ClawdbotKit compiles (`swift build`)
- [ ] All unit tests pass (`swift test`)
- [ ] Changes committed
</verification>

<success_criteria>
- ChatMessage struct with id, content, sender, timestamp, status
- ProtocolEnvelope generic wrapper with version, type, sequence
- MessageAck for delivery confirmation
- BotState enum for thinking/typing indicators
- StreamingChunk for partial responses
- StreamingMessageAssembler actor for chunk aggregation
- All types are Codable + Sendable
- Unit tests verify encoding/decoding
</success_criteria>

<output>
After completion, create `.planning/phases/03-protocol/03-01-SUMMARY.md`
</output>
