---
phase: 03-protocol
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified: [apps/ios/ClawdbotKit/Sources/ClawdbotKit/Protocol/ProtocolCodec.swift, apps/ios/ClawdbotKit/Tests/ClawdbotKitTests/ProtocolCodecTests.swift]
autonomous: true
---

<objective>
Implement protocol encoder/decoder with streaming support.

Purpose: Serialize outgoing messages and deserialize incoming messages including streaming chunks. Handles JSON encoding with proper date formatting and message type routing.
Output: `ProtocolCodec.swift` with encoding/decoding logic and routing for different message types.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Plan 03-01 provides message types:
@.planning/phases/03-protocol/03-01-PLAN.md

# WebSocket layer for raw message transport:
@apps/ios/ClawdbotKit/Sources/ClawdbotKit/Connection/WebSocketMessage.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create protocol codec</name>
  <files>apps/ios/ClawdbotKit/Sources/ClawdbotKit/Protocol/ProtocolCodec.swift</files>
  <action>
Create protocol codec at `apps/ios/ClawdbotKit/Sources/ClawdbotKit/Protocol/ProtocolCodec.swift`:

```swift
//
//  ProtocolCodec.swift
//  ClawdbotKit
//
//  Encoder/decoder for Clawdbot protocol messages.
//

import Foundation

/// Message types in the Clawdbot protocol
public enum ProtocolMessageType: String, Codable, Sendable {
    case chatMessage = "chat.message"
    case messageAck = "message.ack"
    case botState = "bot.state"
    case streamingChunk = "streaming.chunk"
    case ping = "system.ping"
    case pong = "system.pong"
}

/// Decoded protocol message with type information
public enum DecodedMessage: Sendable {
    case chatMessage(ProtocolEnvelope<ChatMessage>)
    case messageAck(ProtocolEnvelope<MessageAck>)
    case botState(ProtocolEnvelope<BotStateUpdate>)
    case streamingChunk(ProtocolEnvelope<StreamingChunk>)
    case ping(sequence: Int)
    case pong(sequence: Int)
    case unknown(type: String, data: Data)
}

/// Errors during protocol encoding/decoding
public enum ProtocolCodecError: Error, Sendable {
    case encodingFailed(Error)
    case decodingFailed(Error)
    case invalidJSON
    case missingTypeField
    case unknownMessageType(String)
}

/// Encodes and decodes Clawdbot protocol messages
public struct ProtocolCodec: Sendable {

    // MARK: - Configuration

    private let encoder: JSONEncoder
    private let decoder: JSONDecoder

    public init() {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .iso8601
        encoder.outputFormatting = [.sortedKeys]  // Deterministic output
        self.encoder = encoder

        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601
        self.decoder = decoder
    }

    // MARK: - Encoding

    /// Encode a chat message for sending
    public func encode(message: ChatMessage, sequence: Int) throws -> Data {
        let envelope = ProtocolEnvelope(
            type: ProtocolMessageType.chatMessage.rawValue,
            sequence: sequence,
            payload: message
        )
        return try encodeEnvelope(envelope)
    }

    /// Encode a ping message
    public func encodePing(sequence: Int) throws -> Data {
        struct PingPayload: Codable {
            let timestamp: Date
        }
        let envelope = ProtocolEnvelope(
            type: ProtocolMessageType.ping.rawValue,
            sequence: sequence,
            payload: PingPayload(timestamp: Date())
        )
        return try encodeEnvelope(envelope)
    }

    /// Encode a pong response
    public func encodePong(sequence: Int) throws -> Data {
        struct PongPayload: Codable {
            let timestamp: Date
        }
        let envelope = ProtocolEnvelope(
            type: ProtocolMessageType.pong.rawValue,
            sequence: sequence,
            payload: PongPayload(timestamp: Date())
        )
        return try encodeEnvelope(envelope)
    }

    private func encodeEnvelope<T: Codable>(_ envelope: ProtocolEnvelope<T>) throws -> Data {
        do {
            return try encoder.encode(envelope)
        } catch {
            throw ProtocolCodecError.encodingFailed(error)
        }
    }

    // MARK: - Decoding

    /// Decode raw data into a typed message
    public func decode(_ data: Data) throws -> DecodedMessage {
        // First, peek at the type field
        guard let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
              let typeString = json["type"] as? String else {
            throw ProtocolCodecError.missingTypeField
        }

        guard let messageType = ProtocolMessageType(rawValue: typeString) else {
            return .unknown(type: typeString, data: data)
        }

        do {
            switch messageType {
            case .chatMessage:
                let envelope = try decoder.decode(ProtocolEnvelope<ChatMessage>.self, from: data)
                return .chatMessage(envelope)

            case .messageAck:
                let envelope = try decoder.decode(ProtocolEnvelope<MessageAck>.self, from: data)
                return .messageAck(envelope)

            case .botState:
                let envelope = try decoder.decode(ProtocolEnvelope<BotStateUpdate>.self, from: data)
                return .botState(envelope)

            case .streamingChunk:
                let envelope = try decoder.decode(ProtocolEnvelope<StreamingChunk>.self, from: data)
                return .streamingChunk(envelope)

            case .ping:
                let envelope = try decoder.decode(ProtocolEnvelope<EmptyPayload>.self, from: data)
                return .ping(sequence: envelope.sequence)

            case .pong:
                let envelope = try decoder.decode(ProtocolEnvelope<EmptyPayload>.self, from: data)
                return .pong(sequence: envelope.sequence)
            }
        } catch {
            throw ProtocolCodecError.decodingFailed(error)
        }
    }

    /// Decode a string message (convenience for WebSocket text messages)
    public func decode(_ string: String) throws -> DecodedMessage {
        guard let data = string.data(using: .utf8) else {
            throw ProtocolCodecError.invalidJSON
        }
        return try decode(data)
    }
}

/// Empty payload for ping/pong messages
private struct EmptyPayload: Codable {
    let timestamp: Date?
}

// MARK: - Streaming Support

extension ProtocolCodec {

    /// Check if data is a streaming chunk without full decode
    public func isStreamingChunk(_ data: Data) -> Bool {
        guard let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
              let typeString = json["type"] as? String else {
            return false
        }
        return typeString == ProtocolMessageType.streamingChunk.rawValue
    }

    /// Fast path decode for streaming chunks
    public func decodeStreamingChunk(_ data: Data) throws -> StreamingChunk {
        let envelope = try decoder.decode(ProtocolEnvelope<StreamingChunk>.self, from: data)
        return envelope.payload
    }
}
```

Key design decisions:
- DecodedMessage enum provides type-safe routing for handlers
- Peek at "type" field before full decode for efficiency
- Streaming chunk has fast-path decoder for real-time performance
- sortedKeys for deterministic JSON (helps with debugging/logging)
  </action>
  <verify>cd apps/ios/ClawdbotKit && swift build</verify>
  <done>ProtocolCodec.swift compiles with encode/decode methods</done>
</task>

<task type="auto">
  <name>Task 2: Add codec unit tests</name>
  <files>apps/ios/ClawdbotKit/Tests/ClawdbotKitTests/ProtocolCodecTests.swift</files>
  <action>
Create codec tests at `apps/ios/ClawdbotKit/Tests/ClawdbotKitTests/ProtocolCodecTests.swift`:

```swift
//
//  ProtocolCodecTests.swift
//  ClawdbotKit
//
//  Tests for protocol encoder/decoder.
//

import XCTest
@testable import ClawdbotKit

final class ProtocolCodecTests: XCTestCase {

    let codec = ProtocolCodec()

    // MARK: - Encoding Tests

    func testEncodeChatMessage() throws {
        let message = ChatMessage(
            id: "msg-1",
            content: "Hello",
            sender: .user
        )

        let data = try codec.encode(message: message, sequence: 1)
        let json = try JSONSerialization.jsonObject(with: data) as? [String: Any]

        XCTAssertEqual(json?["type"] as? String, "chat.message")
        XCTAssertEqual(json?["version"] as? String, "1.0")
        XCTAssertEqual(json?["sequence"] as? Int, 1)
        XCTAssertNotNil(json?["payload"])
    }

    func testEncodePing() throws {
        let data = try codec.encodePing(sequence: 42)
        let json = try JSONSerialization.jsonObject(with: data) as? [String: Any]

        XCTAssertEqual(json?["type"] as? String, "system.ping")
        XCTAssertEqual(json?["sequence"] as? Int, 42)
    }

    func testEncodePong() throws {
        let data = try codec.encodePong(sequence: 42)
        let json = try JSONSerialization.jsonObject(with: data) as? [String: Any]

        XCTAssertEqual(json?["type"] as? String, "system.pong")
        XCTAssertEqual(json?["sequence"] as? Int, 42)
    }

    // MARK: - Decoding Tests

    func testDecodeChatMessage() throws {
        let json = """
        {
            "version": "1.0",
            "type": "chat.message",
            "sequence": 1,
            "payload": {
                "id": {"value": "msg-1"},
                "content": "Hello from bot",
                "sender": {"type": "bot", "name": "Opta"},
                "timestamp": "2024-01-30T12:00:00Z",
                "status": "delivered",
                "threadID": null,
                "replyTo": null
            },
            "serverTimestamp": null
        }
        """

        let decoded = try codec.decode(json)

        guard case .chatMessage(let envelope) = decoded else {
            XCTFail("Expected chatMessage")
            return
        }

        XCTAssertEqual(envelope.payload.id.value, "msg-1")
        XCTAssertEqual(envelope.payload.content, "Hello from bot")
        XCTAssertEqual(envelope.payload.sender, .bot(name: "Opta"))
    }

    func testDecodeMessageAck() throws {
        let json = """
        {
            "version": "1.0",
            "type": "message.ack",
            "sequence": 5,
            "payload": {
                "messageID": {"value": "msg-123"},
                "status": "received",
                "serverTimestamp": "2024-01-30T12:00:00Z"
            },
            "serverTimestamp": null
        }
        """

        let decoded = try codec.decode(json)

        guard case .messageAck(let envelope) = decoded else {
            XCTFail("Expected messageAck")
            return
        }

        XCTAssertEqual(envelope.payload.messageID.value, "msg-123")
        XCTAssertEqual(envelope.payload.status, .received)
    }

    func testDecodeBotState() throws {
        let json = """
        {
            "version": "1.0",
            "type": "bot.state",
            "sequence": 10,
            "payload": {
                "state": "thinking",
                "botName": "Opta",
                "detail": null,
                "timestamp": "2024-01-30T12:00:00Z"
            },
            "serverTimestamp": null
        }
        """

        let decoded = try codec.decode(json)

        guard case .botState(let envelope) = decoded else {
            XCTFail("Expected botState")
            return
        }

        XCTAssertEqual(envelope.payload.state, .thinking)
        XCTAssertEqual(envelope.payload.botName, "Opta")
    }

    func testDecodeStreamingChunk() throws {
        let json = """
        {
            "version": "1.0",
            "type": "streaming.chunk",
            "sequence": 15,
            "payload": {
                "messageID": {"value": "msg-stream"},
                "chunkIndex": 3,
                "content": "Hello ",
                "isFinal": false
            },
            "serverTimestamp": null
        }
        """

        let decoded = try codec.decode(json)

        guard case .streamingChunk(let envelope) = decoded else {
            XCTFail("Expected streamingChunk")
            return
        }

        XCTAssertEqual(envelope.payload.messageID.value, "msg-stream")
        XCTAssertEqual(envelope.payload.chunkIndex, 3)
        XCTAssertEqual(envelope.payload.content, "Hello ")
        XCTAssertFalse(envelope.payload.isFinal)
    }

    func testDecodePing() throws {
        let json = """
        {
            "version": "1.0",
            "type": "system.ping",
            "sequence": 100,
            "payload": {"timestamp": "2024-01-30T12:00:00Z"},
            "serverTimestamp": null
        }
        """

        let decoded = try codec.decode(json)

        guard case .ping(let sequence) = decoded else {
            XCTFail("Expected ping")
            return
        }

        XCTAssertEqual(sequence, 100)
    }

    func testDecodePong() throws {
        let json = """
        {
            "version": "1.0",
            "type": "system.pong",
            "sequence": 100,
            "payload": {"timestamp": "2024-01-30T12:00:00Z"},
            "serverTimestamp": null
        }
        """

        let decoded = try codec.decode(json)

        guard case .pong(let sequence) = decoded else {
            XCTFail("Expected pong")
            return
        }

        XCTAssertEqual(sequence, 100)
    }

    func testDecodeUnknownType() throws {
        let json = """
        {
            "version": "1.0",
            "type": "future.feature",
            "sequence": 1,
            "payload": {},
            "serverTimestamp": null
        }
        """

        let decoded = try codec.decode(json)

        guard case .unknown(let type, _) = decoded else {
            XCTFail("Expected unknown")
            return
        }

        XCTAssertEqual(type, "future.feature")
    }

    func testDecodeMissingType() {
        let json = """
        {
            "version": "1.0",
            "sequence": 1,
            "payload": {}
        }
        """

        XCTAssertThrowsError(try codec.decode(json)) { error in
            guard case ProtocolCodecError.missingTypeField = error else {
                XCTFail("Expected missingTypeField error")
                return
            }
        }
    }

    // MARK: - Streaming Fast Path Tests

    func testIsStreamingChunk() throws {
        let chunkJSON = """
        {"type": "streaming.chunk", "version": "1.0", "sequence": 1, "payload": {}}
        """.data(using: .utf8)!

        let messageJSON = """
        {"type": "chat.message", "version": "1.0", "sequence": 1, "payload": {}}
        """.data(using: .utf8)!

        XCTAssertTrue(codec.isStreamingChunk(chunkJSON))
        XCTAssertFalse(codec.isStreamingChunk(messageJSON))
    }

    // MARK: - Round-trip Tests

    func testEncodeDecodeRoundTrip() throws {
        let original = ChatMessage(
            id: "round-trip",
            content: "Test message",
            sender: .user,
            status: .pending
        )

        let encoded = try codec.encode(message: original, sequence: 99)
        let decoded = try codec.decode(encoded)

        guard case .chatMessage(let envelope) = decoded else {
            XCTFail("Expected chatMessage")
            return
        }

        XCTAssertEqual(envelope.payload.id, original.id)
        XCTAssertEqual(envelope.payload.content, original.content)
        XCTAssertEqual(envelope.payload.sender, original.sender)
        XCTAssertEqual(envelope.sequence, 99)
    }
}
```
  </action>
  <verify>cd apps/ios/ClawdbotKit && swift test</verify>
  <done>All codec tests pass</done>
</task>

<task type="checkpoint:commit">
  <files>apps/ios/ClawdbotKit/Sources/ClawdbotKit/Protocol/ProtocolCodec.swift</files>
  <message>feat(03-02): implement protocol encoder/decoder with streaming support</message>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] ProtocolCodec.swift exists with encode/decode methods
- [ ] DecodedMessage enum routes all message types
- [ ] Streaming fast-path methods work
- [ ] ClawdbotKit compiles (`swift build`)
- [ ] All codec tests pass (`swift test`)
- [ ] Changes committed
</verification>

<success_criteria>
- ProtocolCodec with JSON encoding/decoding
- ISO 8601 date formatting
- DecodedMessage enum for type-safe routing
- Streaming chunk fast-path decoder
- Unknown message type handling (forward compatibility)
- Round-trip encoding/decoding tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-protocol/03-02-SUMMARY.md`
</output>
