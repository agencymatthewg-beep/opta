---
phase: 03-protocol
plan: 04
type: execute
wave: 3
depends_on: ["03-02", "03-03"]
files_modified: [apps/ios/ClawdbotKit/Sources/ClawdbotKit/Protocol/Protocol.swift, apps/ios/ClawdbotKit/Sources/ClawdbotKit/Protocol/ProtocolHandler.swift]
autonomous: true
---

<objective>
Create ProtocolHandler to connect codec and queue to ConnectionManager.

Purpose: Wire together the protocol components (types, codec, queue) and integrate with the connection layer. This creates a complete message flow from user input to server and back.
Output: `ProtocolHandler.swift` actor coordinating message flow. Updated `Protocol.swift` with module exports.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plans in this phase:
@.planning/phases/03-protocol/03-01-PLAN.md
@.planning/phases/03-protocol/03-02-PLAN.md
@.planning/phases/03-protocol/03-03-PLAN.md

# Connection layer to integrate with:
@apps/ios/ClawdbotKit/Sources/ClawdbotKit/Connection/ConnectionManager.swift
@apps/ios/ClawdbotKit/Sources/ClawdbotKit/Connection/WebSocketClient.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create protocol handler</name>
  <files>apps/ios/ClawdbotKit/Sources/ClawdbotKit/Protocol/ProtocolHandler.swift</files>
  <action>
Create protocol handler at `apps/ios/ClawdbotKit/Sources/ClawdbotKit/Protocol/ProtocolHandler.swift`:

```swift
//
//  ProtocolHandler.swift
//  ClawdbotKit
//
//  Coordinates message encoding, decoding, and queue management.
//  Bridges Protocol layer with Connection layer.
//

import Foundation
import Combine

/// Delegate for protocol-level events
public protocol ProtocolHandlerDelegate: AnyObject, Sendable {
    /// Called when a chat message is received
    func protocolHandler(_ handler: ProtocolHandler, didReceiveMessage message: ChatMessage)

    /// Called when bot state changes
    func protocolHandler(_ handler: ProtocolHandler, didReceiveBotState state: BotStateUpdate)

    /// Called when a streaming chunk arrives
    func protocolHandler(_ handler: ProtocolHandler, didReceiveChunk chunk: StreamingChunk)

    /// Called when message delivery is confirmed
    func protocolHandler(_ handler: ProtocolHandler, didDeliverMessage messageID: MessageID)

    /// Called when message delivery fails
    func protocolHandler(_ handler: ProtocolHandler, didFailMessage messageID: MessageID, error: Error?)
}

/// Default implementations for optional delegate methods
public extension ProtocolHandlerDelegate {
    func protocolHandler(_ handler: ProtocolHandler, didReceiveBotState state: BotStateUpdate) {}
    func protocolHandler(_ handler: ProtocolHandler, didReceiveChunk chunk: StreamingChunk) {}
    func protocolHandler(_ handler: ProtocolHandler, didDeliverMessage messageID: MessageID) {}
    func protocolHandler(_ handler: ProtocolHandler, didFailMessage messageID: MessageID, error: Error?) {}
}

/// Central coordinator for Clawdbot protocol communication
public actor ProtocolHandler {

    // MARK: - Properties

    private let codec: ProtocolCodec
    private let queue: OutgoingMessageQueue
    private let assembler: StreamingMessageAssembler

    public weak var delegate: ProtocolHandlerDelegate?

    /// Connection manager reference (set after init)
    private weak var connectionManager: ConnectionManager?

    /// Publisher for incoming messages (alternative to delegate)
    public nonisolated let incomingMessages = PassthroughSubject<ChatMessage, Never>()

    /// Publisher for bot state updates
    public nonisolated let botStateUpdates = PassthroughSubject<BotStateUpdate, Never>()

    // MARK: - Initialization

    public init(queueConfig: MessageQueueConfig = .default) {
        self.codec = ProtocolCodec()
        self.queue = OutgoingMessageQueue(config: queueConfig)
        self.assembler = StreamingMessageAssembler()
    }

    /// Connect to a ConnectionManager
    public func connect(to connectionManager: ConnectionManager) async {
        self.connectionManager = connectionManager
        // Queue delegate is set up to trigger sends
    }

    // MARK: - Sending

    /// Send a user message
    public func send(_ content: String, replyTo: MessageID? = nil, threadID: String? = nil) async {
        let message = ChatMessage(
            content: content,
            sender: .user,
            threadID: threadID,
            replyTo: replyTo
        )

        await queue.enqueue(message)
    }

    /// Send a pre-constructed message
    public func send(message: ChatMessage) async {
        await queue.enqueue(message)
    }

    /// Internal: Actually send a message over WebSocket
    internal func performSend(_ message: ChatMessage) async throws {
        guard let connection = connectionManager else {
            throw ProtocolHandlerError.notConnected
        }

        let sequence = await queue.nextSequence()
        let data = try codec.encode(message: message, sequence: sequence)

        // Convert to string for WebSocket text message
        guard let jsonString = String(data: data, encoding: .utf8) else {
            throw ProtocolHandlerError.encodingFailed
        }

        try await connection.send(text: jsonString)
        await queue.markSent(message.id)
    }

    // MARK: - Receiving

    /// Process incoming WebSocket message
    public func handleIncoming(_ text: String) async {
        do {
            let decoded = try codec.decode(text)

            switch decoded {
            case .chatMessage(let envelope):
                let message = envelope.payload
                delegate?.protocolHandler(self, didReceiveMessage: message)
                incomingMessages.send(message)

            case .messageAck(let envelope):
                let ack = envelope.payload
                if ack.status == .received || ack.status == .processed {
                    await queue.confirmDelivery(ack.messageID)
                    delegate?.protocolHandler(self, didDeliverMessage: ack.messageID)
                } else {
                    await queue.handleSendFailure(ack.messageID, error: nil)
                    delegate?.protocolHandler(self, didFailMessage: ack.messageID, error: nil)
                }

            case .botState(let envelope):
                let state = envelope.payload
                delegate?.protocolHandler(self, didReceiveBotState: state)
                botStateUpdates.send(state)

            case .streamingChunk(let envelope):
                let chunk = envelope.payload
                await assembler.addChunk(chunk)
                delegate?.protocolHandler(self, didReceiveChunk: chunk)

                // Check if stream is complete
                if chunk.isFinal {
                    if let content = await assembler.complete(messageID: chunk.messageID) {
                        // Create completed message
                        let completedMessage = ChatMessage(
                            id: chunk.messageID,
                            content: content,
                            sender: .bot(name: "Unknown"),  // Would be set from context
                            status: .delivered
                        )
                        delegate?.protocolHandler(self, didReceiveMessage: completedMessage)
                        incomingMessages.send(completedMessage)
                    }
                }

            case .ping(let sequence):
                // Respond with pong
                await sendPong(sequence: sequence)

            case .pong:
                // Heartbeat response received (handled by connection layer)
                break

            case .unknown(let type, _):
                // Log unknown message type but don't error
                print("[ProtocolHandler] Unknown message type: \(type)")
            }
        } catch {
            print("[ProtocolHandler] Failed to decode message: \(error)")
        }
    }

    /// Process incoming binary data
    public func handleIncoming(_ data: Data) async {
        guard let text = String(data: data, encoding: .utf8) else {
            print("[ProtocolHandler] Failed to decode binary data as UTF-8")
            return
        }
        await handleIncoming(text)
    }

    // MARK: - Ping/Pong

    private func sendPong(sequence: Int) async {
        guard let connection = connectionManager else { return }

        do {
            let data = try codec.encodePong(sequence: sequence)
            guard let jsonString = String(data: data, encoding: .utf8) else { return }
            try await connection.send(text: jsonString)
        } catch {
            print("[ProtocolHandler] Failed to send pong: \(error)")
        }
    }

    // MARK: - State

    /// Get current streaming content for a message
    public func streamingContent(for messageID: MessageID) async -> String {
        await assembler.currentContent(for: messageID)
    }

    /// Reset streaming state (e.g., on disconnect)
    public func resetStreaming() async {
        await assembler.reset()
    }

    /// Get pending message count
    public func pendingMessageCount() async -> Int {
        await queue.pendingCount()
    }

    /// Retry all failed messages
    public func retryFailedMessages() async {
        await queue.retryFailed()
    }

    /// Clear message queue
    public func clearQueue() async {
        await queue.clear()
    }
}

/// Errors from protocol handler
public enum ProtocolHandlerError: Error, Sendable {
    case notConnected
    case encodingFailed
    case decodingFailed
}

// MARK: - MessageQueueDelegate Conformance

extension ProtocolHandler: MessageQueueDelegate {
    public nonisolated func messageQueue(_ queue: OutgoingMessageQueue, shouldSend message: ChatMessage) async {
        do {
            try await performSend(message)
        } catch {
            await queue.handleSendFailure(message.id, error: error)
        }
    }

    public nonisolated func messageQueue(_ queue: OutgoingMessageQueue, didDeliver messageID: MessageID) {
        // Already handled in handleIncoming
    }

    public nonisolated func messageQueue(_ queue: OutgoingMessageQueue, didFail messageID: MessageID, error: Error?) {
        Task {
            await delegate?.protocolHandler(self, didFailMessage: messageID, error: error)
        }
    }
}
```

Key design decisions:
- ProtocolHandler is the single entry point for protocol operations
- Combines Combine publishers AND delegate pattern (SwiftUI + UIKit support)
- Handles streaming chunk assembly automatically
- Auto-responds to ping with pong
- Graceful handling of unknown message types (forward compatibility)
  </action>
  <verify>cd apps/ios/ClawdbotKit && swift build</verify>
  <done>ProtocolHandler.swift compiles with send/receive coordination</done>
</task>

<task type="auto">
  <name>Task 2: Update Protocol module exports</name>
  <files>apps/ios/ClawdbotKit/Sources/ClawdbotKit/Protocol/Protocol.swift</files>
  <action>
Update Protocol.swift at `apps/ios/ClawdbotKit/Sources/ClawdbotKit/Protocol/Protocol.swift`:

```swift
//
//  Protocol.swift
//  ClawdbotKit
//
//  Message protocol module for Clawdbot native apps.
//
//  This module contains the complete Clawdbot message protocol:
//  - MessageTypes.swift: Core message types (ChatMessage, ProtocolEnvelope)
//  - StreamingTypes.swift: Streaming response types (StreamingChunk, BotState)
//  - ProtocolCodec.swift: JSON encoder/decoder
//  - MessageQueue.swift: Outgoing queue with delivery tracking
//  - ProtocolHandler.swift: Coordination layer
//

import Foundation

/// Message protocol namespace for Clawdbot apps
public enum ClawdbotProtocol {
    /// Protocol version (tracks message format changes)
    public static let version = "1.0.0"

    /// Module status
    public static let status = "implemented"

    /// Default bot names
    public enum Bots {
        public static let opta = "Opta"
        public static let mono = "Mono"
    }

    /// Message type identifiers (matching ProtocolMessageType)
    public enum MessageTypes {
        public static let chatMessage = "chat.message"
        public static let messageAck = "message.ack"
        public static let botState = "bot.state"
        public static let streamingChunk = "streaming.chunk"
        public static let ping = "system.ping"
        public static let pong = "system.pong"
    }
}

// MARK: - Convenience Typealiases

/// Re-export common types at module level for convenience
public typealias Message = ChatMessage
public typealias Envelope<T: Codable & Sendable> = ProtocolEnvelope<T>
```
  </action>
  <verify>cd apps/ios/ClawdbotKit && swift build</verify>
  <done>Protocol.swift updated with proper exports and version 1.0.0</done>
</task>

<task type="auto">
  <name>Task 3: Add integration test</name>
  <files>apps/ios/ClawdbotKit/Tests/ClawdbotKitTests/ProtocolHandlerTests.swift</files>
  <action>
Create integration test at `apps/ios/ClawdbotKit/Tests/ClawdbotKitTests/ProtocolHandlerTests.swift`:

```swift
//
//  ProtocolHandlerTests.swift
//  ClawdbotKit
//
//  Integration tests for protocol handler.
//

import XCTest
@testable import ClawdbotKit

/// Mock delegate for testing
final class MockProtocolDelegate: ProtocolHandlerDelegate, @unchecked Sendable {
    var receivedMessages: [ChatMessage] = []
    var receivedStates: [BotStateUpdate] = []
    var receivedChunks: [StreamingChunk] = []
    var deliveredIDs: [MessageID] = []
    var failedIDs: [MessageID] = []

    func protocolHandler(_ handler: ProtocolHandler, didReceiveMessage message: ChatMessage) {
        receivedMessages.append(message)
    }

    func protocolHandler(_ handler: ProtocolHandler, didReceiveBotState state: BotStateUpdate) {
        receivedStates.append(state)
    }

    func protocolHandler(_ handler: ProtocolHandler, didReceiveChunk chunk: StreamingChunk) {
        receivedChunks.append(chunk)
    }

    func protocolHandler(_ handler: ProtocolHandler, didDeliverMessage messageID: MessageID) {
        deliveredIDs.append(messageID)
    }

    func protocolHandler(_ handler: ProtocolHandler, didFailMessage messageID: MessageID, error: Error?) {
        failedIDs.append(messageID)
    }
}

final class ProtocolHandlerTests: XCTestCase {

    var handler: ProtocolHandler!
    var delegate: MockProtocolDelegate!

    override func setUp() async throws {
        handler = ProtocolHandler()
        delegate = MockProtocolDelegate()
        await handler.setDelegate(delegate)
    }

    // MARK: - Incoming Message Tests

    func testHandleChatMessage() async {
        let json = """
        {
            "version": "1.0",
            "type": "chat.message",
            "sequence": 1,
            "payload": {
                "id": {"value": "incoming-1"},
                "content": "Hello from Opta",
                "sender": {"type": "bot", "name": "Opta"},
                "timestamp": "2024-01-30T12:00:00Z",
                "status": "delivered",
                "threadID": null,
                "replyTo": null
            },
            "serverTimestamp": null
        }
        """

        await handler.handleIncoming(json)

        XCTAssertEqual(delegate.receivedMessages.count, 1)
        XCTAssertEqual(delegate.receivedMessages.first?.content, "Hello from Opta")
        XCTAssertEqual(delegate.receivedMessages.first?.sender, .bot(name: "Opta"))
    }

    func testHandleBotState() async {
        let json = """
        {
            "version": "1.0",
            "type": "bot.state",
            "sequence": 5,
            "payload": {
                "state": "thinking",
                "botName": "Opta",
                "detail": "Processing your request...",
                "timestamp": "2024-01-30T12:00:00Z"
            },
            "serverTimestamp": null
        }
        """

        await handler.handleIncoming(json)

        XCTAssertEqual(delegate.receivedStates.count, 1)
        XCTAssertEqual(delegate.receivedStates.first?.state, .thinking)
        XCTAssertEqual(delegate.receivedStates.first?.botName, "Opta")
        XCTAssertEqual(delegate.receivedStates.first?.detail, "Processing your request...")
    }

    func testHandleStreamingChunks() async {
        // Send multiple chunks
        let chunk1 = """
        {
            "version": "1.0",
            "type": "streaming.chunk",
            "sequence": 10,
            "payload": {
                "messageID": {"value": "stream-1"},
                "chunkIndex": 0,
                "content": "Hello ",
                "isFinal": false
            },
            "serverTimestamp": null
        }
        """

        let chunk2 = """
        {
            "version": "1.0",
            "type": "streaming.chunk",
            "sequence": 11,
            "payload": {
                "messageID": {"value": "stream-1"},
                "chunkIndex": 1,
                "content": "World!",
                "isFinal": true
            },
            "serverTimestamp": null
        }
        """

        await handler.handleIncoming(chunk1)
        await handler.handleIncoming(chunk2)

        XCTAssertEqual(delegate.receivedChunks.count, 2)

        // Final chunk should trigger complete message
        XCTAssertEqual(delegate.receivedMessages.count, 1)
        XCTAssertEqual(delegate.receivedMessages.first?.content, "Hello World!")
    }

    func testHandleUnknownMessageType() async {
        let json = """
        {
            "version": "1.0",
            "type": "future.feature",
            "sequence": 99,
            "payload": {"data": "unknown"},
            "serverTimestamp": null
        }
        """

        // Should not crash
        await handler.handleIncoming(json)

        // Should not call any delegate methods
        XCTAssertTrue(delegate.receivedMessages.isEmpty)
        XCTAssertTrue(delegate.receivedStates.isEmpty)
    }

    func testHandleInvalidJSON() async {
        let invalid = "not valid json {"

        // Should not crash
        await handler.handleIncoming(invalid)

        // Should not call any delegate methods
        XCTAssertTrue(delegate.receivedMessages.isEmpty)
    }

    // MARK: - Module Tests

    func testProtocolVersion() {
        XCTAssertEqual(ClawdbotProtocol.version, "1.0.0")
        XCTAssertEqual(ClawdbotProtocol.status, "implemented")
    }

    func testBotNames() {
        XCTAssertEqual(ClawdbotProtocol.Bots.opta, "Opta")
        XCTAssertEqual(ClawdbotProtocol.Bots.mono, "Mono")
    }

    func testMessageTypeConstants() {
        XCTAssertEqual(ClawdbotProtocol.MessageTypes.chatMessage, "chat.message")
        XCTAssertEqual(ClawdbotProtocol.MessageTypes.messageAck, "message.ack")
        XCTAssertEqual(ClawdbotProtocol.MessageTypes.botState, "bot.state")
        XCTAssertEqual(ClawdbotProtocol.MessageTypes.streamingChunk, "streaming.chunk")
    }
}

// MARK: - Helper Extension

extension ProtocolHandler {
    /// Test helper to set delegate
    public func setDelegate(_ delegate: ProtocolHandlerDelegate?) {
        self.delegate = delegate
    }
}
```
  </action>
  <verify>cd apps/ios/ClawdbotKit && swift test</verify>
  <done>All protocol handler tests pass</done>
</task>

<task type="checkpoint:commit">
  <files>apps/ios/ClawdbotKit/Sources/ClawdbotKit/Protocol/</files>
  <message>feat(03-04): implement ProtocolHandler for complete message flow</message>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] ProtocolHandler.swift exists with send/receive coordination
- [ ] Protocol.swift updated with version 1.0.0 and exports
- [ ] ProtocolHandler handles all message types
- [ ] Streaming assembly works end-to-end
- [ ] ClawdbotKit compiles (`swift build`)
- [ ] All tests pass (`swift test`)
- [ ] Changes committed
</verification>

<success_criteria>
- ProtocolHandler actor coordinates codec + queue
- Delegate and Combine patterns for flexibility
- Handles incoming: chat, ack, state, streaming, ping/pong
- Auto-responds to ping with pong
- Streaming chunks assembled into complete messages
- Graceful handling of unknown message types
- Protocol module version 1.0.0
</success_criteria>

<output>
After completion, create `.planning/phases/03-protocol/03-04-SUMMARY.md`
</output>
