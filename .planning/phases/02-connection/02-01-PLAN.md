---
phase: 02-connection
plan: 01
type: execute
wave: 1
depends_on: ["01-03"]
files_modified: [apps/ios/ClawdbotKit/Sources/ClawdbotKit/Connection/WebSocketClient.swift, apps/ios/ClawdbotKit/Sources/ClawdbotKit/Connection/WebSocketMessage.swift]
autonomous: true
---

<objective>
Implement the core WebSocket client using URLSessionWebSocketTask.

Purpose: Create a robust WebSocket client that handles basic connection, sending, and receiving of messages with proper async/await integration.
Output: `ClawdbotWebSocket` actor with connect/disconnect/send/receive capabilities in ClawdbotKit.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-01-SUMMARY.md

# Existing WebSocket patterns in codebase:
@apps/desktop/opta-native/OptaNative/OptaNative/MCP/MCPWebSocketServer.swift

# Current Connection module stub:
@apps/ios/ClawdbotKit/Sources/ClawdbotKit/Connection/Connection.swift
</context>

<research_findings>
## WebSocket Library Decision

**Choice**: URLSessionWebSocketTask (Apple native)

**Rationale**:
- No third-party dependency (binary size matters for potential App Clips)
- iOS 17+ requirement means mature, stable API
- Codebase already uses Network.framework patterns (MCPWebSocketServer.swift)
- Full control over reconnection logic (needed for Phase 02-02)
- RFC 6455 compliant

**Trade-offs accepted**:
- Manual receive loop required (call receive() after each message)
- Manual ping/pong handling (will implement in 02-02)

**References**:
- Apple docs: https://developer.apple.com/documentation/foundation/urlsessionwebsockettask
- Existing pattern: apps/desktop/opta-native/OptaNative/OptaNative/MCP/MCPWebSocketServer.swift
</research_findings>

<tasks>

<task type="auto">
  <name>Task 1: Create WebSocket message types</name>
  <files>apps/ios/ClawdbotKit/Sources/ClawdbotKit/Connection/WebSocketMessage.swift</files>
  <action>
Create message type definitions at `apps/ios/ClawdbotKit/Sources/ClawdbotKit/Connection/WebSocketMessage.swift`:

```swift
//
//  WebSocketMessage.swift
//  ClawdbotKit
//
//  WebSocket message types for Clawdbot communication.
//

import Foundation

/// Represents a WebSocket message (text or binary)
public enum ClawdbotMessage: Sendable {
    case text(String)
    case data(Data)

    /// Convert to URLSessionWebSocketTask.Message
    var urlSessionMessage: URLSessionWebSocketTask.Message {
        switch self {
        case .text(let string):
            return .string(string)
        case .data(let data):
            return .data(data)
        }
    }

    /// Create from URLSessionWebSocketTask.Message
    init(from message: URLSessionWebSocketTask.Message) {
        switch message {
        case .string(let string):
            self = .text(string)
        case .data(let data):
            self = .data(data)
        @unknown default:
            self = .data(Data())
        }
    }
}

/// WebSocket-specific errors
public enum ClawdbotWebSocketError: Error, Sendable {
    case notConnected
    case invalidURL
    case connectionFailed(Error)
    case sendFailed(Error)
    case receiveFailed(Error)
    case cancelled
}
```
  </action>
  <verify>cd apps/ios/ClawdbotKit && swift build</verify>
  <done>WebSocketMessage.swift compiles with message types and error definitions</done>
</task>

<task type="auto">
  <name>Task 2: Implement WebSocket client actor</name>
  <files>apps/ios/ClawdbotKit/Sources/ClawdbotKit/Connection/WebSocketClient.swift</files>
  <action>
Create the core WebSocket client at `apps/ios/ClawdbotKit/Sources/ClawdbotKit/Connection/WebSocketClient.swift`:

```swift
//
//  WebSocketClient.swift
//  ClawdbotKit
//
//  Core WebSocket client using URLSessionWebSocketTask.
//  Provides basic connect/disconnect/send/receive operations.
//
//  State management and reconnection handled by ConnectionManager (Plan 02-02).
//

import Foundation

/// Delegate protocol for WebSocket events
public protocol ClawdbotWebSocketDelegate: AnyObject, Sendable {
    func webSocketDidConnect()
    func webSocketDidDisconnect(error: Error?)
    func webSocketDidReceiveMessage(_ message: ClawdbotMessage)
}

/// Core WebSocket client using URLSessionWebSocketTask
public actor ClawdbotWebSocket {

    // MARK: - Properties

    private var webSocketTask: URLSessionWebSocketTask?
    private let session: URLSession
    private var isReceiving = false

    public weak var delegate: ClawdbotWebSocketDelegate?

    /// Current connection state
    public private(set) var isConnected = false

    // MARK: - Initialization

    public init() {
        let configuration = URLSessionConfiguration.default
        configuration.waitsForConnectivity = true
        configuration.timeoutIntervalForRequest = 30
        self.session = URLSession(configuration: configuration)
    }

    // MARK: - Connection

    /// Connect to WebSocket server
    /// - Parameter url: WebSocket URL (ws:// or wss://)
    public func connect(to url: URL) async throws {
        guard !isConnected else { return }

        // Validate URL scheme
        guard let scheme = url.scheme,
              scheme == "ws" || scheme == "wss" else {
            throw ClawdbotWebSocketError.invalidURL
        }

        webSocketTask = session.webSocketTask(with: url)
        webSocketTask?.resume()

        isConnected = true
        isReceiving = true

        // Notify delegate
        delegate?.webSocketDidConnect()

        // Start receive loop
        await startReceiveLoop()
    }

    /// Disconnect from WebSocket server
    public func disconnect(code: URLSessionWebSocketTask.CloseCode = .normalClosure) {
        guard isConnected else { return }

        isReceiving = false
        webSocketTask?.cancel(with: code, reason: nil)
        webSocketTask = nil
        isConnected = false

        delegate?.webSocketDidDisconnect(error: nil)
    }

    // MARK: - Send

    /// Send a message
    public func send(_ message: ClawdbotMessage) async throws {
        guard let task = webSocketTask, isConnected else {
            throw ClawdbotWebSocketError.notConnected
        }

        do {
            try await task.send(message.urlSessionMessage)
        } catch {
            throw ClawdbotWebSocketError.sendFailed(error)
        }
    }

    /// Send a text message (convenience)
    public func send(text: String) async throws {
        try await send(.text(text))
    }

    /// Send binary data (convenience)
    public func send(data: Data) async throws {
        try await send(.data(data))
    }

    // MARK: - Receive Loop

    private func startReceiveLoop() async {
        while isReceiving {
            guard let task = webSocketTask else { break }

            do {
                let message = try await task.receive()
                let clawdbotMessage = ClawdbotMessage(from: message)
                delegate?.webSocketDidReceiveMessage(clawdbotMessage)
            } catch {
                if isReceiving {
                    // Unexpected disconnect
                    isConnected = false
                    isReceiving = false
                    delegate?.webSocketDidDisconnect(error: error)
                }
                break
            }
        }
    }

    // MARK: - Ping

    /// Send a ping to keep connection alive
    public func ping() async throws {
        guard let task = webSocketTask, isConnected else {
            throw ClawdbotWebSocketError.notConnected
        }

        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void, Error>) in
            task.sendPing { error in
                if let error = error {
                    continuation.resume(throwing: error)
                } else {
                    continuation.resume()
                }
            }
        }
    }
}
```
  </action>
  <verify>cd apps/ios/ClawdbotKit && swift build</verify>
  <done>WebSocketClient.swift compiles with connect/disconnect/send/receive/ping methods</done>
</task>

<task type="auto">
  <name>Task 3: Update Connection module exports</name>
  <files>apps/ios/ClawdbotKit/Sources/ClawdbotKit/Connection/Connection.swift</files>
  <action>
Update the Connection.swift file to export the new types and remove placeholder content:

```swift
//
//  Connection.swift
//  ClawdbotKit
//
//  Connection module for Clawdbot native apps.
//
//  This module contains WebSocket connection infrastructure:
//  - ClawdbotWebSocket: Core WebSocket client (URLSessionWebSocketTask)
//  - ClawdbotMessage: Message types (text/data)
//  - ClawdbotWebSocketError: Connection errors
//
//  State machine and reconnection: ConnectionManager (Plan 02-02)
//  Network reachability: NetworkMonitor (Plan 02-03)
//

import Foundation

/// Connection infrastructure namespace for Clawdbot apps
public enum ClawdbotConnection {
    /// Module version
    public static let version = "0.2.0"

    /// Connection states for state machine (implemented in Plan 02-02)
    public enum State: String, Sendable {
        case disconnected
        case connecting
        case connected
        case reconnecting
    }
}
```
  </action>
  <verify>cd apps/ios/ClawdbotKit && swift build</verify>
  <done>Connection.swift updated with proper module documentation and exports</done>
</task>

<task type="auto">
  <name>Task 4: Add unit test for WebSocket client</name>
  <files>apps/ios/ClawdbotKit/Tests/ClawdbotKitTests/WebSocketClientTests.swift</files>
  <action>
Create basic unit tests at `apps/ios/ClawdbotKit/Tests/ClawdbotKitTests/WebSocketClientTests.swift`:

```swift
//
//  WebSocketClientTests.swift
//  ClawdbotKit
//
//  Tests for ClawdbotWebSocket client.
//

import XCTest
@testable import ClawdbotKit

final class WebSocketClientTests: XCTestCase {

    func testMessageConversion() {
        // Test text message conversion
        let textMessage = ClawdbotMessage.text("Hello")
        let urlMessage = textMessage.urlSessionMessage

        if case .string(let str) = urlMessage {
            XCTAssertEqual(str, "Hello")
        } else {
            XCTFail("Expected string message")
        }

        // Test data message conversion
        let data = "Binary".data(using: .utf8)!
        let dataMessage = ClawdbotMessage.data(data)
        let urlDataMessage = dataMessage.urlSessionMessage

        if case .data(let d) = urlDataMessage {
            XCTAssertEqual(d, data)
        } else {
            XCTFail("Expected data message")
        }
    }

    func testInvalidURLThrows() async {
        let client = ClawdbotWebSocket()
        let invalidURL = URL(string: "http://example.com")!

        do {
            try await client.connect(to: invalidURL)
            XCTFail("Should have thrown for http:// URL")
        } catch ClawdbotWebSocketError.invalidURL {
            // Expected
        } catch {
            XCTFail("Unexpected error: \(error)")
        }
    }

    func testSendWithoutConnectionThrows() async {
        let client = ClawdbotWebSocket()

        do {
            try await client.send(text: "Test")
            XCTFail("Should have thrown for disconnected send")
        } catch ClawdbotWebSocketError.notConnected {
            // Expected
        } catch {
            XCTFail("Unexpected error: \(error)")
        }
    }

    func testPingWithoutConnectionThrows() async {
        let client = ClawdbotWebSocket()

        do {
            try await client.ping()
            XCTFail("Should have thrown for disconnected ping")
        } catch ClawdbotWebSocketError.notConnected {
            // Expected
        } catch {
            XCTFail("Unexpected error: \(error)")
        }
    }
}
```
  </action>
  <verify>cd apps/ios/ClawdbotKit && swift test</verify>
  <done>WebSocket client tests pass</done>
</task>

<task type="checkpoint:commit">
  <files>apps/ios/ClawdbotKit/Sources/ClawdbotKit/Connection/</files>
  <message>feat(02-01): implement WebSocket client with URLSessionWebSocketTask</message>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] WebSocketMessage.swift exists with message types
- [ ] WebSocketClient.swift exists with ClawdbotWebSocket actor
- [ ] Connection.swift updated with module exports
- [ ] ClawdbotKit compiles (`swift build`)
- [ ] Unit tests pass (`swift test`)
- [ ] Changes committed
</verification>

<success_criteria>
- ClawdbotWebSocket actor implemented with async/await
- connect(), disconnect(), send(), ping() methods working
- Proper error handling with ClawdbotWebSocketError
- Delegate pattern for async events
- Unit tests verify basic functionality
</success_criteria>

<output>
After completion, create `.planning/phases/02-connection/02-01-SUMMARY.md`
</output>
