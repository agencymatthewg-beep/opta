---
phase: 02-connection
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified: [apps/ios/ClawdbotKit/Sources/ClawdbotKit/Connection/NetworkMonitor.swift, apps/ios/ClawdbotKit/Sources/ClawdbotKit/Connection/TailscaleDetector.swift]
autonomous: true
---

<objective>
Implement network reachability monitoring and Tailscale network detection.

Purpose: Detect network changes to trigger reconnection and identify Tailscale mesh network availability for direct connections.
Output: `NetworkMonitor` for reachability and `TailscaleDetector` for VPN mesh detection.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-connection/02-01-PLAN.md
@.planning/phases/02-connection/02-02-PLAN.md

# Tailscale network info from personal context:
# Mac Studio accessible at 100.75.167.36

# Network patterns in codebase:
@apps/desktop/opta-native/OptaNative/OptaNative/Services/NetworkLatencyService.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement NetworkMonitor</name>
  <files>apps/ios/ClawdbotKit/Sources/ClawdbotKit/Connection/NetworkMonitor.swift</files>
  <action>
Create network reachability monitor at `apps/ios/ClawdbotKit/Sources/ClawdbotKit/Connection/NetworkMonitor.swift`:

```swift
//
//  NetworkMonitor.swift
//  ClawdbotKit
//
//  Monitors network reachability using NWPathMonitor.
//  Detects network changes to trigger reconnection behavior.
//

import Foundation
import Network
import Combine

// MARK: - Network Status

/// Current network status
public enum NetworkStatus: String, Sendable, Equatable {
    case connected
    case disconnected
    case requiresConnection  // e.g., captive portal

    /// Whether network is usable for WebSocket
    public var isUsable: Bool {
        self == .connected
    }
}

/// Network interface type
public enum NetworkInterface: String, Sendable {
    case wifi
    case cellular
    case wiredEthernet
    case loopback
    case other
    case unknown

    init(from interface: NWInterface.InterfaceType) {
        switch interface {
        case .wifi:
            self = .wifi
        case .cellular:
            self = .cellular
        case .wiredEthernet:
            self = .wiredEthernet
        case .loopback:
            self = .loopback
        case .other:
            self = .other
        @unknown default:
            self = .unknown
        }
    }
}

/// Network path information
public struct NetworkPath: Sendable, Equatable {
    public let status: NetworkStatus
    public let interfaces: [NetworkInterface]
    public let isExpensive: Bool      // Cellular or hotspot
    public let isConstrained: Bool    // Low Data Mode
    public let supportsIPv4: Bool
    public let supportsIPv6: Bool

    /// Primary interface (first available)
    public var primaryInterface: NetworkInterface? {
        interfaces.first
    }

    /// Whether connection is via VPN (including Tailscale)
    public var usesVPN: Bool {
        // VPN connections often appear as "other" interface type
        interfaces.contains(.other)
    }
}

// MARK: - Network Monitor

/// Monitors network reachability changes
public final class NetworkMonitor: @unchecked Sendable {

    // MARK: - Properties

    private let monitor: NWPathMonitor
    private let queue = DispatchQueue(label: "com.clawdbot.networkmonitor", qos: .utility)
    private var isMonitoring = false

    private let pathSubject = CurrentValueSubject<NetworkPath?, Never>(nil)
    private let statusSubject = CurrentValueSubject<NetworkStatus, Never>(.disconnected)

    /// Current network path
    public var currentPath: NetworkPath? {
        pathSubject.value
    }

    /// Current network status
    public var status: NetworkStatus {
        statusSubject.value
    }

    /// Publisher for network path changes
    public var pathPublisher: AnyPublisher<NetworkPath?, Never> {
        pathSubject.eraseToAnyPublisher()
    }

    /// Publisher for status changes only
    public var statusPublisher: AnyPublisher<NetworkStatus, Never> {
        statusSubject
            .removeDuplicates()
            .eraseToAnyPublisher()
    }

    // MARK: - Initialization

    public init() {
        self.monitor = NWPathMonitor()
    }

    /// Initialize for specific interface type
    public init(requiredInterfaceType: NWInterface.InterfaceType) {
        self.monitor = NWPathMonitor(requiredInterfaceType: requiredInterfaceType)
    }

    deinit {
        stop()
    }

    // MARK: - Monitoring

    /// Start monitoring network changes
    public func start() {
        guard !isMonitoring else { return }

        monitor.pathUpdateHandler = { [weak self] path in
            self?.handlePathUpdate(path)
        }

        monitor.start(queue: queue)
        isMonitoring = true
    }

    /// Stop monitoring
    public func stop() {
        guard isMonitoring else { return }

        monitor.cancel()
        isMonitoring = false
    }

    // MARK: - Path Handling

    private func handlePathUpdate(_ path: NWPath) {
        let status: NetworkStatus
        switch path.status {
        case .satisfied:
            status = .connected
        case .unsatisfied:
            status = .disconnected
        case .requiresConnection:
            status = .requiresConnection
        @unknown default:
            status = .disconnected
        }

        let interfaces = path.availableInterfaces.map {
            NetworkInterface(from: $0.type)
        }

        let networkPath = NetworkPath(
            status: status,
            interfaces: interfaces,
            isExpensive: path.isExpensive,
            isConstrained: path.isConstrained,
            supportsIPv4: path.supportsIPv4,
            supportsIPv6: path.supportsIPv6
        )

        pathSubject.send(networkPath)
        statusSubject.send(status)
    }

    // MARK: - Utilities

    /// Check if a specific host is reachable
    public func isReachable(host: String, port: UInt16 = 443) async -> Bool {
        return await withCheckedContinuation { continuation in
            let endpoint = NWEndpoint.hostPort(
                host: NWEndpoint.Host(host),
                port: NWEndpoint.Port(rawValue: port)!
            )
            let connection = NWConnection(to: endpoint, using: .tcp)

            connection.stateUpdateHandler = { state in
                switch state {
                case .ready:
                    connection.cancel()
                    continuation.resume(returning: true)
                case .failed, .cancelled:
                    continuation.resume(returning: false)
                default:
                    break
                }
            }

            connection.start(queue: self.queue)

            // Timeout after 5 seconds
            DispatchQueue.global().asyncAfter(deadline: .now() + 5) {
                if connection.state != .cancelled {
                    connection.cancel()
                    continuation.resume(returning: false)
                }
            }
        }
    }
}
```
  </action>
  <verify>cd apps/ios/ClawdbotKit && swift build</verify>
  <done>NetworkMonitor.swift compiles with reachability monitoring</done>
</task>

<task type="auto">
  <name>Task 2: Implement TailscaleDetector</name>
  <files>apps/ios/ClawdbotKit/Sources/ClawdbotKit/Connection/TailscaleDetector.swift</files>
  <action>
Create Tailscale detection at `apps/ios/ClawdbotKit/Sources/ClawdbotKit/Connection/TailscaleDetector.swift`:

```swift
//
//  TailscaleDetector.swift
//  ClawdbotKit
//
//  Detects Tailscale mesh network availability.
//  Enables direct connections to Clawdbot servers via Tailscale VPN.
//
//  Tailscale IP range: 100.x.x.x (CGNAT range)
//

import Foundation
import Network
import Combine

// MARK: - Tailscale Status

/// Tailscale connection status
public enum TailscaleStatus: String, Sendable, Equatable {
    case connected      // Tailscale active and reachable
    case disconnected   // Tailscale not available
    case checking       // Currently checking status
}

/// Tailscale network information
public struct TailscaleInfo: Sendable, Equatable {
    public let status: TailscaleStatus
    public let localIP: String?           // Our Tailscale IP (100.x.x.x)
    public let canReachServer: Bool       // Can reach Clawdbot server
    public let serverIP: String?          // Configured server IP
    public let lastChecked: Date
}

// MARK: - Tailscale Detector

/// Detects and monitors Tailscale VPN connectivity
public final class TailscaleDetector: @unchecked Sendable {

    // MARK: - Constants

    /// Tailscale CGNAT IP range prefix
    private static let tailscalePrefix = "100."

    /// Known Clawdbot server IPs on Tailscale
    public struct KnownServers {
        /// Mac Studio (Mono, GLM-4.7)
        public static let macStudio = "100.75.167.36"

        /// Default server to check
        public static let `default` = macStudio
    }

    // MARK: - Properties

    private let serverIP: String
    private let checkInterval: TimeInterval
    private var checkTask: Task<Void, Never>?

    private let infoSubject = CurrentValueSubject<TailscaleInfo, Never>(
        TailscaleInfo(
            status: .disconnected,
            localIP: nil,
            canReachServer: false,
            serverIP: nil,
            lastChecked: Date()
        )
    )

    /// Current Tailscale info
    public var info: TailscaleInfo {
        infoSubject.value
    }

    /// Publisher for Tailscale status changes
    public var infoPublisher: AnyPublisher<TailscaleInfo, Never> {
        infoSubject.eraseToAnyPublisher()
    }

    /// Whether Tailscale is currently connected
    public var isConnected: Bool {
        infoSubject.value.status == .connected
    }

    // MARK: - Initialization

    /// Initialize with server IP and check interval
    /// - Parameters:
    ///   - serverIP: Tailscale IP of the Clawdbot server
    ///   - checkInterval: How often to recheck (0 for one-time check)
    public init(serverIP: String = KnownServers.default, checkInterval: TimeInterval = 60) {
        self.serverIP = serverIP
        self.checkInterval = checkInterval
    }

    deinit {
        stop()
    }

    // MARK: - Detection

    /// Start monitoring Tailscale status
    public func start() {
        stop()

        checkTask = Task { [weak self] in
            guard let self = self else { return }

            while !Task.isCancelled {
                await self.checkTailscale()

                guard self.checkInterval > 0 else { break }

                try? await Task.sleep(nanoseconds: UInt64(self.checkInterval * 1_000_000_000))
            }
        }
    }

    /// Stop monitoring
    public func stop() {
        checkTask?.cancel()
        checkTask = nil
    }

    /// Perform one-time Tailscale check
    @discardableResult
    public func check() async -> TailscaleInfo {
        await checkTailscale()
        return info
    }

    // MARK: - Internal

    private func checkTailscale() async {
        // Update to checking state
        var newInfo = TailscaleInfo(
            status: .checking,
            localIP: nil,
            canReachServer: false,
            serverIP: serverIP,
            lastChecked: Date()
        )
        infoSubject.send(newInfo)

        // 1. Check if we have a Tailscale IP
        let localIP = await getTailscaleIP()

        guard let localIP = localIP else {
            newInfo = TailscaleInfo(
                status: .disconnected,
                localIP: nil,
                canReachServer: false,
                serverIP: serverIP,
                lastChecked: Date()
            )
            infoSubject.send(newInfo)
            return
        }

        // 2. Check if we can reach the server
        let canReach = await isReachable(ip: serverIP)

        newInfo = TailscaleInfo(
            status: canReach ? .connected : .disconnected,
            localIP: localIP,
            canReachServer: canReach,
            serverIP: serverIP,
            lastChecked: Date()
        )
        infoSubject.send(newInfo)
    }

    /// Get our Tailscale IP address (100.x.x.x)
    private func getTailscaleIP() async -> String? {
        var addresses: [String] = []

        // Get all network interfaces
        var ifaddr: UnsafeMutablePointer<ifaddrs>?
        guard getifaddrs(&ifaddr) == 0, let firstAddr = ifaddr else {
            return nil
        }
        defer { freeifaddrs(ifaddr) }

        var ptr = firstAddr
        while true {
            let interface = ptr.pointee

            // Check for IPv4
            if interface.ifa_addr.pointee.sa_family == UInt8(AF_INET) {
                var hostname = [CChar](repeating: 0, count: Int(NI_MAXHOST))
                getnameinfo(
                    interface.ifa_addr,
                    socklen_t(interface.ifa_addr.pointee.sa_len),
                    &hostname,
                    socklen_t(hostname.count),
                    nil,
                    0,
                    NI_NUMERICHOST
                )

                let address = String(cString: hostname)

                // Check if it's a Tailscale IP (100.x.x.x)
                if address.hasPrefix(Self.tailscalePrefix) {
                    addresses.append(address)
                }
            }

            guard let next = interface.ifa_next else { break }
            ptr = next
        }

        // Return first Tailscale IP found
        return addresses.first
    }

    /// Check if a Tailscale IP is reachable
    private func isReachable(ip: String, port: UInt16 = 443) async -> Bool {
        return await withCheckedContinuation { continuation in
            let endpoint = NWEndpoint.hostPort(
                host: NWEndpoint.Host(ip),
                port: NWEndpoint.Port(rawValue: port)!
            )
            let connection = NWConnection(to: endpoint, using: .tcp)

            var didResume = false

            connection.stateUpdateHandler = { state in
                guard !didResume else { return }

                switch state {
                case .ready:
                    didResume = true
                    connection.cancel()
                    continuation.resume(returning: true)
                case .failed, .cancelled:
                    didResume = true
                    continuation.resume(returning: false)
                default:
                    break
                }
            }

            connection.start(queue: DispatchQueue.global(qos: .utility))

            // Timeout after 3 seconds (Tailscale should be fast)
            DispatchQueue.global().asyncAfter(deadline: .now() + 3) {
                guard !didResume else { return }
                didResume = true
                connection.cancel()
                continuation.resume(returning: false)
            }
        }
    }

    // MARK: - URL Building

    /// Build WebSocket URL for Tailscale connection
    public func buildWebSocketURL(port: UInt16 = 8080, path: String = "/ws") -> URL? {
        guard isConnected else { return nil }
        return URL(string: "ws://\(serverIP):\(port)\(path)")
    }

    /// Build secure WebSocket URL for Tailscale connection
    public func buildSecureWebSocketURL(port: UInt16 = 443, path: String = "/ws") -> URL? {
        guard isConnected else { return nil }
        return URL(string: "wss://\(serverIP):\(port)\(path)")
    }
}
```
  </action>
  <verify>cd apps/ios/ClawdbotKit && swift build</verify>
  <done>TailscaleDetector.swift compiles with VPN detection</done>
</task>

<task type="auto">
  <name>Task 3: Add network monitoring tests</name>
  <files>apps/ios/ClawdbotKit/Tests/ClawdbotKitTests/NetworkMonitorTests.swift</files>
  <action>
Create network tests at `apps/ios/ClawdbotKit/Tests/ClawdbotKitTests/NetworkMonitorTests.swift`:

```swift
//
//  NetworkMonitorTests.swift
//  ClawdbotKit
//
//  Tests for NetworkMonitor and TailscaleDetector.
//

import XCTest
@testable import ClawdbotKit

final class NetworkMonitorTests: XCTestCase {

    // MARK: - NetworkStatus Tests

    func testNetworkStatusUsability() {
        XCTAssertTrue(NetworkStatus.connected.isUsable)
        XCTAssertFalse(NetworkStatus.disconnected.isUsable)
        XCTAssertFalse(NetworkStatus.requiresConnection.isUsable)
    }

    // MARK: - NetworkPath Tests

    func testNetworkPathPrimaryInterface() {
        let path = NetworkPath(
            status: .connected,
            interfaces: [.wifi, .cellular],
            isExpensive: false,
            isConstrained: false,
            supportsIPv4: true,
            supportsIPv6: true
        )

        XCTAssertEqual(path.primaryInterface, .wifi)
    }

    func testEmptyInterfacesPrimaryInterface() {
        let path = NetworkPath(
            status: .disconnected,
            interfaces: [],
            isExpensive: false,
            isConstrained: false,
            supportsIPv4: false,
            supportsIPv6: false
        )

        XCTAssertNil(path.primaryInterface)
    }

    func testVPNDetection() {
        // VPN connections appear as "other" interface
        let vpnPath = NetworkPath(
            status: .connected,
            interfaces: [.other, .wifi],
            isExpensive: false,
            isConstrained: false,
            supportsIPv4: true,
            supportsIPv6: true
        )

        XCTAssertTrue(vpnPath.usesVPN)

        let noVPNPath = NetworkPath(
            status: .connected,
            interfaces: [.wifi],
            isExpensive: false,
            isConstrained: false,
            supportsIPv4: true,
            supportsIPv6: true
        )

        XCTAssertFalse(noVPNPath.usesVPN)
    }

    // MARK: - NetworkMonitor Tests

    func testNetworkMonitorInitialState() {
        let monitor = NetworkMonitor()

        XCTAssertNil(monitor.currentPath)
        XCTAssertEqual(monitor.status, .disconnected)
    }

    // MARK: - TailscaleDetector Tests

    func testTailscaleKnownServers() {
        XCTAssertEqual(TailscaleDetector.KnownServers.macStudio, "100.75.167.36")
        XCTAssertEqual(TailscaleDetector.KnownServers.default, "100.75.167.36")
    }

    func testTailscaleDetectorInitialState() {
        let detector = TailscaleDetector()

        XCTAssertEqual(detector.info.status, .disconnected)
        XCTAssertNil(detector.info.localIP)
        XCTAssertFalse(detector.info.canReachServer)
        XCTAssertFalse(detector.isConnected)
    }

    func testTailscaleURLBuilding() {
        let detector = TailscaleDetector(serverIP: "100.75.167.36")

        // Should return nil when not connected
        XCTAssertNil(detector.buildWebSocketURL())
        XCTAssertNil(detector.buildSecureWebSocketURL())
    }

    // MARK: - TailscaleInfo Tests

    func testTailscaleInfoEquality() {
        let info1 = TailscaleInfo(
            status: .connected,
            localIP: "100.1.2.3",
            canReachServer: true,
            serverIP: "100.75.167.36",
            lastChecked: Date(timeIntervalSince1970: 0)
        )

        let info2 = TailscaleInfo(
            status: .connected,
            localIP: "100.1.2.3",
            canReachServer: true,
            serverIP: "100.75.167.36",
            lastChecked: Date(timeIntervalSince1970: 0)
        )

        XCTAssertEqual(info1, info2)
    }
}
```
  </action>
  <verify>cd apps/ios/ClawdbotKit && swift test</verify>
  <done>Network monitoring tests pass</done>
</task>

<task type="checkpoint:commit">
  <files>apps/ios/ClawdbotKit/Sources/ClawdbotKit/Connection/</files>
  <message>feat(02-03): implement network reachability and Tailscale detection</message>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] NetworkMonitor.swift exists with reachability monitoring
- [ ] TailscaleDetector.swift exists with VPN detection
- [ ] ClawdbotKit compiles (`swift build`)
- [ ] Network tests pass (`swift test`)
- [ ] Changes committed
</verification>

<success_criteria>
- NWPathMonitor integration for reachability
- Combine publishers for reactive UI binding
- Tailscale IP detection (100.x.x.x range)
- Server reachability checking
- WebSocket URL building helpers
- Unit tests for all public APIs
</success_criteria>

<output>
After completion, create `.planning/phases/02-connection/02-03-SUMMARY.md`
</output>
