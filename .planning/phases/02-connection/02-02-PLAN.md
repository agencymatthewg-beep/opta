---
phase: 02-connection
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified: [apps/ios/ClawdbotKit/Sources/ClawdbotKit/Connection/ConnectionState.swift, apps/ios/ClawdbotKit/Sources/ClawdbotKit/Connection/ConnectionManager.swift]
autonomous: true
---

<objective>
Implement connection state machine and automatic reconnection logic.

Purpose: Create a robust ConnectionManager that maintains WebSocket connection through network changes, with exponential backoff reconnection and proper state transitions.
Output: `ConnectionManager` actor with state machine, reconnection, and heartbeat capabilities.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-connection/02-01-PLAN.md

# WebSocket client from Plan 02-01:
@apps/ios/ClawdbotKit/Sources/ClawdbotKit/Connection/WebSocketClient.swift
@apps/ios/ClawdbotKit/Sources/ClawdbotKit/Connection/WebSocketMessage.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create connection state machine</name>
  <files>apps/ios/ClawdbotKit/Sources/ClawdbotKit/Connection/ConnectionState.swift</files>
  <action>
Create the state machine at `apps/ios/ClawdbotKit/Sources/ClawdbotKit/Connection/ConnectionState.swift`:

```swift
//
//  ConnectionState.swift
//  ClawdbotKit
//
//  Connection state machine for Clawdbot WebSocket connections.
//  Defines states, events, and valid transitions.
//

import Foundation

// MARK: - Connection State

/// Possible connection states
public enum ConnectionState: String, Sendable, Equatable {
    case disconnected
    case connecting
    case connected
    case reconnecting

    /// Human-readable description
    public var description: String {
        switch self {
        case .disconnected: return "Disconnected"
        case .connecting: return "Connecting..."
        case .connected: return "Connected"
        case .reconnecting: return "Reconnecting..."
        }
    }

    /// Whether messages can be sent in this state
    public var canSend: Bool {
        self == .connected
    }
}

// MARK: - Connection Events

/// Events that trigger state transitions
public enum ConnectionEvent: Sendable {
    case connect
    case connectionSucceeded
    case connectionFailed(Error)
    case disconnect
    case connectionLost(Error)
    case reconnectAttempt
    case reconnectSucceeded
    case reconnectFailed
    case maxRetriesReached
}

// MARK: - State Machine

/// State machine that validates transitions
public struct ConnectionStateMachine: Sendable {
    public private(set) var state: ConnectionState
    public private(set) var reconnectAttempts: Int = 0

    public let maxReconnectAttempts: Int

    public init(maxReconnectAttempts: Int = 5) {
        self.state = .disconnected
        self.maxReconnectAttempts = maxReconnectAttempts
    }

    /// Process an event and return the new state (or nil if invalid transition)
    @discardableResult
    public mutating func process(_ event: ConnectionEvent) -> ConnectionState? {
        switch (state, event) {
        // From disconnected
        case (.disconnected, .connect):
            state = .connecting
            reconnectAttempts = 0
            return state

        // From connecting
        case (.connecting, .connectionSucceeded):
            state = .connected
            reconnectAttempts = 0
            return state

        case (.connecting, .connectionFailed):
            state = .disconnected
            return state

        case (.connecting, .disconnect):
            state = .disconnected
            return state

        // From connected
        case (.connected, .disconnect):
            state = .disconnected
            return state

        case (.connected, .connectionLost):
            state = .reconnecting
            return state

        // From reconnecting
        case (.reconnecting, .reconnectAttempt):
            reconnectAttempts += 1
            return state  // Stay in reconnecting

        case (.reconnecting, .reconnectSucceeded):
            state = .connected
            reconnectAttempts = 0
            return state

        case (.reconnecting, .reconnectFailed):
            if reconnectAttempts >= maxReconnectAttempts {
                state = .disconnected
            }
            return state

        case (.reconnecting, .maxRetriesReached):
            state = .disconnected
            return state

        case (.reconnecting, .disconnect):
            state = .disconnected
            return state

        // Invalid transitions
        default:
            return nil
        }
    }
}

// MARK: - Reconnection Configuration

/// Configuration for reconnection behavior
public struct ReconnectionConfig: Sendable {
    /// Base delay between reconnection attempts (seconds)
    public let baseDelay: TimeInterval

    /// Maximum delay cap (seconds)
    public let maxDelay: TimeInterval

    /// Maximum number of reconnection attempts
    public let maxAttempts: Int

    /// Jitter factor (0-1) for randomizing delays
    public let jitterFactor: Double

    /// Heartbeat/ping interval (seconds)
    public let heartbeatInterval: TimeInterval

    /// Default configuration
    public static let `default` = ReconnectionConfig(
        baseDelay: 1.0,
        maxDelay: 30.0,
        maxAttempts: 5,
        jitterFactor: 0.2,
        heartbeatInterval: 30.0
    )

    /// Aggressive configuration for important connections
    public static let aggressive = ReconnectionConfig(
        baseDelay: 0.5,
        maxDelay: 10.0,
        maxAttempts: 10,
        jitterFactor: 0.1,
        heartbeatInterval: 15.0
    )

    public init(
        baseDelay: TimeInterval = 1.0,
        maxDelay: TimeInterval = 30.0,
        maxAttempts: Int = 5,
        jitterFactor: Double = 0.2,
        heartbeatInterval: TimeInterval = 30.0
    ) {
        self.baseDelay = baseDelay
        self.maxDelay = maxDelay
        self.maxAttempts = maxAttempts
        self.jitterFactor = min(max(jitterFactor, 0), 1)
        self.heartbeatInterval = heartbeatInterval
    }

    /// Calculate delay for attempt n using exponential backoff with jitter
    public func delay(forAttempt attempt: Int) -> TimeInterval {
        // Exponential backoff: base * 2^attempt
        let exponentialDelay = baseDelay * pow(2.0, Double(attempt))
        let cappedDelay = min(exponentialDelay, maxDelay)

        // Add jitter
        let jitterRange = cappedDelay * jitterFactor
        let jitter = Double.random(in: -jitterRange...jitterRange)

        return max(0, cappedDelay + jitter)
    }
}
```
  </action>
  <verify>cd apps/ios/ClawdbotKit && swift build</verify>
  <done>ConnectionState.swift compiles with state machine and reconnection config</done>
</task>

<task type="auto">
  <name>Task 2: Implement ConnectionManager actor</name>
  <files>apps/ios/ClawdbotKit/Sources/ClawdbotKit/Connection/ConnectionManager.swift</files>
  <action>
Create the ConnectionManager at `apps/ios/ClawdbotKit/Sources/ClawdbotKit/Connection/ConnectionManager.swift`:

```swift
//
//  ConnectionManager.swift
//  ClawdbotKit
//
//  Manages WebSocket connection lifecycle with automatic reconnection.
//  Wraps ClawdbotWebSocket with state machine, heartbeat, and retry logic.
//

import Foundation
import Combine

// MARK: - Delegate Protocol

/// Delegate for connection manager events
public protocol ConnectionManagerDelegate: AnyObject, Sendable {
    func connectionManager(_ manager: ConnectionManager, didChangeState state: ConnectionState)
    func connectionManager(_ manager: ConnectionManager, didReceiveMessage message: ClawdbotMessage)
    func connectionManager(_ manager: ConnectionManager, didEncounterError error: Error)
}

// MARK: - Connection Manager

/// Manages WebSocket connection with automatic reconnection
public actor ConnectionManager: ClawdbotWebSocketDelegate {

    // MARK: - Properties

    private let webSocket: ClawdbotWebSocket
    private var stateMachine: ConnectionStateMachine
    private let config: ReconnectionConfig

    private var serverURL: URL?
    private var heartbeatTask: Task<Void, Never>?
    private var reconnectTask: Task<Void, Never>?

    public weak var delegate: ConnectionManagerDelegate?

    /// Current connection state
    public var state: ConnectionState {
        stateMachine.state
    }

    /// Number of reconnection attempts
    public var reconnectAttempts: Int {
        stateMachine.reconnectAttempts
    }

    // MARK: - State Publisher (for SwiftUI)

    private let stateSubject = CurrentValueSubject<ConnectionState, Never>(.disconnected)

    /// Publisher for connection state changes
    public nonisolated var statePublisher: AnyPublisher<ConnectionState, Never> {
        stateSubject.eraseToAnyPublisher()
    }

    // MARK: - Initialization

    public init(config: ReconnectionConfig = .default) {
        self.webSocket = ClawdbotWebSocket()
        self.stateMachine = ConnectionStateMachine(maxReconnectAttempts: config.maxAttempts)
        self.config = config

        Task {
            await webSocket.delegate = self
        }
    }

    // MARK: - Connection Lifecycle

    /// Connect to the Clawdbot server
    public func connect(to url: URL) async {
        serverURL = url

        guard stateMachine.process(.connect) != nil else {
            return  // Invalid state transition
        }

        await notifyStateChange()

        do {
            try await webSocket.connect(to: url)
            stateMachine.process(.connectionSucceeded)
            await notifyStateChange()
            startHeartbeat()
        } catch {
            stateMachine.process(.connectionFailed(error))
            await notifyStateChange()
            delegate?.connectionManager(self, didEncounterError: error)
        }
    }

    /// Disconnect from the server
    public func disconnect() {
        stopHeartbeat()
        stopReconnect()

        stateMachine.process(.disconnect)
        webSocket.disconnect()
        serverURL = nil

        Task { await notifyStateChange() }
    }

    /// Send a message (only when connected)
    public func send(_ message: ClawdbotMessage) async throws {
        guard state.canSend else {
            throw ClawdbotWebSocketError.notConnected
        }
        try await webSocket.send(message)
    }

    /// Send text message (convenience)
    public func send(text: String) async throws {
        try await send(.text(text))
    }

    // MARK: - Heartbeat

    private func startHeartbeat() {
        stopHeartbeat()

        heartbeatTask = Task { [weak self] in
            while !Task.isCancelled {
                try? await Task.sleep(nanoseconds: UInt64(self?.config.heartbeatInterval ?? 30) * 1_000_000_000)

                guard !Task.isCancelled else { break }

                do {
                    try await self?.webSocket.ping()
                } catch {
                    // Ping failed, connection may be dead
                    // The receive loop will detect the disconnect
                }
            }
        }
    }

    private func stopHeartbeat() {
        heartbeatTask?.cancel()
        heartbeatTask = nil
    }

    // MARK: - Reconnection

    private func startReconnect() {
        guard let url = serverURL else { return }
        stopReconnect()

        reconnectTask = Task { [weak self] in
            guard let self = self else { return }

            while !Task.isCancelled {
                await self.stateMachine.process(.reconnectAttempt)
                let attempt = await self.stateMachine.reconnectAttempts

                // Check if max attempts reached
                if attempt > await self.config.maxAttempts {
                    await self.stateMachine.process(.maxRetriesReached)
                    await self.notifyStateChange()
                    return
                }

                // Calculate delay with exponential backoff
                let delay = await self.config.delay(forAttempt: attempt - 1)

                do {
                    try await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))

                    guard !Task.isCancelled else { return }

                    // Attempt reconnection
                    try await self.webSocket.connect(to: url)

                    // Success!
                    await self.stateMachine.process(.reconnectSucceeded)
                    await self.notifyStateChange()
                    await self.startHeartbeat()
                    return

                } catch {
                    await self.stateMachine.process(.reconnectFailed)
                    await self.delegate?.connectionManager(self, didEncounterError: error)
                }
            }
        }
    }

    private func stopReconnect() {
        reconnectTask?.cancel()
        reconnectTask = nil
    }

    // MARK: - State Notifications

    private func notifyStateChange() {
        let currentState = stateMachine.state
        stateSubject.send(currentState)
        delegate?.connectionManager(self, didChangeState: currentState)
    }

    // MARK: - WebSocket Delegate

    nonisolated public func webSocketDidConnect() {
        // Handled in connect() method
    }

    nonisolated public func webSocketDidDisconnect(error: Error?) {
        Task {
            if await self.state == .connected {
                // Unexpected disconnect - start reconnection
                await self.stateMachine.process(.connectionLost(error ?? ClawdbotWebSocketError.cancelled))
                await self.notifyStateChange()
                await self.stopHeartbeat()
                await self.startReconnect()
            }
        }
    }

    nonisolated public func webSocketDidReceiveMessage(_ message: ClawdbotMessage) {
        Task {
            await self.delegate?.connectionManager(self, didReceiveMessage: message)
        }
    }
}
```
  </action>
  <verify>cd apps/ios/ClawdbotKit && swift build</verify>
  <done>ConnectionManager.swift compiles with state machine, reconnection, and heartbeat</done>
</task>

<task type="auto">
  <name>Task 3: Add state machine unit tests</name>
  <files>apps/ios/ClawdbotKit/Tests/ClawdbotKitTests/ConnectionStateTests.swift</files>
  <action>
Create state machine tests at `apps/ios/ClawdbotKit/Tests/ClawdbotKitTests/ConnectionStateTests.swift`:

```swift
//
//  ConnectionStateTests.swift
//  ClawdbotKit
//
//  Tests for ConnectionStateMachine and ReconnectionConfig.
//

import XCTest
@testable import ClawdbotKit

final class ConnectionStateTests: XCTestCase {

    // MARK: - State Machine Tests

    func testInitialState() {
        let machine = ConnectionStateMachine()
        XCTAssertEqual(machine.state, .disconnected)
        XCTAssertEqual(machine.reconnectAttempts, 0)
    }

    func testConnectTransition() {
        var machine = ConnectionStateMachine()
        let newState = machine.process(.connect)

        XCTAssertEqual(newState, .connecting)
        XCTAssertEqual(machine.state, .connecting)
    }

    func testConnectionSucceeded() {
        var machine = ConnectionStateMachine()
        machine.process(.connect)
        let newState = machine.process(.connectionSucceeded)

        XCTAssertEqual(newState, .connected)
        XCTAssertEqual(machine.state, .connected)
    }

    func testConnectionFailed() {
        var machine = ConnectionStateMachine()
        machine.process(.connect)
        let error = ClawdbotWebSocketError.cancelled
        let newState = machine.process(.connectionFailed(error))

        XCTAssertEqual(newState, .disconnected)
        XCTAssertEqual(machine.state, .disconnected)
    }

    func testConnectionLostTriggersReconnect() {
        var machine = ConnectionStateMachine()
        machine.process(.connect)
        machine.process(.connectionSucceeded)

        let error = ClawdbotWebSocketError.cancelled
        let newState = machine.process(.connectionLost(error))

        XCTAssertEqual(newState, .reconnecting)
        XCTAssertEqual(machine.state, .reconnecting)
    }

    func testReconnectAttemptIncrementsCounter() {
        var machine = ConnectionStateMachine()
        machine.process(.connect)
        machine.process(.connectionSucceeded)
        machine.process(.connectionLost(ClawdbotWebSocketError.cancelled))

        XCTAssertEqual(machine.reconnectAttempts, 0)

        machine.process(.reconnectAttempt)
        XCTAssertEqual(machine.reconnectAttempts, 1)

        machine.process(.reconnectAttempt)
        XCTAssertEqual(machine.reconnectAttempts, 2)
    }

    func testReconnectSucceededResetsCounter() {
        var machine = ConnectionStateMachine()
        machine.process(.connect)
        machine.process(.connectionSucceeded)
        machine.process(.connectionLost(ClawdbotWebSocketError.cancelled))
        machine.process(.reconnectAttempt)
        machine.process(.reconnectAttempt)

        XCTAssertEqual(machine.reconnectAttempts, 2)

        machine.process(.reconnectSucceeded)
        XCTAssertEqual(machine.reconnectAttempts, 0)
        XCTAssertEqual(machine.state, .connected)
    }

    func testMaxRetriesReached() {
        var machine = ConnectionStateMachine(maxReconnectAttempts: 3)
        machine.process(.connect)
        machine.process(.connectionSucceeded)
        machine.process(.connectionLost(ClawdbotWebSocketError.cancelled))

        // Simulate 3 failed attempts
        for _ in 0..<3 {
            machine.process(.reconnectAttempt)
            machine.process(.reconnectFailed)
        }

        // Should be disconnected after max retries
        XCTAssertEqual(machine.state, .disconnected)
    }

    func testInvalidTransitionReturnsNil() {
        var machine = ConnectionStateMachine()
        // Can't go from disconnected to reconnecting directly
        let result = machine.process(.reconnectAttempt)
        XCTAssertNil(result)
    }

    func testCanSendOnlyWhenConnected() {
        XCTAssertFalse(ConnectionState.disconnected.canSend)
        XCTAssertFalse(ConnectionState.connecting.canSend)
        XCTAssertTrue(ConnectionState.connected.canSend)
        XCTAssertFalse(ConnectionState.reconnecting.canSend)
    }

    // MARK: - Reconnection Config Tests

    func testExponentialBackoff() {
        let config = ReconnectionConfig(baseDelay: 1.0, maxDelay: 30.0, jitterFactor: 0)

        // Without jitter, delays should be exactly: 1, 2, 4, 8, 16, 30 (capped)
        XCTAssertEqual(config.delay(forAttempt: 0), 1.0)
        XCTAssertEqual(config.delay(forAttempt: 1), 2.0)
        XCTAssertEqual(config.delay(forAttempt: 2), 4.0)
        XCTAssertEqual(config.delay(forAttempt: 3), 8.0)
        XCTAssertEqual(config.delay(forAttempt: 4), 16.0)
        XCTAssertEqual(config.delay(forAttempt: 5), 30.0)  // Capped
        XCTAssertEqual(config.delay(forAttempt: 10), 30.0) // Still capped
    }

    func testJitterAddsVariation() {
        let config = ReconnectionConfig(baseDelay: 10.0, maxDelay: 100.0, jitterFactor: 0.5)

        // With 50% jitter on a 10s base delay, result should be between 5 and 15
        for _ in 0..<10 {
            let delay = config.delay(forAttempt: 0)
            XCTAssertGreaterThanOrEqual(delay, 5.0)
            XCTAssertLessThanOrEqual(delay, 15.0)
        }
    }

    func testDefaultConfig() {
        let config = ReconnectionConfig.default

        XCTAssertEqual(config.baseDelay, 1.0)
        XCTAssertEqual(config.maxDelay, 30.0)
        XCTAssertEqual(config.maxAttempts, 5)
        XCTAssertEqual(config.heartbeatInterval, 30.0)
    }

    func testAggressiveConfig() {
        let config = ReconnectionConfig.aggressive

        XCTAssertEqual(config.baseDelay, 0.5)
        XCTAssertEqual(config.maxDelay, 10.0)
        XCTAssertEqual(config.maxAttempts, 10)
        XCTAssertEqual(config.heartbeatInterval, 15.0)
    }
}
```
  </action>
  <verify>cd apps/ios/ClawdbotKit && swift test</verify>
  <done>State machine and reconnection config tests pass</done>
</task>

<task type="checkpoint:commit">
  <files>apps/ios/ClawdbotKit/Sources/ClawdbotKit/Connection/</files>
  <message>feat(02-02): implement connection state machine and reconnection logic</message>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] ConnectionState.swift exists with state machine
- [ ] ConnectionManager.swift exists with reconnection logic
- [ ] ClawdbotKit compiles (`swift build`)
- [ ] State machine tests pass (`swift test`)
- [ ] Changes committed
</verification>

<success_criteria>
- State machine with valid transitions
- Exponential backoff with jitter
- Configurable reconnection parameters
- Heartbeat/ping for connection health
- Combine publisher for SwiftUI binding
- Comprehensive unit tests
</success_criteria>

<output>
After completion, create `.planning/phases/02-connection/02-02-SUMMARY.md`
</output>
