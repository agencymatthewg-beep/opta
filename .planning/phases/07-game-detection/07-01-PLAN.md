---
phase: 07-game-detection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [mcp-server/src/opta_mcp/games.py, mcp-server/src/opta_mcp/server.py, src-tauri/src/games.rs, src-tauri/src/lib.rs, src/types/games.ts]
autonomous: true
---

<objective>
Implement game detection across major launchers (Steam, Epic, GOG, EA, Ubisoft).

Purpose: Automatically find installed games to enable per-game optimization profiles.
Output: Python game detector, Rust commands, TypeScript types for detected games.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create game detection module</name>
  <files>mcp-server/src/opta_mcp/games.py</files>
  <action>
Create `games.py` module with launcher detection:

1. Define `LAUNCHERS` configuration:
   ```python
   import os
   import json
   import platform
   from pathlib import Path
   from typing import List, Dict, Optional

   LAUNCHERS = {
       "steam": {
           "name": "Steam",
           "paths": {
               "darwin": ["~/Library/Application Support/Steam"],
               "win32": ["C:/Program Files (x86)/Steam", "C:/Program Files/Steam"],
               "linux": ["~/.steam/steam", "~/.local/share/Steam"]
           },
           "library_file": "steamapps/libraryfolders.vdf"
       },
       "epic": {
           "name": "Epic Games",
           "paths": {
               "darwin": ["~/Library/Application Support/Epic"],
               "win32": ["C:/Program Files/Epic Games", "C:/ProgramData/Epic/EpicGamesLauncher"],
               "linux": []
           },
           "manifest_dir": "Manifests"
       },
       "gog": {
           "name": "GOG Galaxy",
           "paths": {
               "darwin": ["~/Library/Application Support/GOG.com"],
               "win32": ["C:/ProgramData/GOG.com/Galaxy"],
               "linux": []
           }
       }
   }
   ```

2. `detect_launcher(launcher_id: str) -> dict`:
   - Check if launcher is installed
   - Return path and status

3. `get_steam_games() -> List[dict]`:
   - Parse libraryfolders.vdf for library paths
   - Scan each library for appmanifest_*.acf files
   - Extract: appid, name, install directory, size
   - Return list of detected games

4. `get_epic_games() -> List[dict]`:
   - Scan manifest directory for .item files
   - Parse JSON manifests
   - Extract: app name, install location, version

5. `detect_all_games() -> dict`:
   - Call all launcher detectors
   - Aggregate results by launcher
   - Return total count and games list

Cross-platform paths are critical - test on macOS first.
  </action>
  <verify>
cd mcp-server && uv run python -c "from opta_mcp.games import detect_all_games; import json; result = detect_all_games(); print(f'Found {result[\"total_games\"]} games')"
  </verify>
  <done>Game detection module finds games across launchers</done>
</task>

<task type="auto">
  <name>Task 2: Register MCP tools and create Rust commands</name>
  <files>mcp-server/src/opta_mcp/server.py, src-tauri/src/games.rs, src-tauri/src/lib.rs</files>
  <action>
1. Register MCP tools in server.py:
   - `detect_games` - scan for all installed games
   - `get_game_info` - get details for specific game

2. Create `games.rs` module:
   ```rust
   use serde::{Deserialize, Serialize};
   use crate::mcp::call_mcp_tool;

   #[derive(Debug, Serialize, Deserialize)]
   pub struct DetectedGame {
       pub id: String,
       pub name: String,
       pub launcher: String,
       pub install_path: String,
       pub size_bytes: Option<u64>,
   }

   #[derive(Debug, Serialize, Deserialize)]
   pub struct GameDetectionResult {
       pub total_games: u32,
       pub launchers: Vec<LauncherInfo>,
       pub games: Vec<DetectedGame>,
   }

   #[derive(Debug, Serialize, Deserialize)]
   pub struct LauncherInfo {
       pub id: String,
       pub name: String,
       pub installed: bool,
       pub game_count: u32,
   }

   #[tauri::command]
   pub async fn detect_games() -> Result<GameDetectionResult, String> {
       call_mcp_tool("detect_games", serde_json::json!({})).await
   }
   ```

3. Register in lib.rs:
   - Add `mod games;`
   - Add `detect_games` to invoke_handler

Keep it simple - detection only, no modification.
  </action>
  <verify>
cd src-tauri && cargo check
  </verify>
  <done>Rust commands compile for game detection</done>
</task>

<task type="auto">
  <name>Task 3: Create TypeScript types and hook</name>
  <files>src/types/games.ts, src/hooks/useGames.ts</files>
  <action>
1. Create `src/types/games.ts`:
   ```typescript
   export interface DetectedGame {
     id: string;
     name: string;
     launcher: string;
     installPath: string;
     sizeBytes?: number;
   }

   export interface LauncherInfo {
     id: string;
     name: string;
     installed: boolean;
     gameCount: number;
   }

   export interface GameDetectionResult {
     totalGames: number;
     launchers: LauncherInfo[];
     games: DetectedGame[];
   }
   ```

2. Create `src/hooks/useGames.ts`:
   ```typescript
   import { useState, useEffect } from "react";
   import { invoke } from "@tauri-apps/api/core";
   import { GameDetectionResult } from "@/types/games";

   export function useGames() {
     const [result, setResult] = useState<GameDetectionResult | null>(null);
     const [loading, setLoading] = useState(false);
     const [error, setError] = useState<string | null>(null);

     const detectGames = async () => {
       setLoading(true);
       setError(null);
       try {
         const data = await invoke<GameDetectionResult>("detect_games");
         setResult(data);
       } catch (err) {
         setError(String(err));
       } finally {
         setLoading(false);
       }
     };

     useEffect(() => {
       detectGames();
     }, []);

     return { result, loading, error, refresh: detectGames };
   }
   ```

Hook provides easy access to detected games for UI components.
  </action>
  <verify>npm run build</verify>
  <done>TypeScript types and hook ready for game UI</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Game detection finds Steam games (if installed)
- [ ] Rust commands compile
- [ ] `npm run build` succeeds
- [ ] TypeScript types match Rust structs
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Game detection works on macOS (primary dev platform)
</success_criteria>

<output>
After completion, create `.planning/phases/07-game-detection/07-01-SUMMARY.md`
</output>
