# Plan 20-03: Trackpad Gestures

**Phase:** 20 - Rich Interactions
**Feature:** Trackpad Gestures with @use-gesture
**Scope:** Small-Medium (1-2 days)
**Dependencies:** None

---

## Summary

Add trackpad gesture support using @use-gesture for pinch-to-zoom on telemetry charts and swipe navigation between pages. Provides natural MacBook trackpad interactions that desktop users expect.

---

## Why This Matters

- **Native feel** - MacBook users expect pinch-to-zoom on content
- **Power users** - Faster navigation via trackpad gestures
- **Data exploration** - Zooming into telemetry charts for detail
- **Differentiation** - Most Electron/Tauri apps lack gesture support

---

## Implementation Tasks

### Task 1: Install @use-gesture
**File:** `package.json`

**Actions:**
1. Install @use-gesture: `npm install @use-gesture/react`
2. Verify installation succeeds

**Verification:** Package appears in package.json, no install errors

---

### Task 2: Create usePinchZoom hook
**File:** `src/hooks/usePinchZoom.ts`

**Actions:**
1. Create hook that wraps @use-gesture's usePinch
2. Return scale, position, and gesture handlers
3. Add bounds (min 0.5, max 3.0 scale)
4. Support scroll-wheel zoom as fallback

**Code pattern:**
```typescript
// src/hooks/usePinchZoom.ts
import { useGesture } from '@use-gesture/react';
import { useState, useCallback } from 'react';
import { useReducedMotion } from './useReducedMotion';

interface PinchZoomState {
  scale: number;
  x: number;
  y: number;
}

interface UsePinchZoomOptions {
  minScale?: number;
  maxScale?: number;
  initialScale?: number;
}

export function usePinchZoom(options: UsePinchZoomOptions = {}) {
  const { minScale = 0.5, maxScale = 3, initialScale = 1 } = options;
  const prefersReducedMotion = useReducedMotion();

  const [state, setState] = useState<PinchZoomState>({
    scale: initialScale,
    x: 0,
    y: 0,
  });

  const clamp = (value: number, min: number, max: number) =>
    Math.min(Math.max(value, min), max);

  const bind = useGesture({
    onPinch: ({ offset: [scale], memo }) => {
      if (prefersReducedMotion) return memo;
      setState(prev => ({
        ...prev,
        scale: clamp(scale, minScale, maxScale),
      }));
      return memo;
    },
    onDrag: ({ offset: [x, y], memo }) => {
      if (state.scale === 1) return memo; // Only drag when zoomed
      setState(prev => ({ ...prev, x, y }));
      return memo;
    },
    onWheel: ({ delta: [, dy], event }) => {
      // Ctrl+scroll for zoom (mouse fallback)
      if (event.ctrlKey) {
        event.preventDefault();
        const newScale = clamp(state.scale - dy * 0.01, minScale, maxScale);
        setState(prev => ({ ...prev, scale: newScale }));
      }
    },
  }, {
    pinch: { scaleBounds: { min: minScale, max: maxScale } },
    drag: { enabled: state.scale > 1 },
  });

  const reset = useCallback(() => {
    setState({ scale: initialScale, x: 0, y: 0 });
  }, [initialScale]);

  return {
    scale: state.scale,
    x: state.x,
    y: state.y,
    bind,
    reset,
    isZoomed: state.scale !== 1,
  };
}
```

**Verification:** Hook compiles, returns expected shape

---

### Task 3: Create PinchZoomContainer component
**File:** `src/components/Gestures/PinchZoomContainer.tsx`

**Actions:**
1. Create wrapper component using usePinchZoom
2. Apply transform styles with Framer Motion
3. Add reset button when zoomed
4. Show zoom percentage indicator

**Code pattern:**
```tsx
// src/components/Gestures/PinchZoomContainer.tsx
import { motion } from 'framer-motion';
import { usePinchZoom } from '@/hooks/usePinchZoom';
import { RotateCcw } from 'lucide-react';
import { cn } from '@/lib/utils';

interface PinchZoomContainerProps {
  children: React.ReactNode;
  className?: string;
  showIndicator?: boolean;
}

export function PinchZoomContainer({
  children,
  className,
  showIndicator = true,
}: PinchZoomContainerProps) {
  const { scale, x, y, bind, reset, isZoomed } = usePinchZoom();

  return (
    <div className={cn('relative overflow-hidden', className)}>
      <motion.div
        {...bind()}
        style={{
          touchAction: 'none', // Prevent browser handling
        }}
        animate={{
          scale,
          x,
          y,
        }}
        transition={{ type: 'spring', stiffness: 300, damping: 30 }}
        className="origin-center cursor-grab active:cursor-grabbing"
      >
        {children}
      </motion.div>

      {/* Zoom indicator */}
      {showIndicator && isZoomed && (
        <motion.div
          initial={{ opacity: 0, y: 10 }}
          animate={{ opacity: 1, y: 0 }}
          className="absolute bottom-3 right-3 flex items-center gap-2 glass-subtle px-2 py-1 rounded-md"
        >
          <span className="text-xs text-muted-foreground">
            {Math.round(scale * 100)}%
          </span>
          <button
            onClick={reset}
            className="p-1 hover:bg-white/10 rounded transition-colors"
            aria-label="Reset zoom"
          >
            <RotateCcw className="w-3 h-3 text-muted-foreground" />
          </button>
        </motion.div>
      )}
    </div>
  );
}
```

**Verification:** Component renders, pinch gestures work on trackpad

---

### Task 4: Integrate with TelemetryCard
**File:** `src/components/TelemetryCard.tsx`

**Actions:**
1. Wrap chart content with PinchZoomContainer
2. Ensure charts render correctly at different scales
3. Add keyboard zoom controls (+ and - keys when focused)

**Verification:** Pinch-to-zoom works on telemetry charts, scroll-wheel fallback works

---

### Task 5: Create useSwipeNavigation hook
**File:** `src/hooks/useSwipeNavigation.ts`

**Actions:**
1. Create hook that detects horizontal swipes
2. Integrate with app navigation (swipe left = forward, right = back)
3. Add velocity threshold to prevent accidental triggers
4. Respect reduced motion preference

**Code pattern:**
```typescript
// src/hooks/useSwipeNavigation.ts
import { useGesture } from '@use-gesture/react';
import { useCallback } from 'react';
import { useReducedMotion } from './useReducedMotion';

interface UseSwipeNavigationOptions {
  onSwipeLeft?: () => void;  // Navigate forward
  onSwipeRight?: () => void; // Navigate back
  threshold?: number;        // Minimum swipe distance
  velocityThreshold?: number;
}

export function useSwipeNavigation(options: UseSwipeNavigationOptions = {}) {
  const {
    onSwipeLeft,
    onSwipeRight,
    threshold = 100,
    velocityThreshold = 0.5,
  } = options;
  const prefersReducedMotion = useReducedMotion();

  const bind = useGesture({
    onDrag: ({ movement: [mx], velocity: [vx], direction: [dx], last }) => {
      if (prefersReducedMotion) return;
      if (!last) return;

      const isValidSwipe = Math.abs(mx) > threshold && Math.abs(vx) > velocityThreshold;

      if (isValidSwipe) {
        if (dx < 0 && onSwipeLeft) {
          onSwipeLeft();
        } else if (dx > 0 && onSwipeRight) {
          onSwipeRight();
        }
      }
    },
  }, {
    drag: {
      axis: 'x',
      filterTaps: true,
    },
  });

  return { bind };
}
```

**Verification:** Hook compiles, swipe detection works

---

### Task 6: Integrate swipe navigation with Layout
**File:** `src/components/Layout.tsx`

**Actions:**
1. Add swipe handlers to main content area
2. Connect to router navigation (back/forward)
3. Add subtle edge indicator when swipe in progress
4. Ensure doesn't conflict with horizontal scrolling

**Code pattern:**
```tsx
// In Layout.tsx
import { useSwipeNavigation } from '@/hooks/useSwipeNavigation';
import { useNavigate } from 'react-router-dom'; // or your router

function Layout({ children }) {
  const navigate = useNavigate();

  const { bind } = useSwipeNavigation({
    onSwipeRight: () => navigate(-1), // Back
    onSwipeLeft: () => navigate(1),   // Forward (if available)
  });

  return (
    <div {...bind()} className="min-h-screen">
      {children}
    </div>
  );
}
```

**Verification:** Swiping navigates between pages, doesn't interfere with scrolling

---

### Task 7: Add gesture instructions tooltip
**File:** `src/components/Gestures/GestureHints.tsx`

**Actions:**
1. Create subtle tooltip showing available gestures
2. Show on first use or in settings
3. Include hints for: pinch-to-zoom, swipe navigation
4. Dismiss permanently option

**Verification:** Hints appear, can be dismissed

---

### Task 8: Create barrel exports
**File:** `src/components/Gestures/index.ts`

**Actions:**
1. Export PinchZoomContainer
2. Export GestureHints
3. Document gesture support in JSDoc

**Verification:** Clean imports work

---

## Verification Checklist

- [ ] @use-gesture installs successfully
- [ ] Pinch gesture zooms telemetry charts (MacBook trackpad)
- [ ] Ctrl+scroll zooms charts (mouse fallback)
- [ ] Reset button returns to 100% scale
- [ ] Zoom indicator shows current percentage
- [ ] Swipe right navigates back
- [ ] Swipe left navigates forward
- [ ] Swipes don't trigger during horizontal scroll
- [ ] Reduced motion preference disables gestures
- [ ] Gesture animations use Framer Motion
- [ ] `npm run build` passes with no errors

---

## Files Created/Modified

| File | Action |
|------|--------|
| `package.json` | Add @use-gesture/react |
| `src/hooks/usePinchZoom.ts` | Create |
| `src/hooks/useSwipeNavigation.ts` | Create |
| `src/components/Gestures/PinchZoomContainer.tsx` | Create |
| `src/components/Gestures/GestureHints.tsx` | Create |
| `src/components/Gestures/index.ts` | Create |
| `src/components/TelemetryCard.tsx` | Modify - add zoom |
| `src/components/Layout.tsx` | Modify - add swipe nav |

---

## Research Reference

From 20-RESEARCH.md:
- Use @use-gesture (not manual touch events) - handles edge cases
- Always provide scroll-wheel fallback for non-trackpad users
- Add + and - keyboard controls for accessibility
- Respect prefers-reduced-motion

---

## Platform Notes

- **macOS:** Full trackpad gesture support
- **Windows:** Limited trackpad support, rely on scroll-wheel fallback
- **Linux:** Varies by desktop environment, scroll-wheel most reliable

---

*Plan created: 2026-01-17*
*Ready for execution: yes*
