# Plan 20-08: Menu Bar Extra - Swift Plugin

**Phase:** 20 - Rich Interactions
**Feature:** Tauri Swift Plugin for macOS Menu Bar
**Scope:** Large (3-4 days)
**Dependencies:** 20-00 (WebGL Foundation for Rive), Rust backend

---

## Summary

Create a native Swift plugin for Tauri that implements macOS MenuBarExtra API. The plugin provides a premium native menu bar experience with animated Rive logo, FlatBuffers binary IPC for 25Hz+ data streaming, and deep integration with the existing Rust backend.

---

## Why This Matters

- **"Easy Access" paradigm** - Users can monitor system state without opening main window
- **Native performance** - Swift/Metal avoids webview overhead in system UI
- **Binary IPC** - FlatBuffers enables 25Hz data without CPU spike
- **Brand presence** - Animated logo in menu bar = constant visibility
- **Apple Silicon optimization** - Direct Metal access for rendering

---

## Gemini Research Context

From Native Capability Across Platforms:
- "MenuBarExtra API (macOS 13+) - SwiftUI declarative UI"
- "Dynamic icon showing live status (not static logo)"
- "Floating popover for deeper engagement"
- "Transient behavior with 'pin' option"

From Gemini Improvements:
- "FlatBuffers for IPC - Zero-Copy access, only way to achieve 16ms Rule"
- "Binary serialization prevents device heating at 25Hz"

---

## Implementation Tasks

### Task 1: Create Swift plugin directory structure
**Directory:** `src-tauri/swift-plugin/`

**Actions:**
1. Create Swift package structure
2. Configure Package.swift with dependencies
3. Setup Xcode project for development
4. Configure build integration with Cargo

**Directory structure:**
```
src-tauri/swift-plugin/
├── Package.swift
├── Sources/
│   └── OptaMenuBar/
│       ├── MenuBarExtra.swift
│       ├── PopoverView.swift
│       ├── SystemOrbitalView.swift
│       ├── FlatBuffersBridge.swift
│       ├── RiveLogoView.swift
│       └── IPCHandler.swift
├── Resources/
│   └── opta-logo.riv
└── Tests/
    └── OptaMenuBarTests/
```

**Package.swift:**
```swift
// swift-tools-version: 5.9
import PackageDescription

let package = Package(
    name: "OptaMenuBar",
    platforms: [.macOS(.v13)],
    products: [
        .library(name: "OptaMenuBar", type: .dynamic, targets: ["OptaMenuBar"])
    ],
    dependencies: [
        .package(url: "https://github.com/rive-app/rive-ios", from: "6.0.0"),
        .package(url: "https://github.com/nicklockwood/FlatBuffersSwift", from: "1.5.0"),
    ],
    targets: [
        .target(
            name: "OptaMenuBar",
            dependencies: [
                .product(name: "RiveRuntime", package: "rive-ios"),
                .product(name: "FlatBuffers", package: "FlatBuffersSwift"),
            ],
            resources: [.process("Resources")]
        ),
    ]
)
```

**Verification:** Swift package builds successfully

---

### Task 2: Create FlatBuffers schema and generate code
**File:** `schemas/system_metrics.fbs`

**Actions:**
1. Define FlatBuffers schema for system metrics
2. Generate Rust code with `flatc`
3. Generate Swift code with `flatc`
4. Integrate generated code into both projects

**Schema:**
```flatbuffers
// schemas/system_metrics.fbs
namespace Opta.Metrics;

table SystemMetrics {
  cpu_usage: float;
  memory_usage: float;
  memory_total: ulong;
  disk_usage: float;
  temperature: float;
  timestamp: ulong;
  top_processes: [ProcessInfo];
}

table ProcessInfo {
  pid: uint;
  name: string;
  cpu_percent: float;
  memory_mb: float;
}

table MomentumState {
  intensity: float;      // 0-1
  color: MomentumColor;
  rotation_speed: float;
}

enum MomentumColor : byte { Idle = 0, Active = 1, Critical = 2 }

root_type SystemMetrics;
```

**Generation commands:**
```bash
# Generate Rust
flatc --rust -o src-tauri/src/generated/ schemas/system_metrics.fbs

# Generate Swift
flatc --swift -o src-tauri/swift-plugin/Sources/Generated/ schemas/system_metrics.fbs
```

**Verification:** Generated code compiles in both Rust and Swift

---

### Task 3: Create FlatBuffers bridge for IPC
**File:** `src-tauri/swift-plugin/Sources/OptaMenuBar/FlatBuffersBridge.swift`

**Actions:**
1. Create Swift wrapper for FlatBuffers deserialization
2. Implement zero-copy data access
3. Add metrics parsing functions
4. Handle IPC communication with Rust

**Code:**
```swift
// FlatBuffersBridge.swift
import Foundation
import FlatBuffers

final class FlatBuffersBridge {
    private var buffer: ByteBuffer?

    /// Parse binary metrics data from Rust backend
    func parseMetrics(data: Data) -> SystemMetrics? {
        var byteBuffer = ByteBuffer(data: data)
        return getRoot(byteBuffer: &byteBuffer)
    }

    /// Zero-copy access to CPU usage
    func getCPUUsage(from metrics: SystemMetrics) -> Float {
        return metrics.cpuUsage
    }

    /// Calculate momentum state from metrics
    func getMomentumState(from metrics: SystemMetrics) -> MomentumState {
        let cpu = metrics.cpuUsage
        let memory = metrics.memoryUsage

        if cpu > 90 || memory > 85 {
            return MomentumState(intensity: 1.0, color: .critical, rotationSpeed: 3.0)
        } else if cpu > 60 || memory > 60 {
            return MomentumState(intensity: 0.7, color: .active, rotationSpeed: 1.5)
        } else {
            return MomentumState(intensity: 0.3, color: .idle, rotationSpeed: 0.5)
        }
    }
}

struct MomentumState {
    let intensity: Float
    let color: MomentumColor
    let rotationSpeed: Float
}

enum MomentumColor {
    case idle, active, critical

    var swiftUIColor: Color {
        switch self {
        case .idle: return .purple.opacity(0.5)
        case .active: return .cyan
        case .critical: return .red
        }
    }
}
```

**Verification:** Bridge parses FlatBuffers data without JSON overhead

---

### Task 4: Create Rive logo animation view
**File:** `src-tauri/swift-plugin/Sources/OptaMenuBar/RiveLogoView.swift`

**Actions:**
1. Load Rive animation file
2. Create SwiftUI view wrapper
3. Implement state-based animation control
4. Support momentum-driven animation speed

**Code:**
```swift
// RiveLogoView.swift
import SwiftUI
import RiveRuntime

struct RiveLogoView: View {
    let momentum: MomentumState
    @State private var riveViewModel: RiveViewModel?

    var body: some View {
        RiveViewRepresentable(viewModel: riveViewModel)
            .frame(width: 22, height: 22)
            .onChange(of: momentum.rotationSpeed) { newSpeed in
                updateAnimationSpeed(newSpeed)
            }
            .onChange(of: momentum.color) { newColor in
                updateGlowColor(newColor)
            }
            .onAppear {
                loadAnimation()
            }
    }

    private func loadAnimation() {
        guard let url = Bundle.module.url(forResource: "opta-logo", withExtension: "riv") else {
            return
        }
        riveViewModel = RiveViewModel(fileName: "opta-logo", stateMachineName: "State Machine 1")
    }

    private func updateAnimationSpeed(_ speed: Float) {
        // Rive state machine input for rotation speed
        riveViewModel?.setInput("speed", value: Double(speed))
    }

    private func updateGlowColor(_ color: MomentumColor) {
        // Rive state machine input for glow state
        let stateIndex: Double = switch color {
        case .idle: 0
        case .active: 1
        case .critical: 2
        }
        riveViewModel?.setInput("glowState", value: stateIndex)
    }
}

struct RiveViewRepresentable: NSViewRepresentable {
    let viewModel: RiveViewModel?

    func makeNSView(context: Context) -> RiveView {
        let view = RiveView()
        if let vm = viewModel {
            view.fit = .contain
            // Configure view with viewModel
        }
        return view
    }

    func updateNSView(_ nsView: RiveView, context: Context) {
        // Update as needed
    }
}
```

**Verification:** Rive logo animates, speed changes with momentum state

---

### Task 5: Create MenuBarExtra implementation
**File:** `src-tauri/swift-plugin/Sources/OptaMenuBar/MenuBarExtra.swift`

**Actions:**
1. Implement MenuBarExtra with SwiftUI
2. Configure icon with Rive animation
3. Setup popover attachment
4. Handle transient/pin behavior

**Code:**
```swift
// MenuBarExtra.swift
import SwiftUI
import AppKit

@main
struct OptaMenuBarApp: App {
    @StateObject private var metricsStore = MetricsStore()

    var body: some Scene {
        MenuBarExtra {
            PopoverView(metrics: metricsStore.currentMetrics)
                .frame(width: 300, height: 400)
        } label: {
            RiveLogoView(momentum: metricsStore.momentum)
        }
        .menuBarExtraStyle(.window) // Allows larger popover
    }
}

@MainActor
final class MetricsStore: ObservableObject {
    @Published var currentMetrics: SystemMetrics?
    @Published var momentum: MomentumState = MomentumState(intensity: 0.3, color: .idle, rotationSpeed: 0.5)

    private let bridge = FlatBuffersBridge()
    private var ipcHandler: IPCHandler?

    init() {
        setupIPC()
    }

    private func setupIPC() {
        ipcHandler = IPCHandler { [weak self] data in
            guard let self = self else { return }

            if let metrics = self.bridge.parseMetrics(data: data) {
                Task { @MainActor in
                    self.currentMetrics = metrics
                    self.momentum = self.bridge.getMomentumState(from: metrics)
                }
            }
        }
    }
}
```

**Verification:** Menu bar icon appears, popover opens on click

---

### Task 6: Create IPC handler for Rust communication
**File:** `src-tauri/swift-plugin/Sources/OptaMenuBar/IPCHandler.swift`

**Actions:**
1. Setup Unix socket or XPC for IPC
2. Handle incoming binary data stream
3. Implement connection lifecycle
4. Add error recovery

**Code:**
```swift
// IPCHandler.swift
import Foundation

final class IPCHandler {
    private let onData: (Data) -> Void
    private var socket: FileHandle?
    private let socketPath = "/tmp/opta-metrics.sock"

    init(onData: @escaping (Data) -> Void) {
        self.onData = onData
        connect()
    }

    private func connect() {
        // Connect to Unix socket created by Rust backend
        let socketFD = socket(AF_UNIX, SOCK_STREAM, 0)
        guard socketFD >= 0 else {
            print("Failed to create socket")
            scheduleReconnect()
            return
        }

        var addr = sockaddr_un()
        addr.sun_family = sa_family_t(AF_UNIX)
        socketPath.withCString { ptr in
            withUnsafeMutablePointer(to: &addr.sun_path.0) { dest in
                strcpy(dest, ptr)
            }
        }

        let result = withUnsafePointer(to: &addr) { ptr in
            ptr.withMemoryRebound(to: sockaddr.self, capacity: 1) { sockPtr in
                Darwin.connect(socketFD, sockPtr, socklen_t(MemoryLayout<sockaddr_un>.size))
            }
        }

        if result == 0 {
            socket = FileHandle(fileDescriptor: socketFD, closeOnDealloc: true)
            startReading()
        } else {
            scheduleReconnect()
        }
    }

    private func startReading() {
        socket?.readabilityHandler = { [weak self] handle in
            let data = handle.availableData
            if data.isEmpty {
                self?.scheduleReconnect()
            } else {
                self?.onData(data)
            }
        }
    }

    private func scheduleReconnect() {
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) { [weak self] in
            self?.connect()
        }
    }
}
```

**Verification:** IPC connects to Rust backend, receives binary data

---

### Task 7: Integrate Swift plugin with Tauri
**Files:** `src-tauri/Cargo.toml`, `src-tauri/src/lib.rs`, `src-tauri/build.rs`

**Actions:**
1. Add Swift plugin to Tauri build process
2. Create Rust FFI bindings
3. Setup Unix socket server for IPC
4. Add FlatBuffers serialization in Rust

**Cargo.toml additions:**
```toml
[dependencies]
flatbuffers = "24.3"

[build-dependencies]
swift-bridge-build = "0.1"
```

**Rust IPC server:**
```rust
// src-tauri/src/ipc_server.rs
use std::os::unix::net::UnixListener;
use std::io::Write;
use flatbuffers::FlatBufferBuilder;

pub fn start_metrics_server(metrics_rx: Receiver<SystemMetrics>) {
    std::thread::spawn(move || {
        let _ = std::fs::remove_file("/tmp/opta-metrics.sock");
        let listener = UnixListener::bind("/tmp/opta-metrics.sock").unwrap();

        for stream in listener.incoming() {
            if let Ok(mut stream) = stream {
                let metrics_rx = metrics_rx.clone();
                std::thread::spawn(move || {
                    loop {
                        if let Ok(metrics) = metrics_rx.recv() {
                            let data = serialize_metrics(&metrics);
                            if stream.write_all(&data).is_err() {
                                break;
                            }
                        }
                    }
                });
            }
        }
    });
}

fn serialize_metrics(metrics: &SystemMetrics) -> Vec<u8> {
    let mut builder = FlatBufferBuilder::new();
    // Serialize using generated FlatBuffers code
    // ...
    builder.finished_data().to_vec()
}
```

**Verification:** Tauri builds with Swift plugin, IPC working

---

### Task 8: Create build scripts and documentation
**Files:** `src-tauri/swift-plugin/build.sh`, `docs/menu-bar-plugin.md`

**Actions:**
1. Create build script for Swift package
2. Add to Tauri build pipeline
3. Document setup requirements
4. Add troubleshooting guide

**Build script:**
```bash
#!/bin/bash
# src-tauri/swift-plugin/build.sh

set -e

cd "$(dirname "$0")"

# Build Swift package
swift build -c release

# Copy dylib to Tauri output
cp .build/release/libOptaMenuBar.dylib ../target/release/
```

**Verification:** Build script completes, plugin loads correctly

---

## Verification Checklist

- [ ] Swift package structure created correctly
- [ ] Package.swift compiles with all dependencies
- [ ] FlatBuffers schema generates Rust and Swift code
- [ ] FlatBuffersBridge parses binary data without JSON
- [ ] Rive logo loads and animates
- [ ] Animation speed changes with momentum state
- [ ] MenuBarExtra appears in system menu bar
- [ ] Popover opens on click
- [ ] IPC connects to Rust backend
- [ ] Binary data streams at 25Hz without CPU spike
- [ ] Momentum state updates border color
- [ ] Tauri builds with Swift plugin integrated
- [ ] `cargo build` passes
- [ ] `swift build` passes

---

## Files Created/Modified

| File | Action |
|------|--------|
| `src-tauri/swift-plugin/Package.swift` | Create |
| `src-tauri/swift-plugin/Sources/OptaMenuBar/MenuBarExtra.swift` | Create |
| `src-tauri/swift-plugin/Sources/OptaMenuBar/FlatBuffersBridge.swift` | Create |
| `src-tauri/swift-plugin/Sources/OptaMenuBar/RiveLogoView.swift` | Create |
| `src-tauri/swift-plugin/Sources/OptaMenuBar/IPCHandler.swift` | Create |
| `schemas/system_metrics.fbs` | Create |
| `src-tauri/Cargo.toml` | Add FlatBuffers |
| `src-tauri/src/ipc_server.rs` | Create |
| `src-tauri/build.rs` | Add Swift build |

---

## Research Reference

From Gemini:
- "FlatBuffers for IPC - Zero-Copy access"
- "MenuBarExtra API (macOS 13+) - SwiftUI declarative UI"
- "Dynamic icon showing live status"
- "Rive runtime for Swift"

---

## Platform Notes

- **Requires macOS 13+** for MenuBarExtra API
- **Apple Silicon optimized** - Native Swift/Metal
- **Code signing required** for distribution

---

*Plan created: 2026-01-17*
*Ready for execution: yes*
*Execute after: 20-00 (for Rive assets)*
