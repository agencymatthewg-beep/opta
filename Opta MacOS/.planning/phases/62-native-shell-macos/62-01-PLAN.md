# Plan 62-01: SwiftUI Shell Foundation

## Wave: 1 (Independent)

## Objective

Create SwiftUI application shell that hosts wgpu render surface with CADisplayLink synchronization for 120Hz ProMotion displays.

## Execution Context

**Reference Documents:**
- `Gemini Deep Research/Hardware & Platform Knowledge/wgpu-SwiftUI-iOS-macOS-Integration.md`
- opta-render FFI exports from Phase 60

**Key Insights:**
- Inverted Control Loop: Swift drives timing, Rust responds
- CAMetalLayer required for wgpu surface
- CVDisplayLink executes on background thread (macOS)
- Autorelease pools critical for memory management
- TBDR optimization: LoadOp::Clear, StoreOp::Discard

## Context

**Depends on:**
- Phase 60 (opta-render with FFI exports)
- Phase 61 (Shader system)

**Builds foundation for:**
- Plan 62-02 (CoreHaptics integration)
- Plan 62-03 (Menu bar integration)
- Phase 63 (Component migration)

## Tasks

### Task 1: Create Xcode project structure

**Location:** `opta-native/OptaApp/`

Create Xcode project with:
- SwiftUI App lifecycle
- macOS deployment target 13.0+
- Rust static library integration

```
OptaApp/
├── OptaApp.xcodeproj/
├── OptaApp/
│   ├── OptaAppApp.swift
│   ├── ContentView.swift
│   ├── Views/
│   │   ├── MetalRenderView.swift
│   │   └── OptaRingView.swift
│   ├── Rendering/
│   │   ├── RenderCoordinator.swift
│   │   └── DisplayLinkController.swift
│   ├── Bridge/
│   │   ├── RustBridge.swift
│   │   └── OptaRender-Bridging-Header.h
│   └── Resources/
│       └── Assets.xcassets
└── OptaAppTests/
```

### Task 2: Create Rust bridge header

**File:** `opta-native/OptaApp/OptaApp/Bridge/OptaRender-Bridging-Header.h`

```c
#ifndef OptaRender_Bridging_Header_h
#define OptaRender_Bridging_Header_h

#include <stdint.h>
#include <stdbool.h>

// Opaque context pointer
typedef struct OptaRenderContext OptaRenderContext;

// GPU Capabilities
typedef struct {
    bool is_unified_memory;
    bool supports_timestamp_query;
    uint32_t max_texture_dimension;
    uint32_t max_compute_workgroup_size;
    char device_name[256];
} OptaGpuCapabilities;

// Render result codes
typedef enum {
    OPTA_RENDER_SUCCESS = 0,
    OPTA_RENDER_ERROR_INIT_FAILED = 1,
    OPTA_RENDER_ERROR_SURFACE_LOST = 2,
    OPTA_RENDER_ERROR_NO_SURFACE = 3,
    OPTA_RENDER_ERROR_NULL_POINTER = 4,
    OPTA_RENDER_ERROR_FRAME_SKIPPED = 5,
} OptaRenderResult;

// Render status for queries
typedef struct {
    uint64_t frames_rendered;
    uint64_t dropped_frames;
    double current_fps;
    double average_frame_time_ms;
    uint32_t quality_level;
    bool is_paused;
} RenderStatus;

// Lifecycle
OptaRenderContext* opta_render_init(void);
void opta_render_destroy(OptaRenderContext* ctx);

// Surface configuration
OptaRenderResult opta_render_configure_surface(
    OptaRenderContext* ctx,
    void* view,
    uint32_t width,
    uint32_t height,
    float scale
);

OptaRenderResult opta_render_resize(
    OptaRenderContext* ctx,
    uint32_t width,
    uint32_t height,
    float scale
);

// Frame loop
OptaRenderResult opta_render_frame_begin(OptaRenderContext* ctx);
OptaRenderResult opta_render_frame_end(OptaRenderContext* ctx);

// Quality control
OptaRenderResult opta_render_set_quality(OptaRenderContext* ctx, uint32_t level);
OptaRenderResult opta_render_set_paused(OptaRenderContext* ctx, bool paused);

// Status queries
OptaRenderResult opta_render_get_status(const OptaRenderContext* ctx, RenderStatus* out_status);
OptaRenderResult opta_render_get_capabilities(const OptaRenderContext* ctx, OptaGpuCapabilities* out_caps);

// Version
const char* opta_render_version(void);

#endif /* OptaRender_Bridging_Header_h */
```

### Task 3: Create Swift bridge wrapper

**File:** `opta-native/OptaApp/OptaApp/Bridge/RustBridge.swift`

```swift
import Foundation

/// Swift wrapper around the Rust render context
final class OptaRenderBridge {
    private var context: OpaquePointer?

    var isInitialized: Bool {
        context != nil
    }

    init() {
        context = opta_render_init()
        if context == nil {
            print("Failed to initialize Opta render context")
        }
    }

    deinit {
        if let ctx = context {
            opta_render_destroy(ctx)
        }
    }

    /// Configure the render surface with a Metal layer
    func configureSurface(view: UnsafeMutableRawPointer, width: UInt32, height: UInt32, scale: Float) -> Bool {
        guard let ctx = context else { return false }
        let result = opta_render_configure_surface(ctx, view, width, height, scale)
        return result == OPTA_RENDER_SUCCESS
    }

    /// Resize the render surface
    func resize(width: UInt32, height: UInt32, scale: Float) -> Bool {
        guard let ctx = context else { return false }
        let result = opta_render_resize(ctx, width, height, scale)
        return result == OPTA_RENDER_SUCCESS
    }

    /// Begin a frame - call from display link
    func frameBegin() -> Bool {
        guard let ctx = context else { return false }
        let result = opta_render_frame_begin(ctx)
        return result == OPTA_RENDER_SUCCESS
    }

    /// End a frame - call from display link
    func frameEnd() -> Bool {
        guard let ctx = context else { return false }
        let result = opta_render_frame_end(ctx)
        return result == OPTA_RENDER_SUCCESS
    }

    /// Set quality level (0=Low, 1=Medium, 2=High, 3=Ultra)
    func setQuality(_ level: UInt32) {
        guard let ctx = context else { return }
        _ = opta_render_set_quality(ctx, level)
    }

    /// Pause/resume rendering
    func setPaused(_ paused: Bool) {
        guard let ctx = context else { return }
        _ = opta_render_set_paused(ctx, paused)
    }

    /// Get current render status
    func getStatus() -> RenderStatus? {
        guard let ctx = context else { return nil }
        var status = RenderStatus()
        let result = opta_render_get_status(ctx, &status)
        return result == OPTA_RENDER_SUCCESS ? status : nil
    }

    /// Get GPU capabilities
    func getCapabilities() -> OptaGpuCapabilities? {
        guard let ctx = context else { return nil }
        var caps = OptaGpuCapabilities()
        let result = opta_render_get_capabilities(ctx, &caps)
        return result == OPTA_RENDER_SUCCESS ? caps : nil
    }

    /// Get Rust library version
    static var version: String {
        guard let cStr = opta_render_version() else { return "unknown" }
        return String(cString: cStr)
    }
}
```

### Task 4: Create Metal render view

**File:** `opta-native/OptaApp/OptaApp/Views/MetalRenderView.swift`

```swift
import SwiftUI
import MetalKit
import QuartzCore

/// NSViewRepresentable wrapper for Metal rendering
struct MetalRenderView: NSViewRepresentable {
    @ObservedObject var coordinator: RenderCoordinator

    func makeNSView(context: Context) -> MTKView {
        let mtkView = MTKView()
        mtkView.device = MTLCreateSystemDefaultDevice()
        mtkView.delegate = context.coordinator

        // Configure for external display link control
        mtkView.enableSetNeedsDisplay = false
        mtkView.isPaused = true

        // Enable CAMetalLayer access
        mtkView.wantsLayer = true

        // Configure layer for optimal rendering
        if let metalLayer = mtkView.layer as? CAMetalLayer {
            metalLayer.pixelFormat = .bgra8Unorm
            metalLayer.framebufferOnly = true
            metalLayer.displaySyncEnabled = true

            // Enable ProMotion if available
            if #available(macOS 14.0, *) {
                metalLayer.wantsExtendedDynamicRangeContent = true
            }
        }

        // Initialize Rust surface
        context.coordinator.configureSurface(mtkView)

        return mtkView
    }

    func updateNSView(_ nsView: MTKView, context: Context) {
        // Handle size changes
        let scale = nsView.window?.backingScaleFactor ?? 2.0
        let size = nsView.bounds.size
        context.coordinator.handleResize(
            width: UInt32(size.width * scale),
            height: UInt32(size.height * scale),
            scale: Float(scale)
        )
    }

    func makeCoordinator() -> RenderCoordinator {
        coordinator
    }
}
```

### Task 5: Create render coordinator with CVDisplayLink

**File:** `opta-native/OptaApp/OptaApp/Rendering/RenderCoordinator.swift`

```swift
import Foundation
import MetalKit
import QuartzCore

/// Coordinates between SwiftUI and Rust rendering
@MainActor
final class RenderCoordinator: NSObject, ObservableObject, MTKViewDelegate {
    private let bridge: OptaRenderBridge
    private var displayLink: DisplayLinkController?
    private weak var mtkView: MTKView?

    @Published var fps: Double = 0
    @Published var frameTime: Double = 0
    @Published var isRendering: Bool = false

    override init() {
        bridge = OptaRenderBridge()
        super.init()
    }

    /// Configure the Rust surface with the MTKView
    func configureSurface(_ view: MTKView) {
        mtkView = view

        guard bridge.isInitialized else {
            print("Rust bridge not initialized")
            return
        }

        let scale = view.window?.backingScaleFactor ?? 2.0
        let size = view.bounds.size
        let physicalWidth = UInt32(size.width * scale)
        let physicalHeight = UInt32(size.height * scale)

        // Get the CAMetalLayer pointer for Rust
        guard let metalLayer = view.layer as? CAMetalLayer else {
            print("View does not have CAMetalLayer")
            return
        }

        let viewPtr = Unmanaged.passUnretained(metalLayer).toOpaque()

        if bridge.configureSurface(view: viewPtr, width: physicalWidth, height: physicalHeight, scale: Float(scale)) {
            print("Surface configured: \(physicalWidth)x\(physicalHeight) @ \(scale)x")
            startDisplayLink()
        } else {
            print("Failed to configure surface")
        }
    }

    /// Handle resize events
    func handleResize(width: UInt32, height: UInt32, scale: Float) {
        guard bridge.isInitialized else { return }
        _ = bridge.resize(width: width, height: height, scale: scale)
    }

    /// Start the CVDisplayLink render loop
    private func startDisplayLink() {
        guard displayLink == nil else { return }

        displayLink = DisplayLinkController { [weak self] in
            self?.renderFrame()
        }
        displayLink?.start()
        isRendering = true
    }

    /// Stop the render loop
    func stopDisplayLink() {
        displayLink?.stop()
        displayLink = nil
        isRendering = false
    }

    /// Called by display link on render thread
    private func renderFrame() {
        guard bridge.isInitialized else { return }

        // Begin frame
        guard bridge.frameBegin() else { return }

        // Rust handles all rendering

        // End frame
        _ = bridge.frameEnd()

        // Update stats on main thread
        if let status = bridge.getStatus() {
            Task { @MainActor in
                self.fps = status.current_fps
                self.frameTime = status.average_frame_time_ms
            }
        }
    }

    /// Pause rendering (e.g., when window is occluded)
    func pause() {
        bridge.setPaused(true)
        displayLink?.stop()
        isRendering = false
    }

    /// Resume rendering
    func resume() {
        bridge.setPaused(false)
        displayLink?.start()
        isRendering = true
    }

    // MARK: - MTKViewDelegate

    func mtkView(_ view: MTKView, drawableSizeWillChange size: CGSize) {
        let scale = view.window?.backingScaleFactor ?? 2.0
        handleResize(
            width: UInt32(size.width),
            height: UInt32(size.height),
            scale: Float(scale)
        )
    }

    func draw(in view: MTKView) {
        // Not used - we drive rendering via CVDisplayLink
    }
}
```

### Task 6: Create CVDisplayLink controller

**File:** `opta-native/OptaApp/OptaApp/Rendering/DisplayLinkController.swift`

```swift
import Foundation
import CoreVideo
import QuartzCore

/// Manages CVDisplayLink for synchronized rendering on macOS
final class DisplayLinkController {
    private var displayLink: CVDisplayLink?
    private let renderCallback: () -> Void
    private var isRunning = false
    private let lock = NSLock()

    init(callback: @escaping () -> Void) {
        self.renderCallback = callback
        setupDisplayLink()
    }

    deinit {
        stop()
        if let link = displayLink {
            CVDisplayLinkRelease(link)
        }
    }

    private func setupDisplayLink() {
        var link: CVDisplayLink?
        CVDisplayLinkCreateWithActiveCGDisplays(&link)

        guard let displayLink = link else {
            print("Failed to create CVDisplayLink")
            return
        }

        self.displayLink = displayLink

        // Set the callback
        let callback: CVDisplayLinkOutputCallback = { (displayLink, inNow, inOutputTime, flagsIn, flagsOut, context) -> CVReturn in
            guard let context = context else { return kCVReturnError }
            let controller = Unmanaged<DisplayLinkController>.fromOpaque(context).takeUnretainedValue()
            controller.handleDisplayLinkCallback()
            return kCVReturnSuccess
        }

        let selfPtr = Unmanaged.passUnretained(self).toOpaque()
        CVDisplayLinkSetOutputCallback(displayLink, callback, selfPtr)

        // Configure for ProMotion (120Hz) if available
        configureFrameRate()
    }

    private func configureFrameRate() {
        guard let displayLink = displayLink else { return }

        // Get the main display
        let displayID = CGMainDisplayID()
        CVDisplayLinkSetCurrentCGDisplay(displayLink, displayID)

        // Query refresh rate
        let refreshPeriod = CVDisplayLinkGetNominalOutputVideoRefreshPeriod(displayLink)
        let refreshRate = Double(refreshPeriod.timeScale) / Double(refreshPeriod.timeValue)
        print("Display refresh rate: \(refreshRate) Hz")
    }

    private func handleDisplayLinkCallback() {
        lock.lock()
        defer { lock.unlock() }

        guard isRunning else { return }

        // Execute render callback on the display link thread
        // Note: This is NOT the main thread
        autoreleasepool {
            renderCallback()
        }
    }

    func start() {
        lock.lock()
        defer { lock.unlock() }

        guard let displayLink = displayLink, !isRunning else { return }
        CVDisplayLinkStart(displayLink)
        isRunning = true
        print("Display link started")
    }

    func stop() {
        lock.lock()
        defer { lock.unlock() }

        guard let displayLink = displayLink, isRunning else { return }
        CVDisplayLinkStop(displayLink)
        isRunning = false
        print("Display link stopped")
    }
}
```

### Task 7: Create SwiftUI app entry point

**File:** `opta-native/OptaApp/OptaApp/OptaAppApp.swift`

```swift
import SwiftUI

@main
struct OptaAppApp: App {
    @StateObject private var coordinator = RenderCoordinator()

    var body: some Scene {
        WindowGroup {
            ContentView(coordinator: coordinator)
                .onAppear {
                    coordinator.resume()
                }
                .onDisappear {
                    coordinator.pause()
                }
        }
        .windowStyle(.hiddenTitleBar)
        .defaultSize(width: 1200, height: 800)
    }
}
```

**File:** `opta-native/OptaApp/OptaApp/ContentView.swift`

```swift
import SwiftUI

struct ContentView: View {
    @ObservedObject var coordinator: RenderCoordinator

    var body: some View {
        ZStack {
            // Full-screen Metal render view
            MetalRenderView(coordinator: coordinator)
                .ignoresSafeArea()

            // Overlay UI
            VStack {
                HStack {
                    Spacer()
                    // FPS counter
                    Text(String(format: "%.1f FPS", coordinator.fps))
                        .font(.system(.caption, design: .monospaced))
                        .foregroundColor(.white.opacity(0.7))
                        .padding(8)
                        .background(.ultraThinMaterial)
                        .cornerRadius(8)
                        .padding()
                }
                Spacer()
            }
        }
    }
}

#Preview {
    ContentView(coordinator: RenderCoordinator())
}
```

### Task 8: Create build script for Rust library

**File:** `opta-native/scripts/build-macos.sh`

```bash
#!/bin/bash
set -e

# Build Rust library for macOS
cd "$(dirname "$0")/.."

echo "Building opta-render for macOS..."

# Build for current architecture (Apple Silicon or Intel)
cargo build --release -p opta-render

# Copy the library to the Xcode project
LIBRARY_PATH="target/release/libopta_render.a"
DEST_PATH="OptaApp/OptaApp/Libraries/"

mkdir -p "$DEST_PATH"
cp "$LIBRARY_PATH" "$DEST_PATH/libopta_render.a"

echo "Library copied to $DEST_PATH"
echo "Build complete!"
```

### Task 9: Add Xcode project configuration

Create xcconfig file for linking:

**File:** `opta-native/OptaApp/OptaApp/Config/Debug.xcconfig`

```
LIBRARY_SEARCH_PATHS = $(inherited) $(PROJECT_DIR)/OptaApp/Libraries
OTHER_LDFLAGS = -lc++ -lresolv -lopta_render
HEADER_SEARCH_PATHS = $(inherited) $(PROJECT_DIR)/OptaApp/Bridge
SWIFT_OBJC_BRIDGING_HEADER = $(PROJECT_DIR)/OptaApp/Bridge/OptaRender-Bridging-Header.h
```

**File:** `opta-native/OptaApp/OptaApp/Config/Release.xcconfig`

```
#include "Debug.xcconfig"

// Release-specific overrides
SWIFT_OPTIMIZATION_LEVEL = -O
```

## Verification

```bash
# Build Rust library
cd opta-native
./scripts/build-macos.sh

# Open Xcode project and build
open OptaApp/OptaApp.xcodeproj
# Cmd+B to build
# Cmd+R to run

# Verify:
# 1. Window opens with Metal rendering
# 2. FPS counter shows ~60Hz or 120Hz
# 3. No memory leaks (use Instruments)
```

## Success Criteria

- [ ] SwiftUI app launches and displays Metal content
- [ ] CVDisplayLink drives 60Hz or 120Hz rendering
- [ ] Rust bridge initializes and renders frames
- [ ] Resize handling works correctly
- [ ] Memory stays flat (autorelease pools working)
- [ ] FPS overlay shows current frame rate

## Output

- Complete SwiftUI shell hosting wgpu render surface
- CVDisplayLink synchronization for ProMotion
- Swift-Rust bridge for rendering control
