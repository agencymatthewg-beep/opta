# Plan 62-02: CoreHaptics Integration

## Wave: 2 (Depends on 62-01)

## Objective

Integrate CoreHaptics for tactile feedback synchronized with Opta Ring animations and UI interactions.

## Execution Context

**Reference Documents:**
- Apple CoreHaptics documentation
- Existing ring state machine from Phase 28

**Key Insights:**
- CoreHaptics available on macOS 11.0+
- Haptic patterns can be synchronized with visual events
- Magic Trackpad and MacBook trackpad support haptics

## Context

**Depends on:**
- Plan 62-01 (SwiftUI shell foundation)

**Builds foundation for:**
- Phase 63 (Component migration with haptic feedback)

## Tasks

### Task 1: Create HapticsManager

**File:** `opta-native/OptaApp/OptaApp/Haptics/HapticsManager.swift`

```swift
import Foundation
import CoreHaptics

/// Manages haptic feedback for Opta interactions
@MainActor
final class HapticsManager: ObservableObject {
    private var engine: CHHapticEngine?
    private var isSupported: Bool = false

    @Published var isEnabled: Bool = true

    init() {
        setupEngine()
    }

    private func setupEngine() {
        guard CHHapticEngine.capabilitiesForHardware().supportsHaptics else {
            print("Haptics not supported on this device")
            return
        }

        isSupported = true

        do {
            engine = try CHHapticEngine()
            engine?.stoppedHandler = { [weak self] reason in
                print("Haptic engine stopped: \(reason)")
                Task { @MainActor in
                    self?.restartEngine()
                }
            }
            engine?.resetHandler = { [weak self] in
                Task { @MainActor in
                    self?.restartEngine()
                }
            }
            try engine?.start()
        } catch {
            print("Failed to create haptic engine: \(error)")
        }
    }

    private func restartEngine() {
        do {
            try engine?.start()
        } catch {
            print("Failed to restart haptic engine: \(error)")
        }
    }

    /// Play a simple tap haptic
    func playTap() {
        guard isEnabled, isSupported else { return }
        playHaptic(intensity: 0.5, sharpness: 0.5, duration: 0.1)
    }

    /// Play a success haptic (ring explosion)
    func playExplosion() {
        guard isEnabled, isSupported else { return }
        playExplosionPattern()
    }

    /// Play a wake-up haptic (ring activation)
    func playWakeUp() {
        guard isEnabled, isSupported else { return }
        playWakeUpPattern()
    }

    /// Play a soft pulse (ring idle breathing)
    func playPulse() {
        guard isEnabled, isSupported else { return }
        playHaptic(intensity: 0.2, sharpness: 0.3, duration: 0.05)
    }

    /// Play a warning haptic
    func playWarning() {
        guard isEnabled, isSupported else { return }
        playWarningPattern()
    }

    // MARK: - Pattern Implementations

    private func playHaptic(intensity: Float, sharpness: Float, duration: TimeInterval) {
        do {
            let event = CHHapticEvent(
                eventType: .hapticTransient,
                parameters: [
                    CHHapticEventParameter(parameterID: .hapticIntensity, value: intensity),
                    CHHapticEventParameter(parameterID: .hapticSharpness, value: sharpness)
                ],
                relativeTime: 0,
                duration: duration
            )

            let pattern = try CHHapticPattern(events: [event], parameters: [])
            let player = try engine?.makePlayer(with: pattern)
            try player?.start(atTime: CHHapticTimeImmediate)
        } catch {
            print("Failed to play haptic: \(error)")
        }
    }

    private func playExplosionPattern() {
        do {
            var events: [CHHapticEvent] = []

            // Initial burst
            events.append(CHHapticEvent(
                eventType: .hapticTransient,
                parameters: [
                    CHHapticEventParameter(parameterID: .hapticIntensity, value: 1.0),
                    CHHapticEventParameter(parameterID: .hapticSharpness, value: 0.8)
                ],
                relativeTime: 0
            ))

            // Aftershock waves
            for i in 1...3 {
                let time = TimeInterval(i) * 0.05
                let intensity = Float(1.0 - Double(i) * 0.25)

                events.append(CHHapticEvent(
                    eventType: .hapticTransient,
                    parameters: [
                        CHHapticEventParameter(parameterID: .hapticIntensity, value: intensity),
                        CHHapticEventParameter(parameterID: .hapticSharpness, value: 0.5)
                    ],
                    relativeTime: time
                ))
            }

            let pattern = try CHHapticPattern(events: events, parameters: [])
            let player = try engine?.makePlayer(with: pattern)
            try player?.start(atTime: CHHapticTimeImmediate)
        } catch {
            print("Failed to play explosion haptic: \(error)")
        }
    }

    private func playWakeUpPattern() {
        do {
            var events: [CHHapticEvent] = []

            // Gentle ramp up
            for i in 0..<5 {
                let time = TimeInterval(i) * 0.1
                let intensity = Float(0.2 + Double(i) * 0.15)

                events.append(CHHapticEvent(
                    eventType: .hapticContinuous,
                    parameters: [
                        CHHapticEventParameter(parameterID: .hapticIntensity, value: intensity),
                        CHHapticEventParameter(parameterID: .hapticSharpness, value: 0.3)
                    ],
                    relativeTime: time,
                    duration: 0.08
                ))
            }

            let pattern = try CHHapticPattern(events: events, parameters: [])
            let player = try engine?.makePlayer(with: pattern)
            try player?.start(atTime: CHHapticTimeImmediate)
        } catch {
            print("Failed to play wake-up haptic: \(error)")
        }
    }

    private func playWarningPattern() {
        do {
            var events: [CHHapticEvent] = []

            // Double tap warning
            events.append(CHHapticEvent(
                eventType: .hapticTransient,
                parameters: [
                    CHHapticEventParameter(parameterID: .hapticIntensity, value: 0.7),
                    CHHapticEventParameter(parameterID: .hapticSharpness, value: 0.9)
                ],
                relativeTime: 0
            ))

            events.append(CHHapticEvent(
                eventType: .hapticTransient,
                parameters: [
                    CHHapticEventParameter(parameterID: .hapticIntensity, value: 0.7),
                    CHHapticEventParameter(parameterID: .hapticSharpness, value: 0.9)
                ],
                relativeTime: 0.15
            ))

            let pattern = try CHHapticPattern(events: events, parameters: [])
            let player = try engine?.makePlayer(with: pattern)
            try player?.start(atTime: CHHapticTimeImmediate)
        } catch {
            print("Failed to play warning haptic: \(error)")
        }
    }
}
```

### Task 2: Create haptic event bridge to Rust

**Update:** `opta-native/OptaApp/OptaApp/Bridge/OptaRender-Bridging-Header.h`

Add haptic event callback:

```c
// Haptic feedback callback type
typedef void (*HapticCallback)(uint32_t haptic_type);

// Haptic types
typedef enum {
    OPTA_HAPTIC_TAP = 0,
    OPTA_HAPTIC_EXPLOSION = 1,
    OPTA_HAPTIC_WAKE_UP = 2,
    OPTA_HAPTIC_PULSE = 3,
    OPTA_HAPTIC_WARNING = 4,
} OptaHapticType;

// Register haptic callback
OptaRenderResult opta_render_set_haptic_callback(
    OptaRenderContext* ctx,
    HapticCallback callback
);
```

### Task 3: Add Rust haptic callback support

**File:** `opta-native/opta-render/src/haptics.rs`

```rust
//! Haptic feedback integration for native platforms.

use std::sync::atomic::{AtomicPtr, Ordering};
use std::ptr;

/// Haptic feedback types.
#[repr(u32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum HapticType {
    Tap = 0,
    Explosion = 1,
    WakeUp = 2,
    Pulse = 3,
    Warning = 4,
}

/// Callback function type for haptic feedback.
pub type HapticCallback = extern "C" fn(haptic_type: u32);

static HAPTIC_CALLBACK: AtomicPtr<()> = AtomicPtr::new(ptr::null_mut());

/// Set the haptic feedback callback.
///
/// # Safety
///
/// The callback must remain valid for the lifetime of the application.
pub unsafe fn set_haptic_callback(callback: HapticCallback) {
    HAPTIC_CALLBACK.store(callback as *mut (), Ordering::SeqCst);
}

/// Trigger haptic feedback.
pub fn trigger_haptic(haptic_type: HapticType) {
    let callback = HAPTIC_CALLBACK.load(Ordering::SeqCst);
    if !callback.is_null() {
        let callback: HapticCallback = unsafe { std::mem::transmute(callback) };
        callback(haptic_type as u32);
    }
}

/// Trigger tap haptic.
pub fn haptic_tap() {
    trigger_haptic(HapticType::Tap);
}

/// Trigger explosion haptic (ring explosion).
pub fn haptic_explosion() {
    trigger_haptic(HapticType::Explosion);
}

/// Trigger wake-up haptic (ring activation).
pub fn haptic_wake_up() {
    trigger_haptic(HapticType::WakeUp);
}

/// Trigger pulse haptic (idle breathing).
pub fn haptic_pulse() {
    trigger_haptic(HapticType::Pulse);
}

/// Trigger warning haptic.
pub fn haptic_warning() {
    trigger_haptic(HapticType::Warning);
}
```

### Task 4: Integrate haptics with RenderCoordinator

**Update:** `opta-native/OptaApp/OptaApp/Rendering/RenderCoordinator.swift`

```swift
// Add to RenderCoordinator class

private var hapticsManager: HapticsManager?

func setupHaptics(_ manager: HapticsManager) {
    self.hapticsManager = manager

    // Register callback with Rust
    let callback: HapticCallback = { hapticType in
        Task { @MainActor in
            RenderCoordinator.shared?.handleHaptic(type: hapticType)
        }
    }

    if let ctx = bridge.context {
        opta_render_set_haptic_callback(ctx, callback)
    }
}

private func handleHaptic(type: UInt32) {
    guard let manager = hapticsManager else { return }

    switch type {
    case 0: manager.playTap()
    case 1: manager.playExplosion()
    case 2: manager.playWakeUp()
    case 3: manager.playPulse()
    case 4: manager.playWarning()
    default: break
    }
}
```

### Task 5: Add haptics to app lifecycle

**Update:** `opta-native/OptaApp/OptaApp/OptaAppApp.swift`

```swift
@main
struct OptaAppApp: App {
    @StateObject private var coordinator = RenderCoordinator()
    @StateObject private var haptics = HapticsManager()

    var body: some Scene {
        WindowGroup {
            ContentView(coordinator: coordinator, haptics: haptics)
                .onAppear {
                    coordinator.setupHaptics(haptics)
                    coordinator.resume()
                }
                .onDisappear {
                    coordinator.pause()
                }
        }
        .windowStyle(.hiddenTitleBar)
        .defaultSize(width: 1200, height: 800)
    }
}
```

## Verification

```bash
# Build and run
cd opta-native
./scripts/build-macos.sh
open OptaApp/OptaApp.xcodeproj

# Test on device with Force Touch trackpad:
# 1. Hover over ring - should feel wake-up haptic
# 2. Click ring - should feel explosion haptic
# 3. UI buttons - should feel tap haptic
```

## Success Criteria

- [ ] HapticsManager initializes CoreHaptics engine
- [ ] Rust can trigger haptics via callback
- [ ] Wake-up, explosion, tap patterns feel distinct
- [ ] Haptics disabled gracefully on unsupported hardware
- [ ] No performance impact on rendering

## Output

- CoreHaptics integration for tactile feedback
- Rust-Swift haptic callback bridge
- Pre-defined haptic patterns for ring states
