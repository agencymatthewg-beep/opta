---
phase: 85-dashboard-obsidian-refresh
plan: 02
type: execute
wave: 2
depends_on: ["85-01"]
files_modified:
  - opta-native/OptaApp/OptaApp/Bridge/PanelBridge.swift
  - opta-native/OptaApp/OptaApp/Views/Components/TelemetryCard.swift
  - opta-native/OptaApp/OptaApp/Views/Components/SparklineView.swift
autonomous: true
---

<objective>
Create Swift bridge for obsidian panel + branch component FFI, then rebuild TelemetryCard with obsidian panel background and BranchMeter visualization.

Purpose: Replace the current glass-material TelemetryCard with GPU-rendered obsidian panels featuring branch energy meters that respond to CPU/Memory/GPU telemetry values.

Output: PanelBridge.swift wrapping the FFI functions, TelemetryCard rebuilt with obsidian styling and branch-energy meters instead of simple sparklines.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/85-dashboard-obsidian-refresh/85-01-PLAN.md
@opta-native/OptaApp/OptaApp/Bridge/RustBridge.swift
@opta-native/OptaApp/OptaApp/Bridge/CircularMenuBridge.swift
@opta-native/OptaApp/OptaApp/Views/Components/TelemetryCard.swift
</context>

<tasks>
<task type="auto">
  <name>Task 1: PanelBridge Swift wrapper</name>
  <files>opta-native/OptaApp/OptaApp/Bridge/PanelBridge.swift</files>
  <action>
Create `PanelBridge.swift` following the pattern in `CircularMenuBridge.swift`. This Swift class wraps the C FFI functions from `ffi_panels.rs` into Swift-friendly APIs.

Classes to create:

**ObsidianPanel** (wraps OptaPanel):
```swift
final class ObsidianPanel {
    private var handle: OpaquePointer?
    init(config: ObsidianPanelConfig)
    func setPosition(_ x: Float, _ y: Float)
    func setSize(_ width: Float, _ height: Float)
    func setEnergy(_ energy: Float)
    func setDepth(_ depth: Float)
    func setQuality(_ level: UInt32)
    func update(dt: Float)
    func render(context: OpaquePointer)
    deinit { destroy() }
}
```

**BranchMeterView** (wraps OptaBranchMeter):
```swift
final class BranchMeterView {
    private var handle: OpaquePointer?
    init(config: BranchMeterConfig)
    func setFill(_ level: Float)
    func setEnergy(_ energy: Float)
    func update(dt: Float)
    func render(context: OpaquePointer)
    deinit { destroy() }
}
```

**BranchIndicatorView** (wraps OptaBranchIndicator):
```swift
final class BranchIndicatorView {
    private var handle: OpaquePointer?
    init(config: BranchIndicatorConfig)
    func setEnergy(_ energy: Float)
    func update(dt: Float)
    func render(context: OpaquePointer)
    deinit { destroy() }
}
```

**BranchBorderView** (wraps OptaBranchBorder):
```swift
final class BranchBorderView {
    private var handle: OpaquePointer?
    init(config: BranchBorderConfig)
    func setEnergy(_ energy: Float)
    func update(dt: Float)
    func render(context: OpaquePointer)
    deinit { destroy() }
}
```

Config structs mirror the C `#[repr(C)]` structs. Use `@MainActor` on classes for thread safety. Import the C functions via the bridging header (add declarations to the existing bridging header file).

Handle errors by checking OptaRenderResult and logging via print (matching existing bridge pattern).
  </action>
  <verify>Xcode project builds without errors (the bridge compiles against the FFI header)</verify>
  <done>4 Swift wrapper classes created, each with init/setters/update/render/deinit lifecycle</done>
</task>

<task type="auto">
  <name>Task 2: TelemetryCard obsidian refresh</name>
  <files>opta-native/OptaApp/OptaApp/Views/Components/TelemetryCard.swift</files>
  <action>
Rebuild TelemetryCard to use obsidian panel background with branch-energy meter visualization. The card structure changes:

**Layout (top to bottom):**
1. Header row: SF Symbol icon + title + BranchIndicator status dot (replaces Circle status indicator)
2. Value display: Large percentage number (keep existing spring animation)
3. BranchMeter: Horizontal meter with fill_level = value/100, energy = value/100 (replaces SparklineView)
4. Mini sparkline: Keep the existing SparklineView but smaller (20px height, below the meter)

**Background change:**
Replace the current `glassBackground` (ultraThinMaterial) with an obsidian-styled background:
- Base: Color(hex: "0A0A0F") (deep obsidian, nearly black)
- Subtle gradient overlay from top-left to bottom-right for depth
- BranchBorder along the card perimeter (energy tied to value/100)
- Remove the `.ultraThinMaterial` overlay

**Color palette (branch-energy violet):**
- Replace per-card accent colors (blue, purple, orange) with a unified branch energy violet: Color(hex: "8B5CF6") at varying intensities
- The BranchMeter and BranchBorder energy determines visual intensity (low usage = dim violet, high = bright)
- Keep the status indicator color logic (green/yellow/red) but render via BranchIndicator energy levels

**BranchMeter integration:**
- fill_level = value / 100.0 (percentage mapped to 0-1)
- energy = value / 100.0 (higher usage = more visible branches)
- The BranchMeter renders as a horizontal bar below the value number
- Height: 32px, corner_radius: 6px

**BranchIndicator integration:**
- Replace the Circle().fill(indicatorColor) with a conceptual BranchIndicator
- Since BranchIndicator is GPU-rendered and we can't easily embed it inline in SwiftUI yet, approximate it with a SwiftUI Circle that uses branch-energy-derived colors:
  - Green (< 60%): energy 0.3, dim violet glow
  - Yellow (60-85%): energy 0.6, medium violet
  - Red (> 85%): energy 1.0, bright violet with pulsing

**BranchBorder integration:**
- For now, approximate with a SwiftUI overlay stroke using branch-energy-inspired gradient:
  - Color(hex: "8B5CF6").opacity(energy * 0.5) for the border stroke
  - energy = value / 100.0
- Full GPU BranchBorder integration will come when MetalRenderView supports compositing multiple components

**Important:** This is a SwiftUI-level visual refresh. The GPU components (BranchMeter, BranchBorder) will be fully composited in a future phase when the render pipeline supports multi-component composition. For now, use SwiftUI approximations of the obsidian aesthetic (dark base + violet energy accents) rather than actual GPU rendering calls.

Keep the existing `onChange(of: value)` animation logic and `onAppear` initialization. Keep the SparklineView component but shrink it. Keep accessibility support (reduce motion).
  </action>
  <verify>Build project with `xcodebuild -scheme OptaApp -configuration Debug build` (or verify no compiler errors in the file)</verify>
  <done>TelemetryCard has obsidian background, branch-energy-inspired violet meter bar, violet border glow, and reduced sparkline. No glass/ultraThinMaterial remaining.</done>
</task>

<task type="auto">
  <name>Task 3: Extract SparklineView to separate file</name>
  <files>opta-native/OptaApp/OptaApp/Views/Components/SparklineView.swift</files>
  <action>
Extract `SparklineView` from TelemetryCard.swift into its own file for reuse across the dashboard. Also extract the `Color(hex:)` extension to a shared file (or keep it in TelemetryCard if already duplicated elsewhere â€” check first).

SparklineView stays the same implementation but gets its own file. Update the color palette to use branch-energy violet as the default accent:
- Default gradient: from Color(hex: "8B5CF6").opacity(0.3) to Color(hex: "8B5CF6").opacity(0.0)
- Default line color: Color(hex: "8B5CF6")
- Keep the `color` parameter for overriding

Note: The Color(hex:) extension likely already exists in TelemetryCard.swift. Check if it's already in a shared location. If not, leave it in TelemetryCard.swift (avoid creating unnecessary shared files unless there's actual duplication elsewhere).
  </action>
  <verify>Project compiles, SparklineView renders correctly in TelemetryCard</verify>
  <done>SparklineView in its own file, branch-energy violet as default color</done>
</task>
</tasks>

<verification>
Before declaring plan complete:
- [ ] Project compiles without errors
- [ ] TelemetryCard displays obsidian background (no glass/ultraThinMaterial)
- [ ] TelemetryCard shows branch-energy-inspired violet meter bar
- [ ] TelemetryCard shows violet border glow proportional to value
- [ ] SparklineView renders as compact chart below meter
- [ ] PanelBridge.swift compiles with all 4 wrapper classes
- [ ] Accessibility: reduceMotion still suppresses animations
</verification>

<success_criteria>
- PanelBridge.swift created with ObsidianPanel, BranchMeterView, BranchIndicatorView, BranchBorderView wrappers
- TelemetryCard rebuilt with obsidian aesthetic (dark base, violet energy, no glass material)
- SparklineView extracted and reusable
- Branch-energy violet color palette applied consistently
- No regressions in existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/85-dashboard-obsidian-refresh/85-02-SUMMARY.md`
</output>
