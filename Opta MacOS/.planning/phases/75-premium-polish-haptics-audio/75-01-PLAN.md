---
phase: 75-premium-polish-haptics-audio
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - opta-native/OptaApp/OptaApp/Haptics/HapticsManager.swift
  - opta-native/OptaApp/OptaApp/Haptics/Resources/ring_explosion.ahap
  - opta-native/OptaApp/OptaApp/Haptics/Resources/optimization_pulse.ahap
  - opta-native/OptaApp/OptaApp/Haptics/Resources/wake_up.ahap
  - opta-native/OptaApp/OptaApp/Audio/SpatialAudioManager.swift
  - opta-native/OptaApp/OptaApp/Services/ThermalStateManager.swift
  - opta-native/OptaApp/OptaApp/Managers/SensoryManager.swift
autonomous: true
---

<objective>
Implement premium haptics with AHAP files, spatial audio foundation, and thermal-adaptive quality based on Gemini Deep Research recommendations.

Purpose: Elevate the sensory experience to "premium" status by using designer-authored AHAP patterns instead of programmatic haptics, adding a spatial audio foundation for 3D sound positioning, and implementing thermal state monitoring for graceful degradation.
Output: Complete sensory stack with AHAP-based haptics, AVAudioEngine spatial audio, and thermal-reactive quality system.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Gemini Research (PRIMARY SOURCE):**
@Gemini Deep Research/Apple-Platforms/UI-UX/Premium-Haptics-Spatial-Audio-Opta.md

**Existing haptics implementation:**
@opta-native/OptaApp/OptaApp/Haptics/HapticsManager.swift

**Design reference:**
- Ring explosion: High-sharpness transient (shatter) + decaying continuous (crumble)
- Wake-up: Ramping intensity from 0.2 to 0.8 over 500ms
- Pulse: Soft 0.3 intensity, 0.2 sharpness, 150ms continuous
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AHAP haptic pattern files</name>
  <files>
opta-native/OptaApp/OptaApp/Haptics/Resources/ring_explosion.ahap
opta-native/OptaApp/OptaApp/Haptics/Resources/optimization_pulse.ahap
opta-native/OptaApp/OptaApp/Haptics/Resources/wake_up.ahap
opta-native/OptaApp/OptaApp/Haptics/Resources/warning.ahap
opta-native/OptaApp/OptaApp/Haptics/Resources/tap.ahap
  </files>
  <action>
Create AHAP files based on Gemini research specifications:

**ring_explosion.ahap** (from Section 2.2):
```json
{
    "Version": 1.0,
    "Metadata": {
        "Project": "Opta",
        "Created": "2026-01-22",
        "Description": "High-Energy Ring Detonation - transient shatter with decaying rumble"
    },
    "Pattern": [
        {
            "Event": {
                "Time": 0.0,
                "EventType": "HapticTransient",
                "EventParameters": [
                    { "ParameterID": "HapticIntensity", "ParameterValue": 1.0 },
                    { "ParameterID": "HapticSharpness", "ParameterValue": 1.0 }
                ]
            }
        },
        {
            "Event": {
                "Time": 0.02,
                "EventType": "HapticContinuous",
                "EventDuration": 0.6,
                "EventParameters": [
                    { "ParameterID": "HapticIntensity", "ParameterValue": 0.8 },
                    { "ParameterID": "HapticSharpness", "ParameterValue": 0.5 }
                ]
            }
        },
        {
            "ParameterCurve": {
                "ParameterID": "HapticIntensityControl",
                "Time": 0.02,
                "ParameterCurveControlPoints": [
                    { "Time": 0.0, "ParameterValue": 1.0 },
                    { "Time": 0.1, "ParameterValue": 0.4 },
                    { "Time": 0.5, "ParameterValue": 0.0 }
                ]
            }
        },
        {
            "ParameterCurve": {
                "ParameterID": "HapticSharpnessControl",
                "Time": 0.02,
                "ParameterCurveControlPoints": [
                    { "Time": 0.0, "ParameterValue": 0.6 },
                    { "Time": 0.3, "ParameterValue": 0.2 },
                    { "Time": 0.5, "ParameterValue": 0.0 }
                ]
            }
        }
    ]
}
```

**optimization_pulse.ahap** - Celebratory pulse for optimization complete:
- Soft continuous event with rising then falling intensity
- Duration: 300ms
- Peak intensity: 0.6

**wake_up.ahap** - Ring activation with ramping intensity:
- 5 sequential continuous events
- Intensity ramps from 0.2 to 0.8
- Total duration: 500ms

**warning.ahap** - Double-tap alert:
- Two transients at 0ms and 150ms
- Intensity: 0.8, Sharpness: 0.7

**tap.ahap** - Simple UI feedback:
- Single transient
- Intensity: 0.7, Sharpness: 0.5

Create Resources/ directory if not exists.

Key: AHAP files enable iteration without recompilation. JSON parsing should happen at app launch, not on trigger.
  </action>
  <verify>
```bash
ls -la /Users/matthewbyrden/Documents/Opta/opta-native/OptaApp/OptaApp/Haptics/Resources/
cat /Users/matthewbyrden/Documents/Opta/opta-native/OptaApp/OptaApp/Haptics/Resources/ring_explosion.ahap | head -20
```
Expected: All 5 AHAP files exist with valid JSON
  </verify>
  <done>AHAP files created for all haptic types with parameter curves</done>
</task>

<task type="auto">
  <name>Task 2: Update HapticsManager to use AHAP files</name>
  <files>
opta-native/OptaApp/OptaApp/Haptics/HapticsManager.swift
  </files>
  <action>
Refactor HapticsManager to load and use AHAP patterns:

1. Add pattern storage:
   ```swift
   /// Pre-loaded haptic patterns from AHAP files
   private var patterns: [HapticType: CHHapticPattern] = [:]

   /// Pre-created players for each pattern (reusable)
   private var players: [HapticType: CHHapticPatternPlayer] = [:]
   ```

2. Add loadPatterns() method called at init:
   ```swift
   private func loadPatterns() {
       guard supportsHaptics else { return }

       let patternFiles: [(HapticType, String)] = [
           (.tap, "tap"),
           (.explosion, "ring_explosion"),
           (.wakeUp, "wake_up"),
           (.pulse, "optimization_pulse"),
           (.warning, "warning")
       ]

       for (type, filename) in patternFiles {
           guard let url = Bundle.main.url(
               forResource: filename,
               withExtension: "ahap",
               subdirectory: "Haptics/Resources"
           ) else {
               print("[HapticsManager] Missing AHAP: \(filename)")
               continue
           }

           do {
               let pattern = try CHHapticPattern(contentsOf: url)
               patterns[type] = pattern
               players[type] = try engine?.makePlayer(with: pattern)
               print("[HapticsManager] Loaded pattern: \(filename)")
           } catch {
               print("[HapticsManager] Failed to load \(filename): \(error)")
           }
       }
   }
   ```

3. Update playHaptic to use pre-loaded players:
   ```swift
   func playHaptic(type: HapticType) {
       guard supportsHaptics, isEngineRunning else { return }

       do {
           if let player = players[type] {
               try player.start(atTime: CHHapticTimeImmediate)
           } else {
               // Fallback to programmatic if AHAP not loaded
               playFallbackHaptic(type: type)
           }
       } catch {
           print("[HapticsManager] Play failed: \(error)")
       }
   }
   ```

4. Move existing programmatic haptics to playFallbackHaptic() for graceful degradation

5. Add pattern preload verification in init

Key: Parse AHAP at launch, not during explosion. Use pre-created players to avoid allocation during trigger.
  </action>
  <verify>
```bash
grep -l "CHHapticPattern(contentsOf:" /Users/matthewbyrden/Documents/Opta/opta-native/OptaApp/OptaApp/Haptics/HapticsManager.swift
grep -l "patterns\[" /Users/matthewbyrden/Documents/Opta/opta-native/OptaApp/OptaApp/Haptics/HapticsManager.swift
```
Expected: HapticsManager loads AHAP files and uses pattern dictionary
  </verify>
  <done>HapticsManager refactored to load and use AHAP patterns with fallback</done>
</task>

<task type="auto">
  <name>Task 3: Create SpatialAudioManager with AVAudioEnvironmentNode</name>
  <files>
opta-native/OptaApp/OptaApp/Audio/SpatialAudioManager.swift
  </files>
  <action>
Create spatial audio manager based on Gemini research Part III:

```swift
import AVFoundation
import simd

/// Manages spatial audio for 3D sound positioning
/// Based on Gemini Research: Premium-Haptics-Spatial-Audio-Opta.md
@MainActor
final class SpatialAudioManager {

    // MARK: - Singleton

    static let shared = SpatialAudioManager()

    // MARK: - Properties

    private var audioEngine: AVAudioEngine?
    private var environmentNode: AVAudioEnvironmentNode?

    /// Pool of player nodes for concurrent sounds
    private var playerPool: [AVAudioPlayerNode] = []
    private let poolSize = 4

    /// Pre-loaded audio buffers
    private var buffers: [String: AVAudioPCMBuffer] = [:]

    /// Whether spatial audio is available
    private(set) var isAvailable: Bool = false

    /// Scale factor for coordinate conversion (visual units to meters)
    var coordinateScale: Float = 0.01  // Default: 1 unit = 1cm

    // MARK: - Initialization

    private init() {
        setupAudioSession()
        setupAudioEngine()
        loadAudioAssets()
    }

    // MARK: - Setup

    private func setupAudioSession() {
        do {
            let session = AVAudioSession.sharedInstance()
            try session.setCategory(.playback, mode: .default, options: [.mixWithOthers])
            try session.setActive(true)
        } catch {
            print("[SpatialAudioManager] Audio session setup failed: \(error)")
        }
    }

    private func setupAudioEngine() {
        audioEngine = AVAudioEngine()
        environmentNode = AVAudioEnvironmentNode()

        guard let engine = audioEngine,
              let environment = environmentNode else { return }

        // Attach environment node
        engine.attach(environment)

        // Configure environment
        environment.listenerPosition = AVAudio3DPoint(x: 0, y: 0, z: 0)
        environment.listenerAngularOrientation = AVAudio3DVectorOrientation(
            forward: AVAudio3DVector(x: 0, y: 0, z: -1),
            up: AVAudio3DVector(x: 0, y: 1, z: 0)
        )

        // Distance attenuation (inverse model for realistic physics)
        environment.distanceAttenuationParameters.distanceAttenuationModel = .inverse
        environment.distanceAttenuationParameters.referenceDistance = 1.0
        environment.distanceAttenuationParameters.maximumDistance = 100.0
        environment.distanceAttenuationParameters.rolloffFactor = 1.0

        // Rendering algorithm
        environment.renderingAlgorithm = .auto

        // Connect environment to main mixer
        let format = environment.outputFormat(forBus: 0)
        engine.connect(environment, to: engine.mainMixerNode, format: format)

        // Create player pool
        for _ in 0..<poolSize {
            let player = AVAudioPlayerNode()
            engine.attach(player)
            // Connect with mono format for spatialization
            let monoFormat = AVAudioFormat(standardFormatWithSampleRate: 48000, channels: 1)
            engine.connect(player, to: environment, format: monoFormat)
            playerPool.append(player)
        }

        // Start engine
        do {
            try engine.start()
            isAvailable = true
            print("[SpatialAudioManager] Audio engine started")
        } catch {
            print("[SpatialAudioManager] Engine start failed: \(error)")
        }
    }

    private func loadAudioAssets() {
        // Load explosion sound (must be mono for spatialization)
        loadBuffer(named: "explosion", extension: "wav")
        loadBuffer(named: "optimize_complete", extension: "wav")
    }

    private func loadBuffer(named name: String, extension ext: String) {
        guard let url = Bundle.main.url(forResource: name, withExtension: ext) else {
            print("[SpatialAudioManager] Audio file not found: \(name).\(ext)")
            return
        }

        do {
            let file = try AVAudioFile(forReading: url)
            guard let buffer = AVAudioPCMBuffer(
                pcmFormat: file.processingFormat,
                frameCapacity: AVAudioFrameCount(file.length)
            ) else { return }

            try file.read(into: buffer)
            buffers[name] = buffer
            print("[SpatialAudioManager] Loaded audio: \(name)")
        } catch {
            print("[SpatialAudioManager] Failed to load \(name): \(error)")
        }
    }

    // MARK: - Playback

    /// Play a sound at a 3D position
    func playSound(named name: String, at position: SIMD3<Float>, volume: Float = 1.0) {
        guard isAvailable,
              let buffer = buffers[name],
              let player = getAvailablePlayer() else { return }

        // Convert visual coordinates to audio coordinates
        let audioPos = AVAudio3DPoint(
            x: position.x * coordinateScale,
            y: position.y * coordinateScale,
            z: position.z * coordinateScale
        )

        player.position = audioPos
        player.volume = volume

        player.scheduleBuffer(buffer, at: nil, options: .interrupts)
        player.play()
    }

    /// Play explosion at position (convenience method)
    func playExplosion(at position: SIMD3<Float>, intensity: Float = 1.0) {
        playSound(named: "explosion", at: position, volume: intensity)
    }

    private func getAvailablePlayer() -> AVAudioPlayerNode? {
        // Find non-playing player
        for player in playerPool where !player.isPlaying {
            return player
        }
        // If all busy, return first (will interrupt)
        return playerPool.first
    }

    // MARK: - Listener Control

    /// Update listener position (call when camera moves)
    func updateListenerPosition(_ position: SIMD3<Float>) {
        environmentNode?.listenerPosition = AVAudio3DPoint(
            x: position.x * coordinateScale,
            y: position.y * coordinateScale,
            z: position.z * coordinateScale
        )
    }

    /// Update listener orientation (call when camera rotates)
    func updateListenerOrientation(forward: SIMD3<Float>, up: SIMD3<Float>) {
        environmentNode?.listenerAngularOrientation = AVAudio3DVectorOrientation(
            forward: AVAudio3DVector(x: forward.x, y: forward.y, z: forward.z),
            up: AVAudio3DVector(x: up.x, y: up.y, z: up.z)
        )
    }
}
```

Key points from Gemini research:
- Use mono audio files for proper spatialization
- Pool player nodes to avoid allocation during playback
- Coordinate transform from visual units to meters
- Inverse distance attenuation for realistic physics

Create Audio/ directory if not exists.
  </action>
  <verify>
```bash
ls -la /Users/matthewbyrden/Documents/Opta/opta-native/OptaApp/OptaApp/Audio/
grep -l "AVAudioEnvironmentNode" /Users/matthewbyrden/Documents/Opta/opta-native/OptaApp/OptaApp/Audio/SpatialAudioManager.swift
```
Expected: SpatialAudioManager exists with AVAudioEnvironmentNode configuration
  </verify>
  <done>SpatialAudioManager created with spatial audio, player pooling, and coordinate transform</done>
</task>

<task type="auto">
  <name>Task 4: Create ThermalStateManager for graceful degradation</name>
  <files>
opta-native/OptaApp/OptaApp/Services/ThermalStateManager.swift
  </files>
  <action>
Create thermal state manager based on Gemini research Part VI:

```swift
import Foundation
import Combine

/// Monitors thermal state and triggers quality adaptations
/// Based on Gemini Research: Section 6.1 Thermal Throttling Mitigation
@Observable
final class ThermalStateManager {

    // MARK: - Singleton

    static let shared = ThermalStateManager()

    // MARK: - State

    /// Current thermal state
    private(set) var thermalState: ProcessInfo.ThermalState = .nominal

    /// Whether haptics should be disabled
    var shouldDisableHaptics: Bool {
        thermalState == .serious || thermalState == .critical
    }

    /// Whether spatial audio should be simplified
    var shouldSimplifyAudio: Bool {
        thermalState == .serious || thermalState == .critical
    }

    /// Whether to reduce visual quality
    var shouldReduceVisualQuality: Bool {
        thermalState == .fair || thermalState == .serious || thermalState == .critical
    }

    /// Whether low power mode is enabled
    private(set) var isLowPowerModeEnabled: Bool = false

    /// Quality reduction level (0.0 = full quality, 1.0 = minimum quality)
    var qualityReductionLevel: Float {
        switch thermalState {
        case .nominal: return 0.0
        case .fair: return 0.25
        case .serious: return 0.6
        case .critical: return 1.0
        @unknown default: return 0.0
        }
    }

    // MARK: - Private

    private var cancellables = Set<AnyCancellable>()

    // MARK: - Initialization

    private init() {
        // Get initial state
        thermalState = ProcessInfo.processInfo.thermalState
        isLowPowerModeEnabled = ProcessInfo.processInfo.isLowPowerModeEnabled

        // Monitor thermal state changes
        NotificationCenter.default.publisher(
            for: ProcessInfo.thermalStateDidChangeNotification
        )
        .receive(on: DispatchQueue.main)
        .sink { [weak self] _ in
            self?.handleThermalStateChange()
        }
        .store(in: &cancellables)

        // Monitor low power mode changes
        NotificationCenter.default.publisher(
            for: .NSProcessInfoPowerStateDidChange
        )
        .receive(on: DispatchQueue.main)
        .sink { [weak self] _ in
            self?.handlePowerStateChange()
        }
        .store(in: &cancellables)

        print("[ThermalStateManager] Initial state: \(thermalStateDescription)")
    }

    // MARK: - Handlers

    private func handleThermalStateChange() {
        let newState = ProcessInfo.processInfo.thermalState
        let oldState = thermalState
        thermalState = newState

        print("[ThermalStateManager] Thermal state: \(thermalStateDescription(for: oldState)) â†’ \(thermalStateDescription)")

        // Notify dependent systems
        NotificationCenter.default.post(
            name: .thermalStateDidChange,
            object: nil,
            userInfo: [
                "thermalState": newState,
                "shouldDisableHaptics": shouldDisableHaptics,
                "qualityReduction": qualityReductionLevel
            ]
        )
    }

    private func handlePowerStateChange() {
        isLowPowerModeEnabled = ProcessInfo.processInfo.isLowPowerModeEnabled
        print("[ThermalStateManager] Low Power Mode: \(isLowPowerModeEnabled ? "ON" : "OFF")")

        NotificationCenter.default.post(
            name: .powerStateDidChange,
            object: nil,
            userInfo: ["isLowPowerMode": isLowPowerModeEnabled]
        )
    }

    // MARK: - Helpers

    var thermalStateDescription: String {
        thermalStateDescription(for: thermalState)
    }

    private func thermalStateDescription(for state: ProcessInfo.ThermalState) -> String {
        switch state {
        case .nominal: return "Nominal"
        case .fair: return "Fair"
        case .serious: return "Serious"
        case .critical: return "Critical"
        @unknown default: return "Unknown"
        }
    }
}

// MARK: - Notifications

extension Notification.Name {
    static let thermalStateDidChange = Notification.Name("thermalStateDidChange")
    static let powerStateDidChange = Notification.Name("powerStateDidChange")
}
```

Key Gemini insights:
- At .fair: Reduce visual particle count
- At .serious: Disable haptics, simplify audio
- At .critical: Minimal operation
- Check isLowPowerModeEnabled: Use UIImpactFeedbackGenerator instead of CoreHaptics
  </action>
  <verify>
```bash
ls -la /Users/matthewbyrden/Documents/Opta/opta-native/OptaApp/OptaApp/Services/ThermalStateManager.swift
grep -l "thermalState" /Users/matthewbyrden/Documents/Opta/opta-native/OptaApp/OptaApp/Services/ThermalStateManager.swift
```
Expected: ThermalStateManager exists with thermal monitoring and quality adaptation
  </verify>
  <done>ThermalStateManager created with thermal/power monitoring and quality degradation levels</done>
</task>

<task type="auto">
  <name>Task 5: Create unified SensoryManager orchestrating haptics and audio</name>
  <files>
opta-native/OptaApp/OptaApp/Managers/SensoryManager.swift
  </files>
  <action>
Create unified sensory manager that coordinates haptics and audio:

```swift
import Foundation
import simd

/// Unified manager for coordinated haptic and audio feedback
/// Based on Gemini Research: Part VII Implementation Guide
@MainActor
final class SensoryManager {

    // MARK: - Singleton

    static let shared = SensoryManager()

    // MARK: - Dependencies

    private let haptics = HapticsManager.shared
    private let audio = SpatialAudioManager.shared
    private let thermal = ThermalStateManager.shared

    // MARK: - State

    /// Whether sensory feedback is enabled
    var isEnabled: Bool = true

    /// Whether to use fallback haptics in low power mode
    var useFallbackInLowPower: Bool = true

    // MARK: - Initialization

    private init() {
        setupThermalObserver()
        print("[SensoryManager] Initialized")
    }

    private func setupThermalObserver() {
        NotificationCenter.default.addObserver(
            forName: .thermalStateDidChange,
            object: nil,
            queue: .main
        ) { [weak self] notification in
            self?.handleThermalChange(notification)
        }
    }

    private func handleThermalChange(_ notification: Notification) {
        guard let userInfo = notification.userInfo,
              let shouldDisable = userInfo["shouldDisableHaptics"] as? Bool else { return }

        if shouldDisable {
            print("[SensoryManager] Disabling haptics due to thermal state")
        }
    }

    // MARK: - Coordinated Triggers

    /// Trigger explosion at 3D position with synced haptics and audio
    func triggerExplosion(at position: SIMD3<Float>, intensity: Float = 1.0) {
        guard isEnabled else { return }

        // Play haptic (respects thermal state internally)
        if !thermal.shouldDisableHaptics {
            haptics.playHaptic(type: .explosion)
        }

        // Play spatial audio (simplified if thermal stressed)
        if thermal.shouldSimplifyAudio {
            // Use non-spatial fallback
            audio.playSound(named: "explosion", at: .zero, volume: intensity)
        } else {
            audio.playExplosion(at: position, intensity: intensity)
        }
    }

    /// Trigger optimization complete feedback
    func triggerOptimizationComplete() {
        guard isEnabled else { return }

        if !thermal.shouldDisableHaptics {
            haptics.playHaptic(type: .pulse)
        }

        audio.playSound(named: "optimize_complete", at: .zero, volume: 0.7)
    }

    /// Trigger ring wake-up feedback
    func triggerWakeUp() {
        guard isEnabled else { return }

        if !thermal.shouldDisableHaptics {
            haptics.playHaptic(type: .wakeUp)
        }
    }

    /// Trigger warning feedback
    func triggerWarning() {
        guard isEnabled else { return }

        if !thermal.shouldDisableHaptics {
            haptics.playHaptic(type: .warning)
        }
    }

    /// Trigger simple tap feedback
    func triggerTap() {
        guard isEnabled else { return }

        // Use low-power fallback if in low power mode
        if thermal.isLowPowerModeEnabled && useFallbackInLowPower {
            // UIImpactFeedbackGenerator is more power-efficient
            // (Would need to import UIKit for this, or skip)
            return
        }

        if !thermal.shouldDisableHaptics {
            haptics.playHaptic(type: .tap)
        }
    }

    // MARK: - Configuration

    /// Update listener position for spatial audio
    func updateListenerPosition(_ position: SIMD3<Float>) {
        audio.updateListenerPosition(position)
    }

    /// Update listener orientation for spatial audio
    func updateListenerOrientation(forward: SIMD3<Float>, up: SIMD3<Float>) {
        audio.updateListenerOrientation(forward: forward, up: up)
    }
}
```

Key: SensoryManager is the single entry point for all sensory feedback. It coordinates haptics and audio while respecting thermal state.
  </action>
  <verify>
```bash
ls -la /Users/matthewbyrden/Documents/Opta/opta-native/OptaApp/OptaApp/Managers/SensoryManager.swift
grep -l "triggerExplosion" /Users/matthewbyrden/Documents/Opta/opta-native/OptaApp/OptaApp/Managers/SensoryManager.swift
```
Expected: SensoryManager exists coordinating haptics, audio, and thermal state
  </verify>
  <done>SensoryManager created as unified orchestrator for all sensory feedback</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] 5 AHAP files exist in Haptics/Resources/
- [ ] ring_explosion.ahap has parameter curves for organic decay
- [ ] HapticsManager loads patterns from AHAP files at init
- [ ] HapticsManager has fallback to programmatic haptics
- [ ] SpatialAudioManager exists with AVAudioEnvironmentNode
- [ ] Player pool of 4 nodes for concurrent sounds
- [ ] Coordinate scale factor for visual-to-audio transform
- [ ] ThermalStateManager monitors ProcessInfo.thermalState
- [ ] Quality reduction levels defined for each thermal state
- [ ] SensoryManager coordinates all sensory feedback
- [ ] Thermal state respected in all trigger methods
</verification>

<success_criteria>
- AHAP files are valid JSON and load without errors
- Haptics use pre-loaded patterns, not runtime JSON parsing
- Spatial audio positions sounds correctly in 3D space
- Thermal degradation gracefully disables haptics at .serious
- SensoryManager provides single entry point for all feedback
- Ring explosion feels "organic" with parameter curve decay
</success_criteria>

<output>
After completion, create `.planning/phases/75-premium-polish-haptics-audio/75-01-SUMMARY.md`
</output>
