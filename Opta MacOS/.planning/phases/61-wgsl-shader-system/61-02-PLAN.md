# Plan 61-02: SDF Primitives & Glass Material

## Wave: 1 (Independent)

## Objective

Create WGSL shader library for SDF (Signed Distance Field) primitives and a physically-based glass material with fresnel effect.

## Execution Context

**Reference Documents:**
- `Gemini Deep Research/Hardware & Platform Knowledge/wgpu-SwiftUI-iOS-macOS-Integration.md`
- Inigo Quilez SDF functions reference

**Key Insights:**
- SDFs enable resolution-independent shapes
- Glass requires fresnel (view-angle reflectivity)
- Apple GPUs handle branching well in fragment shaders

## Context

**Depends on:**
- Plan 61-01 (ShaderLibrary infrastructure)

**Builds foundation for:**
- Plan 61-03 (Effects that use SDFs)
- Plan 62 (SwiftUI MetalView integration)

## Tasks

### Task 1: Create SDF primitives shader include

**File:** `opta-native/opta-render/shaders/includes/sdf.wgsl`

```wgsl
// Signed Distance Field primitives
// Based on Inigo Quilez's SDF functions

// 2D Primitives

fn sdf_circle(p: vec2<f32>, r: f32) -> f32 {
    return length(p) - r;
}

fn sdf_box(p: vec2<f32>, b: vec2<f32>) -> f32 {
    let d = abs(p) - b;
    return length(max(d, vec2<f32>(0.0))) + min(max(d.x, d.y), 0.0);
}

fn sdf_rounded_box(p: vec2<f32>, b: vec2<f32>, r: f32) -> f32 {
    let d = abs(p) - b + r;
    return length(max(d, vec2<f32>(0.0))) + min(max(d.x, d.y), 0.0) - r;
}

fn sdf_segment(p: vec2<f32>, a: vec2<f32>, b: vec2<f32>) -> f32 {
    let pa = p - a;
    let ba = b - a;
    let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
    return length(pa - ba * h);
}

fn sdf_capsule(p: vec2<f32>, a: vec2<f32>, b: vec2<f32>, r: f32) -> f32 {
    return sdf_segment(p, a, b) - r;
}

fn sdf_triangle(p: vec2<f32>, p0: vec2<f32>, p1: vec2<f32>, p2: vec2<f32>) -> f32 {
    let e0 = p1 - p0;
    let e1 = p2 - p1;
    let e2 = p0 - p2;
    let v0 = p - p0;
    let v1 = p - p1;
    let v2 = p - p2;
    let pq0 = v0 - e0 * clamp(dot(v0, e0) / dot(e0, e0), 0.0, 1.0);
    let pq1 = v1 - e1 * clamp(dot(v1, e1) / dot(e1, e1), 0.0, 1.0);
    let pq2 = v2 - e2 * clamp(dot(v2, e2) / dot(e2, e2), 0.0, 1.0);
    let s = sign(e0.x * e2.y - e0.y * e2.x);
    let d = min(min(
        vec2<f32>(dot(pq0, pq0), s * (v0.x * e0.y - v0.y * e0.x)),
        vec2<f32>(dot(pq1, pq1), s * (v1.x * e1.y - v1.y * e1.x))),
        vec2<f32>(dot(pq2, pq2), s * (v2.x * e2.y - v2.y * e2.x)));
    return -sqrt(d.x) * sign(d.y);
}

// 3D Primitives

fn sdf_sphere(p: vec3<f32>, r: f32) -> f32 {
    return length(p) - r;
}

fn sdf_box3d(p: vec3<f32>, b: vec3<f32>) -> f32 {
    let q = abs(p) - b;
    return length(max(q, vec3<f32>(0.0))) + min(max(q.x, max(q.y, q.z)), 0.0);
}

fn sdf_rounded_box3d(p: vec3<f32>, b: vec3<f32>, r: f32) -> f32 {
    let q = abs(p) - b;
    return length(max(q, vec3<f32>(0.0))) + min(max(q.x, max(q.y, q.z)), 0.0) - r;
}

fn sdf_torus(p: vec3<f32>, t: vec2<f32>) -> f32 {
    let q = vec2<f32>(length(p.xz) - t.x, p.y);
    return length(q) - t.y;
}

fn sdf_cylinder(p: vec3<f32>, h: f32, r: f32) -> f32 {
    let d = abs(vec2<f32>(length(p.xz), p.y)) - vec2<f32>(r, h);
    return min(max(d.x, d.y), 0.0) + length(max(d, vec2<f32>(0.0)));
}

// SDF Operations

fn sdf_union(d1: f32, d2: f32) -> f32 {
    return min(d1, d2);
}

fn sdf_subtract(d1: f32, d2: f32) -> f32 {
    return max(-d1, d2);
}

fn sdf_intersect(d1: f32, d2: f32) -> f32 {
    return max(d1, d2);
}

fn sdf_smooth_union(d1: f32, d2: f32, k: f32) -> f32 {
    let h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);
    return mix(d2, d1, h) - k * h * (1.0 - h);
}

fn sdf_smooth_subtract(d1: f32, d2: f32, k: f32) -> f32 {
    let h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);
    return mix(d2, -d1, h) + k * h * (1.0 - h);
}

fn sdf_smooth_intersect(d1: f32, d2: f32, k: f32) -> f32 {
    let h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);
    return mix(d2, d1, h) + k * h * (1.0 - h);
}

// Utility

fn sdf_annular(d: f32, r: f32) -> f32 {
    return abs(d) - r;
}

fn sdf_round(d: f32, r: f32) -> f32 {
    return d - r;
}
```

### Task 2: Create glass material shader include

**File:** `opta-native/opta-render/shaders/includes/glass.wgsl`

```wgsl
// Glass material with fresnel effect

#include "math.wgsl"

/// Schlick's fresnel approximation.
/// F0 is reflectance at normal incidence (0.04 for glass).
fn fresnel_schlick(cos_theta: f32, f0: f32) -> f32 {
    return f0 + (1.0 - f0) * pow(saturate(1.0 - cos_theta), 5.0);
}

/// Fresnel for vec3 F0 (colored reflectance).
fn fresnel_schlick3(cos_theta: f32, f0: vec3<f32>) -> vec3<f32> {
    return f0 + (1.0 - f0) * pow(saturate(1.0 - cos_theta), 5.0);
}

/// Glass material parameters.
struct GlassMaterial {
    /// Index of refraction (1.5 for common glass).
    ior: f32,
    /// Tint color for transmitted light.
    tint: vec3<f32>,
    /// Roughness for blurry glass (0 = perfect, 1 = frosted).
    roughness: f32,
    /// Opacity (1 = fully transparent glass, 0 = invisible).
    opacity: f32,
}

/// Default glass material (clear glass).
fn glass_default() -> GlassMaterial {
    var mat: GlassMaterial;
    mat.ior = 1.5;
    mat.tint = vec3<f32>(1.0);
    mat.roughness = 0.0;
    mat.opacity = 1.0;
    return mat;
}

/// Calculate glass color given view direction and normal.
/// Returns blend of reflection and refraction with fresnel.
fn glass_shade(
    view_dir: vec3<f32>,
    normal: vec3<f32>,
    mat: GlassMaterial,
    env_color: vec3<f32>,
    background_color: vec3<f32>,
) -> vec4<f32> {
    // Calculate fresnel
    let n_dot_v = max(dot(normal, view_dir), 0.0);
    let f0 = pow((1.0 - mat.ior) / (1.0 + mat.ior), 2.0);
    let fresnel = fresnel_schlick(n_dot_v, f0);

    // Reflection contribution
    let reflection = env_color * fresnel;

    // Refraction/transmission contribution
    let transmission = background_color * mat.tint * (1.0 - fresnel);

    // Combine
    let color = reflection + transmission;
    return vec4<f32>(color, mat.opacity);
}

/// Simplified glass for 2D UI elements.
/// Uses screen-space normal approximation.
fn glass_2d(
    uv: vec2<f32>,
    center: vec2<f32>,
    radius: f32,
    mat: GlassMaterial,
    background: vec3<f32>,
    highlight: vec3<f32>,
) -> vec4<f32> {
    // Approximate normal from distance to center
    let d = uv - center;
    let dist = length(d) / radius;

    // Fake view angle based on distance from center
    let view_angle = saturate(1.0 - dist);

    // Apply fresnel
    let f0 = pow((1.0 - mat.ior) / (1.0 + mat.ior), 2.0);
    let fresnel = fresnel_schlick(view_angle, f0);

    // Edge highlight (more reflection at edges)
    let edge_glow = (1.0 - view_angle) * fresnel * highlight;

    // Center shows background through tint
    let center_color = background * mat.tint * (1.0 - fresnel * 0.5);

    let color = center_color + edge_glow;
    return vec4<f32>(color, mat.opacity);
}
```

### Task 3: Create color utilities shader include

**File:** `opta-native/opta-render/shaders/includes/color.wgsl`

```wgsl
// Color space utilities

/// Convert linear RGB to sRGB.
fn linear_to_srgb(linear: vec3<f32>) -> vec3<f32> {
    let cutoff = linear < vec3<f32>(0.0031308);
    let higher = vec3<f32>(1.055) * pow(linear, vec3<f32>(1.0/2.4)) - vec3<f32>(0.055);
    let lower = linear * vec3<f32>(12.92);
    return select(higher, lower, cutoff);
}

/// Convert sRGB to linear RGB.
fn srgb_to_linear(srgb: vec3<f32>) -> vec3<f32> {
    let cutoff = srgb < vec3<f32>(0.04045);
    let higher = pow((srgb + vec3<f32>(0.055)) / vec3<f32>(1.055), vec3<f32>(2.4));
    let lower = srgb / vec3<f32>(12.92);
    return select(higher, lower, cutoff);
}

/// Convert RGB to HSL.
fn rgb_to_hsl(rgb: vec3<f32>) -> vec3<f32> {
    let max_c = max(max(rgb.r, rgb.g), rgb.b);
    let min_c = min(min(rgb.r, rgb.g), rgb.b);
    let l = (max_c + min_c) * 0.5;

    if (max_c == min_c) {
        return vec3<f32>(0.0, 0.0, l);
    }

    let d = max_c - min_c;
    let s = select(d / (2.0 - max_c - min_c), d / (max_c + min_c), l > 0.5);

    var h: f32;
    if (max_c == rgb.r) {
        h = (rgb.g - rgb.b) / d + select(0.0, 6.0, rgb.g < rgb.b);
    } else if (max_c == rgb.g) {
        h = (rgb.b - rgb.r) / d + 2.0;
    } else {
        h = (rgb.r - rgb.g) / d + 4.0;
    }
    h /= 6.0;

    return vec3<f32>(h, s, l);
}

fn hue_to_rgb(p: f32, q: f32, t: f32) -> f32 {
    var t_adj = t;
    if (t_adj < 0.0) { t_adj += 1.0; }
    if (t_adj > 1.0) { t_adj -= 1.0; }
    if (t_adj < 1.0/6.0) { return p + (q - p) * 6.0 * t_adj; }
    if (t_adj < 1.0/2.0) { return q; }
    if (t_adj < 2.0/3.0) { return p + (q - p) * (2.0/3.0 - t_adj) * 6.0; }
    return p;
}

/// Convert HSL to RGB.
fn hsl_to_rgb(hsl: vec3<f32>) -> vec3<f32> {
    if (hsl.y == 0.0) {
        return vec3<f32>(hsl.z);
    }

    let q = select(hsl.z + hsl.y - hsl.z * hsl.y, hsl.z * (1.0 + hsl.y), hsl.z < 0.5);
    let p = 2.0 * hsl.z - q;

    return vec3<f32>(
        hue_to_rgb(p, q, hsl.x + 1.0/3.0),
        hue_to_rgb(p, q, hsl.x),
        hue_to_rgb(p, q, hsl.x - 1.0/3.0)
    );
}

/// Blend two colors with alpha.
fn blend_alpha(base: vec4<f32>, overlay: vec4<f32>) -> vec4<f32> {
    let a = overlay.a + base.a * (1.0 - overlay.a);
    if (a == 0.0) {
        return vec4<f32>(0.0);
    }
    let rgb = (overlay.rgb * overlay.a + base.rgb * base.a * (1.0 - overlay.a)) / a;
    return vec4<f32>(rgb, a);
}

/// Apply contrast adjustment.
fn adjust_contrast(color: vec3<f32>, contrast: f32) -> vec3<f32> {
    return (color - 0.5) * contrast + 0.5;
}

/// Apply brightness adjustment.
fn adjust_brightness(color: vec3<f32>, brightness: f32) -> vec3<f32> {
    return color + brightness;
}

/// Apply saturation adjustment.
fn adjust_saturation(color: vec3<f32>, saturation: f32) -> vec3<f32> {
    let luminance = dot(color, vec3<f32>(0.2126, 0.7152, 0.0722));
    return mix(vec3<f32>(luminance), color, saturation);
}
```

### Task 4: Register includes in ShaderLibrary

**Update:** `opta-native/opta-render/src/shader/library.rs`

Add embedded includes for sdf, glass, and color:

```rust
impl ShaderLibrary {
    pub fn new(device: &Device) -> Self {
        let mut preprocessor = ShaderPreprocessor::new();

        // Register built-in includes
        preprocessor.register_include("math.wgsl", include_str!("../../shaders/includes/math.wgsl"));
        preprocessor.register_include("transforms.wgsl", include_str!("../../shaders/includes/transforms.wgsl"));
        preprocessor.register_include("sdf.wgsl", include_str!("../../shaders/includes/sdf.wgsl"));
        preprocessor.register_include("glass.wgsl", include_str!("../../shaders/includes/glass.wgsl"));
        preprocessor.register_include("color.wgsl", include_str!("../../shaders/includes/color.wgsl"));

        Self {
            preprocessor,
            loader: ShaderLoader::new(),
        }
    }
}
```

### Task 5: Create SDF demo shader

**File:** `opta-native/opta-render/shaders/sdf_demo.wgsl`

```wgsl
// SDF Demo Shader - demonstrates SDF primitives with glass material

#include "sdf.wgsl"
#include "glass.wgsl"
#include "color.wgsl"

struct Uniforms {
    resolution: vec2<f32>,
    time: f32,
    _padding: f32,
}

@group(0) @binding(0)
var<uniform> uniforms: Uniforms;

struct VertexOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv: vec2<f32>,
}

@vertex
fn vs_main(@builtin(vertex_index) vertex_index: u32) -> VertexOutput {
    // Fullscreen triangle
    var positions = array<vec2<f32>, 3>(
        vec2<f32>(-1.0, -1.0),
        vec2<f32>(3.0, -1.0),
        vec2<f32>(-1.0, 3.0)
    );

    var output: VertexOutput;
    output.position = vec4<f32>(positions[vertex_index], 0.0, 1.0);
    output.uv = positions[vertex_index] * 0.5 + 0.5;
    return output;
}

@fragment
fn fs_main(input: VertexOutput) -> @location(0) vec4<f32> {
    let aspect = uniforms.resolution.x / uniforms.resolution.y;
    var uv = input.uv * 2.0 - 1.0;
    uv.x *= aspect;

    // Animated position
    let t = uniforms.time * 0.5;

    // Multiple SDF shapes
    let circle = sdf_circle(uv - vec2<f32>(sin(t) * 0.5, 0.0), 0.3);
    let box = sdf_rounded_box(uv - vec2<f32>(-0.5, sin(t * 1.3) * 0.3), vec2<f32>(0.2, 0.2), 0.05);

    // Smooth union of shapes
    let d = sdf_smooth_union(circle, box, 0.2);

    // Glass material
    var mat = glass_default();
    mat.tint = vec3<f32>(0.9, 0.95, 1.0);  // Slight blue tint
    mat.ior = 1.5;

    // Background gradient
    let bg = mix(
        vec3<f32>(0.1, 0.1, 0.15),
        vec3<f32>(0.2, 0.15, 0.25),
        input.uv.y
    );

    // Highlight color
    let highlight = vec3<f32>(1.0, 0.9, 0.8);

    // Apply glass effect inside SDF
    if (d < 0.0) {
        let center = vec2<f32>(sin(t) * 0.25, 0.0);
        let glass_color = glass_2d(uv, center, 0.5, mat, bg, highlight);
        return glass_color;
    }

    // Anti-aliased edge
    let aa = fwidth(d) * 1.5;
    let edge = smoothstep(0.0, aa, d);

    // Edge glow
    let glow = exp(-d * 8.0) * vec3<f32>(0.4, 0.5, 0.7);

    let final_color = bg + glow * (1.0 - edge);
    return vec4<f32>(linear_to_srgb(final_color), 1.0);
}
```

### Task 6: Add tests for SDF and glass shaders

**File:** `opta-native/opta-render/tests/shader_sdf_test.rs`

```rust
//! Tests for SDF and glass shader includes.

use opta_render::shader::{ShaderLibrary, ShaderPreprocessor};

#[test]
fn test_sdf_include_available() {
    let mut preprocessor = ShaderPreprocessor::new();
    preprocessor.register_include("sdf.wgsl", include_str!("../shaders/includes/sdf.wgsl"));

    let source = r#"
#include "sdf.wgsl"

fn main() {
    let d = sdf_circle(vec2<f32>(0.0), 1.0);
}
"#;

    let result = preprocessor.process(source);
    assert!(result.is_ok());
    let processed = result.unwrap();
    assert!(processed.contains("fn sdf_circle"));
}

#[test]
fn test_glass_include_available() {
    let mut preprocessor = ShaderPreprocessor::new();
    preprocessor.register_include("math.wgsl", include_str!("../shaders/includes/math.wgsl"));
    preprocessor.register_include("glass.wgsl", include_str!("../shaders/includes/glass.wgsl"));

    let source = r#"
#include "glass.wgsl"

fn main() {
    let f = fresnel_schlick(0.5, 0.04);
}
"#;

    let result = preprocessor.process(source);
    assert!(result.is_ok());
    let processed = result.unwrap();
    assert!(processed.contains("fn fresnel_schlick"));
}

#[test]
fn test_color_include_available() {
    let mut preprocessor = ShaderPreprocessor::new();
    preprocessor.register_include("color.wgsl", include_str!("../shaders/includes/color.wgsl"));

    let source = r#"
#include "color.wgsl"

fn main() {
    let srgb = linear_to_srgb(vec3<f32>(0.5));
}
"#;

    let result = preprocessor.process(source);
    assert!(result.is_ok());
    let processed = result.unwrap();
    assert!(processed.contains("fn linear_to_srgb"));
}

#[test]
fn test_nested_include_glass_needs_math() {
    let mut preprocessor = ShaderPreprocessor::new();
    preprocessor.register_include("math.wgsl", include_str!("../shaders/includes/math.wgsl"));
    preprocessor.register_include("glass.wgsl", include_str!("../shaders/includes/glass.wgsl"));

    // Glass includes math.wgsl, so saturate should be available
    let source = r#"
#include "glass.wgsl"

fn main() {
    let x = saturate(1.5);
}
"#;

    let result = preprocessor.process(source);
    assert!(result.is_ok());
    let processed = result.unwrap();
    // Both math and glass functions should be present
    assert!(processed.contains("fn saturate"));
    assert!(processed.contains("fn fresnel_schlick"));
}
```

## Verification

```bash
cd opta-native
cargo check -p opta-render
cargo clippy -p opta-render -- -D warnings
cargo test -p opta-render
```

## Success Criteria

- [ ] SDF primitives shader include with 2D and 3D shapes
- [ ] Glass material shader with fresnel effect
- [ ] Color utilities for sRGB/linear conversion
- [ ] Demo shader combining SDF + glass
- [ ] All shader includes registered in ShaderLibrary
- [ ] Tests pass for include resolution

## Output

- Complete SDF library for resolution-independent shapes
- Glass material ready for UI effects
- Color space utilities for correct rendering
