# Plan 61-01: Shader Infrastructure

## Wave: 1 (Independent)

## Objective

Build the WGSL shader loading, compilation, and hot-reload infrastructure for the opta-render crate.

## Execution Context

**Reference Documents:**
- `Gemini Deep Research/Hardware & Platform Knowledge/wgpu-SwiftUI-iOS-macOS-Integration.md`
- wgpu documentation on shader modules

**Key Insights:**
- wgpu uses WGSL natively (no GLSL conversion needed)
- Shader modules created from WGSL source strings
- Include system for modular shader code
- Watch mode for development hot-reload

## Context

**Depends on:**
- Plan 60-01 (GpuContext with device)
- Plan 60-02 (RenderPipeline2D with basic shader)

**Builds foundation for:**
- Plan 61-02 (SDF primitives)
- Plan 61-03 (Effects shaders)

## Tasks

### Task 1: Create shader module structure

**File:** `opta-native/opta-render/src/shader/mod.rs`

```rust
//! WGSL shader module loading and management.

mod loader;
mod library;
mod preprocessor;

pub use loader::{ShaderLoader, ShaderSource};
pub use library::ShaderLibrary;
pub use preprocessor::ShaderPreprocessor;
```

### Task 2: Implement shader loader

**File:** `opta-native/opta-render/src/shader/loader.rs`

```rust
use std::collections::HashMap;
use std::path::{Path, PathBuf};
use wgpu::{Device, ShaderModule, ShaderModuleDescriptor, ShaderSource as WgpuSource};

/// Source for a shader module.
#[derive(Debug, Clone)]
pub enum ShaderSource {
    /// Embedded WGSL source code.
    Embedded(&'static str),
    /// File path to load WGSL from.
    File(PathBuf),
    /// Pre-processed WGSL string.
    Processed(String),
}

/// Loads and compiles WGSL shaders.
pub struct ShaderLoader {
    shader_dir: Option<PathBuf>,
    cache: HashMap<String, ShaderModule>,
}

impl ShaderLoader {
    pub fn new() -> Self;
    pub fn with_shader_dir(dir: impl AsRef<Path>) -> Self;

    /// Load shader from source.
    pub fn load(&mut self, device: &Device, name: &str, source: ShaderSource) -> &ShaderModule;

    /// Load shader from embedded source.
    pub fn load_embedded(&mut self, device: &Device, name: &str, wgsl: &'static str) -> &ShaderModule;

    /// Load shader from file (for hot-reload).
    pub fn load_file(&mut self, device: &Device, name: &str, path: &Path) -> Result<&ShaderModule, ShaderError>;

    /// Reload a shader (for hot-reload).
    pub fn reload(&mut self, device: &Device, name: &str) -> Result<(), ShaderError>;

    /// Get a cached shader module.
    pub fn get(&self, name: &str) -> Option<&ShaderModule>;
}
```

### Task 3: Implement shader preprocessor

**File:** `opta-native/opta-render/src/shader/preprocessor.rs`

Support simple #include directives for modular shaders:

```rust
use std::collections::HashSet;

/// Preprocessor for WGSL shaders.
///
/// Supports:
/// - #include "filename.wgsl" - include another shader file
/// - #define NAME VALUE - simple text replacement
pub struct ShaderPreprocessor {
    includes: HashMap<String, String>,
    defines: HashMap<String, String>,
}

impl ShaderPreprocessor {
    pub fn new() -> Self;

    /// Register an include file.
    pub fn register_include(&mut self, name: &str, source: &str);

    /// Add a define.
    pub fn define(&mut self, name: &str, value: &str);

    /// Process WGSL source, resolving includes and defines.
    pub fn process(&self, source: &str) -> Result<String, PreprocessError>;
}

#[derive(Debug, Clone, thiserror::Error)]
pub enum PreprocessError {
    #[error("Include not found: {0}")]
    IncludeNotFound(String),
    #[error("Circular include detected: {0}")]
    CircularInclude(String),
    #[error("Max include depth exceeded")]
    MaxDepthExceeded,
}
```

### Task 4: Create shader library with common includes

**File:** `opta-native/opta-render/src/shader/library.rs`

```rust
/// Built-in shader library with common utilities.
pub struct ShaderLibrary {
    preprocessor: ShaderPreprocessor,
    loader: ShaderLoader,
}

impl ShaderLibrary {
    pub fn new(device: &Device) -> Self;

    /// Get the preprocessor for adding custom includes.
    pub fn preprocessor_mut(&mut self) -> &mut ShaderPreprocessor;

    /// Load a shader with preprocessing.
    pub fn load_shader(
        &mut self,
        device: &Device,
        name: &str,
        source: &str,
    ) -> Result<&ShaderModule, ShaderError>;

    /// Get a loaded shader.
    pub fn get_shader(&self, name: &str) -> Option<&ShaderModule>;
}
```

### Task 5: Create common shader includes

**File:** `opta-native/opta-render/shaders/includes/math.wgsl`

```wgsl
// Common math utilities

const PI: f32 = 3.14159265359;
const TAU: f32 = 6.28318530718;
const E: f32 = 2.71828182846;

fn saturate(x: f32) -> f32 {
    return clamp(x, 0.0, 1.0);
}

fn saturate3(v: vec3<f32>) -> vec3<f32> {
    return clamp(v, vec3<f32>(0.0), vec3<f32>(1.0));
}

fn lerp(a: f32, b: f32, t: f32) -> f32 {
    return a + (b - a) * t;
}

fn lerp3(a: vec3<f32>, b: vec3<f32>, t: f32) -> vec3<f32> {
    return a + (b - a) * t;
}

fn remap(value: f32, in_min: f32, in_max: f32, out_min: f32, out_max: f32) -> f32 {
    return out_min + (value - in_min) * (out_max - out_min) / (in_max - in_min);
}
```

**File:** `opta-native/opta-render/shaders/includes/transforms.wgsl`

```wgsl
// Transform utilities

fn rotate2d(angle: f32) -> mat2x2<f32> {
    let c = cos(angle);
    let s = sin(angle);
    return mat2x2<f32>(c, -s, s, c);
}

fn rotate3d_x(angle: f32) -> mat3x3<f32> {
    let c = cos(angle);
    let s = sin(angle);
    return mat3x3<f32>(
        1.0, 0.0, 0.0,
        0.0, c, -s,
        0.0, s, c
    );
}

fn rotate3d_y(angle: f32) -> mat3x3<f32> {
    let c = cos(angle);
    let s = sin(angle);
    return mat3x3<f32>(
        c, 0.0, s,
        0.0, 1.0, 0.0,
        -s, 0.0, c
    );
}

fn rotate3d_z(angle: f32) -> mat3x3<f32> {
    let c = cos(angle);
    let s = sin(angle);
    return mat3x3<f32>(
        c, -s, 0.0,
        s, c, 0.0,
        0.0, 0.0, 1.0
    );
}
```

### Task 6: Add shader error types

**File:** `opta-native/opta-render/src/shader/error.rs`

```rust
use thiserror::Error;

#[derive(Debug, Clone, Error)]
pub enum ShaderError {
    #[error("Shader not found: {0}")]
    NotFound(String),

    #[error("Shader compilation failed: {0}")]
    CompilationFailed(String),

    #[error("File read error: {0}")]
    FileReadError(String),

    #[error("Preprocessor error: {0}")]
    PreprocessError(#[from] PreprocessError),
}
```

### Task 7: Add hot-reload support (dev mode)

**File:** `opta-native/opta-render/src/shader/watcher.rs`

```rust
#[cfg(feature = "shader-hot-reload")]
use notify::{Watcher, RecursiveMode, watcher};

/// Watches shader files for changes and triggers reloads.
#[cfg(feature = "shader-hot-reload")]
pub struct ShaderWatcher {
    watcher: RecommendedWatcher,
    changed_files: Arc<Mutex<HashSet<PathBuf>>>,
}

#[cfg(feature = "shader-hot-reload")]
impl ShaderWatcher {
    pub fn new(shader_dir: &Path) -> Result<Self, notify::Error>;

    /// Check for changed files and return them.
    pub fn poll_changes(&self) -> Vec<PathBuf>;

    /// Stop watching.
    pub fn stop(self);
}
```

### Task 8: Update lib.rs and add tests

**File:** `opta-native/opta-render/src/lib.rs` (update)

Add shader module and exports:
```rust
pub mod shader;

pub use shader::{ShaderLoader, ShaderSource, ShaderLibrary, ShaderPreprocessor};
```

**File:** `opta-native/opta-render/tests/shader_test.rs`

```rust
#[test]
fn test_shader_loader_embedded() {
    // Test loading embedded shader
}

#[test]
fn test_preprocessor_includes() {
    // Test include resolution
}

#[test]
fn test_preprocessor_circular_include() {
    // Test circular include detection
}

#[test]
fn test_shader_library_math_include() {
    // Test math.wgsl include
}
```

## Verification

```bash
cd opta-native
cargo check -p opta-render
cargo clippy -p opta-render -- -D warnings
cargo test -p opta-render
```

## Success Criteria

- [ ] ShaderLoader can load embedded and file-based WGSL
- [ ] ShaderPreprocessor resolves #include directives
- [ ] ShaderLibrary provides common math/transform utilities
- [ ] Hot-reload support available via feature flag
- [ ] All tests pass

## Output

- Shader infrastructure ready for SDF and effects shaders
- Common shader includes for reuse across effects
- Development hot-reload capability
