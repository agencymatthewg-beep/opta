# Plan 66-02: GPU Memory & ASTC Textures

## Wave: 2 (Depends on 66-01)

## Objective

Optimize GPU memory usage through ASTC texture compression, memory pools, and efficient resource management.

## Execution Context

**Reference Documents:**
- Apple ASTC compression guide
- wgpu resource management

**Key Insights:**
- ASTC provides 4:1 to 8:1 compression with minimal quality loss
- Memory pools reduce allocation overhead
- Texture atlases reduce draw calls

## Context

**Depends on:**
- Phase 66-01 (LTO optimization)

**Builds foundation for:**
- Mobile performance (iOS/Android)
- Lower VRAM usage

## Tasks

### Task 1: Create texture compression utility

**File:** `opta-native/opta-render/src/texture/compression.rs`

```rust
//! Texture compression utilities for ASTC and BC formats.

use std::path::Path;

/// Supported texture formats.
#[derive(Debug, Clone, Copy)]
pub enum TextureFormat {
    /// Uncompressed RGBA8.
    Rgba8,
    /// ASTC 4x4 (iOS/macOS with Apple Silicon).
    Astc4x4,
    /// ASTC 8x8 (higher compression, mobile).
    Astc8x8,
    /// BC7 (Windows/Desktop).
    Bc7,
}

impl TextureFormat {
    /// Get wgpu texture format.
    pub fn to_wgpu(&self) -> wgpu::TextureFormat {
        match self {
            TextureFormat::Rgba8 => wgpu::TextureFormat::Rgba8Unorm,
            TextureFormat::Astc4x4 => wgpu::TextureFormat::Astc4x4RgbaUnorm,
            TextureFormat::Astc8x8 => wgpu::TextureFormat::Astc8x8RgbaUnorm,
            TextureFormat::Bc7 => wgpu::TextureFormat::Bc7RgbaUnorm,
        }
    }

    /// Bytes per pixel (for uncompressed) or per block.
    pub fn bytes_per_block(&self) -> usize {
        match self {
            TextureFormat::Rgba8 => 4,
            TextureFormat::Astc4x4 => 16, // 16 bytes per 4x4 block
            TextureFormat::Astc8x8 => 16, // 16 bytes per 8x8 block
            TextureFormat::Bc7 => 16,     // 16 bytes per 4x4 block
        }
    }

    /// Block dimensions.
    pub fn block_size(&self) -> (u32, u32) {
        match self {
            TextureFormat::Rgba8 => (1, 1),
            TextureFormat::Astc4x4 => (4, 4),
            TextureFormat::Astc8x8 => (8, 8),
            TextureFormat::Bc7 => (4, 4),
        }
    }

    /// Calculate storage size for texture.
    pub fn storage_size(&self, width: u32, height: u32) -> usize {
        let (bw, bh) = self.block_size();
        let blocks_x = (width + bw - 1) / bw;
        let blocks_y = (height + bh - 1) / bh;
        (blocks_x * blocks_y) as usize * self.bytes_per_block()
    }

    /// Best format for current platform.
    pub fn best_for_platform() -> Self {
        #[cfg(target_os = "macos")]
        {
            // Apple Silicon supports ASTC natively
            TextureFormat::Astc4x4
        }
        #[cfg(target_os = "windows")]
        {
            TextureFormat::Bc7
        }
        #[cfg(target_os = "linux")]
        {
            TextureFormat::Bc7
        }
        #[cfg(target_os = "ios")]
        {
            TextureFormat::Astc4x4
        }
        #[cfg(target_os = "android")]
        {
            TextureFormat::Astc8x8
        }
        #[cfg(not(any(
            target_os = "macos",
            target_os = "windows",
            target_os = "linux",
            target_os = "ios",
            target_os = "android"
        )))]
        {
            TextureFormat::Rgba8
        }
    }
}

/// Load and optionally compress a texture.
pub struct TextureLoader {
    format: TextureFormat,
}

impl TextureLoader {
    pub fn new(format: TextureFormat) -> Self {
        Self { format }
    }

    /// Load texture from file.
    pub fn load(&self, path: impl AsRef<Path>) -> Result<TextureData, TextureError> {
        let path = path.as_ref();
        let extension = path.extension()
            .and_then(|e| e.to_str())
            .unwrap_or("");

        match extension {
            "astc" => self.load_astc(path),
            "ktx" | "ktx2" => self.load_ktx(path),
            _ => self.load_image(path),
        }
    }

    fn load_image(&self, path: &Path) -> Result<TextureData, TextureError> {
        let img = image::open(path)
            .map_err(|e| TextureError::LoadFailed(e.to_string()))?;
        let rgba = img.to_rgba8();
        let (width, height) = rgba.dimensions();

        Ok(TextureData {
            width,
            height,
            format: TextureFormat::Rgba8,
            data: rgba.into_raw(),
        })
    }

    fn load_astc(&self, _path: &Path) -> Result<TextureData, TextureError> {
        // ASTC files are pre-compressed
        todo!("Implement ASTC loading")
    }

    fn load_ktx(&self, _path: &Path) -> Result<TextureData, TextureError> {
        // KTX container format
        todo!("Implement KTX loading")
    }
}

/// Loaded texture data.
pub struct TextureData {
    pub width: u32,
    pub height: u32,
    pub format: TextureFormat,
    pub data: Vec<u8>,
}

#[derive(Debug)]
pub enum TextureError {
    LoadFailed(String),
    CompressionFailed(String),
    UnsupportedFormat(String),
}
```

### Task 2: Create GPU memory pool

**File:** `opta-native/opta-render/src/memory/pool.rs`

```rust
//! GPU memory pooling for efficient resource allocation.

use std::collections::HashMap;
use wgpu::{Device, Buffer, BufferUsages, BufferDescriptor};

/// Size classes for buffer pooling.
#[derive(Debug, Clone, Copy, Hash, Eq, PartialEq)]
pub enum BufferSizeClass {
    Tiny,    // 256 bytes
    Small,   // 1 KB
    Medium,  // 4 KB
    Large,   // 16 KB
    Huge,    // 64 KB
}

impl BufferSizeClass {
    pub fn size(&self) -> u64 {
        match self {
            BufferSizeClass::Tiny => 256,
            BufferSizeClass::Small => 1024,
            BufferSizeClass::Medium => 4096,
            BufferSizeClass::Large => 16384,
            BufferSizeClass::Huge => 65536,
        }
    }

    pub fn from_size(size: u64) -> Self {
        if size <= 256 {
            BufferSizeClass::Tiny
        } else if size <= 1024 {
            BufferSizeClass::Small
        } else if size <= 4096 {
            BufferSizeClass::Medium
        } else if size <= 16384 {
            BufferSizeClass::Large
        } else {
            BufferSizeClass::Huge
        }
    }
}

/// GPU buffer pool to reduce allocations.
pub struct BufferPool {
    pools: HashMap<(BufferSizeClass, BufferUsages), Vec<Buffer>>,
    allocated: usize,
    reused: usize,
}

impl BufferPool {
    pub fn new() -> Self {
        Self {
            pools: HashMap::new(),
            allocated: 0,
            reused: 0,
        }
    }

    /// Acquire a buffer from the pool or allocate a new one.
    pub fn acquire(
        &mut self,
        device: &Device,
        size: u64,
        usage: BufferUsages,
        label: Option<&str>,
    ) -> Buffer {
        let size_class = BufferSizeClass::from_size(size);
        let key = (size_class, usage);

        // Try to reuse from pool
        if let Some(pool) = self.pools.get_mut(&key) {
            if let Some(buffer) = pool.pop() {
                self.reused += 1;
                return buffer;
            }
        }

        // Allocate new buffer
        self.allocated += 1;
        device.create_buffer(&BufferDescriptor {
            label,
            size: size_class.size(),
            usage,
            mapped_at_creation: false,
        })
    }

    /// Return a buffer to the pool.
    pub fn release(&mut self, buffer: Buffer, usage: BufferUsages) {
        let size_class = BufferSizeClass::from_size(buffer.size());
        let key = (size_class, usage);

        self.pools
            .entry(key)
            .or_insert_with(Vec::new)
            .push(buffer);
    }

    /// Get pool statistics.
    pub fn stats(&self) -> PoolStats {
        let pooled: usize = self.pools.values().map(|v| v.len()).sum();
        PoolStats {
            allocated: self.allocated,
            reused: self.reused,
            pooled,
            reuse_rate: if self.allocated > 0 {
                self.reused as f32 / (self.allocated + self.reused) as f32
            } else {
                0.0
            },
        }
    }

    /// Clear all pooled buffers.
    pub fn clear(&mut self) {
        self.pools.clear();
    }
}

impl Default for BufferPool {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Debug, Clone)]
pub struct PoolStats {
    pub allocated: usize,
    pub reused: usize,
    pub pooled: usize,
    pub reuse_rate: f32,
}
```

### Task 3: Create memory module

**File:** `opta-native/opta-render/src/memory/mod.rs`

```rust
//! GPU memory management.

mod pool;

pub use pool::{BufferPool, BufferSizeClass, PoolStats};
```

## Verification

```bash
cd opta-native
cargo test -p opta-render -- memory
cargo check -p opta-render
```

## Success Criteria

- [ ] Texture formats support ASTC/BC7
- [ ] Buffer pool reduces allocations
- [ ] Pool reuse rate > 50% in steady state
- [ ] Memory stats available for debugging

## Output

- Texture compression utilities
- GPU buffer pooling system
- Platform-optimized texture formats
