---
phase: 04-conflict-detection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [mcp-server/src/opta_mcp/conflicts.py, mcp-server/src/opta_mcp/server.py, src-tauri/src/conflicts.rs, src-tauri/src/lib.rs, src/types/conflicts.ts, src/hooks/useConflicts.ts]
autonomous: true
---

<objective>
Implement competitor tool detection engine to identify conflicting optimization software.

Purpose: Detect when other optimization tools (GeForce Experience, Razer Cortex, OMEN Hub, MSI Afterburner) are running or installed, so users can be warned about conflicts.
Output: Python detection functions, Rust Tauri command, React hook for conflict data.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Prior phase context (process listing):
@.planning/phases/03-process-management/03-01-SUMMARY.md

Source files to extend:
@mcp-server/src/opta_mcp/server.py
@mcp-server/src/opta_mcp/processes.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create conflict detection module in Python MCP server</name>
  <files>mcp-server/src/opta_mcp/conflicts.py, mcp-server/src/opta_mcp/server.py</files>
  <action>
Create new `conflicts.py` module with:

1. `COMPETITOR_TOOLS` dict defining known optimization tools:
   ```python
   COMPETITOR_TOOLS = {
       "geforce_experience": {
           "name": "NVIDIA GeForce Experience",
           "process_names": ["nvcontainer", "nvidia share", "nvidia web helper"],
           "description": "NVIDIA's game optimization and driver updater",
           "conflict_severity": "high",
           "recommendation": "GeForce Experience optimizes the same settings. Consider disabling its auto-optimization."
       },
       "razer_cortex": {
           "name": "Razer Cortex",
           "process_names": ["razer cortex", "rzsynapse", "razer central"],
           "description": "Razer's game booster and system optimizer",
           "conflict_severity": "high",
           "recommendation": "Razer Cortex's Game Booster may conflict. Disable it while using Opta."
       },
       "msi_afterburner": {
           "name": "MSI Afterburner",
           "process_names": ["msiafterburner", "rtss"],
           "description": "GPU overclocking and monitoring tool",
           "conflict_severity": "medium",
           "recommendation": "Afterburner's OSD and monitoring can coexist, but avoid conflicting GPU settings."
       },
       "omen_hub": {
           "name": "HP OMEN Gaming Hub",
           "process_names": ["omen command center", "omen gaming hub"],
           "description": "HP's optimization suite for OMEN devices",
           "conflict_severity": "high",
           "recommendation": "OMEN Hub's performance modes may conflict. Use one optimizer at a time."
       },
       "xbox_game_bar": {
           "name": "Xbox Game Bar",
           "process_names": ["gamebar", "gamebarftsvc"],
           "description": "Windows built-in game overlay",
           "conflict_severity": "low",
           "recommendation": "Game Bar's overlay can impact performance. Consider disabling if not needed."
       },
       "discord": {
           "name": "Discord (Game Activity)",
           "process_names": ["discord"],
           "description": "Discord's game activity detection",
           "conflict_severity": "low",
           "recommendation": "Discord's overlay may use resources. Disable overlay if not needed."
       }
   }
   ```

2. `detect_running_conflicts()` function:
   - Get process list from processes.py
   - Match against COMPETITOR_TOOLS process_names (case-insensitive)
   - Return list of detected conflicts with severity and recommendations

3. `get_conflict_summary()` function:
   - Returns total count, high/medium/low severity counts
   - List of active conflicts with details

4. Register `detect_conflicts` tool in server.py

Use process list from existing processes module - don't duplicate psutil calls.
  </action>
  <verify>
cd mcp-server && uv run python -c "from opta_mcp.conflicts import detect_running_conflicts; import json; print(json.dumps(detect_running_conflicts(), indent=2))"
  </verify>
  <done>detect_conflicts MCP tool returns list of detected competitor tools</done>
</task>

<task type="auto">
  <name>Task 2: Create Rust command and TypeScript types for conflict detection</name>
  <files>src-tauri/src/conflicts.rs, src-tauri/src/lib.rs, src/types/conflicts.ts</files>
  <action>
1. Create `conflicts.rs` module with:
   - `ConflictInfo` struct: tool_id, name, description, severity (high/medium/low), recommendation, process_names
   - `ConflictSummary` struct: total_count, high_count, medium_count, low_count, conflicts (Vec<ConflictInfo>)
   - `#[tauri::command] async fn detect_conflicts()` - invoke Python MCP tool
   - Parse JSON response into typed structs

2. Register in `lib.rs`:
   - Add `mod conflicts;`
   - Add `conflicts::detect_conflicts` to invoke_handler

3. Create `src/types/conflicts.ts`:
   - `ConflictSeverity` type: "high" | "medium" | "low"
   - `ConflictInfo` interface matching Rust struct
   - `ConflictSummary` interface

Follow established patterns from telemetry.rs and processes.rs.
  </action>
  <verify>
cd src-tauri && cargo check
  </verify>
  <done>Rust command compiles and TypeScript types match</done>
</task>

<task type="auto">
  <name>Task 3: Create useConflicts hook for frontend</name>
  <files>src/hooks/useConflicts.ts</files>
  <action>
1. Create `useConflicts.ts` hook:
   - Poll every 10 seconds (conflicts change infrequently)
   - Return { conflicts, summary, loading, error, refresh }
   - summary includes severity counts for UI badges

2. Hook interface:
   ```typescript
   interface UseConflictsResult {
     conflicts: ConflictInfo[];
     summary: ConflictSummary | null;
     loading: boolean;
     error: string | null;
     refresh: () => void;
   }
   ```

3. Follow useTelemetry pattern:
   - Use useEffect with interval
   - Clean up on unmount
   - Handle errors gracefully

Longer poll interval since conflicts don't change rapidly.
  </action>
  <verify>npm run build</verify>
  <done>useConflicts hook ready for UI integration</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd mcp-server && uv run python -c "from opta_mcp.conflicts import detect_running_conflicts; print(len(detect_running_conflicts()))"` runs without error
- [ ] `cd src-tauri && cargo check` passes
- [ ] `npm run build` succeeds
- [ ] useConflicts hook exports correctly
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Conflict detection works for at least GeForce Experience, Razer Cortex, MSI Afterburner
</success_criteria>

<output>
After completion, create `.planning/phases/04-conflict-detection/04-01-SUMMARY.md`
</output>
