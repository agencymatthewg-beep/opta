# Plan 68-01: Testing & App Store Compliance

## Wave: 1 (Independent)

## Objective

Comprehensive testing suite and App Store compliance preparation for v8.0 release.

## Execution Context

**Reference Documents:**
- Apple App Store Review Guidelines
- macOS App Sandbox documentation
- Privacy Nutrition Labels requirements

**Key Insights:**
- App Store requires notarization and hardened runtime
- Privacy Nutrition Labels must accurately describe data collection
- TestFlight for beta distribution

## Context

**Depends on:**
- All previous phases complete

**Builds foundation for:**
- Public release
- User feedback collection

## Tasks

### Task 1: Create comprehensive test suite

**File:** `opta-native/tests/integration_tests.rs`

```rust
//! Integration tests for Opta v8.0

use opta_core::*;
use opta_render::*;

mod render_tests {
    use super::*;

    #[test]
    fn test_wgpu_initialization() {
        let instance = wgpu::Instance::new(wgpu::InstanceDescriptor::default());
        let adapters: Vec<_> = instance.enumerate_adapters(wgpu::Backends::all()).collect();
        assert!(!adapters.is_empty(), "No GPU adapters found");
    }

    #[test]
    fn test_shader_compilation() {
        // Test all shaders compile without error
        let device = create_test_device();
        let loader = ShaderLoader::new();

        // Test math includes
        assert!(loader.load_embedded(&device, "math", include_str!("../shaders/includes/math.wgsl")).is_ok());

        // Test SDF shader
        assert!(loader.load_embedded(&device, "sdf", include_str!("../shaders/includes/sdf.wgsl")).is_ok());
    }

    #[test]
    fn test_ring_state_machine() {
        use animation::ring_states::*;

        let mut sm = create_ring_state_machine();
        assert_eq!(sm.current_state(), DORMANT);

        sm.transition_to(WAKING);
        assert_eq!(sm.current_state(), WAKING);

        // Simulate time passing
        for _ in 0..100 {
            sm.update(std::time::Duration::from_millis(10));
        }

        assert_eq!(sm.current_state(), ACTIVE);
    }

    fn create_test_device() -> wgpu::Device {
        let instance = wgpu::Instance::new(wgpu::InstanceDescriptor::default());
        let adapter = pollster::block_on(instance.request_adapter(&wgpu::RequestAdapterOptions::default()))
            .expect("No adapter");
        let (device, _) = pollster::block_on(adapter.request_device(&wgpu::DeviceDescriptor::default(), None))
            .expect("No device");
        device
    }
}

mod state_tests {
    use super::*;

    #[test]
    fn test_app_model_serialization() {
        let model = AppModel::default();
        let serialized = serde_json::to_string(&model).unwrap();
        let deserialized: AppModel = serde_json::from_str(&serialized).unwrap();
        assert_eq!(model.current_view, deserialized.current_view);
    }

    #[test]
    fn test_settings_persistence() {
        let db = Database::open_in_memory().unwrap();

        let settings = Settings {
            haptics_enabled: true,
            sound_enabled: false,
            quality_level: QualityLevel::High,
            ..Default::default()
        };

        let bytes = bincode::serialize(&settings).unwrap();
        db.save_setting("settings", &bytes).unwrap();

        let loaded = db.load_setting("settings").unwrap().unwrap();
        let restored: Settings = bincode::deserialize(&loaded).unwrap();

        assert_eq!(settings.haptics_enabled, restored.haptics_enabled);
        assert_eq!(settings.quality_level, restored.quality_level);
    }
}

mod animation_tests {
    use super::*;

    #[test]
    fn test_spring_physics() {
        let mut spring = Spring::new(0.0, SpringConfig::RESPONSIVE);
        spring.set_target(100.0);

        for _ in 0..240 {
            spring.update(1.0 / 120.0);
        }

        assert!(spring.is_at_rest());
        assert!((spring.value() - 100.0).abs() < 0.1);
    }

    #[test]
    fn test_particle_system() {
        let mut emitter = ParticleEmitter::new(EmitterConfig::explosion());
        emitter.burst(100);

        assert_eq!(emitter.active_particles().len(), 100);

        // Update past lifetime
        emitter.update(1.0);
        assert!(emitter.active_particles().len() < 100);
    }
}
```

### Task 2: Create App Store entitlements

**File:** `opta-native/OptaApp/OptaApp/OptaApp.entitlements`

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <!-- App Sandbox -->
    <key>com.apple.security.app-sandbox</key>
    <true/>

    <!-- Network access for sync -->
    <key>com.apple.security.network.client</key>
    <true/>

    <!-- User-selected file access -->
    <key>com.apple.security.files.user-selected.read-write</key>
    <true/>

    <!-- Hardened runtime -->
    <key>com.apple.security.cs.allow-unsigned-executable-memory</key>
    <false/>
    <key>com.apple.security.cs.disable-library-validation</key>
    <false/>

    <!-- Metal GPU access -->
    <key>com.apple.security.device.gpu</key>
    <true/>
</dict>
</plist>
```

### Task 3: Create privacy manifest

**File:** `opta-native/OptaApp/OptaApp/PrivacyInfo.xcprivacy`

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>NSPrivacyTracking</key>
    <false/>

    <key>NSPrivacyTrackingDomains</key>
    <array/>

    <key>NSPrivacyCollectedDataTypes</key>
    <array>
        <dict>
            <key>NSPrivacyCollectedDataType</key>
            <string>NSPrivacyCollectedDataTypeDeviceID</string>
            <key>NSPrivacyCollectedDataTypeLinked</key>
            <false/>
            <key>NSPrivacyCollectedDataTypeTracking</key>
            <false/>
            <key>NSPrivacyCollectedDataTypePurposes</key>
            <array>
                <string>NSPrivacyCollectedDataTypePurposeAppFunctionality</string>
            </array>
        </dict>
    </array>

    <key>NSPrivacyAccessedAPITypes</key>
    <array>
        <dict>
            <key>NSPrivacyAccessedAPIType</key>
            <string>NSPrivacyAccessedAPICategoryUserDefaults</string>
            <key>NSPrivacyAccessedAPITypeReasons</key>
            <array>
                <string>CA92.1</string>
            </array>
        </dict>
    </array>
</dict>
</plist>
```

### Task 4: Create notarization script

**File:** `opta-native/scripts/notarize.sh`

```bash
#!/bin/bash
# Notarize Opta for macOS distribution

set -e

APP_PATH="$1"
BUNDLE_ID="com.opta.app"
TEAM_ID="${APPLE_TEAM_ID}"
APPLE_ID="${APPLE_ID}"
APP_PASSWORD="${APP_SPECIFIC_PASSWORD}"

if [ -z "$APP_PATH" ]; then
    echo "Usage: ./notarize.sh <path-to-app>"
    exit 1
fi

echo "Creating ZIP for notarization..."
ZIP_PATH="/tmp/opta-notarize.zip"
ditto -c -k --keepParent "$APP_PATH" "$ZIP_PATH"

echo "Submitting for notarization..."
xcrun notarytool submit "$ZIP_PATH" \
    --apple-id "$APPLE_ID" \
    --team-id "$TEAM_ID" \
    --password "$APP_PASSWORD" \
    --wait

echo "Stapling notarization ticket..."
xcrun stapler staple "$APP_PATH"

echo "Verifying notarization..."
spctl -a -v "$APP_PATH"

echo "Notarization complete!"
```

### Task 5: Create release checklist

**File:** `opta-native/RELEASE_CHECKLIST.md`

```markdown
# Opta v8.0 Release Checklist

## Pre-Release

- [ ] All tests pass (`cargo test --all`)
- [ ] No compiler warnings (`cargo clippy`)
- [ ] Documentation complete (`cargo doc`)
- [ ] CHANGELOG.md updated
- [ ] Version bumped in Cargo.toml

## macOS

- [ ] Build release binary
- [ ] Code sign with Developer ID
- [ ] Notarize with Apple
- [ ] Verify notarization stapled
- [ ] Test on macOS 13, 14, 15
- [ ] Test on Intel and Apple Silicon
- [ ] App Store Connect metadata complete
- [ ] Screenshots for all device sizes
- [ ] Privacy Nutrition Labels accurate

## Windows

- [ ] Build release binary
- [ ] Sign with Authenticode certificate
- [ ] Test on Windows 10 and 11
- [ ] NSIS installer tested

## Linux

- [ ] Build release binary
- [ ] AppImage created
- [ ] Test on Ubuntu, Fedora
- [ ] Test Wayland and X11

## Performance

- [ ] Binary size < 15MB
- [ ] 60fps on minimum spec hardware
- [ ] 120fps on recommended hardware
- [ ] Memory usage < 200MB idle

## Final

- [ ] Tag release in git
- [ ] Create GitHub release
- [ ] Upload binaries
- [ ] Submit to App Store
- [ ] Announce release
```

## Verification

```bash
cd opta-native
cargo test --all
./scripts/notarize.sh target/release/Opta.app
```

## Success Criteria

- [ ] All integration tests pass
- [ ] App Store entitlements configured
- [ ] Privacy manifest accurate
- [ ] Notarization succeeds
- [ ] Release checklist complete

## Output

- Comprehensive test suite
- App Store compliance files
- Notarization automation
- Release checklist
