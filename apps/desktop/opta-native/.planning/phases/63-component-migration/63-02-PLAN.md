# Plan 63-02: Glass Panel System

## Wave: 1 (Independent)

## Objective

Create reusable glass panel rendering system for UI overlays with blur and depth effects.

## Execution Context

**Reference Documents:**
- Phase 33 Glass Depth System (React implementation)
- Phase 61 glass shader includes

**Key Insights:**
- Glass panels are quads with blur backdrop
- Multiple depth layers for visual hierarchy
- Frosted edge effects on borders

## Context

**Depends on:**
- Phase 61 (glass shader)
- Phase 62-01 (SwiftUI shell)

**Builds foundation for:**
- All UI components rendered in wgpu
- Dashboard layouts

## Tasks

### Task 1: Create glass panel component

**File:** `opta-native/opta-render/src/components/glass_panel.rs`

```rust
//! Glass panel component for UI backgrounds.

use bytemuck::{Pod, Zeroable};
use wgpu::{Device, Queue, RenderPipeline, BindGroup};

/// Glass panel vertex.
#[repr(C)]
#[derive(Debug, Clone, Copy, Pod, Zeroable)]
pub struct PanelVertex {
    pub position: [f32; 2],
    pub uv: [f32; 2],
}

/// Glass panel configuration.
#[derive(Debug, Clone)]
pub struct GlassPanelConfig {
    /// Position (x, y) in normalized device coordinates
    pub position: [f32; 2],
    /// Size (width, height) in NDC
    pub size: [f32; 2],
    /// Corner radius in pixels
    pub corner_radius: f32,
    /// Blur intensity (0-1)
    pub blur: f32,
    /// Opacity (0-1)
    pub opacity: f32,
    /// Tint color
    pub tint: [f32; 3],
    /// Border width in pixels
    pub border_width: f32,
    /// Border color with alpha
    pub border_color: [f32; 4],
    /// Depth layer (affects blur intensity)
    pub depth_layer: u32,
}

impl Default for GlassPanelConfig {
    fn default() -> Self {
        Self {
            position: [0.0, 0.0],
            size: [1.0, 1.0],
            corner_radius: 16.0,
            blur: 0.5,
            opacity: 0.8,
            tint: [1.0, 1.0, 1.0],
            border_width: 1.0,
            border_color: [1.0, 1.0, 1.0, 0.2],
            depth_layer: 0,
        }
    }
}

/// Glass panel uniforms.
#[repr(C)]
#[derive(Debug, Clone, Copy, Pod, Zeroable)]
pub struct GlassPanelUniforms {
    pub position: [f32; 2],
    pub size: [f32; 2],
    pub corner_radius: f32,
    pub blur: f32,
    pub opacity: f32,
    pub depth_layer: f32,
    pub tint: [f32; 3],
    pub border_width: f32,
    pub border_color: [f32; 4],
    pub resolution: [f32; 2],
    pub _padding: [f32; 2],
}

/// Glass panel renderer.
pub struct GlassPanel {
    vertex_buffer: wgpu::Buffer,
    index_buffer: wgpu::Buffer,
    uniform_buffer: wgpu::Buffer,
    bind_group: BindGroup,
    pipeline: RenderPipeline,
    config: GlassPanelConfig,
}

impl GlassPanel {
    /// Create a new glass panel.
    pub fn new(device: &Device, format: wgpu::TextureFormat) -> Self {
        // Implementation creates quad geometry and shader pipeline
        todo!("Implement glass panel creation")
    }

    /// Update panel configuration.
    pub fn set_config(&mut self, queue: &Queue, config: GlassPanelConfig) {
        self.config = config;
        // Upload uniforms
    }

    /// Render the glass panel.
    pub fn render<'a>(&'a self, render_pass: &mut wgpu::RenderPass<'a>) {
        render_pass.set_pipeline(&self.pipeline);
        render_pass.set_bind_group(0, &self.bind_group, &[]);
        render_pass.set_vertex_buffer(0, self.vertex_buffer.slice(..));
        render_pass.set_index_buffer(self.index_buffer.slice(..), wgpu::IndexFormat::Uint16);
        render_pass.draw_indexed(0..6, 0, 0..1);
    }
}
```

### Task 2: Create glass panel shader

**File:** `opta-native/opta-render/shaders/glass_panel.wgsl`

```wgsl
// Glass panel shader with blur and rounded corners

#include "math.wgsl"
#include "sdf.wgsl"
#include "glass.wgsl"

struct Uniforms {
    position: vec2<f32>,
    size: vec2<f32>,
    corner_radius: f32,
    blur: f32,
    opacity: f32,
    depth_layer: f32,
    tint: vec3<f32>,
    border_width: f32,
    border_color: vec4<f32>,
    resolution: vec2<f32>,
    _padding: vec2<f32>,
}

@group(0) @binding(0)
var<uniform> uniforms: Uniforms;

@group(0) @binding(1)
var backdrop_texture: texture_2d<f32>;

@group(0) @binding(2)
var backdrop_sampler: sampler;

struct VertexOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv: vec2<f32>,
}

@vertex
fn vs_main(@builtin(vertex_index) vertex_index: u32) -> VertexOutput {
    // Fullscreen quad vertices
    var positions = array<vec2<f32>, 4>(
        vec2<f32>(-1.0, -1.0),
        vec2<f32>(1.0, -1.0),
        vec2<f32>(-1.0, 1.0),
        vec2<f32>(1.0, 1.0)
    );
    var indices = array<u32, 6>(0u, 1u, 2u, 2u, 1u, 3u);

    let idx = indices[vertex_index];
    var output: VertexOutput;

    // Scale and position the quad
    var pos = positions[idx];
    pos = pos * uniforms.size * 0.5 + uniforms.position;

    output.position = vec4<f32>(pos, 0.0, 1.0);
    output.uv = positions[idx] * 0.5 + 0.5;

    return output;
}

@fragment
fn fs_main(input: VertexOutput) -> @location(0) vec4<f32> {
    // Calculate pixel position
    let pixel_pos = input.uv * uniforms.size * uniforms.resolution * 0.5;

    // SDF for rounded rectangle
    let half_size = uniforms.size * uniforms.resolution * 0.25 - uniforms.corner_radius;
    let center = uniforms.size * uniforms.resolution * 0.25;
    let d = sdf_rounded_box(pixel_pos - center, half_size, uniforms.corner_radius);

    // Outside the panel - discard
    if (d > 0.0) {
        discard;
    }

    // Sample backdrop with blur
    var color = vec3<f32>(0.0);
    let blur_samples = 16;
    let blur_radius = uniforms.blur * (1.0 + uniforms.depth_layer * 0.5) * 0.01;

    for (var i = 0; i < blur_samples; i++) {
        let angle = f32(i) * TAU / f32(blur_samples);
        let offset = vec2<f32>(cos(angle), sin(angle)) * blur_radius;
        color += textureSample(backdrop_texture, backdrop_sampler, input.uv + offset).rgb;
    }
    color /= f32(blur_samples);

    // Apply tint
    color *= uniforms.tint;

    // Glass fresnel effect at edges (subtle)
    let edge_dist = abs(d) / uniforms.corner_radius;
    let fresnel = pow(saturate(1.0 - edge_dist), 2.0) * 0.1;
    color += fresnel;

    // Border
    let border_dist = -d;
    if (border_dist < uniforms.border_width) {
        let border_alpha = 1.0 - border_dist / uniforms.border_width;
        color = mix(color, uniforms.border_color.rgb, border_alpha * uniforms.border_color.a);
    }

    return vec4<f32>(color, uniforms.opacity);
}
```

### Task 3: Add to components module

**Update:** `opta-native/opta-render/src/components/mod.rs`

```rust
mod glass_panel;
pub use glass_panel::{GlassPanel, GlassPanelConfig};
```

## Verification

```bash
cd opta-native
cargo check -p opta-render
cargo test -p opta-render
```

## Success Criteria

- [ ] Glass panel renders with blur
- [ ] Rounded corners work via SDF
- [ ] Border renders at edges
- [ ] Depth layer affects blur intensity
- [ ] Multiple panels layer correctly

## Output

- Reusable glass panel component
- Shader with blur, SDF corners, and borders
