# Plan 63-03: Telemetry Visualization Components

## Wave: 2 (Depends on 63-02)

## Objective

Port telemetry visualization components from React to wgpu with real-time GPU-rendered metrics and artistic data visualization.

## Execution Context

**Reference Documents:**
- Phase 36 Telemetry Visualization (React implementation)
- Phase 61 color space and noise shaders

**Key Insights:**
- CPU as pulsing energy core (Phase 36 concept)
- Memory as liquid fill with surface tension
- GPU as heat visualization with glow
- All rendered directly via wgpu for maximum performance

## Context

**Depends on:**
- Phase 63-02 (Glass Panel System)
- Phase 61 (color, noise shaders)

**Builds foundation for:**
- Complete dashboard UI
- Real-time monitoring interface

## Tasks

### Task 1: Create telemetry data structures

**File:** `opta-native/opta-render/src/components/telemetry.rs`

```rust
//! Telemetry visualization components.

use bytemuck::{Pod, Zeroable};

/// CPU telemetry data for rendering.
#[repr(C)]
#[derive(Debug, Clone, Copy, Pod, Zeroable)]
pub struct CpuTelemetry {
    /// Overall CPU usage (0-1).
    pub usage: f32,
    /// Per-core usage (up to 16 cores).
    pub core_usage: [f32; 16],
    /// Number of active cores.
    pub core_count: u32,
    /// Temperature in Celsius.
    pub temperature: f32,
    /// Frequency in GHz.
    pub frequency: f32,
    pub _padding: f32,
}

/// Memory telemetry data.
#[repr(C)]
#[derive(Debug, Clone, Copy, Pod, Zeroable)]
pub struct MemoryTelemetry {
    /// Total memory in GB.
    pub total: f32,
    /// Used memory in GB.
    pub used: f32,
    /// Memory pressure (0-1).
    pub pressure: f32,
    /// Swap usage (0-1).
    pub swap_usage: f32,
}

/// GPU telemetry data.
#[repr(C)]
#[derive(Debug, Clone, Copy, Pod, Zeroable)]
pub struct GpuTelemetry {
    /// GPU usage (0-1).
    pub usage: f32,
    /// VRAM usage (0-1).
    pub vram_usage: f32,
    /// Temperature in Celsius.
    pub temperature: f32,
    /// Power draw in Watts.
    pub power: f32,
}

/// Combined telemetry for the renderer.
#[derive(Debug, Clone, Copy)]
pub struct SystemTelemetry {
    pub cpu: CpuTelemetry,
    pub memory: MemoryTelemetry,
    pub gpu: GpuTelemetry,
    pub time: f32,
}

impl Default for SystemTelemetry {
    fn default() -> Self {
        Self {
            cpu: CpuTelemetry {
                usage: 0.0,
                core_usage: [0.0; 16],
                core_count: 8,
                temperature: 45.0,
                frequency: 3.2,
                _padding: 0.0,
            },
            memory: MemoryTelemetry {
                total: 32.0,
                used: 8.0,
                pressure: 0.25,
                swap_usage: 0.0,
            },
            gpu: GpuTelemetry {
                usage: 0.0,
                vram_usage: 0.0,
                temperature: 40.0,
                power: 0.0,
            },
            time: 0.0,
        }
    }
}
```

### Task 2: Create CPU energy core visualizer

**File:** `opta-native/opta-render/src/components/cpu_meter.rs`

```rust
//! CPU meter as pulsing energy core visualization.

use wgpu::{Device, Queue, RenderPipeline, BindGroup};
use super::telemetry::CpuTelemetry;

/// CPU meter uniforms.
#[repr(C)]
#[derive(Debug, Clone, Copy, bytemuck::Pod, bytemuck::Zeroable)]
pub struct CpuMeterUniforms {
    pub center: [f32; 2],
    pub size: f32,
    pub usage: f32,
    pub core_count: u32,
    pub temperature: f32,
    pub time: f32,
    pub _padding: f32,
    pub core_usage: [f32; 16],
}

/// CPU energy core meter renderer.
pub struct CpuMeter {
    pipeline: RenderPipeline,
    bind_group: BindGroup,
    uniform_buffer: wgpu::Buffer,
}

impl CpuMeter {
    pub fn new(device: &Device, format: wgpu::TextureFormat) -> Self {
        // Creates pipeline with cpu_meter.wgsl shader
        todo!("Implement CPU meter")
    }

    pub fn update(&mut self, queue: &Queue, telemetry: &CpuTelemetry, time: f32) {
        // Update uniform buffer with latest telemetry
    }

    pub fn render<'a>(&'a self, render_pass: &mut wgpu::RenderPass<'a>) {
        render_pass.set_pipeline(&self.pipeline);
        render_pass.set_bind_group(0, &self.bind_group, &[]);
        render_pass.draw(0..6, 0..1);
    }
}
```

### Task 3: Create CPU meter shader

**File:** `opta-native/opta-render/shaders/cpu_meter.wgsl`

```wgsl
// CPU Energy Core Visualization
// Renders CPU as a pulsing energy core with per-core indicators

#include "math.wgsl"
#include "sdf.wgsl"
#include "noise.wgsl"
#include "color.wgsl"

struct Uniforms {
    center: vec2<f32>,
    size: f32,
    usage: f32,
    core_count: u32,
    temperature: f32,
    time: f32,
    _padding: f32,
    core_usage: array<f32, 16>,
}

@group(0) @binding(0)
var<uniform> uniforms: Uniforms;

struct VertexOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv: vec2<f32>,
}

@vertex
fn vs_main(@builtin(vertex_index) vertex_index: u32) -> VertexOutput {
    var positions = array<vec2<f32>, 6>(
        vec2<f32>(-1.0, -1.0),
        vec2<f32>(1.0, -1.0),
        vec2<f32>(-1.0, 1.0),
        vec2<f32>(-1.0, 1.0),
        vec2<f32>(1.0, -1.0),
        vec2<f32>(1.0, 1.0)
    );

    var output: VertexOutput;
    output.position = vec4<f32>(positions[vertex_index], 0.0, 1.0);
    output.uv = positions[vertex_index] * 0.5 + 0.5;
    return output;
}

@fragment
fn fs_main(input: VertexOutput) -> @location(0) vec4<f32> {
    let uv = input.uv * 2.0 - 1.0;
    let dist = length(uv);

    // Core circle SDF
    let core_radius = 0.6;
    let core_d = dist - core_radius;

    // Outer glow
    let glow = exp(-core_d * 3.0) * uniforms.usage;

    // Inner energy based on usage
    var energy = 0.0;
    if (core_d < 0.0) {
        // Procedural noise for energy effect
        let noise_coord = uv * 3.0 + uniforms.time * 0.5;
        energy = fbm(noise_coord) * uniforms.usage;
        energy = pow(energy, 1.5);
    }

    // Per-core indicators around the ring
    let angle = atan2(uv.y, uv.x);
    let core_idx = u32((angle + PI) / TAU * f32(uniforms.core_count));
    let core_activity = uniforms.core_usage[core_idx % 16u];

    // Core indicator dots
    let ring_radius = 0.75;
    let dot_d = abs(dist - ring_radius) - 0.02;
    let core_dot = smoothstep(0.01, 0.0, dot_d) * core_activity;

    // Temperature-based color (cool blue to hot orange)
    let temp_norm = saturate((uniforms.temperature - 30.0) / 70.0);
    let cool_color = vec3<f32>(0.2, 0.4, 1.0);
    let hot_color = vec3<f32>(1.0, 0.4, 0.1);
    let temp_color = mix(cool_color, hot_color, temp_norm);

    // Final color composition
    var color = vec3<f32>(0.0);
    color += glow * vec3<f32>(0.5, 0.3, 1.0); // Purple glow
    color += energy * temp_color; // Inner energy
    color += core_dot * vec3<f32>(0.3, 0.8, 1.0); // Core dots

    let alpha = saturate(glow + energy * 0.8 + core_dot);

    return vec4<f32>(color, alpha);
}
```

### Task 4: Create memory liquid fill visualizer

**File:** `opta-native/opta-render/src/components/memory_meter.rs`

```rust
//! Memory meter as liquid fill visualization.

use wgpu::{Device, Queue, RenderPipeline, BindGroup};
use super::telemetry::MemoryTelemetry;

/// Memory meter uniforms.
#[repr(C)]
#[derive(Debug, Clone, Copy, bytemuck::Pod, bytemuck::Zeroable)]
pub struct MemoryMeterUniforms {
    pub position: [f32; 2],
    pub size: [f32; 2],
    pub fill_level: f32,
    pub pressure: f32,
    pub time: f32,
    pub _padding: f32,
}

/// Memory liquid meter renderer.
pub struct MemoryMeter {
    pipeline: RenderPipeline,
    bind_group: BindGroup,
    uniform_buffer: wgpu::Buffer,
}

impl MemoryMeter {
    pub fn new(device: &Device, format: wgpu::TextureFormat) -> Self {
        todo!("Implement memory meter")
    }

    pub fn update(&mut self, queue: &Queue, telemetry: &MemoryTelemetry, time: f32) {
        // Update uniforms
    }

    pub fn render<'a>(&'a self, render_pass: &mut wgpu::RenderPass<'a>) {
        render_pass.set_pipeline(&self.pipeline);
        render_pass.set_bind_group(0, &self.bind_group, &[]);
        render_pass.draw(0..6, 0..1);
    }
}
```

### Task 5: Create memory meter shader

**File:** `opta-native/opta-render/shaders/memory_meter.wgsl`

```wgsl
// Memory Liquid Fill Visualization
// Renders memory as liquid with surface tension effect

#include "math.wgsl"
#include "sdf.wgsl"
#include "noise.wgsl"

struct Uniforms {
    position: vec2<f32>,
    size: vec2<f32>,
    fill_level: f32,
    pressure: f32,
    time: f32,
    _padding: f32,
}

@group(0) @binding(0)
var<uniform> uniforms: Uniforms;

struct VertexOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv: vec2<f32>,
}

@vertex
fn vs_main(@builtin(vertex_index) vertex_index: u32) -> VertexOutput {
    var positions = array<vec2<f32>, 6>(
        vec2<f32>(-1.0, -1.0),
        vec2<f32>(1.0, -1.0),
        vec2<f32>(-1.0, 1.0),
        vec2<f32>(-1.0, 1.0),
        vec2<f32>(1.0, -1.0),
        vec2<f32>(1.0, 1.0)
    );

    var output: VertexOutput;
    let pos = positions[vertex_index] * uniforms.size + uniforms.position;
    output.position = vec4<f32>(pos, 0.0, 1.0);
    output.uv = positions[vertex_index] * 0.5 + 0.5;
    return output;
}

@fragment
fn fs_main(input: VertexOutput) -> @location(0) vec4<f32> {
    let uv = input.uv;

    // Rounded rectangle container
    let container_d = sdf_rounded_box(
        uv - 0.5,
        vec2<f32>(0.45, 0.45),
        0.05
    );

    // Wave animation on liquid surface
    let wave1 = sin(uv.x * 8.0 + uniforms.time * 2.0) * 0.02;
    let wave2 = sin(uv.x * 12.0 - uniforms.time * 1.5) * 0.01;
    let surface_y = uniforms.fill_level + wave1 + wave2;

    // Liquid fill
    let is_liquid = uv.y < surface_y;

    // Surface tension highlight at the edge
    let surface_dist = abs(uv.y - surface_y);
    let surface_highlight = exp(-surface_dist * 50.0) * 0.5;

    // Pressure affects color saturation
    let base_color = vec3<f32>(0.2, 0.5, 1.0);
    let pressure_color = vec3<f32>(1.0, 0.3, 0.3);
    let liquid_color = mix(base_color, pressure_color, uniforms.pressure);

    // Add internal movement
    let internal_noise = fbm(uv * 5.0 + uniforms.time * 0.3) * 0.2;

    var color = vec3<f32>(0.0);
    if (container_d < 0.0) {
        if (is_liquid) {
            color = liquid_color * (0.8 + internal_noise);
            color += surface_highlight * vec3<f32>(1.0);
        } else {
            // Empty space inside container
            color = vec3<f32>(0.05);
        }
    }

    // Container border
    let border = smoothstep(0.0, 0.02, -container_d) - smoothstep(0.02, 0.04, -container_d);
    color += border * vec3<f32>(0.3, 0.5, 0.7);

    let alpha = smoothstep(0.01, 0.0, container_d);

    return vec4<f32>(color, alpha);
}
```

### Task 6: Create GPU heat meter

**File:** `opta-native/opta-render/shaders/gpu_meter.wgsl`

```wgsl
// GPU Heat Visualization
// Renders GPU as heat map with thermal glow

#include "math.wgsl"
#include "sdf.wgsl"
#include "noise.wgsl"
#include "color.wgsl"

struct Uniforms {
    position: vec2<f32>,
    size: vec2<f32>,
    usage: f32,
    temperature: f32,
    power: f32,
    time: f32,
}

@group(0) @binding(0)
var<uniform> uniforms: Uniforms;

struct VertexOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv: vec2<f32>,
}

@vertex
fn vs_main(@builtin(vertex_index) vertex_index: u32) -> VertexOutput {
    var positions = array<vec2<f32>, 6>(
        vec2<f32>(-1.0, -1.0),
        vec2<f32>(1.0, -1.0),
        vec2<f32>(-1.0, 1.0),
        vec2<f32>(-1.0, 1.0),
        vec2<f32>(1.0, -1.0),
        vec2<f32>(1.0, 1.0)
    );

    var output: VertexOutput;
    let pos = positions[vertex_index] * uniforms.size + uniforms.position;
    output.position = vec4<f32>(pos, 0.0, 1.0);
    output.uv = positions[vertex_index] * 0.5 + 0.5;
    return output;
}

@fragment
fn fs_main(input: VertexOutput) -> @location(0) vec4<f32> {
    let uv = input.uv;

    // GPU chip shape (rounded square with cutouts)
    let chip_d = sdf_rounded_box(uv - 0.5, vec2<f32>(0.4, 0.4), 0.02);

    // Heat map based on temperature
    let temp_norm = saturate((uniforms.temperature - 30.0) / 70.0);

    // Animated heat distortion
    let heat_noise = fbm((uv + vec2<f32>(0.0, uniforms.time * 0.2)) * 4.0);
    let heat_wave = sin(uv.y * 20.0 - uniforms.time * 3.0) * temp_norm * 0.05;

    // Heat color gradient (green -> yellow -> orange -> red)
    var heat_color: vec3<f32>;
    if (temp_norm < 0.33) {
        heat_color = mix(vec3<f32>(0.2, 0.8, 0.3), vec3<f32>(0.9, 0.9, 0.2), temp_norm * 3.0);
    } else if (temp_norm < 0.66) {
        heat_color = mix(vec3<f32>(0.9, 0.9, 0.2), vec3<f32>(1.0, 0.5, 0.1), (temp_norm - 0.33) * 3.0);
    } else {
        heat_color = mix(vec3<f32>(1.0, 0.5, 0.1), vec3<f32>(1.0, 0.2, 0.1), (temp_norm - 0.66) * 3.0);
    }

    // Usage affects intensity
    let intensity = 0.3 + uniforms.usage * 0.7;

    var color = vec3<f32>(0.0);
    if (chip_d < 0.0) {
        // Inside the chip
        color = heat_color * intensity;
        color += heat_noise * 0.1 * uniforms.usage;

        // Heat shimmer effect
        color += vec3<f32>(heat_wave) * temp_norm;
    }

    // Glow around chip based on power draw
    let glow_intensity = uniforms.power / 300.0; // Normalize to ~300W max
    let glow = exp(-chip_d * 5.0) * glow_intensity;
    color += glow * heat_color * 0.5;

    let alpha = smoothstep(0.01, 0.0, chip_d) + glow * 0.5;

    return vec4<f32>(color, saturate(alpha));
}
```

### Task 7: Update components module

**Update:** `opta-native/opta-render/src/components/mod.rs`

```rust
mod glass_panel;
mod telemetry;
mod cpu_meter;
mod memory_meter;

pub use glass_panel::{GlassPanel, GlassPanelConfig};
pub use telemetry::{CpuTelemetry, MemoryTelemetry, GpuTelemetry, SystemTelemetry};
pub use cpu_meter::CpuMeter;
pub use memory_meter::MemoryMeter;
```

## Verification

```bash
cd opta-native
cargo check -p opta-render
cargo test -p opta-render
```

## Success Criteria

- [ ] CPU energy core renders with pulsing effect
- [ ] Per-core indicators show individual usage
- [ ] Memory liquid fill animates smoothly
- [ ] GPU heat map reflects temperature
- [ ] All meters update in real-time from telemetry

## Output

- Telemetry visualization components in wgpu
- CPU energy core, memory liquid, GPU heat shaders
- Real-time data-driven artistic visualization
