---
phase: 85-dashboard-obsidian-refresh
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - opta-native/opta-render/src/ffi.rs
  - opta-native/opta-render/src/ffi_panels.rs
autonomous: true
---

<objective>
Add C-compatible FFI exports for GlassPanel and Branch energy components so Swift can create, configure, update, and render these GPU components.

Purpose: The obsidian panel (GlassPanel) and branch energy components (BranchMeter, BranchIndicator, BranchBorder) from Phases 83-84 are Rust-only. This plan exposes them via C ABI for Swift consumption.

Output: New `ffi_panels.rs` module with FFI functions following the existing opaque-pointer pattern from `ffi.rs` (circular menu section). Each component gets create/destroy/update/render FFI functions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/84-energy-branch-components/84-01-SUMMARY.md
@opta-native/opta-render/src/ffi.rs
@opta-native/opta-render/src/components/mod.rs
@opta-native/opta-render/src/components/glass_panel.rs
@opta-native/opta-render/src/components/branch_meter.rs
@opta-native/opta-render/src/components/branch_indicator.rs
@opta-native/opta-render/src/components/branch_border.rs
</context>

<tasks>
<task type="auto">
  <name>Task 1: GlassPanel FFI exports</name>
  <files>opta-native/opta-render/src/ffi_panels.rs</files>
  <action>
Create new module `ffi_panels.rs` with C-compatible FFI functions for GlassPanel. Follow the opaque-pointer pattern from the circular menu FFI section in `ffi.rs`.

Exports needed:
- `opta_panel_create(ctx: *mut OptaRenderContext, config: *const OptaPanelConfig) -> *mut OptaPanel` — Creates a GlassPanel with given config
- `opta_panel_destroy(panel: *mut OptaPanel)` — Frees panel resources
- `opta_panel_set_position(panel, x, y) -> OptaRenderResult` — Update panel position
- `opta_panel_set_size(panel, width, height) -> OptaRenderResult` — Update panel dimensions
- `opta_panel_set_energy(panel, energy: f32) -> OptaRenderResult` — Set branch energy level [0,1]
- `opta_panel_set_depth(panel, depth: f32) -> OptaRenderResult` — Set depth layer [0,1]
- `opta_panel_set_quality(panel, level: u32) -> OptaRenderResult` — Set quality level
- `opta_panel_update(panel, dt: f32) -> OptaRenderResult` — Advance animation
- `opta_panel_render(panel, ctx: *mut OptaRenderContext) -> OptaRenderResult` — Render to current surface

The `OptaPanelConfig` struct (#[repr(C)]):
- position: [f32; 2] (x, y in pixels)
- size: [f32; 2] (width, height in pixels)
- corner_radius: f32
- border_width: f32
- energy: f32 (initial branch energy [0,1])
- depth_layer: f32 (depth hierarchy [0,1])
- quality_level: u32

The `OptaPanel` opaque struct wraps:
- config: GlassPanelConfig
- panel: GlassPanel
- uniforms state (updated per-frame)

Use `tracing::{info, debug, warn, error}` for logging. Return OptaRenderResult codes for error handling. All functions are `unsafe extern "C"` with null-pointer guards.
  </action>
  <verify>`cargo build --release -p opta-render` succeeds</verify>
  <done>GlassPanel FFI module compiles with 9 exported functions matching the C ABI pattern</done>
</task>

<task type="auto">
  <name>Task 2: Branch component FFI exports</name>
  <files>opta-native/opta-render/src/ffi_panels.rs</files>
  <action>
Extend `ffi_panels.rs` with FFI exports for BranchMeter, BranchIndicator, and BranchBorder. Each component follows the same opaque-pointer pattern.

**BranchMeter FFI:**
- `opta_branch_meter_create(ctx, config: *const OptaBranchMeterConfig) -> *mut OptaBranchMeter`
- `opta_branch_meter_destroy(meter: *mut OptaBranchMeter)`
- `opta_branch_meter_set_fill(meter, fill_level: f32) -> OptaRenderResult` — Set fill [0,1]
- `opta_branch_meter_set_energy(meter, energy: f32) -> OptaRenderResult` — Set branch energy
- `opta_branch_meter_update(meter, dt: f32) -> OptaRenderResult`
- `opta_branch_meter_render(meter, ctx) -> OptaRenderResult`

`OptaBranchMeterConfig` (#[repr(C)]): position [f32;2], size [f32;2], corner_radius f32, fill_level f32, energy f32, quality_level u32, resolution [f32;2]

**BranchIndicator FFI:**
- `opta_branch_indicator_create(ctx, config) -> *mut OptaBranchIndicator`
- `opta_branch_indicator_destroy(indicator)`
- `opta_branch_indicator_set_energy(indicator, energy: f32) -> OptaRenderResult`
- `opta_branch_indicator_update(indicator, dt: f32) -> OptaRenderResult`
- `opta_branch_indicator_render(indicator, ctx) -> OptaRenderResult`

`OptaBranchIndicatorConfig` (#[repr(C)]): center [f32;2], inner_radius f32, outer_radius f32, energy f32, branch_count u32, quality_level u32, resolution [f32;2]

**BranchBorder FFI:**
- `opta_branch_border_create(ctx, config) -> *mut OptaBranchBorder`
- `opta_branch_border_destroy(border)`
- `opta_branch_border_set_energy(border, energy: f32) -> OptaRenderResult`
- `opta_branch_border_update(border, dt: f32) -> OptaRenderResult`
- `opta_branch_border_render(border, ctx) -> OptaRenderResult`

`OptaBranchBorderConfig` (#[repr(C)]): position [f32;2], size [f32;2], corner_radius f32, border_width f32, energy f32, quality_level u32, resolution [f32;2]

All structs derive Copy + Clone for FFI safety.
  </action>
  <verify>`cargo build --release -p opta-render` succeeds and `cargo test -p opta-render` passes</verify>
  <done>All 3 branch component FFI modules compile with create/destroy/set/update/render functions</done>
</task>

<task type="auto">
  <name>Task 3: Wire ffi_panels module into lib.rs</name>
  <files>opta-native/opta-render/src/lib.rs, opta-native/opta-render/src/ffi_panels.rs</files>
  <action>
Add `mod ffi_panels;` declaration to `lib.rs` (after the existing `mod ffi;` line). The module should be public so the linker exports the symbols.

Also add a test section at the bottom of `ffi_panels.rs` with null-pointer handling tests for all component FFI functions (following the pattern in `ffi.rs` tests section). Test that null pointers return `OptaRenderResult::NullPointer` for all setters/update/render functions.
  </action>
  <verify>`cargo build --release -p opta-render` succeeds and `cargo test -p opta-render -- ffi_panels` passes</verify>
  <done>Module declared in lib.rs, all null-pointer guard tests pass</done>
</task>
</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo build --release -p opta-render` succeeds
- [ ] `cargo test -p opta-render` passes (all existing + new tests)
- [ ] No clippy warnings: `cargo clippy -p opta-render`
- [ ] FFI function symbols visible: `nm target/release/libopta_render.a | grep opta_panel`
- [ ] FFI function symbols visible: `nm target/release/libopta_render.a | grep opta_branch`
</verification>

<success_criteria>
- GlassPanel exposed via 9 FFI functions (create/destroy/setters/update/render)
- BranchMeter exposed via 6 FFI functions
- BranchIndicator exposed via 5 FFI functions
- BranchBorder exposed via 5 FFI functions
- All follow opaque-pointer + OptaRenderResult error pattern
- Null-pointer tests pass for all functions
- No regressions in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/85-dashboard-obsidian-refresh/85-01-SUMMARY.md`
</output>
