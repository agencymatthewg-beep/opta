# Plan 08-01: Optimization Action Framework with Rollback

## Overview

Create the core optimization engine that can apply settings to games and revert them if needed. This establishes the safe, reversible foundation all optimization actions build upon.

## Dependencies

**Required:**
- Phase 7 complete (game detection, game settings database)
- `game_settings.py` with community optimization presets
- `games.rs` with game detection commands
- `GameOptimization` type in TypeScript

**Provides:**
- `OptimizationAction` struct with apply/revert methods
- Backup system for original settings
- `apply_optimization` Tauri command
- `revert_optimization` Tauri command
- `get_optimization_history` Tauri command

## Tasks

### Task 1: Create optimization action module in Python

**File:** `mcp-server/src/opta_mcp/optimizer.py`

Create the core optimization logic:

```python
"""
Optimization action framework with backup and rollback support.
"""
import json
import os
import time
from pathlib import Path
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, asdict
import shutil

# Backup directory for original settings
BACKUP_DIR = Path.home() / ".opta" / "backups"

@dataclass
class OptimizationAction:
    """Single optimization action with rollback capability."""
    action_id: str
    game_id: str
    game_name: str
    action_type: str  # "graphics", "launch_options", "priority"
    setting_key: str
    original_value: Any
    new_value: Any
    file_path: Optional[str]  # Config file if applicable
    applied_at: Optional[float] = None

@dataclass
class OptimizationResult:
    """Result of applying/reverting optimizations."""
    success: bool
    actions_applied: int
    actions_failed: int
    message: str
    details: List[Dict[str, Any]]

def get_backup_path(game_id: str) -> Path:
    """Get backup directory for a game."""
    return BACKUP_DIR / game_id

def backup_original_settings(game_id: str, settings: Dict) -> bool:
    """Backup original settings before applying optimization."""
    backup_path = get_backup_path(game_id)
    backup_path.mkdir(parents=True, exist_ok=True)

    backup_file = backup_path / f"backup_{int(time.time())}.json"
    try:
        with open(backup_file, 'w') as f:
            json.dump({
                "game_id": game_id,
                "timestamp": time.time(),
                "settings": settings
            }, f, indent=2)
        return True
    except Exception as e:
        print(f"Backup failed: {e}")
        return False

def get_latest_backup(game_id: str) -> Optional[Dict]:
    """Get the most recent backup for a game."""
    backup_path = get_backup_path(game_id)
    if not backup_path.exists():
        return None

    backups = sorted(backup_path.glob("backup_*.json"), reverse=True)
    if not backups:
        return None

    try:
        with open(backups[0], 'r') as f:
            return json.load(f)
    except Exception:
        return None

def apply_game_optimization(game_id: str, optimization: Dict) -> OptimizationResult:
    """
    Apply optimization settings to a game.

    For Phase 8-01, this creates the framework but actual file modifications
    are minimal - we store the "intended" optimizations and prepare launch options.
    Full registry/config file modifications come in later phases.
    """
    actions: List[OptimizationAction] = []
    applied = 0
    failed = 0
    details = []

    settings = optimization.get("settings", {})

    # Create optimization actions for each setting
    if "graphics" in settings:
        for key, value in settings["graphics"].items():
            action = OptimizationAction(
                action_id=f"{game_id}_{key}_{int(time.time())}",
                game_id=game_id,
                game_name=optimization.get("name", "Unknown"),
                action_type="graphics",
                setting_key=key,
                original_value=None,  # Would be read from game config
                new_value=value,
                file_path=None,  # Game config file path
                applied_at=time.time()
            )
            actions.append(action)
            details.append({
                "action": "graphics_setting",
                "key": key,
                "value": value,
                "status": "applied"
            })
            applied += 1

    if "launch_options" in settings:
        action = OptimizationAction(
            action_id=f"{game_id}_launch_{int(time.time())}",
            game_id=game_id,
            game_name=optimization.get("name", "Unknown"),
            action_type="launch_options",
            setting_key="launch_options",
            original_value="",
            new_value=settings["launch_options"],
            file_path=None,
            applied_at=time.time()
        )
        actions.append(action)
        details.append({
            "action": "launch_options",
            "value": settings["launch_options"],
            "status": "applied"
        })
        applied += 1

    if "priority" in settings:
        action = OptimizationAction(
            action_id=f"{game_id}_priority_{int(time.time())}",
            game_id=game_id,
            game_name=optimization.get("name", "Unknown"),
            action_type="priority",
            setting_key="priority",
            original_value="normal",
            new_value=settings["priority"],
            file_path=None,
            applied_at=time.time()
        )
        actions.append(action)
        details.append({
            "action": "priority",
            "value": settings["priority"],
            "status": "applied"
        })
        applied += 1

    # Store actions for rollback
    save_optimization_history(game_id, actions)

    return OptimizationResult(
        success=failed == 0,
        actions_applied=applied,
        actions_failed=failed,
        message=f"Applied {applied} optimizations" if failed == 0 else f"Applied {applied}, failed {failed}",
        details=details
    )

def revert_game_optimization(game_id: str) -> OptimizationResult:
    """Revert a game to its original settings."""
    backup = get_latest_backup(game_id)
    if not backup:
        return OptimizationResult(
            success=False,
            actions_applied=0,
            actions_failed=1,
            message="No backup found to revert to",
            details=[]
        )

    # In full implementation, this would restore config files
    # For now, we clear the optimization history
    history_path = get_backup_path(game_id) / "history.json"
    if history_path.exists():
        history_path.unlink()

    return OptimizationResult(
        success=True,
        actions_applied=1,
        actions_failed=0,
        message="Reverted to original settings",
        details=[{"action": "revert", "backup_timestamp": backup.get("timestamp")}]
    )

def save_optimization_history(game_id: str, actions: List[OptimizationAction]):
    """Save optimization history for a game."""
    history_path = get_backup_path(game_id) / "history.json"
    history_path.parent.mkdir(parents=True, exist_ok=True)

    history = []
    if history_path.exists():
        try:
            with open(history_path, 'r') as f:
                history = json.load(f)
        except Exception:
            history = []

    for action in actions:
        history.append(asdict(action))

    with open(history_path, 'w') as f:
        json.dump(history, f, indent=2)

def get_optimization_history(game_id: str) -> List[Dict]:
    """Get optimization history for a game."""
    history_path = get_backup_path(game_id) / "history.json"
    if not history_path.exists():
        return []

    try:
        with open(history_path, 'r') as f:
            return json.load(f)
    except Exception:
        return []

def get_all_optimized_games() -> List[Dict]:
    """Get all games that have been optimized."""
    if not BACKUP_DIR.exists():
        return []

    games = []
    for game_dir in BACKUP_DIR.iterdir():
        if game_dir.is_dir():
            history = get_optimization_history(game_dir.name)
            if history:
                games.append({
                    "game_id": game_dir.name,
                    "action_count": len(history),
                    "last_optimized": max(a.get("applied_at", 0) for a in history)
                })

    return games
```

### Task 2: Add MCP tools for optimization

**File:** `mcp-server/src/opta_mcp/server.py`

Add to TOOLS list:

```python
Tool(
    name="apply_optimization",
    description="Apply optimization settings to a game",
    inputSchema={
        "type": "object",
        "properties": {
            "game_id": {"type": "string", "description": "Game ID (e.g., '730' for CS2)"},
        },
        "required": ["game_id"]
    }
),
Tool(
    name="revert_optimization",
    description="Revert a game to its original settings",
    inputSchema={
        "type": "object",
        "properties": {
            "game_id": {"type": "string", "description": "Game ID to revert"},
        },
        "required": ["game_id"]
    }
),
Tool(
    name="get_optimization_history",
    description="Get optimization history for a game or all games",
    inputSchema={
        "type": "object",
        "properties": {
            "game_id": {"type": "string", "description": "Optional game ID, omit for all games"},
        },
        "required": []
    }
),
```

Add tool handlers in handle_call_tool:

```python
elif name == "apply_optimization":
    from opta_mcp.optimizer import apply_game_optimization
    from opta_mcp.game_settings import get_game_settings

    game_id = arguments.get("game_id")
    optimization = get_game_settings(game_id)
    result = apply_game_optimization(game_id, optimization)
    return [TextContent(type="text", text=json.dumps(asdict(result)))]

elif name == "revert_optimization":
    from opta_mcp.optimizer import revert_game_optimization

    game_id = arguments.get("game_id")
    result = revert_game_optimization(game_id)
    return [TextContent(type="text", text=json.dumps(asdict(result)))]

elif name == "get_optimization_history":
    from opta_mcp.optimizer import get_optimization_history, get_all_optimized_games

    game_id = arguments.get("game_id")
    if game_id:
        history = get_optimization_history(game_id)
    else:
        history = get_all_optimized_games()
    return [TextContent(type="text", text=json.dumps(history))]
```

### Task 3: Create Rust commands for optimization

**File:** `src-tauri/src/optimizer.rs`

```rust
use serde::{Deserialize, Serialize};
use std::process::Command;

#[derive(Debug, Serialize, Deserialize)]
pub struct OptimizationResult {
    pub success: bool,
    pub actions_applied: u32,
    pub actions_failed: u32,
    pub message: String,
    pub details: Vec<serde_json::Value>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct OptimizationHistoryEntry {
    pub action_id: String,
    pub game_id: String,
    pub game_name: String,
    pub action_type: String,
    pub setting_key: String,
    pub original_value: serde_json::Value,
    pub new_value: serde_json::Value,
    pub file_path: Option<String>,
    pub applied_at: Option<f64>,
}

const APPLY_OPTIMIZATION_SCRIPT: &str = r#"
import sys
import json
sys.path.insert(0, 'mcp-server/src')
from opta_mcp.optimizer import apply_game_optimization
from opta_mcp.game_settings import get_game_settings
from dataclasses import asdict

game_id = sys.argv[1]
optimization = get_game_settings(game_id)
result = apply_game_optimization(game_id, optimization)
print(json.dumps(asdict(result)))
"#;

const REVERT_OPTIMIZATION_SCRIPT: &str = r#"
import sys
import json
sys.path.insert(0, 'mcp-server/src')
from opta_mcp.optimizer import revert_game_optimization
from dataclasses import asdict

game_id = sys.argv[1]
result = revert_game_optimization(game_id)
print(json.dumps(asdict(result)))
"#;

const GET_HISTORY_SCRIPT: &str = r#"
import sys
import json
sys.path.insert(0, 'mcp-server/src')
from opta_mcp.optimizer import get_optimization_history, get_all_optimized_games

game_id = sys.argv[1] if len(sys.argv) > 1 and sys.argv[1] != "" else None
if game_id:
    history = get_optimization_history(game_id)
else:
    history = get_all_optimized_games()
print(json.dumps(history))
"#;

#[tauri::command]
pub async fn apply_optimization(game_id: String) -> Result<OptimizationResult, String> {
    let output = Command::new("python3")
        .arg("-c")
        .arg(APPLY_OPTIMIZATION_SCRIPT)
        .arg(&game_id)
        .current_dir(std::env::current_dir().map_err(|e| e.to_string())?)
        .output()
        .map_err(|e| format!("Failed to execute Python: {}", e))?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        return Err(format!("Python script failed: {}", stderr));
    }

    let stdout = String::from_utf8_lossy(&output.stdout);
    serde_json::from_str(&stdout)
        .map_err(|e| format!("Failed to parse result: {} - Output: {}", e, stdout))
}

#[tauri::command]
pub async fn revert_optimization(game_id: String) -> Result<OptimizationResult, String> {
    let output = Command::new("python3")
        .arg("-c")
        .arg(REVERT_OPTIMIZATION_SCRIPT)
        .arg(&game_id)
        .current_dir(std::env::current_dir().map_err(|e| e.to_string())?)
        .output()
        .map_err(|e| format!("Failed to execute Python: {}", e))?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        return Err(format!("Python script failed: {}", stderr));
    }

    let stdout = String::from_utf8_lossy(&output.stdout);
    serde_json::from_str(&stdout)
        .map_err(|e| format!("Failed to parse result: {} - Output: {}", e, stdout))
}

#[tauri::command]
pub async fn get_optimization_history(game_id: Option<String>) -> Result<Vec<serde_json::Value>, String> {
    let output = Command::new("python3")
        .arg("-c")
        .arg(GET_HISTORY_SCRIPT)
        .arg(game_id.unwrap_or_default())
        .current_dir(std::env::current_dir().map_err(|e| e.to_string())?)
        .output()
        .map_err(|e| format!("Failed to execute Python: {}", e))?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        return Err(format!("Python script failed: {}", stderr));
    }

    let stdout = String::from_utf8_lossy(&output.stdout);
    serde_json::from_str(&stdout)
        .map_err(|e| format!("Failed to parse result: {} - Output: {}", e, stdout))
}
```

Register in `src-tauri/src/lib.rs`:

```rust
mod optimizer;

// In run() function, add to invoke_handler:
optimizer::apply_optimization,
optimizer::revert_optimization,
optimizer::get_optimization_history,
```

### Task 4: Add TypeScript types and hook

**File:** `src/types/optimizer.ts`

```typescript
/**
 * Optimization engine types.
 */

export interface OptimizationResult {
  success: boolean;
  actions_applied: number;
  actions_failed: number;
  message: string;
  details: OptimizationDetail[];
}

export interface OptimizationDetail {
  action: string;
  key?: string;
  value?: string | number;
  status: 'applied' | 'failed' | 'skipped';
  error?: string;
}

export interface OptimizationHistoryEntry {
  action_id: string;
  game_id: string;
  game_name: string;
  action_type: 'graphics' | 'launch_options' | 'priority';
  setting_key: string;
  original_value: unknown;
  new_value: unknown;
  file_path: string | null;
  applied_at: number | null;
}

export interface OptimizedGame {
  game_id: string;
  action_count: number;
  last_optimized: number;
}
```

**File:** `src/hooks/useOptimizer.ts`

```typescript
/**
 * Hook for game optimization operations.
 */

import { useState, useCallback } from 'react';
import { invoke } from '@tauri-apps/api/core';
import type { OptimizationResult, OptimizedGame, OptimizationHistoryEntry } from '../types/optimizer';

export interface UseOptimizerResult {
  /** Apply optimization to a game */
  applyOptimization: (gameId: string) => Promise<OptimizationResult>;
  /** Revert optimization for a game */
  revertOptimization: (gameId: string) => Promise<OptimizationResult>;
  /** Get optimization history */
  getHistory: (gameId?: string) => Promise<OptimizationHistoryEntry[] | OptimizedGame[]>;
  /** Whether an operation is in progress */
  loading: boolean;
  /** Last error message */
  error: string | null;
  /** Last result */
  lastResult: OptimizationResult | null;
}

export function useOptimizer(): UseOptimizerResult {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [lastResult, setLastResult] = useState<OptimizationResult | null>(null);

  const applyOptimization = useCallback(async (gameId: string): Promise<OptimizationResult> => {
    setLoading(true);
    setError(null);
    try {
      const result = await invoke<OptimizationResult>('apply_optimization', { gameId });
      setLastResult(result);
      return result;
    } catch (e) {
      const errorMessage = e instanceof Error ? e.message : String(e);
      setError(errorMessage);
      throw new Error(errorMessage);
    } finally {
      setLoading(false);
    }
  }, []);

  const revertOptimization = useCallback(async (gameId: string): Promise<OptimizationResult> => {
    setLoading(true);
    setError(null);
    try {
      const result = await invoke<OptimizationResult>('revert_optimization', { gameId });
      setLastResult(result);
      return result;
    } catch (e) {
      const errorMessage = e instanceof Error ? e.message : String(e);
      setError(errorMessage);
      throw new Error(errorMessage);
    } finally {
      setLoading(false);
    }
  }, []);

  const getHistory = useCallback(async (gameId?: string) => {
    setLoading(true);
    setError(null);
    try {
      const result = await invoke<OptimizationHistoryEntry[] | OptimizedGame[]>(
        'get_optimization_history',
        { gameId: gameId || null }
      );
      return result;
    } catch (e) {
      const errorMessage = e instanceof Error ? e.message : String(e);
      setError(errorMessage);
      throw new Error(errorMessage);
    } finally {
      setLoading(false);
    }
  }, []);

  return {
    applyOptimization,
    revertOptimization,
    getHistory,
    loading,
    error,
    lastResult,
  };
}

export default useOptimizer;
```

## Success Criteria

- [ ] `optimizer.py` module created with apply/revert/history functions
- [ ] MCP tools registered for optimization operations
- [ ] Rust commands compile and invoke Python correctly
- [ ] TypeScript types and hook created
- [ ] Test: `python -c "from opta_mcp.optimizer import apply_game_optimization; print('OK')"`
- [ ] `cargo build` succeeds
- [ ] `npm run build` succeeds

## Verification

```bash
# Test Python module
cd /Users/matthewbyrden/Documents/Opta
python3 -c "
import sys
sys.path.insert(0, 'mcp-server/src')
from opta_mcp.optimizer import apply_game_optimization
from opta_mcp.game_settings import get_game_settings

opt = get_game_settings('730')  # CS2
result = apply_game_optimization('730', opt)
print(f'Applied {result.actions_applied} actions')
print(f'Success: {result.success}')
"

# Build checks
cargo build
npm run build
```

## Estimated Complexity

- **Scope:** Medium (new module + 3 commands + types + hook)
- **Risk:** Low (builds on existing patterns)
- **Duration:** ~15 min
