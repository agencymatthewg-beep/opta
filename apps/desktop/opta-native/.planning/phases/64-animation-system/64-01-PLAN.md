# Plan 64-01: Spring Physics Engine

## Wave: 1 (Independent)

## Objective

Implement a spring physics engine in Rust for smooth, natural animations with configurable tension, friction, and mass.

## Execution Context

**Reference Documents:**
- React Spring patterns from existing codebase
- Phase 26/35 animation specifications

**Key Insights:**
- Spring physics creates more natural motion than easing functions
- Need configurable presets (wobbly, stiff, gentle)
- Must support 120Hz rendering (8.33ms per frame)

## Context

**Depends on:**
- Phase 60 (render loop timing)

**Builds foundation for:**
- All UI animations
- Ring state transitions
- Particle systems

## Tasks

### Task 1: Create spring physics core

**File:** `opta-native/opta-render/src/animation/spring.rs`

```rust
//! Spring physics simulation for natural animations.
//!
//! Based on damped harmonic oscillator:
//! F = -k*x - d*v
//! where k is stiffness, d is damping, x is displacement, v is velocity

/// Spring configuration.
#[derive(Debug, Clone, Copy)]
pub struct SpringConfig {
    /// Stiffness coefficient (k). Higher = snappier.
    pub stiffness: f32,
    /// Damping coefficient (d). Higher = less oscillation.
    pub damping: f32,
    /// Mass of the object. Higher = more inertia.
    pub mass: f32,
    /// Velocity threshold below which spring is considered at rest.
    pub rest_velocity: f32,
    /// Displacement threshold below which spring is considered at rest.
    pub rest_displacement: f32,
}

impl Default for SpringConfig {
    fn default() -> Self {
        Self::RESPONSIVE
    }
}

impl SpringConfig {
    /// Responsive spring - good for UI interactions.
    pub const RESPONSIVE: Self = Self {
        stiffness: 170.0,
        damping: 26.0,
        mass: 1.0,
        rest_velocity: 0.001,
        rest_displacement: 0.001,
    };

    /// Wobbly spring - playful, bouncy motion.
    pub const WOBBLY: Self = Self {
        stiffness: 180.0,
        damping: 12.0,
        mass: 1.0,
        rest_velocity: 0.001,
        rest_displacement: 0.001,
    };

    /// Stiff spring - quick, minimal overshoot.
    pub const STIFF: Self = Self {
        stiffness: 210.0,
        damping: 30.0,
        mass: 1.0,
        rest_velocity: 0.001,
        rest_displacement: 0.001,
    };

    /// Gentle spring - slow, elegant motion.
    pub const GENTLE: Self = Self {
        stiffness: 120.0,
        damping: 14.0,
        mass: 1.0,
        rest_velocity: 0.001,
        rest_displacement: 0.001,
    };

    /// Molasses spring - very slow, dramatic.
    pub const MOLASSES: Self = Self {
        stiffness: 100.0,
        damping: 30.0,
        mass: 2.0,
        rest_velocity: 0.001,
        rest_displacement: 0.001,
    };

    /// Create custom spring from tension and friction (React Spring style).
    pub fn from_tension_friction(tension: f32, friction: f32) -> Self {
        Self {
            stiffness: tension,
            damping: friction,
            mass: 1.0,
            rest_velocity: 0.001,
            rest_displacement: 0.001,
        }
    }
}

/// Spring animation state for a single value.
#[derive(Debug, Clone)]
pub struct Spring {
    config: SpringConfig,
    /// Current value.
    value: f32,
    /// Target value.
    target: f32,
    /// Current velocity.
    velocity: f32,
    /// Whether the spring is at rest.
    at_rest: bool,
}

impl Spring {
    /// Create a new spring at the given initial value.
    pub fn new(initial: f32, config: SpringConfig) -> Self {
        Self {
            config,
            value: initial,
            target: initial,
            velocity: 0.0,
            at_rest: true,
        }
    }

    /// Set the target value, waking the spring.
    pub fn set_target(&mut self, target: f32) {
        if (self.target - target).abs() > f32::EPSILON {
            self.target = target;
            self.at_rest = false;
        }
    }

    /// Immediately set the value without animation.
    pub fn set_immediate(&mut self, value: f32) {
        self.value = value;
        self.target = value;
        self.velocity = 0.0;
        self.at_rest = true;
    }

    /// Get the current value.
    pub fn value(&self) -> f32 {
        self.value
    }

    /// Check if the spring is at rest.
    pub fn is_at_rest(&self) -> bool {
        self.at_rest
    }

    /// Update the spring simulation.
    ///
    /// `dt` is delta time in seconds (typically 1/60 or 1/120).
    pub fn update(&mut self, dt: f32) {
        if self.at_rest {
            return;
        }

        let displacement = self.value - self.target;
        let spring_force = -self.config.stiffness * displacement;
        let damping_force = -self.config.damping * self.velocity;
        let acceleration = (spring_force + damping_force) / self.config.mass;

        // Semi-implicit Euler integration
        self.velocity += acceleration * dt;
        self.value += self.velocity * dt;

        // Check if at rest
        if self.velocity.abs() < self.config.rest_velocity
            && (self.value - self.target).abs() < self.config.rest_displacement
        {
            self.value = self.target;
            self.velocity = 0.0;
            self.at_rest = true;
        }
    }
}

/// Spring animation for 2D vectors.
#[derive(Debug, Clone)]
pub struct Spring2D {
    pub x: Spring,
    pub y: Spring,
}

impl Spring2D {
    pub fn new(initial: [f32; 2], config: SpringConfig) -> Self {
        Self {
            x: Spring::new(initial[0], config),
            y: Spring::new(initial[1], config),
        }
    }

    pub fn set_target(&mut self, target: [f32; 2]) {
        self.x.set_target(target[0]);
        self.y.set_target(target[1]);
    }

    pub fn value(&self) -> [f32; 2] {
        [self.x.value(), self.y.value()]
    }

    pub fn is_at_rest(&self) -> bool {
        self.x.is_at_rest() && self.y.is_at_rest()
    }

    pub fn update(&mut self, dt: f32) {
        self.x.update(dt);
        self.y.update(dt);
    }
}

/// Spring animation for 3D vectors.
#[derive(Debug, Clone)]
pub struct Spring3D {
    pub x: Spring,
    pub y: Spring,
    pub z: Spring,
}

impl Spring3D {
    pub fn new(initial: [f32; 3], config: SpringConfig) -> Self {
        Self {
            x: Spring::new(initial[0], config),
            y: Spring::new(initial[1], config),
            z: Spring::new(initial[2], config),
        }
    }

    pub fn set_target(&mut self, target: [f32; 3]) {
        self.x.set_target(target[0]);
        self.y.set_target(target[1]);
        self.z.set_target(target[2]);
    }

    pub fn value(&self) -> [f32; 3] {
        [self.x.value(), self.y.value(), self.z.value()]
    }

    pub fn is_at_rest(&self) -> bool {
        self.x.is_at_rest() && self.y.is_at_rest() && self.z.is_at_rest()
    }

    pub fn update(&mut self, dt: f32) {
        self.x.update(dt);
        self.y.update(dt);
        self.z.update(dt);
    }
}

/// Spring animation for colors (RGBA).
#[derive(Debug, Clone)]
pub struct SpringColor {
    pub r: Spring,
    pub g: Spring,
    pub b: Spring,
    pub a: Spring,
}

impl SpringColor {
    pub fn new(initial: [f32; 4], config: SpringConfig) -> Self {
        Self {
            r: Spring::new(initial[0], config),
            g: Spring::new(initial[1], config),
            b: Spring::new(initial[2], config),
            a: Spring::new(initial[3], config),
        }
    }

    pub fn set_target(&mut self, target: [f32; 4]) {
        self.r.set_target(target[0]);
        self.g.set_target(target[1]);
        self.b.set_target(target[2]);
        self.a.set_target(target[3]);
    }

    pub fn value(&self) -> [f32; 4] {
        [self.r.value(), self.g.value(), self.b.value(), self.a.value()]
    }

    pub fn is_at_rest(&self) -> bool {
        self.r.is_at_rest() && self.g.is_at_rest() && self.b.is_at_rest() && self.a.is_at_rest()
    }

    pub fn update(&mut self, dt: f32) {
        self.r.update(dt);
        self.g.update(dt);
        self.b.update(dt);
        self.a.update(dt);
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_spring_reaches_target() {
        let mut spring = Spring::new(0.0, SpringConfig::RESPONSIVE);
        spring.set_target(1.0);

        // Simulate 2 seconds at 120Hz
        for _ in 0..240 {
            spring.update(1.0 / 120.0);
        }

        assert!(spring.is_at_rest());
        assert!((spring.value() - 1.0).abs() < 0.01);
    }

    #[test]
    fn test_spring_overshoots_with_wobbly() {
        let mut spring = Spring::new(0.0, SpringConfig::WOBBLY);
        spring.set_target(1.0);

        let mut max_value = 0.0f32;
        for _ in 0..120 {
            spring.update(1.0 / 120.0);
            max_value = max_value.max(spring.value());
        }

        // Wobbly spring should overshoot
        assert!(max_value > 1.0);
    }

    #[test]
    fn test_spring_2d() {
        let mut spring = Spring2D::new([0.0, 0.0], SpringConfig::STIFF);
        spring.set_target([100.0, 200.0]);

        for _ in 0..240 {
            spring.update(1.0 / 120.0);
        }

        let [x, y] = spring.value();
        assert!((x - 100.0).abs() < 0.1);
        assert!((y - 200.0).abs() < 0.1);
    }
}
```

### Task 2: Create animation module

**File:** `opta-native/opta-render/src/animation/mod.rs`

```rust
//! Animation system for Opta.
//!
//! Provides spring physics, easing functions, and animation state management.

mod spring;

pub use spring::{Spring, Spring2D, Spring3D, SpringColor, SpringConfig};

/// Standard delta time for 60Hz rendering.
pub const DT_60HZ: f32 = 1.0 / 60.0;

/// Standard delta time for 120Hz rendering.
pub const DT_120HZ: f32 = 1.0 / 120.0;
```

### Task 3: Add animation module to lib

**Update:** `opta-native/opta-render/src/lib.rs`

Add:

```rust
pub mod animation;
```

## Verification

```bash
cd opta-native
cargo test -p opta-render -- animation
cargo check -p opta-render
```

## Success Criteria

- [ ] Spring physics simulates correctly
- [ ] Springs reach target and come to rest
- [ ] Wobbly config overshoots as expected
- [ ] 2D/3D/Color springs work
- [ ] Tests pass

## Output

- Spring physics engine in Rust
- Configurable presets (responsive, wobbly, stiff, gentle, molasses)
- Support for 1D, 2D, 3D, and color animations
