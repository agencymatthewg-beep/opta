# Plan 64-02: Animation State Machine

## Wave: 1 (Independent)

## Objective

Create a state machine for managing complex animation sequences with transitions, timing, and event callbacks.

## Execution Context

**Reference Documents:**
- Phase 28 Ring State Machine
- Rive state machine patterns

**Key Insights:**
- Ring has 6 states: dormant → waking → active → processing → exploding → recovering
- Each state has entry/exit animations
- Transitions have defined durations and easing

## Context

**Depends on:**
- Phase 64-01 (Spring physics)

**Builds foundation for:**
- Ring animation controller
- UI component animations
- Loading states

## Tasks

### Task 1: Create animation state machine

**File:** `opta-native/opta-render/src/animation/state_machine.rs`

```rust
//! Animation state machine for managing complex animation sequences.

use std::collections::HashMap;
use std::time::Duration;
use super::spring::{Spring, SpringConfig};

/// Animation state identifier.
pub type StateId = &'static str;

/// Transition event type.
pub type TransitionCallback = Box<dyn Fn(StateId, StateId) + Send + Sync>;

/// Animation state definition.
#[derive(Debug, Clone)]
pub struct AnimationState {
    /// Unique state identifier.
    pub id: StateId,
    /// Duration to hold in this state (None = indefinite).
    pub duration: Option<Duration>,
    /// Spring config for entering this state.
    pub entry_spring: SpringConfig,
    /// Animation values in this state.
    pub values: HashMap<&'static str, f32>,
}

impl AnimationState {
    pub fn new(id: StateId) -> Self {
        Self {
            id,
            duration: None,
            entry_spring: SpringConfig::RESPONSIVE,
            values: HashMap::new(),
        }
    }

    pub fn with_duration(mut self, duration: Duration) -> Self {
        self.duration = Some(duration);
        self
    }

    pub fn with_spring(mut self, config: SpringConfig) -> Self {
        self.entry_spring = config;
        self
    }

    pub fn with_value(mut self, key: &'static str, value: f32) -> Self {
        self.values.insert(key, value);
        self
    }
}

/// Transition definition between states.
#[derive(Debug, Clone)]
pub struct Transition {
    pub from: StateId,
    pub to: StateId,
    /// Minimum time before transition can occur.
    pub delay: Duration,
    /// Spring config for this transition (overrides state default).
    pub spring: Option<SpringConfig>,
}

impl Transition {
    pub fn new(from: StateId, to: StateId) -> Self {
        Self {
            from,
            to,
            delay: Duration::ZERO,
            spring: None,
        }
    }

    pub fn with_delay(mut self, delay: Duration) -> Self {
        self.delay = delay;
        self
    }

    pub fn with_spring(mut self, config: SpringConfig) -> Self {
        self.spring = Some(config);
        self
    }
}

/// Animation state machine.
pub struct AnimationStateMachine {
    states: HashMap<StateId, AnimationState>,
    transitions: Vec<Transition>,
    current_state: StateId,
    time_in_state: Duration,
    /// Animated values (spring-interpolated).
    values: HashMap<&'static str, Spring>,
    /// Pending transition (to, delay remaining).
    pending_transition: Option<(StateId, Duration)>,
}

impl AnimationStateMachine {
    /// Create a new state machine starting in the given state.
    pub fn new(initial_state: AnimationState) -> Self {
        let id = initial_state.id;
        let mut values = HashMap::new();

        // Initialize springs from initial state values
        for (&key, &value) in &initial_state.values {
            values.insert(key, Spring::new(value, initial_state.entry_spring));
        }

        let mut states = HashMap::new();
        states.insert(id, initial_state);

        Self {
            states,
            transitions: Vec::new(),
            current_state: id,
            time_in_state: Duration::ZERO,
            values,
            pending_transition: None,
        }
    }

    /// Add a state to the machine.
    pub fn add_state(&mut self, state: AnimationState) {
        // Ensure springs exist for any new values
        for (&key, &value) in &state.values {
            self.values.entry(key).or_insert_with(|| {
                Spring::new(value, state.entry_spring)
            });
        }
        self.states.insert(state.id, state);
    }

    /// Add a transition between states.
    pub fn add_transition(&mut self, transition: Transition) {
        self.transitions.push(transition);
    }

    /// Get the current state ID.
    pub fn current_state(&self) -> StateId {
        self.current_state
    }

    /// Get an animated value by key.
    pub fn get_value(&self, key: &str) -> Option<f32> {
        self.values.get(key).map(|s| s.value())
    }

    /// Get all animated values.
    pub fn get_values(&self) -> HashMap<&'static str, f32> {
        self.values.iter().map(|(&k, v)| (k, v.value())).collect()
    }

    /// Check if all animations are at rest.
    pub fn is_at_rest(&self) -> bool {
        self.values.values().all(|s| s.is_at_rest())
    }

    /// Trigger a transition to a new state.
    pub fn transition_to(&mut self, target: StateId) -> bool {
        // Find valid transition
        let transition = self.transitions.iter()
            .find(|t| t.from == self.current_state && t.to == target);

        if let Some(transition) = transition {
            if transition.delay > Duration::ZERO {
                self.pending_transition = Some((target, transition.delay));
            } else {
                self.enter_state(target);
            }
            true
        } else {
            // Direct transition if no explicit transition defined
            if self.states.contains_key(target) {
                self.enter_state(target);
                true
            } else {
                false
            }
        }
    }

    /// Force transition without checking valid transitions.
    pub fn force_transition(&mut self, target: StateId) {
        if self.states.contains_key(target) {
            self.enter_state(target);
        }
    }

    /// Update the state machine.
    pub fn update(&mut self, dt: Duration) {
        let dt_secs = dt.as_secs_f32();

        // Update time in state
        self.time_in_state += dt;

        // Handle pending transition
        if let Some((target, remaining)) = self.pending_transition.as_mut() {
            if *remaining <= dt {
                let target = *target;
                self.pending_transition = None;
                self.enter_state(target);
            } else {
                *remaining -= dt;
            }
        }

        // Check auto-transition based on duration
        if let Some(state) = self.states.get(self.current_state) {
            if let Some(duration) = state.duration {
                if self.time_in_state >= duration {
                    // Find next state from transitions
                    if let Some(transition) = self.transitions.iter()
                        .find(|t| t.from == self.current_state)
                    {
                        let next = transition.to;
                        self.enter_state(next);
                    }
                }
            }
        }

        // Update all spring animations
        for spring in self.values.values_mut() {
            spring.update(dt_secs);
        }
    }

    fn enter_state(&mut self, target: StateId) {
        if let Some(state) = self.states.get(target) {
            self.current_state = target;
            self.time_in_state = Duration::ZERO;

            // Update spring targets
            for (&key, &value) in &state.values {
                if let Some(spring) = self.values.get_mut(key) {
                    spring.set_target(value);
                }
            }
        }
    }
}

/// Pre-built ring animation states.
pub mod ring_states {
    use super::*;
    use std::time::Duration;

    pub const DORMANT: StateId = "dormant";
    pub const WAKING: StateId = "waking";
    pub const ACTIVE: StateId = "active";
    pub const PROCESSING: StateId = "processing";
    pub const EXPLODING: StateId = "exploding";
    pub const RECOVERING: StateId = "recovering";

    /// Create the ring animation state machine.
    pub fn create_ring_state_machine() -> AnimationStateMachine {
        let dormant = AnimationState::new(DORMANT)
            .with_spring(SpringConfig::GENTLE)
            .with_value("energy", 0.0)
            .with_value("spin_speed", 0.1)
            .with_value("tilt", 15.0)
            .with_value("glow", 0.0)
            .with_value("plasma", 0.0);

        let waking = AnimationState::new(WAKING)
            .with_duration(Duration::from_millis(800))
            .with_spring(SpringConfig::RESPONSIVE)
            .with_value("energy", 0.5)
            .with_value("spin_speed", 0.5)
            .with_value("tilt", 5.0)
            .with_value("glow", 0.3)
            .with_value("plasma", 0.3);

        let active = AnimationState::new(ACTIVE)
            .with_spring(SpringConfig::RESPONSIVE)
            .with_value("energy", 1.0)
            .with_value("spin_speed", 1.0)
            .with_value("tilt", 0.0)
            .with_value("glow", 0.6)
            .with_value("plasma", 0.6);

        let processing = AnimationState::new(PROCESSING)
            .with_spring(SpringConfig::STIFF)
            .with_value("energy", 1.5)
            .with_value("spin_speed", 2.0)
            .with_value("tilt", 0.0)
            .with_value("glow", 1.0)
            .with_value("plasma", 0.8);

        let exploding = AnimationState::new(EXPLODING)
            .with_duration(Duration::from_millis(500))
            .with_spring(SpringConfig::WOBBLY)
            .with_value("energy", 3.0)
            .with_value("spin_speed", 5.0)
            .with_value("tilt", 0.0)
            .with_value("glow", 2.0)
            .with_value("plasma", 1.0);

        let recovering = AnimationState::new(RECOVERING)
            .with_duration(Duration::from_millis(1500))
            .with_spring(SpringConfig::MOLASSES)
            .with_value("energy", 0.8)
            .with_value("spin_speed", 0.8)
            .with_value("tilt", 0.0)
            .with_value("glow", 0.4)
            .with_value("plasma", 0.5);

        let mut sm = AnimationStateMachine::new(dormant);
        sm.add_state(waking);
        sm.add_state(active);
        sm.add_state(processing);
        sm.add_state(exploding);
        sm.add_state(recovering);

        // Define transitions
        sm.add_transition(Transition::new(DORMANT, WAKING));
        sm.add_transition(Transition::new(WAKING, ACTIVE));
        sm.add_transition(Transition::new(ACTIVE, DORMANT)
            .with_delay(Duration::from_secs(3)));
        sm.add_transition(Transition::new(ACTIVE, PROCESSING));
        sm.add_transition(Transition::new(PROCESSING, ACTIVE));
        sm.add_transition(Transition::new(ACTIVE, EXPLODING));
        sm.add_transition(Transition::new(EXPLODING, RECOVERING));
        sm.add_transition(Transition::new(RECOVERING, ACTIVE));

        sm
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_state_machine_basic() {
        let initial = AnimationState::new("idle")
            .with_value("x", 0.0);

        let mut sm = AnimationStateMachine::new(initial);
        assert_eq!(sm.current_state(), "idle");
        assert_eq!(sm.get_value("x"), Some(0.0));
    }

    #[test]
    fn test_ring_state_machine() {
        use ring_states::*;

        let mut sm = create_ring_state_machine();
        assert_eq!(sm.current_state(), DORMANT);

        // Transition to waking
        assert!(sm.transition_to(WAKING));
        assert_eq!(sm.current_state(), WAKING);

        // Update for a bit
        for _ in 0..100 {
            sm.update(Duration::from_millis(8));
        }

        // Should auto-transition to active after 800ms
        assert_eq!(sm.current_state(), ACTIVE);
    }
}
```

### Task 2: Update animation module

**Update:** `opta-native/opta-render/src/animation/mod.rs`

```rust
mod spring;
mod state_machine;

pub use spring::{Spring, Spring2D, Spring3D, SpringColor, SpringConfig};
pub use state_machine::{
    AnimationState, AnimationStateMachine, StateId, Transition,
    ring_states,
};

pub const DT_60HZ: f32 = 1.0 / 60.0;
pub const DT_120HZ: f32 = 1.0 / 120.0;
```

## Verification

```bash
cd opta-native
cargo test -p opta-render -- animation
cargo check -p opta-render
```

## Success Criteria

- [ ] State machine manages states correctly
- [ ] Transitions work with delays
- [ ] Auto-transitions based on duration work
- [ ] Ring state machine has all 6 states
- [ ] Values animate via springs

## Output

- Animation state machine framework
- Pre-built ring animation states
- Transition system with delays and springs
