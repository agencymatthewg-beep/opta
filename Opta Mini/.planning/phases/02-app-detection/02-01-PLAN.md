---
phase: 02-app-detection
plan: 01
subsystem: services
requires: [menu-bar-app, popover-infrastructure]
provides: [app-registry, process-monitor, app-status]
affects: [03-menu-ui, 04-app-controls]
tags: [nsworkspace, process-monitoring, combine]
discovery-level: 0
discovery-reason: NSWorkspace APIs are well-documented standard macOS patterns
---

# Phase 02-01 Plan: App Detection

## Overview

Implement process monitoring to detect running Opta ecosystem apps in real-time. This creates the data layer that Phase 3 (Menu UI) will display.

## Tasks

### Task 1: Create AppRegistry model defining Opta ecosystem apps

**Files to create:**
- `OptaMini/Models/OptaApp.swift`

**Implementation:**
```swift
import Foundation

/// Represents an app in the Opta ecosystem
struct OptaApp: Identifiable, Hashable {
    let id: String  // Bundle identifier
    let name: String
    let bundleIdentifier: String
    let icon: String  // SF Symbol name for now

    static let allApps: [OptaApp] = [
        OptaApp(
            id: "com.opta.OptaNative",
            name: "Opta MacOS",
            bundleIdentifier: "com.opta.OptaNative",
            icon: "dial.high"
        ),
        OptaApp(
            id: "com.opta.OptaLM",
            name: "Opta LM",
            bundleIdentifier: "com.opta.OptaLM",
            icon: "brain"
        ),
        OptaApp(
            id: "com.opta.OptaScan",
            name: "Opta Scan",
            bundleIdentifier: "com.opta.OptaScan",
            icon: "viewfinder"
        )
    ]
}
```

**Verification:**
- [ ] Model compiles without errors
- [ ] `OptaApp.allApps` returns expected apps

---

### Task 2: Create ProcessMonitor service using NSWorkspace

**Files to create:**
- `OptaMini/Services/ProcessMonitor.swift`

**Implementation:**
```swift
import Foundation
import AppKit
import Combine

/// Monitors running applications and tracks Opta ecosystem app status
@MainActor
final class ProcessMonitor: ObservableObject {
    /// Current status of each Opta app (bundleId -> isRunning)
    @Published private(set) var appStatus: [String: Bool] = [:]

    private var cancellables = Set<AnyCancellable>()

    init() {
        // Initialize status for all Opta apps
        for app in OptaApp.allApps {
            appStatus[app.bundleIdentifier] = false
        }

        // Check initial state
        refreshStatus()

        // Subscribe to workspace notifications
        subscribeToNotifications()
    }

    /// Refresh status by checking currently running apps
    func refreshStatus() {
        let runningApps = NSWorkspace.shared.runningApplications
        let runningBundleIds = Set(runningApps.compactMap { $0.bundleIdentifier })

        for app in OptaApp.allApps {
            appStatus[app.bundleIdentifier] = runningBundleIds.contains(app.bundleIdentifier)
        }
    }

    /// Check if a specific app is running
    func isRunning(_ app: OptaApp) -> Bool {
        appStatus[app.bundleIdentifier] ?? false
    }

    /// Count of running Opta apps
    var runningCount: Int {
        appStatus.values.filter { $0 }.count
    }

    private func subscribeToNotifications() {
        let workspace = NSWorkspace.shared
        let nc = workspace.notificationCenter

        // App launched
        nc.publisher(for: NSWorkspace.didLaunchApplicationNotification)
            .compactMap { $0.userInfo?[NSWorkspace.applicationUserInfoKey] as? NSRunningApplication }
            .sink { [weak self] app in
                self?.handleAppLaunch(app)
            }
            .store(in: &cancellables)

        // App terminated
        nc.publisher(for: NSWorkspace.didTerminateApplicationNotification)
            .compactMap { $0.userInfo?[NSWorkspace.applicationUserInfoKey] as? NSRunningApplication }
            .sink { [weak self] app in
                self?.handleAppTermination(app)
            }
            .store(in: &cancellables)
    }

    private func handleAppLaunch(_ app: NSRunningApplication) {
        guard let bundleId = app.bundleIdentifier,
              OptaApp.allApps.contains(where: { $0.bundleIdentifier == bundleId }) else {
            return
        }
        appStatus[bundleId] = true
    }

    private func handleAppTermination(_ app: NSRunningApplication) {
        guard let bundleId = app.bundleIdentifier,
              OptaApp.allApps.contains(where: { $0.bundleIdentifier == bundleId }) else {
            return
        }
        appStatus[bundleId] = false
    }
}
```

**Verification:**
- [ ] ProcessMonitor compiles without errors
- [ ] `@Published appStatus` triggers SwiftUI updates
- [ ] Notifications are received for app launch/termination

---

### Task 3: Integrate ProcessMonitor with ContentView

**Files to modify:**
- `OptaMini/ContentView.swift`
- `OptaMini/AppDelegate.swift`

**Implementation:**

Update ContentView to display app list with status:
```swift
import SwiftUI

struct ContentView: View {
    @ObservedObject var processMonitor: ProcessMonitor

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Header
            VStack(alignment: .leading, spacing: 4) {
                Text("Opta Mini")
                    .font(.title2.bold())

                Text("\(processMonitor.runningCount) of \(OptaApp.allApps.count) apps running")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }

            Divider()

            // App list
            ForEach(OptaApp.allApps) { app in
                AppRowView(app: app, isRunning: processMonitor.isRunning(app))
            }

            Spacer()
        }
        .padding()
        .frame(width: 300, height: 400)
    }
}

struct AppRowView: View {
    let app: OptaApp
    let isRunning: Bool

    var body: some View {
        HStack(spacing: 12) {
            // Status indicator
            Circle()
                .fill(isRunning ? Color.green : Color.gray.opacity(0.3))
                .frame(width: 8, height: 8)

            // App icon
            Image(systemName: app.icon)
                .font(.title3)
                .foregroundColor(isRunning ? .primary : .secondary)
                .frame(width: 24)

            // App name
            Text(app.name)
                .font(.body)
                .foregroundColor(isRunning ? .primary : .secondary)

            Spacer()

            // Status text
            Text(isRunning ? "Running" : "Stopped")
                .font(.caption)
                .foregroundColor(.secondary)
        }
        .padding(.vertical, 4)
    }
}
```

Update AppDelegate to inject ProcessMonitor:
```swift
// In AppDelegate, add property:
private var processMonitor: ProcessMonitor?

// In applicationDidFinishLaunching, before creating popover:
processMonitor = ProcessMonitor()

// Update contentViewController line:
popover?.contentViewController = NSHostingController(rootView: ContentView(processMonitor: processMonitor!))
```

**Verification:**
- [ ] App list displays all Opta ecosystem apps
- [ ] Running apps show green indicator and "Running" status
- [ ] Stopped apps show gray indicator and "Stopped" status
- [ ] Status updates in real-time when apps launch/terminate

---

### Task 4: Add Xcode project file references

**Files to modify:**
- `OptaMini.xcodeproj/project.pbxproj`

**Implementation:**
Add file references for new files to Xcode project:
- `OptaMini/Models/OptaApp.swift`
- `OptaMini/Services/ProcessMonitor.swift`

**Verification:**
- [ ] `xcodebuild build` succeeds
- [ ] All files appear in Xcode project navigator

---

## Commit Strategy

1. `feat(02-01): add OptaApp model for ecosystem apps`
2. `feat(02-01): add ProcessMonitor service with NSWorkspace`
3. `feat(02-01): integrate ProcessMonitor with ContentView`
4. `feat(02-01): update Xcode project references`

## Success Criteria

- [ ] Build succeeds with no warnings
- [ ] App displays list of Opta ecosystem apps
- [ ] Running status detected correctly for each app
- [ ] Real-time updates when apps launch/terminate
- [ ] Memory usage remains minimal (no polling, event-driven only)
