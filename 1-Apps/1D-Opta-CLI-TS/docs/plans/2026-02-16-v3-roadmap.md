# Opta CLI V3 Roadmap — Closing the Gap

> **Status:** Draft (post-V2 competitive analysis)
> **Date:** 2026-02-16
> **Goal:** Close the Agent Depth gap (45 → 80) and reach composite parity with Claude Code

## Current State (v0.3.0-alpha.1)

| Metric | Value |
|--------|-------|
| Built-in Tools | 14 |
| Tests | 195 passing (25 files) |
| Source Files | 97 |
| Lines of Code | 13,315 |
| Permission Modes | 5 (safe, auto, plan, dangerous, ci) |
| Circuit Breaker | 3-level (warn@20, pause@40, hard-stop@100) |
| MCP | Extensible (stdio + HTTP/SSE) |

## Capability Scores (0-100)

| Dimension | Current | After V3 | Delta |
|-----------|---------|----------|-------|
| File I/O | 88 | 92 | +4 |
| Search | 83 | 95 | +12 |
| Safety | 85 | 92 | +7 |
| Web Access | 65 | 70 | +5 |
| Context Mgmt | 70 | 85 | +15 |
| Agent Depth | 45 | 80 | **+35** |
| **Composite** | **73** | **86** | **+18%** |

## Remaining Gaps vs. Claude Code

1. **No Sub-Agents** — Claude Code spawns parallel child agents via Task tool
2. **No Background Shell** — Blocking shell execution limits parallel workflows
3. **No Notebook Support** — Can't edit Jupyter .ipynb cells
4. **No LSP Integration** — No go-to-definition, find-references, hover
5. **No Hook System** — No user-defined pre/post tool execution hooks
6. **No Repo Map** — Simpler than Aider's structural repo maps

---

## Phase 1: Background Shell + Async Execution

**Impact:** Unblocks parallel workflows. Currently the biggest day-to-day friction.

- Non-blocking shell execution with output polling
- Process management tools: `bg_start`, `bg_status`, `bg_output`, `bg_kill`
- Long-running task support (builds, tests, dev servers)
- Configurable timeout per command
- Tool count: 14 → 18

**Files:**
- Create: `src/core/background.ts` (~120 LOC)
- Modify: `src/core/tools.ts` (add 4 bg tools)
- Create: `tests/core/background.test.ts`

---

## Phase 2: LSP Integration

**Impact:** Precise code intelligence. Massive search quality improvement.

- Language Server Protocol client for TypeScript, Python, Go
- Tools: `lsp_definition`, `lsp_references`, `lsp_hover`, `lsp_symbols`
- Workspace-wide symbol search
- Call hierarchy (incoming/outgoing calls)
- Auto-detect available LSP servers

**Files:**
- Create: `src/lsp/client.ts` (~200 LOC)
- Create: `src/lsp/servers.ts` (server configs, ~80 LOC)
- Modify: `src/core/tools.ts` (add 4 LSP tools)
- Create: `tests/lsp/client.test.ts`

**Dependencies:** None. Language servers must be installed by user.

---

## Phase 3: Sub-Agent / Task System

**Impact:** Biggest capability gap closure. Enables parallel investigation and complex multi-step tasks.

- Spawn child agent loops with isolated context windows
- Task delegation: parent defines scope, child executes
- Result aggregation and conflict detection
- Resource budgets per sub-agent (max tool calls, max tokens)
- Parent-child communication protocol

**Files:**
- Create: `src/core/subagent.ts` (~250 LOC)
- Modify: `src/core/agent.ts` (spawn/collect interface)
- Modify: `src/core/tools.ts` (add `spawn_agent`, `collect_results`)
- Create: `tests/core/subagent.test.ts`

**Risks:** Context isolation is tricky with local LLMs. May need separate sessions per sub-agent.

---

## Phase 4: Hook System + Path Restrictions

**Impact:** Safety + automation. Enables custom validation workflows.

- Pre/post tool execution hooks (user-defined shell commands)
- Path-based access restrictions (allowlist/blocklist in config)
- Command allowlist/blocklist for shell execution
- Hook config in `.opta/config.json`
- Built-in hooks: auto-lint on write, auto-test on edit

**Files:**
- Create: `src/core/hooks.ts` (~100 LOC)
- Create: `src/core/restrictions.ts` (~80 LOC)
- Modify: `src/core/tools.ts` (wrap tool execution with hooks)
- Modify: `src/core/config.ts` (hook + restriction schemas)
- Create: `tests/core/hooks.test.ts`

---

## Phase 5: Notebook + Enhanced UX

**Impact:** Data science support + quality-of-life improvements.

- Jupyter .ipynb cell-level read/edit/insert/delete
- `notebook_read`, `notebook_edit` tools
- Shift+Tab keyboard shortcut for quick accept/reject
- Session history search across all sessions (`opta sessions search <query>`)
- Enhanced repo map with dependency graph
- Auto-detection heuristics (framework, language, project type)

**Files:**
- Create: `src/core/notebook.ts` (~120 LOC)
- Modify: `src/core/tools.ts` (add notebook tools)
- Modify: `src/commands/sessions.ts` (search subcommand)
- Create: `src/context/repomap.ts` (~150 LOC)
- Create: `tests/core/notebook.test.ts`

---

## New Ideas (Beyond Parity)

These leverage Opta's unique local-first architecture:

### Smart Tool Selection
Lightweight local classifier predicts which tools the model needs. Pre-loads file context before the model asks. Reduces round-trips 30-40%.

### SKILL-CANON Integration
Port Claude Code's 88-skill system. Skills as structured prompts injecting domain expertise (TDD, debugging, brainstorming) into the system prompt on demand.

### Inference Routing
Route tasks to different models by complexity. Simple edits → small model (fast). Complex architecture → large model (accurate). Semantic router with latency optimization.

### Screen Capture Tool
Capture screenshots for visual debugging. Feed UI screenshots to vision models. Only possible with local-first architecture — cloud CLIs can't access the user's screen.

### Auto-Lint / Auto-Test Hooks
Automatically run linter and relevant tests after every file edit. Feed failures back into agent loop without user intervention.

### Multi-Model Consensus
Run same prompt through 2-3 local models, compare outputs, pick best. Zero API cost per model. Higher accuracy on critical edits.
