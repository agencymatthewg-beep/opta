name: Opta Code — Windows Build

on:
  push:
    branches: [main]
    paths:
      - "1-Apps/optalocal/1P-Opta-Code-Desktop/**"
      - ".github/workflows/opta-code-windows-build.yml"
  pull_request:
    branches: [main]
    paths:
      - "1-Apps/optalocal/1P-Opta-Code-Desktop/**"
  workflow_dispatch:

defaults:
  run:
    working-directory: 1-Apps/optalocal/1P-Opta-Code-Desktop

jobs:
  # Unit + vitest tests (Linux, fast)
  unit-tests:
    name: Unit tests (Linux)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"
          cache-dependency-path: 1-Apps/optalocal/1P-Opta-Code-Desktop/package-lock.json
      - name: Install dependencies
        run: npm ci
      - name: Type-check
        run: npm run typecheck
      - name: Run vitest
        run: npm run test:run

  # Windows MSI/NSIS installer build via Tauri v2
  windows-build:
    name: Windows installer (Tauri v2)
    runs-on: windows-latest
    needs: unit-tests
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"
          cache-dependency-path: 1-Apps/optalocal/1P-Opta-Code-Desktop/package-lock.json
      - name: Install Rust stable
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: x86_64-pc-windows-msvc
      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: "1-Apps/optalocal/1P-Opta-Code-Desktop/src-tauri -> target"
      - name: Install Node dependencies
        run: npm ci

      # Authenticode signing — only runs when WINDOWS_CERTIFICATE secret is set.
      # To enable code signing:
      #   1. Obtain an Authenticode PFX certificate
      #   2. Store base64(PFX) as repository secret WINDOWS_CERTIFICATE
      #   3. Store PFX passphrase as repository secret WINDOWS_CERTIFICATE_PASSWORD
      # The step imports the PFX and patches tauri.conf.json with the thumbprint.
      - name: Configure Authenticode signing
        if: env.SIGNING_ENABLED == 'true'
        env:
          SIGNING_ENABLED: ${{ secrets.WINDOWS_CERTIFICATE != '' }}
          WINDOWS_CERTIFICATE: ${{ secrets.WINDOWS_CERTIFICATE }}
          WINDOWS_CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}
        shell: pwsh
        run: |
          $pfxPath = Join-Path $env:RUNNER_TEMP "opta-code.pfx"
          [IO.File]::WriteAllBytes(
            $pfxPath,
            [Convert]::FromBase64String($env:WINDOWS_CERTIFICATE)
          )
          $securePwd = ConvertTo-SecureString $env:WINDOWS_CERTIFICATE_PASSWORD -AsPlainText -Force
          Import-PfxCertificate -FilePath $pfxPath -CertStoreLocation Cert:\CurrentUser\My -Password $securePwd | Out-Null
          $thumbprint = (Get-PfxCertificate -FilePath $pfxPath -Password $securePwd).Thumbprint
          Remove-Item $pfxPath -Force
          $confPath = "src-tauri\tauri.conf.json"
          $conf = Get-Content $confPath -Raw | ConvertFrom-Json
          $conf.bundle.windows.certificateThumbprint = $thumbprint
          $conf.bundle.windows.timestampUrl = "http://timestamp.digicert.com"
          $conf | ConvertTo-Json -Depth 20 | Set-Content $confPath
          Write-Host "Code signing configured (thumbprint: $thumbprint)"

      - name: Build Vite frontend
        run: npm run build
      - name: Build Tauri app (Windows)
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          projectPath: 1-Apps/optalocal/1P-Opta-Code-Desktop
          tauriScript: npx tauri
      - name: Upload Windows installer artifact
        uses: actions/upload-artifact@v4
        with:
          name: opta-code-windows-installer
          path: |
            1-Apps/optalocal/1P-Opta-Code-Desktop/src-tauri/target/release/bundle/msi/*.msi
            1-Apps/optalocal/1P-Opta-Code-Desktop/src-tauri/target/release/bundle/nsis/*.exe
            1-Apps/optalocal/1P-Opta-Code-Desktop/src-tauri/target/release/opta-code.exe
          if-no-files-found: error
          retention-days: 30

  # Smoke test — verify installer artifacts + packaged app startup (main only)
  windows-smoke:
    name: Windows smoke test
    runs-on: windows-latest
    needs: windows-build
    if: github.event_name == 'pull_request' || github.event_name == 'workflow_dispatch' || (github.event_name == 'push' && github.ref == 'refs/heads/main')
    steps:
      - uses: actions/checkout@v4
      - uses: actions/download-artifact@v4
        with:
          name: opta-code-windows-installer
          path: dist-artifacts
      - name: Verify installer artifact exists
        shell: pwsh
        working-directory: .
        run: |
          $msiArtifacts = @(Get-ChildItem -Recurse dist-artifacts -Filter *.msi)
          $nsisArtifacts = @(Get-ChildItem -Recurse dist-artifacts -Filter *.exe | Where-Object {
            $_.FullName -match '[\\/]bundle[\\/]nsis[\\/]' -or $_.Name -match '(?i)(setup|installer|nsis)'
          })
          $installerArtifacts = @($msiArtifacts + $nsisArtifacts)
          if ($installerArtifacts.Count -eq 0) { Write-Error "No installer artifacts (.msi/.nsis) found"; exit 1 }
          Write-Host "Installer artifacts:"; $installerArtifacts | ForEach-Object { Write-Host "  $_" }
      - name: Smoke test packaged app startup
        shell: pwsh
        working-directory: .
        run: |
          .\1-Apps\optalocal\1P-Opta-Code-Desktop\tests\windows\packaged-smoke.ps1 -ArtifactsPath dist-artifacts -LogFile dist-artifacts\windows-smoke.log
      - name: Upload Windows smoke logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: opta-code-windows-smoke-logs
          path: dist-artifacts/windows-smoke.log
          if-no-files-found: error

  # Full NSIS install/liveness/uninstall smoke — manual trigger only (slow, ~5 min)
  windows-installer-smoke:
    name: Windows installer smoke (install/uninstall)
    runs-on: windows-latest
    needs: windows-build
    if: github.event_name == 'workflow_dispatch'
    steps:
      - uses: actions/checkout@v4
      - uses: actions/download-artifact@v4
        with:
          name: opta-code-windows-installer
          path: dist-artifacts
      - name: Run NSIS install, liveness, and uninstall smoke
        shell: pwsh
        working-directory: .
        run: |
          .\1-Apps\optalocal\1P-Opta-Code-Desktop\tests\windows\installer-smoke.ps1 `
            -ArtifactsPath dist-artifacts `
            -MinAliveSeconds 5 `
            -LogFile dist-artifacts\installer-smoke.log
      - name: Upload installer smoke logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: opta-code-installer-smoke-logs
          path: dist-artifacts/installer-smoke.log
          if-no-files-found: ignore

  # Aggregate release-readiness summary and enforce required gates.
  windows-release-readiness:
    name: Windows release readiness summary
    runs-on: ubuntu-latest
    needs: [unit-tests, windows-build, windows-smoke]
    if: always()
    steps:
      - name: Publish readiness summary
        env:
          UNIT_RESULT: ${{ needs.unit-tests.result }}
          BUILD_RESULT: ${{ needs.windows-build.result }}
          SMOKE_RESULT: ${{ needs.windows-smoke.result }}
          EVENT_NAME: ${{ github.event_name }}
          REF_NAME: ${{ github.ref }}
        run: |
          {
            echo "## Windows Release Readiness"
            echo ""
            echo "| Gate | Result |"
            echo "| --- | --- |"
            echo "| unit-tests | ${UNIT_RESULT} |"
            echo "| windows-build | ${BUILD_RESULT} |"
            echo "| windows-smoke | ${SMOKE_RESULT} |"
            echo ""
            echo "Event: ${EVENT_NAME}"
            echo "Ref: ${REF_NAME}"
          } >> "$GITHUB_STEP_SUMMARY"

          if [ "${UNIT_RESULT}" != "success" ]; then
            echo "unit-tests gate failed (${UNIT_RESULT})"
            exit 1
          fi

          if [ "${BUILD_RESULT}" != "success" ]; then
            echo "windows-build gate failed (${BUILD_RESULT})"
            exit 1
          fi

          if [ "${SMOKE_RESULT}" != "success" ]; then
            echo "windows-smoke gate failed (${SMOKE_RESULT})"
            exit 1
          fi
