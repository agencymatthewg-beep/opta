[{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/accounts/storage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/accounts/supabase.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/accounts/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/benchmark/news.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/benchmark/pages.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/browser/adaptation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/browser/approval-log.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/browser/artifacts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/browser/canary-evidence.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/browser/control-surface.ts","messages":[{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":1,"message":"Invalid type \"never\" of template literal expression.","line":136,"column":53,"nodeType":"Identifier","messageId":"invalidType","endLine":136,"endColumn":59}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { OptaConfig } from '../core/config.js';\nimport {\n  getSharedBrowserRuntimeDaemon,\n  type BrowserRuntimeHealth,\n} from './runtime-daemon.js';\n\nexport const BROWSER_CONTROL_ACTIONS = ['status', 'start', 'pause', 'resume', 'stop', 'kill'] as const;\nexport type BrowserControlAction = (typeof BROWSER_CONTROL_ACTIONS)[number];\n\nexport interface BrowserControlResult {\n  ok: boolean;\n  action: BrowserControlAction;\n  message: string;\n  health: BrowserRuntimeHealth;\n}\n\nexport async function runBrowserControlAction(\n  action: BrowserControlAction,\n  config: OptaConfig,\n): Promise<BrowserControlResult> {\n  const daemon = await getSharedBrowserRuntimeDaemon({\n    cwd: process.cwd(),\n    maxSessions: config.browser.runtime.maxSessions,\n    persistSessions: config.browser.runtime.persistSessions,\n    persistProfileContinuity: config.browser.runtime.persistProfileContinuity,\n    profileRetentionPolicy: {\n      retentionDays: config.browser.runtime.profileRetentionDays,\n      maxPersistedProfiles: config.browser.runtime.maxPersistedProfiles,\n    },\n    profilePruneIntervalMs: config.browser.runtime.profilePruneIntervalHours * 60 * 60 * 1_000,\n    artifactPrune: {\n      enabled: config.browser.artifacts.retention.enabled,\n      policy: {\n        retentionDays: config.browser.artifacts.retention.retentionDays,\n        maxPersistedSessions: config.browser.artifacts.retention.maxPersistedSessions,\n      },\n      intervalMs: config.browser.artifacts.retention.pruneIntervalHours * 60 * 60 * 1_000,\n    },\n    runCorpusRefresh: {\n      enabled: config.browser.runtime.runCorpus.enabled,\n      windowHours: config.browser.runtime.runCorpus.windowHours,\n    },\n  });\n  const healthBefore = daemon.health();\n\n  switch (action) {\n    case 'status': {\n      // Auto-start the daemon if enabled in config but not yet running.\n      // This ensures the Browser Control Workspace shows running=true on first open.\n      if (!healthBefore.running && config.browser.runtime.enabled) {\n        await daemon.start();\n      }\n      const health = daemon.health();\n      return {\n        ok: true,\n        action,\n        message: health.running\n          ? 'Browser runtime is running.'\n          : 'Browser runtime status retrieved.',\n        health,\n      };\n    }\n    case 'start': {\n      if (healthBefore.running) {\n        return {\n          ok: true,\n          action,\n          message: 'Browser runtime already running.',\n          health: healthBefore,\n        };\n      }\n      await daemon.start();\n      return {\n        ok: true,\n        action,\n        message: 'Browser runtime started.',\n        health: daemon.health(),\n      };\n    }\n    case 'pause':\n      if (!healthBefore.running) {\n        return {\n          ok: false,\n          action,\n          message: 'Browser runtime is not running.',\n          health: healthBefore,\n        };\n      }\n      daemon.pause();\n      return {\n        ok: true,\n        action,\n        message: 'Browser runtime paused.',\n        health: daemon.health(),\n      };\n    case 'resume':\n      if (!healthBefore.running) {\n        return {\n          ok: false,\n          action,\n          message: 'Browser runtime is not running.',\n          health: healthBefore,\n        };\n      }\n      daemon.resume();\n      return {\n        ok: true,\n        action,\n        message: 'Browser runtime resumed.',\n        health: daemon.health(),\n      };\n    case 'stop':\n      await daemon.stop({ closeSessions: true });\n      return {\n        ok: true,\n        action,\n        message: healthBefore.running\n          ? 'Browser runtime stopped and sessions closed.'\n          : 'Browser runtime already stopped.',\n        health: daemon.health(),\n      };\n    case 'kill':\n      await daemon.kill();\n      return {\n        ok: true,\n        action,\n        message: healthBefore.killed\n          ? 'Browser runtime already killed.'\n          : 'Browser runtime killed.',\n        health: daemon.health(),\n      };\n    default:\n      return {\n        ok: false,\n        action,\n        message: `Unknown browser control action: ${action}`,\n        health: daemon.health(),\n      };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/browser/intent-router.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":65,"column":18,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":65,"endColumn":20,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1295,1297],"text":"."},"desc":"Remove unnecessary optional chain"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { BrowserIntentAdaptationHint } from './adaptation.js';\nimport { clamp } from '../utils/common.js';\n\nexport type BrowserIntentConfidence = 'low' | 'medium' | 'high';\n\nexport interface BrowserIntentDecision {\n  shouldRoute: boolean;\n  confidence: BrowserIntentConfidence;\n  confidenceScore?: number;\n  reason: string;\n  rationale?: string;\n  signals: string[];\n  suggestedUrl?: string;\n  adaptationPenalty?: number;\n  adaptationReason?: string;\n}\n\nconst URL_PATTERN = /\\bhttps?:\\/\\/[^\\s<>\"'`)]+/gi;\n\nconst STRONG_SIGNALS = [\n  'open website',\n  'open this site',\n  'browser',\n  'web page',\n  'website',\n  'navigate',\n  'fill form',\n  'submit form',\n  'click',\n  'screenshot',\n  'login',\n  'sign in',\n  'checkout',\n];\n\nconst WEAK_SIGNALS = [\n  'scrape',\n  'crawl',\n  'web',\n  'url',\n  'search online',\n  'online',\n  'dashboard',\n];\n\nconst LOCAL_ONLY_SIGNALS = [\n  'refactor',\n  'unit test',\n  'typecheck',\n  'tsconfig',\n  'eslint',\n  'local file',\n  'repository',\n  'git',\n];\n\nconst ROUTE_SCORE_THRESHOLD = 3;\nconst HIGH_CONFIDENCE_SCORE_THRESHOLD = 6;\nconst NORMALIZED_SCORE_MIN = -4;\nconst NORMALIZED_SCORE_MAX = 8;\n\nfunction firstUrl(task: string): string | undefined {\n  const match = task.match(URL_PATTERN);\n  if (!match || match.length === 0) return undefined;\n  return match[0]?.replace(/[),.;:!?]+$/, '');\n}\n\nfunction includesSignal(taskLower: string, signal: string): boolean {\n  return taskLower.includes(signal);\n}\n\nfunction normalizeConfidenceScore(score: number): number {\n  const normalized = (score - NORMALIZED_SCORE_MIN) / (NORMALIZED_SCORE_MAX - NORMALIZED_SCORE_MIN);\n  return Number(clamp(normalized, 0, 1).toFixed(2));\n}\n\nfunction stableSignals(signals: string[]): string[] {\n  return [...new Set(signals)].sort((a, b) => a.localeCompare(b));\n}\n\nexport function routeBrowserIntent(\n  task: string,\n  options: {\n    adaptationHint?: BrowserIntentAdaptationHint;\n  } = {},\n): BrowserIntentDecision {\n  const normalized = task.trim();\n  const adaptationPenalty = Math.max(0, Math.floor(options.adaptationHint?.routePenalty ?? 0));\n  const adaptationReason = options.adaptationHint?.reason;\n\n  if (!normalized) {\n    return {\n      shouldRoute: false,\n      confidence: 'low',\n      confidenceScore: 0,\n      reason: 'Empty task did not contain browser intent.',\n      rationale: `route=false; score=0; threshold=${ROUTE_SCORE_THRESHOLD}; positive=0; negative=0; adaptation_penalty=${adaptationPenalty}; matched=none`,\n      signals: [],\n      adaptationPenalty,\n      adaptationReason,\n    };\n  }\n\n  const lower = normalized.toLowerCase();\n  const positiveSignals: string[] = [];\n  const negativeSignals: string[] = [];\n  let positiveScore = 0;\n  let negativeScore = 0;\n\n  const suggestedUrl = firstUrl(normalized);\n  if (suggestedUrl) {\n    positiveSignals.push('explicit:url');\n    positiveScore += 3;\n  }\n\n  for (const signal of STRONG_SIGNALS) {\n    if (includesSignal(lower, signal)) {\n      positiveSignals.push(`strong:${signal}`);\n      positiveScore += 2;\n    }\n  }\n\n  for (const signal of WEAK_SIGNALS) {\n    if (includesSignal(lower, signal)) {\n      positiveSignals.push(`weak:${signal}`);\n      positiveScore += 1;\n    }\n  }\n\n  for (const signal of LOCAL_ONLY_SIGNALS) {\n    if (includesSignal(lower, signal)) {\n      negativeSignals.push(`local:${signal}`);\n      negativeScore += 1;\n    }\n  }\n\n  if (adaptationPenalty > 0) {\n    negativeSignals.push('adaptive:route-penalty');\n    negativeScore += adaptationPenalty;\n  }\n\n  const score = positiveScore - negativeScore;\n  const shouldRoute = score >= ROUTE_SCORE_THRESHOLD;\n  const confidenceScore = normalizeConfidenceScore(score);\n  const signals = stableSignals([...positiveSignals, ...negativeSignals]);\n  const rationale = [\n    `route=${shouldRoute}`,\n    `score=${score}`,\n    `threshold=${ROUTE_SCORE_THRESHOLD}`,\n    `positive=${positiveScore}`,\n    `negative=${negativeScore}`,\n    `adaptation_penalty=${adaptationPenalty}`,\n    `matched=${signals.join('|') || 'none'}`,\n  ].join('; ');\n\n  let confidence: BrowserIntentConfidence = 'low';\n  if (shouldRoute && (score >= HIGH_CONFIDENCE_SCORE_THRESHOLD || confidenceScore >= 0.8)) {\n    confidence = 'high';\n  } else if (shouldRoute) {\n    confidence = 'medium';\n  }\n\n  return {\n    shouldRoute,\n    confidence,\n    confidenceScore,\n    reason: shouldRoute\n      ? `Intent router matched browser workflow signals with score ${score} (threshold ${ROUTE_SCORE_THRESHOLD}).`\n      : `Intent router did not meet browser routing threshold (score ${score}, threshold ${ROUTE_SCORE_THRESHOLD}).`,\n    rationale,\n    signals,\n    suggestedUrl,\n    adaptationPenalty,\n    adaptationReason,\n  };\n}\n\nexport function buildBrowserRoutingInstruction(\n  decision: BrowserIntentDecision,\n  sessionId?: string,\n): string {\n  if (!decision.shouldRoute) return '';\n\n  const lines: string[] = [\n    '### Browser Auto-Routing',\n    `Detected browser-capable intent (${decision.confidence} confidence${typeof decision.confidenceScore === 'number' ? `, score ${decision.confidenceScore.toFixed(2)}` : ''}). ${decision.reason}`,\n    'Prefer browser tools for web interaction steps in this task.',\n  ];\n\n  if (decision.rationale) {\n    lines.push(`Routing rationale: ${decision.rationale}`);\n  }\n\n  if (decision.adaptationReason) {\n    lines.push(`Routing adaptation: ${decision.adaptationReason}`);\n  }\n\n  if (sessionId) {\n    lines.push(\n      `Use browser session_id \"${sessionId}\" for browser_navigate/browser_click/browser_type/browser_snapshot/browser_screenshot.`,\n    );\n  } else {\n    lines.push('Open a browser session first with browser_open before browser interactions.');\n  }\n\n  lines.push('Policy reminder: blocked hosts are denied and high-risk actions require approval.');\n  return lines.join('\\n');\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/browser/mcp-bootstrap.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/browser/native-session-manager.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":114,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":114,"endColumn":44},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":275,"column":15,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":275,"endColumn":28,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[8700,8701],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":281,"column":36,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":281,"endColumn":49,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[8919,8920],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":324,"column":15,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":324,"endColumn":28,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[10359,10360],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":363,"column":15,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":363,"endColumn":28,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[11800,11801],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":400,"column":78,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":400,"endColumn":91,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[13206,13207],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":454,"column":9,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":454,"endColumn":22,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[15083,15084],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, value is always falsy.","line":848,"column":11,"nodeType":"Identifier","messageId":"alwaysFalsy","endLine":848,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { randomUUID } from 'node:crypto';\nimport { readFile } from 'node:fs/promises';\nimport { isAbsolute, join } from 'node:path';\nimport {\n  appendBrowserVisualDiffResultEntry,\n  appendBrowserVisualDiffManifestEntry,\n  appendBrowserSessionStep,\n  browserSessionArtifactsDir,\n  writeBrowserArtifact,\n  writeBrowserSessionMetadata,\n  writeBrowserSessionRecordings,\n} from './artifacts.js';\nimport type {\n  BrowserAction,\n  BrowserActionError,\n  BrowserActionRecord,\n  BrowserActionResult,\n  BrowserArtifactMetadata,\n  BrowserClickInput,\n  BrowserNavigateInput,\n  BrowserOpenSessionInput,\n  BrowserScreenshotData,\n  BrowserScreenshotInput,\n  BrowserSession,\n  BrowserSessionMetadata,\n  BrowserSessionRecordingEntry,\n  BrowserSessionRecordingIndex,\n  BrowserSessionStepRecord,\n  BrowserSnapshotData,\n  BrowserTypeInput,\n  BrowserVisualDiffRegressionSignal,\n  BrowserVisualDiffSeverity,\n} from './types.js';\nimport {\n  assessVisualDiffPair,\n  inferVisualDiffRegression,\n  inferVisualDiffSeverity,\n} from './visual-diff.js';\nimport { withRetryTaxonomy } from './retry-taxonomy.js';\n\nconst DEFAULT_NAVIGATION_TIMEOUT_MS = 30_000;\nconst DEFAULT_ACTION_TIMEOUT_MS = 10_000;\nconst ACTION_CANCELLED_MESSAGE = 'Browser action cancelled by runtime kill signal.';\n\nconst PLAYWRIGHT_UNAVAILABLE_ERROR: BrowserActionError = {\n  code: 'PLAYWRIGHT_UNAVAILABLE',\n  message: 'Playwright runtime is unavailable. Install \"playwright\" to enable native browser sessions.',\n  retryable: false,\n  retryCategory: 'runtime-unavailable',\n  retryHint: 'Install Playwright or enable browser runtime before retrying.',\n};\n\ninterface PlaywrightPageLike {\n  goto(url: string, options?: Record<string, unknown>): Promise<unknown>;\n  click(selector: string, options?: Record<string, unknown>): Promise<unknown>;\n  fill(selector: string, text: string, options?: Record<string, unknown>): Promise<unknown>;\n  content(): Promise<string>;\n  screenshot(options?: Record<string, unknown>): Promise<Uint8Array>;\n  url(): string;\n}\n\ninterface PlaywrightContextLike {\n  newPage(): Promise<PlaywrightPageLike>;\n  pages(): PlaywrightPageLike[];\n  close(): Promise<void>;\n}\n\ninterface PlaywrightBrowserLike {\n  newContext(options?: Record<string, unknown>): Promise<PlaywrightContextLike>;\n  contexts(): PlaywrightContextLike[];\n  close(): Promise<void>;\n}\n\ninterface PlaywrightChromiumLike {\n  launch(options?: Record<string, unknown>): Promise<PlaywrightBrowserLike>;\n  launchPersistentContext?(\n    userDataDir: string,\n    options?: Record<string, unknown>,\n  ): Promise<PlaywrightContextLike>;\n  connectOverCDP(endpoint: string, options?: Record<string, unknown>): Promise<PlaywrightBrowserLike>;\n}\n\ninterface PlaywrightRuntimeLike {\n  chromium: PlaywrightChromiumLike;\n}\n\ninterface ManagedSession {\n  session: BrowserSession;\n  browser?: PlaywrightBrowserLike;\n  context?: PlaywrightContextLike;\n  page?: PlaywrightPageLike;\n  artifacts: BrowserArtifactMetadata[];\n  actions: BrowserActionRecord[];\n  recordings: BrowserSessionRecordingEntry[];\n  artifactSequence: number;\n  timelineSequence: number;\n  timelineWrite: Promise<void>;\n}\n\nexport interface NativeSessionManagerOptions {\n  cwd?: string;\n  now?: () => Date;\n  idFactory?: () => string;\n  loadPlaywright?: () => Promise<PlaywrightRuntimeLike | null>;\n}\n\nexport interface NativeSessionActionOptions {\n  signal?: AbortSignal;\n}\n\nasync function defaultPlaywrightLoader(): Promise<PlaywrightRuntimeLike | null> {\n  try {\n    const specifier = 'playwright';\n    const runtime = await import(specifier);\n    if (!runtime || typeof runtime !== 'object' || !('chromium' in runtime)) {\n      return null;\n    }\n    return runtime as PlaywrightRuntimeLike;\n  } catch {\n    return null;\n  }\n}\n\nexport class NativeSessionManager {\n  private readonly sessions = new Map<string, ManagedSession>();\n  private readonly cwd: string;\n  private readonly now: () => Date;\n  private readonly idFactory: () => string;\n  private readonly loadPlaywright: () => Promise<PlaywrightRuntimeLike | null>;\n  private globalActionSequence = 0;\n\n  constructor(options: NativeSessionManagerOptions = {}) {\n    this.cwd = options.cwd ?? process.cwd();\n    this.now = options.now ?? (() => new Date());\n    this.idFactory = options.idFactory ?? (() => randomUUID());\n    this.loadPlaywright = options.loadPlaywright ?? defaultPlaywrightLoader;\n  }\n\n  async openSession(\n    input: BrowserOpenSessionInput = {},\n    options?: NativeSessionActionOptions,\n  ): Promise<BrowserActionResult<BrowserSession>> {\n    const sessionId = input.sessionId ?? this.idFactory();\n    const runId = input.runId?.trim() ? input.runId.trim() : sessionId;\n    const mode = input.mode ?? 'isolated';\n    const action = this.createAction(sessionId, 'openSession', {\n      runId,\n      mode,\n      wsEndpoint: input.wsEndpoint ?? '',\n      headless: input.headless ?? true,\n      profileDir: input.profileDir ?? '',\n    });\n\n    if (this.sessions.has(sessionId)) {\n      return this.fail(action, 'SESSION_EXISTS', `Browser session \"${sessionId}\" already exists.`);\n    }\n\n    const nowIso = this.timestamp();\n    const session: BrowserSession = {\n      id: sessionId,\n      runId,\n      mode,\n      status: 'open',\n      runtime: 'unavailable',\n      createdAt: nowIso,\n      updatedAt: nowIso,\n      artifactsDir: browserSessionArtifactsDir(this.cwd, sessionId),\n      profileDir: input.profileDir,\n      wsEndpoint: input.wsEndpoint,\n    };\n\n    const managed: ManagedSession = {\n      session,\n      artifacts: [],\n      actions: [],\n      recordings: [],\n      artifactSequence: 0,\n      timelineSequence: 0,\n      timelineWrite: Promise.resolve(),\n    };\n\n    this.sessions.set(sessionId, managed);\n\n    const runtime = await this.loadPlaywright();\n    if (!runtime) {\n      await this.recordAction(managed, action, false, PLAYWRIGHT_UNAVAILABLE_ERROR);\n      await this.persist(managed);\n      return {\n        ok: false,\n        action,\n        data: { ...session },\n        error: { ...PLAYWRIGHT_UNAVAILABLE_ERROR },\n      };\n    }\n\n    try {\n      const opened = await this.withActionSignal(managed, options, async () =>\n        this.openRuntimeSession(\n          runtime,\n          mode,\n          input.wsEndpoint,\n          input.headless ?? true,\n          input.profileDir,\n        ));\n      managed.browser = opened.browser;\n      managed.context = opened.context;\n      managed.page = opened.page;\n      managed.session.runtime = 'playwright';\n      managed.session.updatedAt = this.timestamp();\n\n      await this.recordAction(managed, action, true);\n      await this.persist(managed);\n      return { ok: true, action, data: { ...managed.session } };\n    } catch (err) {\n      const error = this.isAbortError(err)\n        ? this.error('ACTION_CANCELLED', ACTION_CANCELLED_MESSAGE)\n        : this.error('OPEN_SESSION_FAILED', `Failed to open browser session: ${this.errorMessage(err)}`);\n      managed.session.lastError = error;\n      managed.session.updatedAt = this.timestamp();\n      await this.recordAction(managed, action, false, error);\n      await this.safeCloseRuntime(managed);\n      await this.persist(managed);\n      return { ok: false, action, data: { ...managed.session }, error };\n    }\n  }\n\n  async closeSession(\n    sessionId: string,\n  ): Promise<BrowserActionResult<{ sessionId: string; status: 'closed' }>> {\n    const action = this.createAction(sessionId, 'closeSession', {});\n    const managed = this.sessions.get(sessionId);\n\n    if (!managed) {\n      return this.fail(action, 'SESSION_NOT_FOUND', `Browser session \"${sessionId}\" was not found.`);\n    }\n\n    await this.safeCloseRuntime(managed);\n    managed.session.status = 'closed';\n    managed.session.updatedAt = this.timestamp();\n\n    await this.recordAction(managed, action, true);\n    await this.persist(managed);\n\n    this.sessions.delete(sessionId);\n    return {\n      ok: true,\n      action,\n      data: {\n        sessionId,\n        status: 'closed',\n      },\n    };\n  }\n\n  async navigate(\n    sessionId: string,\n    input: BrowserNavigateInput,\n    options?: NativeSessionActionOptions,\n  ): Promise<BrowserActionResult<{ url: string }>> {\n    const action = this.createAction(sessionId, 'navigate', input as unknown as Record<string, unknown>);\n    const managed = this.sessions.get(sessionId);\n    if (!managed) {\n      return this.fail(action, 'SESSION_NOT_FOUND', `Browser session \"${sessionId}\" was not found.`);\n    }\n\n    const gate = this.ensurePage(managed);\n    if (gate) {\n      await this.recordAction(managed, action, false, gate);\n      await this.persist(managed);\n      return { ok: false, action, error: gate };\n    }\n\n    try {\n      await this.withActionSignal(managed, options, async () => {\n        await managed.page!.goto(input.url, {\n          timeout: input.timeoutMs ?? DEFAULT_NAVIGATION_TIMEOUT_MS,\n          waitUntil: input.waitUntil ?? 'domcontentloaded',\n        });\n      });\n\n      managed.session.currentUrl = managed.page!.url();\n      managed.session.updatedAt = this.timestamp();\n\n      await this.recordAction(managed, action, true);\n      await this.persist(managed);\n      return {\n        ok: true,\n        action,\n        data: {\n          url: managed.session.currentUrl,\n        },\n      };\n    } catch (err) {\n      const error = this.isAbortError(err)\n        ? this.error('ACTION_CANCELLED', ACTION_CANCELLED_MESSAGE)\n        : this.error('NAVIGATE_FAILED', `Navigate failed: ${this.errorMessage(err)}`);\n      managed.session.updatedAt = this.timestamp();\n      await this.recordAction(managed, action, false, error);\n      await this.persist(managed);\n      return { ok: false, action, error };\n    }\n  }\n\n  async click(\n    sessionId: string,\n    input: BrowserClickInput,\n    options?: NativeSessionActionOptions,\n  ): Promise<BrowserActionResult> {\n    const action = this.createAction(sessionId, 'click', input as unknown as Record<string, unknown>);\n    const managed = this.sessions.get(sessionId);\n    if (!managed) {\n      return this.fail(action, 'SESSION_NOT_FOUND', `Browser session \"${sessionId}\" was not found.`);\n    }\n\n    const gate = this.ensurePage(managed);\n    if (gate) {\n      await this.recordAction(managed, action, false, gate);\n      await this.persist(managed);\n      return { ok: false, action, error: gate };\n    }\n\n    try {\n      await this.withActionSignal(managed, options, async () => {\n        await managed.page!.click(input.selector, {\n          timeout: input.timeoutMs ?? DEFAULT_ACTION_TIMEOUT_MS,\n        });\n      });\n      managed.session.updatedAt = this.timestamp();\n      await this.recordAction(managed, action, true);\n      await this.persist(managed);\n      return { ok: true, action };\n    } catch (err) {\n      const error = this.isAbortError(err)\n        ? this.error('ACTION_CANCELLED', ACTION_CANCELLED_MESSAGE)\n        : this.error('CLICK_FAILED', `Click failed: ${this.errorMessage(err)}`);\n      managed.session.updatedAt = this.timestamp();\n      await this.recordAction(managed, action, false, error);\n      await this.persist(managed);\n      return { ok: false, action, error };\n    }\n  }\n\n  async type(\n    sessionId: string,\n    input: BrowserTypeInput,\n    options?: NativeSessionActionOptions,\n  ): Promise<BrowserActionResult> {\n    const action = this.createAction(sessionId, 'type', input as unknown as Record<string, unknown>);\n    const managed = this.sessions.get(sessionId);\n    if (!managed) {\n      return this.fail(action, 'SESSION_NOT_FOUND', `Browser session \"${sessionId}\" was not found.`);\n    }\n\n    const gate = this.ensurePage(managed);\n    if (gate) {\n      await this.recordAction(managed, action, false, gate);\n      await this.persist(managed);\n      return { ok: false, action, error: gate };\n    }\n\n    try {\n      await this.withActionSignal(managed, options, async () => {\n        await managed.page!.fill(input.selector, input.text, {\n          timeout: input.timeoutMs ?? DEFAULT_ACTION_TIMEOUT_MS,\n        });\n      });\n      managed.session.updatedAt = this.timestamp();\n      await this.recordAction(managed, action, true);\n      await this.persist(managed);\n      return { ok: true, action };\n    } catch (err) {\n      const error = this.isAbortError(err)\n        ? this.error('ACTION_CANCELLED', ACTION_CANCELLED_MESSAGE)\n        : this.error('TYPE_FAILED', `Type failed: ${this.errorMessage(err)}`);\n      managed.session.updatedAt = this.timestamp();\n      await this.recordAction(managed, action, false, error);\n      await this.persist(managed);\n      return { ok: false, action, error };\n    }\n  }\n\n  async snapshot(\n    sessionId: string,\n    options?: NativeSessionActionOptions,\n  ): Promise<BrowserActionResult<BrowserSnapshotData>> {\n    const action = this.createAction(sessionId, 'snapshot', {});\n    const managed = this.sessions.get(sessionId);\n    if (!managed) {\n      return this.fail(action, 'SESSION_NOT_FOUND', `Browser session \"${sessionId}\" was not found.`);\n    }\n\n    const gate = this.ensurePage(managed);\n    if (gate) {\n      await this.recordAction(managed, action, false, gate);\n      await this.persist(managed);\n      return { ok: false, action, error: gate };\n    }\n\n    try {\n      const html = await this.withActionSignal(managed, options, async () => managed.page!.content());\n      const artifact = await this.createArtifact(managed, action.id, 'snapshot', 'html', 'text/html', html);\n      managed.session.updatedAt = this.timestamp();\n      await this.recordAction(managed, action, true, undefined, artifact);\n      await this.persist(managed);\n      return {\n        ok: true,\n        action,\n        data: {\n          html,\n          artifact,\n        },\n      };\n    } catch (err) {\n      const error = this.isAbortError(err)\n        ? this.error('ACTION_CANCELLED', ACTION_CANCELLED_MESSAGE)\n        : this.error('SNAPSHOT_FAILED', `Snapshot failed: ${this.errorMessage(err)}`);\n      managed.session.updatedAt = this.timestamp();\n      await this.recordAction(managed, action, false, error);\n      await this.persist(managed);\n      return { ok: false, action, error };\n    }\n  }\n\n  async screenshot(\n    sessionId: string,\n    input: BrowserScreenshotInput = {},\n    options?: NativeSessionActionOptions,\n  ): Promise<BrowserActionResult<BrowserScreenshotData>> {\n    const action = this.createAction(sessionId, 'screenshot', input as Record<string, unknown>);\n    const managed = this.sessions.get(sessionId);\n    if (!managed) {\n      return this.fail(action, 'SESSION_NOT_FOUND', `Browser session \"${sessionId}\" was not found.`);\n    }\n\n    const gate = this.ensurePage(managed);\n    if (gate) {\n      await this.recordAction(managed, action, false, gate);\n      await this.persist(managed);\n      return { ok: false, action, error: gate };\n    }\n\n    try {\n      const type = input.type ?? 'png';\n      const screenshotOptions: Record<string, unknown> = {\n        fullPage: input.fullPage ?? true,\n        type,\n      };\n\n      if (typeof input.quality === 'number') {\n        screenshotOptions.quality = input.quality;\n      }\n\n      const image = await this.withActionSignal(managed, options, async () =>\n        managed.page!.screenshot(screenshotOptions));\n      const artifact = await this.createArtifact(\n        managed,\n        action.id,\n        'screenshot',\n        type === 'jpeg' ? 'jpg' : 'png',\n        type === 'jpeg' ? 'image/jpeg' : 'image/png',\n        image,\n      );\n\n      managed.session.updatedAt = this.timestamp();\n      await this.recordAction(managed, action, true, undefined, artifact);\n      await this.persist(managed);\n\n      return {\n        ok: true,\n        action,\n        data: {\n          artifact,\n        },\n      };\n    } catch (err) {\n      const error = this.isAbortError(err)\n        ? this.error('ACTION_CANCELLED', ACTION_CANCELLED_MESSAGE)\n        : this.error('SCREENSHOT_FAILED', `Screenshot failed: ${this.errorMessage(err)}`);\n      managed.session.updatedAt = this.timestamp();\n      await this.recordAction(managed, action, false, error);\n      await this.persist(managed);\n      return { ok: false, action, error };\n    }\n  }\n\n  private async openRuntimeSession(\n    runtime: PlaywrightRuntimeLike,\n    mode: BrowserOpenSessionInput['mode'],\n    wsEndpoint: string | undefined,\n    headless: boolean,\n    profileDir: string | undefined,\n  ): Promise<{\n    browser?: PlaywrightBrowserLike;\n    context: PlaywrightContextLike;\n    page: PlaywrightPageLike;\n  }> {\n    if (mode === 'attach') {\n      if (!wsEndpoint) {\n        throw new Error('Attach mode requires wsEndpoint.');\n      }\n      const browser = await runtime.chromium.connectOverCDP(wsEndpoint);\n      const context = browser.contexts()[0] ?? await browser.newContext();\n      const page = context.pages()[0] ?? await context.newPage();\n      return { browser, context, page };\n    }\n\n    if (profileDir && typeof runtime.chromium.launchPersistentContext === 'function') {\n      const context = await runtime.chromium.launchPersistentContext(profileDir, { headless });\n      const page = context.pages()[0] ?? await context.newPage();\n      return { context, page };\n    }\n\n    const browser = await runtime.chromium.launch({ headless });\n    const context = await browser.newContext();\n    const page = await context.newPage();\n    return { browser, context, page };\n  }\n\n  private ensurePage(managed: ManagedSession): BrowserActionError | null {\n    if (managed.session.status !== 'open') {\n      return this.error('SESSION_CLOSED', `Browser session \"${managed.session.id}\" is closed.`);\n    }\n\n    if (!managed.page || managed.session.runtime !== 'playwright') {\n      return { ...PLAYWRIGHT_UNAVAILABLE_ERROR };\n    }\n\n    return null;\n  }\n\n  private async createArtifact(\n    managed: ManagedSession,\n    actionId: string,\n    kind: 'snapshot' | 'screenshot',\n    extension: string,\n    mimeType: string,\n    content: string | Uint8Array,\n  ): Promise<BrowserArtifactMetadata> {\n    managed.artifactSequence += 1;\n\n    return writeBrowserArtifact({\n      cwd: this.cwd,\n      sessionId: managed.session.id,\n      actionId,\n      sequence: managed.artifactSequence,\n      kind,\n      extension,\n      mimeType,\n      content,\n      createdAt: this.timestamp(),\n    });\n  }\n\n  private async persist(managed: ManagedSession): Promise<void> {\n    const metadata: BrowserSessionMetadata = {\n      schemaVersion: 1,\n      sessionId: managed.session.id,\n      runId: managed.session.runId,\n      mode: managed.session.mode,\n      status: managed.session.status,\n      runtime: managed.session.runtime,\n      createdAt: managed.session.createdAt,\n      updatedAt: managed.session.updatedAt,\n      currentUrl: managed.session.currentUrl,\n      wsEndpoint: managed.session.wsEndpoint,\n      profileDir: managed.session.profileDir,\n      lastError: managed.session.lastError,\n      artifacts: [...managed.artifacts],\n      actions: [...managed.actions],\n    };\n\n    const recordings: BrowserSessionRecordingIndex = {\n      schemaVersion: 1,\n      sessionId: managed.session.id,\n      runId: managed.session.runId,\n      createdAt: managed.session.createdAt,\n      updatedAt: managed.session.updatedAt,\n      recordings: [...managed.recordings].sort((left, right) => left.sequence - right.sequence),\n    };\n\n    await writeBrowserSessionMetadata(this.cwd, metadata);\n    await writeBrowserSessionRecordings(this.cwd, recordings);\n  }\n\n  private async recordAction(\n    managed: ManagedSession,\n    action: BrowserAction,\n    ok: boolean,\n    error?: BrowserActionError,\n    artifact?: BrowserArtifactMetadata,\n  ): Promise<void> {\n    const artifactIds: string[] = [];\n    const artifactPaths: string[] = [];\n    if (artifact) {\n      managed.artifacts.push(artifact);\n      artifactIds.push(artifact.id);\n      artifactPaths.push(artifact.relativePath);\n    }\n\n    managed.actions.push({\n      action,\n      ok,\n      error,\n      artifactIds,\n    });\n\n    managed.timelineSequence += 1;\n    const timestamp = this.timestamp();\n    const step: BrowserSessionStepRecord = {\n      sequence: managed.timelineSequence,\n      sessionId: managed.session.id,\n      runId: managed.session.runId,\n      actionId: action.id,\n      actionType: action.type,\n      timestamp,\n      ok,\n      error,\n      artifactIds: [...artifactIds],\n      artifactPaths: [...artifactPaths],\n    };\n\n    managed.recordings.push({\n      sequence: step.sequence,\n      sessionId: step.sessionId,\n      runId: step.runId,\n      actionId: step.actionId,\n      actionType: step.actionType,\n      timestamp: step.timestamp,\n      ok: step.ok,\n      error: step.error,\n      artifactIds: [...step.artifactIds],\n      artifactPaths: [...step.artifactPaths],\n    });\n\n    managed.timelineWrite = managed.timelineWrite\n      .catch(() => undefined)\n      .then(async () => {\n        await appendBrowserSessionStep(this.cwd, step);\n        await appendBrowserVisualDiffManifestEntry(this.cwd, {\n          schemaVersion: 1,\n          sessionId: step.sessionId,\n          runId: step.runId,\n          sequence: step.sequence,\n          actionId: step.actionId,\n          actionType: step.actionType,\n          timestamp: step.timestamp,\n          status: 'pending',\n          artifactIds: [...step.artifactIds],\n          artifactPaths: [...step.artifactPaths],\n        });\n\n        const previousStep = managed.recordings.at(-2);\n        if (previousStep) {\n          const {\n            status,\n            fromScreenshotPath,\n            toScreenshotPath,\n            changedByteRatio,\n            perceptualDiffScore,\n            severity,\n            regressionScore,\n            regressionSignal,\n          } = await this.computeVisualDiffStatus(\n            previousStep,\n            step,\n          );\n          await appendBrowserVisualDiffResultEntry(this.cwd, {\n            schemaVersion: 1,\n            sessionId: step.sessionId,\n            runId: step.runId,\n            index: step.sequence - 2,\n            fromSequence: previousStep.sequence,\n            fromActionId: previousStep.actionId,\n            fromActionType: previousStep.actionType,\n            toSequence: step.sequence,\n            toActionId: step.actionId,\n            toActionType: step.actionType,\n            fromScreenshotPath,\n            toScreenshotPath,\n            status,\n            changedByteRatio,\n            perceptualDiffScore,\n            severity,\n            regressionScore,\n            regressionSignal,\n          });\n        }\n      })\n      .then(() => undefined);\n    await managed.timelineWrite;\n\n    managed.session.updatedAt = timestamp;\n    managed.session.lastError = error;\n  }\n\n  private resolveArtifactAbsolutePath(sessionId: string, artifactPath: string): string {\n    if (isAbsolute(artifactPath)) return artifactPath;\n    if (artifactPath.startsWith('.opta/')) {\n      return join(this.cwd, artifactPath);\n    }\n    return join(browserSessionArtifactsDir(this.cwd, sessionId), artifactPath);\n  }\n\n  private isScreenshotArtifactPath(artifactPath: string): boolean {\n    const lower = artifactPath.toLowerCase();\n    return (\n      lower.endsWith('.png') ||\n      lower.endsWith('.jpg') ||\n      lower.endsWith('.jpeg') ||\n      lower.endsWith('.webp') ||\n      lower.endsWith('.gif') ||\n      lower.endsWith('.bmp')\n    );\n  }\n\n  private findStepScreenshotPath(step: Pick<BrowserSessionStepRecord, 'sessionId' | 'artifactPaths'>): string | undefined {\n    return step.artifactPaths.find((path) => this.isScreenshotArtifactPath(path));\n  }\n\n  private async computeVisualDiffStatus(\n    fromStep: BrowserSessionStepRecord,\n    toStep: BrowserSessionStepRecord,\n  ): Promise<{\n    status: 'changed' | 'unchanged' | 'missing';\n    fromScreenshotPath?: string;\n    toScreenshotPath?: string;\n    changedByteRatio?: number;\n    perceptualDiffScore?: number;\n    severity: BrowserVisualDiffSeverity;\n    regressionScore: number;\n    regressionSignal: BrowserVisualDiffRegressionSignal;\n  }> {\n    const fromScreenshotPath = this.findStepScreenshotPath(fromStep);\n    const toScreenshotPath = this.findStepScreenshotPath(toStep);\n    if (!fromScreenshotPath || !toScreenshotPath) {\n      const status = 'missing';\n      const severity = inferVisualDiffSeverity(status);\n      const regression = inferVisualDiffRegression(status, severity);\n      return {\n        status,\n        fromScreenshotPath,\n        toScreenshotPath,\n        severity,\n        ...regression,\n      };\n    }\n\n    try {\n      const [fromBytes, toBytes] = await Promise.all([\n        readFile(this.resolveArtifactAbsolutePath(fromStep.sessionId, fromScreenshotPath)),\n        readFile(this.resolveArtifactAbsolutePath(toStep.sessionId, toScreenshotPath)),\n      ]);\n      const assessment = assessVisualDiffPair(fromBytes, toBytes);\n\n      return {\n        status: assessment.status,\n        fromScreenshotPath,\n        toScreenshotPath,\n        changedByteRatio: assessment.changedByteRatio,\n        perceptualDiffScore: assessment.perceptualDiffScore,\n        severity: assessment.severity,\n        regressionScore: assessment.regressionScore,\n        regressionSignal: assessment.regressionSignal,\n      };\n    } catch {\n      const status = 'missing';\n      const severity = inferVisualDiffSeverity(status);\n      const regression = inferVisualDiffRegression(status, severity);\n      return {\n        status,\n        fromScreenshotPath,\n        toScreenshotPath,\n        severity,\n        ...regression,\n      };\n    }\n  }\n\n  private createAction(\n    sessionId: string,\n    type: BrowserAction['type'],\n    input: Record<string, unknown>,\n  ): BrowserAction {\n    this.globalActionSequence += 1;\n    return {\n      id: `action-${String(this.globalActionSequence).padStart(6, '0')}`,\n      sessionId,\n      type,\n      createdAt: this.timestamp(),\n      input,\n    };\n  }\n\n  private fail<T>(\n    action: BrowserAction,\n    code: string,\n    message: string,\n  ): BrowserActionResult<T> {\n    return {\n      ok: false,\n      action,\n      error: this.error(code, message),\n    };\n  }\n\n  private error(code: string, message: string): BrowserActionError {\n    return withRetryTaxonomy(code, message);\n  }\n\n  private errorMessage(err: unknown): string {\n    return err instanceof Error ? err.message : String(err);\n  }\n\n  private isAbortError(err: unknown): boolean {\n    return err instanceof Error && err.name === 'AbortError';\n  }\n\n  private makeAbortError(): Error {\n    const err = new Error(ACTION_CANCELLED_MESSAGE);\n    err.name = 'AbortError';\n    return err;\n  }\n\n  private async withActionSignal<T>(\n    managed: ManagedSession,\n    options: NativeSessionActionOptions | undefined,\n    execute: () => Promise<T>,\n  ): Promise<T> {\n    const signal = options?.signal;\n    if (!signal) return execute();\n    if (signal.aborted) {\n      await this.safeCloseRuntime(managed);\n      throw this.makeAbortError();\n    }\n\n    let onAbort: (() => void) | null = null;\n    const abortPromise = new Promise<never>((_, reject) => {\n      onAbort = () => {\n        void this.safeCloseRuntime(managed);\n        reject(this.makeAbortError());\n      };\n      signal.addEventListener('abort', onAbort, { once: true });\n    });\n\n    try {\n      return await Promise.race([execute(), abortPromise]);\n    } finally {\n      if (onAbort) {\n        signal.removeEventListener('abort', onAbort);\n      }\n    }\n  }\n\n  private timestamp(): string {\n    return this.now().toISOString();\n  }\n\n  private async safeCloseRuntime(managed: ManagedSession): Promise<void> {\n    const context = managed.context;\n    if (context) {\n      try {\n        await context.close();\n      } catch {\n        // Best-effort cleanup\n      }\n    }\n\n    const browser = managed.browser;\n    if (browser) {\n      try {\n        await browser.close();\n      } catch {\n        // Best-effort cleanup\n      }\n    }\n\n    managed.page = undefined;\n    managed.context = undefined;\n    managed.browser = undefined;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/browser/policy-engine.ts","messages":[{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['url'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":146,"column":22,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":146,"endColumn":39},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['mode'] ?? 'isolated'' will use Object's default stringification format ('[object Object]') when stringified.","line":228,"column":25,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":228,"endColumn":51}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { BrowserPolicyAdaptationHint } from './adaptation.js';\n\nconst DEFAULT_SENSITIVE_ACTIONS = ['auth_submit', 'post', 'checkout', 'delete'] as const;\n\nexport type BrowserRiskLevel = 'low' | 'medium' | 'high';\nexport type BrowserPolicyDecisionType = 'allow' | 'gate' | 'deny';\n\nexport interface BrowserPolicyConfig {\n  requireApprovalForHighRisk: boolean;\n  allowedHosts: string[];\n  blockedOrigins: string[];\n  sensitiveActions: string[];\n}\n\nexport interface BrowserPolicyRequest {\n  toolName: string;\n  args: Record<string, unknown>;\n  approved?: boolean;\n  adaptationHint?: BrowserPolicyAdaptationHint;\n}\n\nexport interface BrowserRiskEvidence {\n  classifier: 'static' | 'adaptive-escalation';\n  matchedSignals: string[];\n  adaptationReason?: string;\n}\n\nexport interface BrowserPolicyDecision {\n  decision: BrowserPolicyDecisionType;\n  risk: BrowserRiskLevel;\n  reason: string;\n  actionKey: string;\n  targetHost?: string;\n  targetOrigin?: string;\n  riskEvidence: BrowserRiskEvidence;\n}\n\nfunction normalizeList(values: string[] | undefined): string[] {\n  if (!values || values.length === 0) return [];\n  const seen = new Set<string>();\n  const normalized: string[] = [];\n  for (const value of values) {\n    const candidate = value.trim().toLowerCase();\n    if (!candidate || seen.has(candidate)) continue;\n    seen.add(candidate);\n    normalized.push(candidate);\n  }\n  return normalized;\n}\n\nfunction uniqueSorted(values: string[]): string[] {\n  return [...new Set(values)].sort((left, right) => left.localeCompare(right));\n}\n\nexport function normalizeBrowserPolicyConfig(\n  input?: Partial<BrowserPolicyConfig> | null,\n): BrowserPolicyConfig {\n  const allowedHosts = normalizeList(input?.allowedHosts ?? ['*']);\n  return {\n    requireApprovalForHighRisk: input?.requireApprovalForHighRisk !== false,\n    allowedHosts: allowedHosts.length > 0 ? allowedHosts : ['*'],\n    blockedOrigins: normalizeList(input?.blockedOrigins ?? []),\n    sensitiveActions: normalizeList(\n      input?.sensitiveActions?.length\n        ? input.sensitiveActions\n        : [...DEFAULT_SENSITIVE_ACTIONS],\n    ),\n  };\n}\n\nfunction wildcardHostMatch(host: string, pattern: string): boolean {\n  if (pattern === '*') return true;\n  if (pattern.startsWith('*.')) {\n    const suffix = pattern.slice(1);\n    return host.endsWith(suffix);\n  }\n  return host === pattern;\n}\n\nfunction normalizePatternInput(pattern: string): string {\n  return pattern.trim().toLowerCase();\n}\n\nfunction parseHostPattern(pattern: string): string {\n  const normalized = normalizePatternInput(pattern);\n  if (!normalized) return '';\n  if (normalized === '*') return '*';\n\n  if (normalized.startsWith('*.')) {\n    const wildcardHost = normalized.split('/')[0] ?? '';\n    return wildcardHost.replace(/:\\d+$/, '');\n  }\n\n  const candidate = normalized.includes('://') ? normalized : `https://${normalized}`;\n  try {\n    const parsed = new URL(candidate);\n    return parsed.hostname.toLowerCase();\n  } catch {\n    return '';\n  }\n}\n\nfunction parseOriginPattern(pattern: string): string | null {\n  const normalized = normalizePatternInput(pattern);\n  if (!normalized) return null;\n  if (normalized.includes('://')) {\n    try {\n      const parsed = new URL(normalized);\n      return `${parsed.protocol}//${parsed.host}`.toLowerCase();\n    } catch {\n      return null;\n    }\n  }\n  return null;\n}\n\nfunction hostAllowed(host: string, allowedHosts: string[]): boolean {\n  if (allowedHosts.length === 0) return true;\n  for (const pattern of allowedHosts) {\n    const parsedPattern = parseHostPattern(pattern);\n    if (!parsedPattern) continue;\n    if (wildcardHostMatch(host, parsedPattern)) return true;\n  }\n  return false;\n}\n\nfunction originBlocked(origin: string, host: string, blockedOrigins: string[]): boolean {\n  for (const pattern of blockedOrigins) {\n    const parsedOrigin = parseOriginPattern(pattern);\n    if (parsedOrigin) {\n      if (origin === parsedOrigin) return true;\n      continue;\n    }\n    const hostPattern = parseHostPattern(pattern);\n    if (!hostPattern) continue;\n    if (wildcardHostMatch(host, hostPattern)) return true;\n  }\n  return false;\n}\n\nfunction extractUrlTarget(args: Record<string, unknown>): {\n  url?: URL;\n  host?: string;\n  origin?: string;\n} {\n  const raw = String(args['url'] ?? '').trim();\n  if (!raw) return {};\n  try {\n    const parsed = new URL(raw);\n    if (parsed.protocol !== 'http:' && parsed.protocol !== 'https:') {\n      return {};\n    }\n    return {\n      url: parsed,\n      host: parsed.hostname.toLowerCase(),\n      origin: `${parsed.protocol}//${parsed.host}`.toLowerCase(),\n    };\n  } catch {\n    return {};\n  }\n}\n\ninterface SensitiveSignalMatch {\n  actionKey: string;\n  signal: string;\n}\n\nfunction signalContainsSensitiveKeyword(value: string): SensitiveSignalMatch | null {\n  const text = value.toLowerCase();\n  if (/(login|sign[-_\\s]?in|auth|password|otp|2fa)/.test(text)) {\n    return { actionKey: 'auth_submit', signal: 'keyword:auth' };\n  }\n  if (/(checkout|payment|billing|purchase|buy|order)/.test(text)) {\n    return { actionKey: 'checkout', signal: 'keyword:checkout' };\n  }\n  if (/(delete|remove|destroy|erase|deactivate)/.test(text)) {\n    return { actionKey: 'delete', signal: 'keyword:delete' };\n  }\n  if (/(post|publish|submit|send|comment|tweet)/.test(text)) {\n    return { actionKey: 'post', signal: 'keyword:post' };\n  }\n  return null;\n}\n\nconst SENSITIVE_TEXT_ARG_KEYS = [\n  'selector',\n  'text',\n  'element',\n  'name',\n  'label',\n  'title',\n  'value',\n  'promptText',\n  'url',\n  'href',\n] as const;\n\nfunction collectSensitiveSignalText(args: Record<string, unknown>): string {\n  const parts: string[] = [];\n  for (const key of SENSITIVE_TEXT_ARG_KEYS) {\n    const candidate = args[key];\n    if (typeof candidate === 'string' && candidate.trim()) {\n      parts.push(candidate);\n    }\n  }\n  return parts.join(' ');\n}\n\nfunction isTruthyFlag(value: unknown): boolean {\n  if (value === true || value === 1) return true;\n  if (typeof value === 'string') {\n    const normalized = value.trim().toLowerCase();\n    return normalized === 'true' || normalized === '1' || normalized === 'yes' || normalized === 'on';\n  }\n  return false;\n}\n\nfunction classifyAction(\n  toolName: string,\n  args: Record<string, unknown>,\n  sensitiveActions: Set<string>,\n): { risk: BrowserRiskLevel; actionKey: string; matchedSignals: string[] } {\n  if (toolName === 'browser_snapshot' || toolName === 'browser_screenshot' || toolName === 'browser_close') {\n    return { risk: 'low', actionKey: 'observe', matchedSignals: [`tool:${toolName}`] };\n  }\n\n  if (toolName === 'browser_open') {\n    const mode = String(args['mode'] ?? 'isolated').toLowerCase();\n    return mode === 'attach'\n      ? { risk: 'medium', actionKey: 'attach', matchedSignals: ['tool:browser_open', 'mode:attach'] }\n      : { risk: 'low', actionKey: 'open', matchedSignals: ['tool:browser_open', 'mode:isolated'] };\n  }\n\n  if (toolName === 'browser_navigate') {\n    const target = extractUrlTarget(args);\n    const matchedSignals = ['tool:browser_navigate'];\n    if (target.url) {\n      const candidate = signalContainsSensitiveKeyword(\n        `${target.url.pathname} ${target.url.search} ${target.url.hash}`,\n      );\n      if (candidate && sensitiveActions.has(candidate.actionKey)) {\n        matchedSignals.push(`url:${candidate.signal}`);\n        return { risk: 'high', actionKey: candidate.actionKey, matchedSignals };\n      }\n    }\n    return { risk: 'medium', actionKey: 'navigate', matchedSignals };\n  }\n\n  if (toolName === 'browser_click' || toolName === 'browser_type') {\n    const matchedSignals = [`tool:${toolName}`];\n    const keywordMatch = signalContainsSensitiveKeyword(collectSensitiveSignalText(args));\n    if (keywordMatch && sensitiveActions.has(keywordMatch.actionKey)) {\n      matchedSignals.push(`args:${keywordMatch.signal}`);\n      return { risk: 'high', actionKey: keywordMatch.actionKey, matchedSignals };\n    }\n\n    if (toolName === 'browser_type' && isTruthyFlag(args['submit']) && sensitiveActions.has('post')) {\n      matchedSignals.push('flag:submit');\n      return { risk: 'high', actionKey: 'post', matchedSignals };\n    }\n\n    return {\n      risk: 'medium',\n      actionKey: toolName === 'browser_click' ? 'click' : 'type',\n      matchedSignals,\n    };\n  }\n\n  if (toolName === 'browser_handle_dialog') {\n    const accepted = isTruthyFlag(args['accept']);\n    const matchedSignals = ['tool:browser_handle_dialog', accepted ? 'dialog:accept' : 'dialog:dismiss'];\n    const keywordMatch = signalContainsSensitiveKeyword(collectSensitiveSignalText(args));\n\n    if (accepted && keywordMatch && sensitiveActions.has(keywordMatch.actionKey)) {\n      matchedSignals.push(`dialog:${keywordMatch.signal}`);\n      return { risk: 'high', actionKey: keywordMatch.actionKey, matchedSignals };\n    }\n\n    return accepted\n      ? { risk: 'medium', actionKey: 'confirm', matchedSignals }\n      : { risk: 'low', actionKey: 'dismiss', matchedSignals };\n  }\n\n  return { risk: 'low', actionKey: 'other', matchedSignals: [`tool:${toolName}`] };\n}\n\nexport function isBrowserToolName(toolName: string): boolean {\n  return toolName.startsWith('browser_');\n}\n\nexport function evaluateBrowserPolicyAction(\n  configInput: Partial<BrowserPolicyConfig> | undefined,\n  request: BrowserPolicyRequest,\n): BrowserPolicyDecision {\n  const config = normalizeBrowserPolicyConfig(configInput);\n  const target = extractUrlTarget(request.args);\n  const hasTarget = Boolean(target.url && target.host && target.origin);\n\n  if (request.toolName === 'browser_navigate') {\n    if (!hasTarget || !target.host || !target.origin) {\n      return {\n        decision: 'deny',\n        risk: 'high',\n        actionKey: 'navigate',\n        reason: 'Policy denied browser navigate action due to missing/invalid URL.',\n        riskEvidence: {\n          classifier: 'static',\n          matchedSignals: ['url:invalid'],\n        },\n      };\n    }\n  }\n\n  if (hasTarget && target.host && target.origin) {\n    if (originBlocked(target.origin, target.host, config.blockedOrigins)) {\n      return {\n        decision: 'deny',\n        risk: 'high',\n        actionKey: request.toolName === 'browser_navigate' ? 'navigate' : 'interaction',\n        reason: `Policy denied browser action due to blocked origin: ${target.origin}`,\n        targetHost: target.host,\n        targetOrigin: target.origin,\n        riskEvidence: {\n          classifier: 'static',\n          matchedSignals: ['policy:blocked-origin'],\n        },\n      };\n    }\n\n    if (!hostAllowed(target.host, config.allowedHosts)) {\n      return {\n        decision: 'deny',\n        risk: 'high',\n        actionKey: request.toolName === 'browser_navigate' ? 'navigate' : 'interaction',\n        reason: `Policy denied browser action due to host allowlist mismatch: ${target.host}`,\n        targetHost: target.host,\n        targetOrigin: target.origin,\n        riskEvidence: {\n          classifier: 'static',\n          matchedSignals: ['policy:allowlist-mismatch'],\n        },\n      };\n    }\n  }\n\n  const sensitiveActions = new Set(config.sensitiveActions);\n  const classified = classifyAction(request.toolName, request.args, sensitiveActions);\n\n  let risk = classified.risk;\n  let classifier: BrowserRiskEvidence['classifier'] = 'static';\n  const matchedSignals = [...classified.matchedSignals];\n  let adaptationReason: string | undefined;\n\n  if (\n    request.adaptationHint?.escalateRisk === true\n    && (classified.risk === 'medium' || classified.risk === 'low')\n    && request.toolName !== 'browser_snapshot'\n    && request.toolName !== 'browser_screenshot'\n    && request.toolName !== 'browser_close'\n  ) {\n    classifier = 'adaptive-escalation';\n    matchedSignals.push('adaptive:risk-escalation');\n    adaptationReason = request.adaptationHint.reason;\n    if (classified.risk === 'medium') {\n      risk = 'high';\n    } else {\n      risk = 'medium';\n    }\n  }\n\n  const riskEvidence: BrowserRiskEvidence = {\n    classifier,\n    matchedSignals: uniqueSorted(matchedSignals),\n    adaptationReason,\n  };\n\n  if (risk === 'high' && config.requireApprovalForHighRisk && !request.approved) {\n    return {\n      decision: 'gate',\n      risk,\n      actionKey: classified.actionKey,\n      reason: adaptationReason\n        ? `Policy requires explicit approval for high-risk browser action: ${classified.actionKey}. ${adaptationReason}`\n        : `Policy requires explicit approval for high-risk browser action: ${classified.actionKey}.`,\n      targetHost: target.host,\n      targetOrigin: target.origin,\n      riskEvidence,\n    };\n  }\n\n  return {\n    decision: 'allow',\n    risk,\n    actionKey: classified.actionKey,\n    reason: adaptationReason\n      ? `Allowed by browser policy checks with adaptive risk context. ${adaptationReason}`\n      : 'Allowed by browser policy checks.',\n    targetHost: target.host,\n    targetOrigin: target.origin,\n    riskEvidence,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/browser/profile-store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/browser/quality-gates.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":1,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":380,"column":22,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":380,"endColumn":73,"fix":{"range":[12252,12286],"text":""}},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":1,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":520,"column":27,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":520,"endColumn":78,"fix":{"range":[16865,16902],"text":""}},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":548,"column":32,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":548,"endColumn":34,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[17856,17858],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, value is always falsy.","line":549,"column":9,"nodeType":"UnaryExpression","messageId":"alwaysFalsy","endLine":549,"endColumn":16},{"ruleId":"@typescript-eslint/no-unnecessary-type-conversion","severity":1,"message":"Passing a string to String() does not change the type or value of the string.","line":662,"column":27,"nodeType":"Identifier","messageId":"unnecessaryTypeConversion","endLine":662,"endColumn":33,"suggestions":[{"messageId":"suggestRemove","fix":{"range":[21695,21708],"text":"label"},"desc":"Remove the type conversion."},{"messageId":"suggestSatisfies","data":{"type":"string"},"fix":{"range":[21695,21708],"text":"label satisfies string"},"desc":"Instead, assert that the value satisfies the string type."}]},{"ruleId":"@typescript-eslint/no-unnecessary-type-conversion","severity":1,"message":"Passing a string to String() does not change the type or value of the string.","line":672,"column":30,"nodeType":"Identifier","messageId":"unnecessaryTypeConversion","endLine":672,"endColumn":36,"suggestions":[{"messageId":"suggestRemove","fix":{"range":[21958,21971],"text":"label"},"desc":"Remove the type conversion."},{"messageId":"suggestSatisfies","data":{"type":"string"},"fix":{"range":[21958,21971],"text":"label satisfies string"},"desc":"Instead, assert that the value satisfies the string type."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { access, readFile } from 'node:fs/promises';\nimport { isAbsolute, join } from 'node:path';\nimport {\n  BROWSER_SESSION_METADATA_FILE,\n  BROWSER_SESSION_RECORDINGS_FILE,\n  BROWSER_SESSION_STEPS_FILE,\n  BROWSER_VISUAL_DIFF_MANIFEST_FILE,\n  browserSessionMetadataPath,\n  browserSessionRecordingsPath,\n  browserSessionStepsPath,\n  browserSessionVisualDiffManifestPath,\n} from './artifacts.js';\nimport type {\n  BrowserArtifactMetadata,\n  BrowserSessionMetadata,\n  BrowserSessionRecordingEntry,\n  BrowserSessionRecordingIndex,\n  BrowserSessionStepRecord,\n  BrowserVisualDiffManifestEntry,\n} from './types.js';\n\nexport interface BrowserArtifactCompletenessCounts {\n  metadataActions: number;\n  metadataArtifacts: number;\n  stepEntries: number;\n  recordingEntries: number;\n  visualDiffEntries: number;\n  stepArtifactRefs: number;\n  recordingArtifactRefs: number;\n  visualDiffArtifactRefs: number;\n}\n\nexport interface BrowserArtifactCompletenessResult {\n  ok: boolean;\n  sessionId: string;\n  missingFiles: string[];\n  issues: string[];\n  counts: BrowserArtifactCompletenessCounts;\n}\n\nexport interface BrowserBenchmarkMetrics {\n  successRate: number;\n  medianActionLatencyMs: number;\n  recoveryMs: number;\n}\n\nexport interface BrowserBenchmarkThresholds {\n  minSuccessRate: number;\n  maxMedianActionLatencyMs: number;\n  maxRecoveryMs: number;\n}\n\nexport interface BrowserBenchmarkThresholdResult {\n  ok: boolean;\n  failures: string[];\n  metrics: BrowserBenchmarkMetrics;\n  thresholds: BrowserBenchmarkThresholds;\n}\n\nexport interface BrowserBenchmarkTelemetryIngestionResult {\n  ok: boolean;\n  sessionId: string;\n  issues: string[];\n  actionCount: number;\n  successCount: number;\n  failureCount: number;\n  latencySamplesMs: number[];\n  recoverySamplesMs: number[];\n  metrics: BrowserBenchmarkMetrics;\n}\n\nexport interface BrowserBenchmarkThresholdFeedResult extends BrowserBenchmarkThresholdResult {\n  sessionId: string;\n  ingestion: BrowserBenchmarkTelemetryIngestionResult;\n}\n\nexport const DEFAULT_BROWSER_BENCHMARK_THRESHOLDS: BrowserBenchmarkThresholds = {\n  minSuccessRate: 0.95,\n  maxMedianActionLatencyMs: 1200,\n  maxRecoveryMs: 3000,\n};\n\nfunction formatNumber(value: number): string {\n  if (Number.isInteger(value)) return String(value);\n  return value.toFixed(6).replace(/0+$/, '').replace(/\\.$/, '');\n}\n\nfunction uniqueSorted(values: Iterable<string>): string[] {\n  return [...new Set(values)].sort((left, right) => left.localeCompare(right));\n}\n\nfunction sumArtifactRefs(entries: Array<{ artifactIds: string[] }>): number {\n  return entries.reduce((sum, entry) => sum + entry.artifactIds.length, 0);\n}\n\nfunction median(values: number[]): number {\n  if (values.length === 0) return 0;\n  const sorted = [...values].sort((left, right) => left - right);\n  const midpoint = Math.floor(sorted.length / 2);\n  if (sorted.length % 2 === 1) return sorted[midpoint] ?? 0;\n  return ((sorted[midpoint - 1] ?? 0) + (sorted[midpoint] ?? 0)) / 2;\n}\n\nfunction flattenArtifactIds(entries: Array<{ artifactIds: string[] }>): string[] {\n  return entries.flatMap((entry) => entry.artifactIds);\n}\n\nfunction flattenArtifactPaths(entries: Array<{ artifactPaths: string[] }>): string[] {\n  return entries.flatMap((entry) => entry.artifactPaths);\n}\n\nfunction resolveMetadataArtifactPath(cwd: string, artifact: BrowserArtifactMetadata): string {\n  if (artifact.absolutePath.trim().length > 0) {\n    return artifact.absolutePath;\n  }\n  return isAbsolute(artifact.relativePath) ? artifact.relativePath : join(cwd, artifact.relativePath);\n}\n\nfunction compareStringSets(\n  expected: string[],\n  actual: string[],\n  expectedLabel: string,\n  actualLabel: string,\n  issues: string[],\n): void {\n  const missing = expected.filter((value) => !actual.includes(value));\n  const unexpected = actual.filter((value) => !expected.includes(value));\n\n  if (missing.length > 0 || unexpected.length > 0) {\n    const missingList = missing.length > 0 ? missing.join(', ') : 'none';\n    const unexpectedList = unexpected.length > 0 ? unexpected.join(', ') : 'none';\n    issues.push(\n      `${actualLabel} does not match ${expectedLabel} (missing: ${missingList}; unexpected: ${unexpectedList}).`,\n    );\n  }\n}\n\nfunction verifySequence(\n  sourceLabel: string,\n  entries: Array<{ sequence: number }>,\n  issues: string[],\n): void {\n  for (let index = 0; index < entries.length; index += 1) {\n    const expectedSequence = index + 1;\n    const actualSequence = entries[index]?.sequence;\n    if (actualSequence !== expectedSequence) {\n      issues.push(\n        `${sourceLabel} has non-contiguous sequence at index ${index} (expected ${expectedSequence}, got ${String(actualSequence)}).`,\n      );\n      return;\n    }\n  }\n}\n\nfunction verifySessionIds(\n  sourceLabel: string,\n  entries: Array<{ sessionId: string }>,\n  expectedSessionId: string,\n  issues: string[],\n): void {\n  for (const [index, entry] of entries.entries()) {\n    if (entry.sessionId !== expectedSessionId) {\n      issues.push(\n        `${sourceLabel} entry ${index} has sessionId ${entry.sessionId} but expected ${expectedSessionId}.`,\n      );\n      return;\n    }\n  }\n}\n\nasync function fileExists(path: string): Promise<boolean> {\n  try {\n    await access(path);\n    return true;\n  } catch (error) {\n    const err = error as NodeJS.ErrnoException;\n    if (err.code === 'ENOENT') return false;\n    throw error;\n  }\n}\n\nfunction parseJsonl<T>(raw: string, sourceLabel: string, issues: string[]): T[] {\n  const entries: T[] = [];\n  const lines = raw.split(/\\r?\\n/);\n\n  for (let index = 0; index < lines.length; index += 1) {\n    const line = lines[index]?.trim();\n    if (!line) continue;\n\n    try {\n      entries.push(JSON.parse(line) as T);\n    } catch {\n      issues.push(`${sourceLabel} contains invalid JSON at line ${index + 1}.`);\n      return [];\n    }\n  }\n\n  return entries;\n}\n\nfunction parseTimestampMs(label: string, timestamp: string, issues: string[]): number | null {\n  const value = Date.parse(timestamp);\n  if (Number.isFinite(value)) return value;\n  issues.push(`${label} has invalid timestamp \"${timestamp}\".`);\n  return null;\n}\n\nfunction toCounts(\n  metadata: BrowserSessionMetadata | null,\n  steps: BrowserSessionStepRecord[],\n  recordings: BrowserSessionRecordingEntry[],\n  visualDiffEntries: BrowserVisualDiffManifestEntry[],\n): BrowserArtifactCompletenessCounts {\n  return {\n    metadataActions: metadata?.actions.length ?? 0,\n    metadataArtifacts: metadata?.artifacts.length ?? 0,\n    stepEntries: steps.length,\n    recordingEntries: recordings.length,\n    visualDiffEntries: visualDiffEntries.length,\n    stepArtifactRefs: sumArtifactRefs(steps),\n    recordingArtifactRefs: sumArtifactRefs(recordings),\n    visualDiffArtifactRefs: sumArtifactRefs(visualDiffEntries),\n  };\n}\n\nfunction compareActionCounts(\n  metadata: BrowserSessionMetadata | null,\n  steps: BrowserSessionStepRecord[],\n  recordings: BrowserSessionRecordingEntry[],\n  visualDiffEntries: BrowserVisualDiffManifestEntry[],\n  issues: string[],\n): void {\n  const metadataActions = metadata?.actions.length;\n\n  if (metadataActions !== undefined && metadataActions !== steps.length) {\n    issues.push(\n      `metadata.json action count (${metadataActions}) does not match steps.jsonl count (${steps.length}).`,\n    );\n  }\n\n  if (metadataActions !== undefined && metadataActions !== recordings.length) {\n    issues.push(\n      `metadata.json action count (${metadataActions}) does not match recordings.json count (${recordings.length}).`,\n    );\n  }\n\n  if (steps.length !== recordings.length) {\n    issues.push(`steps.jsonl count (${steps.length}) does not match recordings.json count (${recordings.length}).`);\n  }\n\n  if (steps.length !== visualDiffEntries.length) {\n    issues.push(\n      `steps.jsonl count (${steps.length}) does not match visual-diff-manifest.jsonl count (${visualDiffEntries.length}).`,\n    );\n  }\n}\n\nfunction compareArtifactReferenceCounts(\n  metadata: BrowserSessionMetadata | null,\n  counts: BrowserArtifactCompletenessCounts,\n  issues: string[],\n): void {\n  if (!metadata) return;\n\n  if (counts.stepArtifactRefs !== counts.metadataArtifacts) {\n    issues.push(\n      `steps.jsonl artifact reference count (${counts.stepArtifactRefs}) does not match metadata.json artifact count (${counts.metadataArtifacts}).`,\n    );\n  }\n\n  if (counts.recordingArtifactRefs !== counts.metadataArtifacts) {\n    issues.push(\n      `recordings.json artifact reference count (${counts.recordingArtifactRefs}) does not match metadata.json artifact count (${counts.metadataArtifacts}).`,\n    );\n  }\n\n  if (counts.visualDiffArtifactRefs !== counts.metadataArtifacts) {\n    issues.push(\n      `visual-diff-manifest.jsonl artifact reference count (${counts.visualDiffArtifactRefs}) does not match metadata.json artifact count (${counts.metadataArtifacts}).`,\n    );\n  }\n}\n\nasync function verifyArtifactPathsExist(\n  cwd: string,\n  metadata: BrowserSessionMetadata | null,\n  steps: BrowserSessionStepRecord[],\n  recordings: BrowserSessionRecordingEntry[],\n  visualDiffEntries: BrowserVisualDiffManifestEntry[],\n  issues: string[],\n): Promise<void> {\n  if (metadata) {\n    for (const artifact of metadata.artifacts) {\n      const absolutePath = resolveMetadataArtifactPath(cwd, artifact);\n      if (!await fileExists(absolutePath)) {\n        issues.push(`metadata.json artifact file is missing: ${absolutePath}.`);\n      }\n    }\n  }\n\n  const referencedPaths = uniqueSorted([\n    ...flattenArtifactPaths(steps),\n    ...flattenArtifactPaths(recordings),\n    ...flattenArtifactPaths(visualDiffEntries),\n  ]);\n\n  for (const relativePath of referencedPaths) {\n    const absolutePath = isAbsolute(relativePath) ? relativePath : join(cwd, relativePath);\n    if (!await fileExists(absolutePath)) {\n      issues.push(`Referenced artifact path does not exist: ${relativePath}.`);\n    }\n  }\n}\n\nexport async function validateBrowserSessionArtifactCompleteness(\n  cwd: string,\n  sessionId: string,\n): Promise<BrowserArtifactCompletenessResult> {\n  const missingFiles: string[] = [];\n  const issues: string[] = [];\n\n  const metadataPath = browserSessionMetadataPath(cwd, sessionId);\n  const stepsPath = browserSessionStepsPath(cwd, sessionId);\n  const recordingsPath = browserSessionRecordingsPath(cwd, sessionId);\n  const visualDiffPath = browserSessionVisualDiffManifestPath(cwd, sessionId);\n\n  const requiredFiles = [\n    { label: BROWSER_SESSION_METADATA_FILE, path: metadataPath },\n    { label: BROWSER_SESSION_STEPS_FILE, path: stepsPath },\n    { label: BROWSER_SESSION_RECORDINGS_FILE, path: recordingsPath },\n    { label: BROWSER_VISUAL_DIFF_MANIFEST_FILE, path: visualDiffPath },\n  ];\n\n  const filePresence = new Map<string, boolean>();\n  for (const file of requiredFiles) {\n    const exists = await fileExists(file.path);\n    filePresence.set(file.label, exists);\n    if (!exists) {\n      missingFiles.push(file.label);\n      issues.push(`Missing required artifact file: ${file.label}.`);\n    }\n  }\n\n  let metadata: BrowserSessionMetadata | null = null;\n  let steps: BrowserSessionStepRecord[] = [];\n  let recordings: BrowserSessionRecordingEntry[] = [];\n  let visualDiffEntries: BrowserVisualDiffManifestEntry[] = [];\n\n  if (filePresence.get(BROWSER_SESSION_METADATA_FILE)) {\n    try {\n      const parsed = JSON.parse(await readFile(metadataPath, 'utf-8')) as Partial<BrowserSessionMetadata>;\n      if (!Array.isArray(parsed.actions) || !Array.isArray(parsed.artifacts)) {\n        issues.push('metadata.json must include \"actions\" and \"artifacts\" arrays.');\n      } else {\n        metadata = parsed as BrowserSessionMetadata;\n      }\n    } catch {\n      issues.push('metadata.json is not valid JSON.');\n    }\n  }\n\n  if (filePresence.get(BROWSER_SESSION_STEPS_FILE)) {\n    try {\n      steps = parseJsonl<BrowserSessionStepRecord>(\n        await readFile(stepsPath, 'utf-8'),\n        'steps.jsonl',\n        issues,\n      );\n    } catch {\n      issues.push('steps.jsonl could not be read.');\n    }\n  }\n\n  if (filePresence.get(BROWSER_SESSION_RECORDINGS_FILE)) {\n    try {\n      const parsed = JSON.parse(await readFile(recordingsPath, 'utf-8')) as Partial<BrowserSessionRecordingIndex>;\n      if (!Array.isArray(parsed.recordings)) {\n        issues.push('recordings.json must include a \"recordings\" array.');\n      } else {\n        recordings = parsed.recordings as BrowserSessionRecordingEntry[];\n      }\n    } catch {\n      issues.push('recordings.json is not valid JSON.');\n    }\n  }\n\n  if (filePresence.get(BROWSER_VISUAL_DIFF_MANIFEST_FILE)) {\n    try {\n      visualDiffEntries = parseJsonl<BrowserVisualDiffManifestEntry>(\n        await readFile(visualDiffPath, 'utf-8'),\n        'visual-diff-manifest.jsonl',\n        issues,\n      );\n    } catch {\n      issues.push('visual-diff-manifest.jsonl could not be read.');\n    }\n  }\n\n  const counts = toCounts(metadata, steps, recordings, visualDiffEntries);\n\n  if (metadata && metadata.sessionId !== sessionId) {\n    issues.push(`metadata.json sessionId ${metadata.sessionId} does not match expected sessionId ${sessionId}.`);\n  }\n\n  verifySessionIds('steps.jsonl', steps, sessionId, issues);\n  verifySessionIds('recordings.json', recordings, sessionId, issues);\n  verifySessionIds('visual-diff-manifest.jsonl', visualDiffEntries, sessionId, issues);\n\n  verifySequence('steps.jsonl', steps, issues);\n  verifySequence('recordings.json', recordings, issues);\n  verifySequence('visual-diff-manifest.jsonl', visualDiffEntries, issues);\n\n  compareActionCounts(metadata, steps, recordings, visualDiffEntries, issues);\n  compareArtifactReferenceCounts(metadata, counts, issues);\n\n  const metadataArtifactIds = uniqueSorted(metadata?.artifacts.map((artifact) => artifact.id) ?? []);\n  const stepArtifactIds = uniqueSorted(flattenArtifactIds(steps));\n  const recordingArtifactIds = uniqueSorted(flattenArtifactIds(recordings));\n  const visualArtifactIds = uniqueSorted(flattenArtifactIds(visualDiffEntries));\n\n  if (metadata) {\n    compareStringSets(metadataArtifactIds, stepArtifactIds, 'metadata.json artifact IDs', 'steps.jsonl artifact IDs', issues);\n    compareStringSets(\n      metadataArtifactIds,\n      recordingArtifactIds,\n      'metadata.json artifact IDs',\n      'recordings.json artifact IDs',\n      issues,\n    );\n    compareStringSets(\n      metadataArtifactIds,\n      visualArtifactIds,\n      'metadata.json artifact IDs',\n      'visual-diff-manifest.jsonl artifact IDs',\n      issues,\n    );\n  }\n\n  compareStringSets(stepArtifactIds, recordingArtifactIds, 'steps.jsonl artifact IDs', 'recordings.json artifact IDs', issues);\n  compareStringSets(\n    stepArtifactIds,\n    visualArtifactIds,\n    'steps.jsonl artifact IDs',\n    'visual-diff-manifest.jsonl artifact IDs',\n    issues,\n  );\n\n  const metadataArtifactPaths = uniqueSorted(metadata?.artifacts.map((artifact) => artifact.relativePath) ?? []);\n  const stepArtifactPaths = uniqueSorted(flattenArtifactPaths(steps));\n  const recordingArtifactPaths = uniqueSorted(flattenArtifactPaths(recordings));\n  const visualArtifactPaths = uniqueSorted(flattenArtifactPaths(visualDiffEntries));\n\n  if (metadata) {\n    compareStringSets(\n      metadataArtifactPaths,\n      stepArtifactPaths,\n      'metadata.json artifact paths',\n      'steps.jsonl artifact paths',\n      issues,\n    );\n    compareStringSets(\n      metadataArtifactPaths,\n      recordingArtifactPaths,\n      'metadata.json artifact paths',\n      'recordings.json artifact paths',\n      issues,\n    );\n    compareStringSets(\n      metadataArtifactPaths,\n      visualArtifactPaths,\n      'metadata.json artifact paths',\n      'visual-diff-manifest.jsonl artifact paths',\n      issues,\n    );\n  }\n\n  compareStringSets(\n    stepArtifactPaths,\n    recordingArtifactPaths,\n    'steps.jsonl artifact paths',\n    'recordings.json artifact paths',\n    issues,\n  );\n  compareStringSets(\n    stepArtifactPaths,\n    visualArtifactPaths,\n    'steps.jsonl artifact paths',\n    'visual-diff-manifest.jsonl artifact paths',\n    issues,\n  );\n\n  await verifyArtifactPathsExist(cwd, metadata, steps, recordings, visualDiffEntries, issues);\n\n  return {\n    ok: issues.length === 0,\n    sessionId,\n    missingFiles,\n    issues,\n    counts,\n  };\n}\n\nexport async function ingestBrowserBenchmarkTelemetry(\n  cwd: string,\n  sessionId: string,\n): Promise<BrowserBenchmarkTelemetryIngestionResult> {\n  const issues: string[] = [];\n\n  const metadataPath = browserSessionMetadataPath(cwd, sessionId);\n  const stepsPath = browserSessionStepsPath(cwd, sessionId);\n\n  let metadataActions: BrowserSessionMetadata['actions'] = [];\n  let metadataUpdatedAtMs: number | null = null;\n  if (await fileExists(metadataPath)) {\n    try {\n      const parsed = JSON.parse(await readFile(metadataPath, 'utf-8')) as Partial<BrowserSessionMetadata>;\n      if (!Array.isArray(parsed.actions)) {\n        issues.push('metadata.json must include an \"actions\" array for benchmark telemetry ingestion.');\n      } else {\n        metadataActions = parsed.actions as BrowserSessionMetadata['actions'];\n      }\n\n      if (typeof parsed.updatedAt === 'string') {\n        metadataUpdatedAtMs = parseTimestampMs('metadata.json updatedAt', parsed.updatedAt, issues);\n      } else {\n        issues.push('metadata.json must include \"updatedAt\" for benchmark telemetry ingestion.');\n      }\n    } catch {\n      issues.push('metadata.json is not valid JSON.');\n    }\n  } else {\n    issues.push('Missing required telemetry file: metadata.json.');\n  }\n\n  let steps: BrowserSessionStepRecord[] = [];\n  if (await fileExists(stepsPath)) {\n    try {\n      steps = parseJsonl<BrowserSessionStepRecord>(await readFile(stepsPath, 'utf-8'), 'steps.jsonl', issues);\n    } catch {\n      issues.push('steps.jsonl could not be read.');\n    }\n  } else {\n    issues.push('Missing required telemetry file: steps.jsonl.');\n  }\n\n  const actionCreatedAtMs = new Map<string, number>();\n  for (const [index, actionRecord] of metadataActions.entries()) {\n    const action = actionRecord?.action;\n    if (!action || typeof action.id !== 'string' || typeof action.createdAt !== 'string') {\n      issues.push(`metadata.json action record at index ${index} is missing a valid action id or createdAt timestamp.`);\n      continue;\n    }\n\n    if (actionCreatedAtMs.has(action.id)) {\n      issues.push(`metadata.json contains duplicate action id ${action.id}.`);\n      continue;\n    }\n\n    const createdAtMs = parseTimestampMs(`metadata.json action ${action.id}`, action.createdAt, issues);\n    if (createdAtMs !== null) {\n      actionCreatedAtMs.set(action.id, createdAtMs);\n    }\n  }\n\n  const orderedSteps = [...steps].sort((left, right) => {\n    if (left.sequence !== right.sequence) return left.sequence - right.sequence;\n    return left.actionId.localeCompare(right.actionId);\n  });\n\n  const latencySamplesMs: number[] = [];\n  const recoverySamplesMs: number[] = [];\n\n  let successCount = 0;\n  let failureCount = 0;\n  let failureStartMs: number | null = null;\n  let lastStepTimestampMs: number | null = null;\n\n  for (const step of orderedSteps) {\n    if (step.ok) successCount += 1;\n    else failureCount += 1;\n\n    const stepTimestampMs = parseTimestampMs(`steps.jsonl action ${step.actionId}`, step.timestamp, issues);\n    if (stepTimestampMs !== null) {\n      lastStepTimestampMs = stepTimestampMs;\n    }\n\n    const createdAtMs = actionCreatedAtMs.get(step.actionId);\n    if (createdAtMs === undefined) {\n      issues.push(`steps.jsonl action ${step.actionId} is missing in metadata.json actions.`);\n    } else if (stepTimestampMs !== null) {\n      const latencyMs = stepTimestampMs - createdAtMs;\n      if (!Number.isFinite(latencyMs) || latencyMs < 0) {\n        issues.push(`Action latency for ${step.actionId} is invalid (${String(latencyMs)}ms).`);\n      } else {\n        latencySamplesMs.push(latencyMs);\n      }\n    }\n\n    if (!step.ok) {\n      if (failureStartMs === null && stepTimestampMs !== null) {\n        failureStartMs = stepTimestampMs;\n      }\n      continue;\n    }\n\n    if (failureStartMs !== null && stepTimestampMs !== null) {\n      const recoveryMs = stepTimestampMs - failureStartMs;\n      if (!Number.isFinite(recoveryMs) || recoveryMs < 0) {\n        issues.push(`Recovery duration is invalid around action ${step.actionId}.`);\n      } else {\n        recoverySamplesMs.push(recoveryMs);\n      }\n      failureStartMs = null;\n    }\n  }\n\n  if (failureStartMs !== null) {\n    const recoveryEndMs = lastStepTimestampMs ?? metadataUpdatedAtMs;\n    if (recoveryEndMs !== null) {\n      const unresolvedRecoveryMs = recoveryEndMs - failureStartMs;\n      if (Number.isFinite(unresolvedRecoveryMs) && unresolvedRecoveryMs >= 0) {\n        recoverySamplesMs.push(unresolvedRecoveryMs);\n      } else {\n        issues.push('Unresolved failure recovery duration is invalid.');\n      }\n    } else {\n      issues.push('Unable to compute unresolved failure recovery duration.');\n    }\n    issues.push('Session ended with an unrecovered failure sequence.');\n  }\n\n  const actionCount = orderedSteps.length;\n  const metrics: BrowserBenchmarkMetrics = {\n    successRate: actionCount === 0 ? 0 : successCount / actionCount,\n    medianActionLatencyMs: median(latencySamplesMs),\n    recoveryMs: median(recoverySamplesMs),\n  };\n\n  validateFiniteMetric('successRate', metrics.successRate, issues);\n  validateFiniteMetric('medianActionLatencyMs', metrics.medianActionLatencyMs, issues);\n  validateFiniteMetric('recoveryMs', metrics.recoveryMs, issues);\n\n  return {\n    ok: issues.length === 0,\n    sessionId,\n    issues,\n    actionCount,\n    successCount,\n    failureCount,\n    latencySamplesMs,\n    recoverySamplesMs,\n    metrics,\n  };\n}\n\nfunction validateFiniteMetric(\n  label: keyof BrowserBenchmarkMetrics,\n  value: number,\n  failures: string[],\n): boolean {\n  if (Number.isFinite(value)) return true;\n  failures.push(`Metric ${String(label)} must be a finite number.`);\n  return false;\n}\n\nfunction validateFiniteThreshold(\n  label: keyof BrowserBenchmarkThresholds,\n  value: number,\n  failures: string[],\n): boolean {\n  if (Number.isFinite(value)) return true;\n  failures.push(`Threshold ${String(label)} must be a finite number.`);\n  return false;\n}\n\nexport function validateBrowserBenchmarkThresholds(\n  metrics: BrowserBenchmarkMetrics,\n  thresholds: BrowserBenchmarkThresholds = DEFAULT_BROWSER_BENCHMARK_THRESHOLDS,\n): BrowserBenchmarkThresholdResult {\n  const failures: string[] = [];\n\n  const hasSuccessRate = validateFiniteMetric('successRate', metrics.successRate, failures);\n  const hasMedianLatency = validateFiniteMetric('medianActionLatencyMs', metrics.medianActionLatencyMs, failures);\n  const hasRecovery = validateFiniteMetric('recoveryMs', metrics.recoveryMs, failures);\n\n  const hasMinSuccessRate = validateFiniteThreshold('minSuccessRate', thresholds.minSuccessRate, failures);\n  const hasMaxMedianLatency = validateFiniteThreshold(\n    'maxMedianActionLatencyMs',\n    thresholds.maxMedianActionLatencyMs,\n    failures,\n  );\n  const hasMaxRecovery = validateFiniteThreshold('maxRecoveryMs', thresholds.maxRecoveryMs, failures);\n\n  if (hasSuccessRate && hasMinSuccessRate && metrics.successRate < thresholds.minSuccessRate) {\n    failures.push(\n      `successRate ${formatNumber(metrics.successRate)} is below minimum ${formatNumber(thresholds.minSuccessRate)}.`,\n    );\n  }\n\n  if (hasMedianLatency && hasMaxMedianLatency && metrics.medianActionLatencyMs > thresholds.maxMedianActionLatencyMs) {\n    failures.push(\n      `medianActionLatencyMs ${formatNumber(metrics.medianActionLatencyMs)} exceeds maximum ${formatNumber(thresholds.maxMedianActionLatencyMs)}.`,\n    );\n  }\n\n  if (hasRecovery && hasMaxRecovery && metrics.recoveryMs > thresholds.maxRecoveryMs) {\n    failures.push(\n      `recoveryMs ${formatNumber(metrics.recoveryMs)} exceeds maximum ${formatNumber(thresholds.maxRecoveryMs)}.`,\n    );\n  }\n\n  return {\n    ok: failures.length === 0,\n    failures,\n    metrics,\n    thresholds,\n  };\n}\n\nexport async function validateBrowserBenchmarkThresholdFeed(\n  cwd: string,\n  sessionId: string,\n  thresholds: BrowserBenchmarkThresholds = DEFAULT_BROWSER_BENCHMARK_THRESHOLDS,\n): Promise<BrowserBenchmarkThresholdFeedResult> {\n  const ingestion = await ingestBrowserBenchmarkTelemetry(cwd, sessionId);\n  const thresholdResult = validateBrowserBenchmarkThresholds(ingestion.metrics, thresholds);\n  const failures = [\n    ...thresholdResult.failures,\n    ...ingestion.issues.map((issue) => `Telemetry ingestion issue: ${issue}`),\n  ];\n\n  return {\n    ok: failures.length === 0,\n    failures,\n    metrics: ingestion.metrics,\n    thresholds,\n    sessionId,\n    ingestion,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/browser/replay.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":408,"column":22,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":408,"endColumn":39},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":409,"column":20,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":409,"endColumn":33}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { readFile, stat } from 'node:fs/promises';\nimport { isAbsolute, join } from 'node:path';\nimport {\n  browserSessionArtifactsDir,\n  browserSessionMetadataPath,\n  browserSessionRecordingsPath,\n  browserSessionStepsPath,\n  browserSessionVisualDiffManifestPath,\n  readBrowserVisualDiffResults as readPersistedBrowserVisualDiffResults,\n} from './artifacts.js';\nimport {\n  assessVisualDiffPair,\n  inferVisualDiffRegression,\n  inferVisualDiffSeverity,\n} from './visual-diff.js';\nimport type {\n  BrowserArtifactMetadata,\n  BrowserSessionMetadata,\n  BrowserSessionRecordingEntry,\n  BrowserSessionRecordingIndex,\n  BrowserSessionStepRecord,\n  BrowserVisualDiffManifestEntry,\n  BrowserVisualDiffRegressionSignal,\n  BrowserVisualDiffResultEntry,\n  BrowserVisualDiffResultStatus,\n  BrowserVisualDiffSeverity,\n} from './types.js';\n\nexport interface BrowserReplaySummary {\n  sessionId: string;\n  runId?: string;\n  status: BrowserSessionMetadata['status'];\n  runtime: BrowserSessionMetadata['runtime'];\n  actionCount: number;\n  artifactCount: number;\n  failureCount: number;\n  lastActionAt: string;\n  lastUpdatedAt: string;\n  regressionScore: number;\n  regressionSignal: BrowserVisualDiffRegressionSignal;\n  regressionPairCount: number;\n}\n\nexport interface BrowserReplayArtifactPreview {\n  path: string;\n  mimeType?: string;\n  sizeBytes?: number;\n  htmlSnippet?: string;\n  textSnippet?: string;\n  inlinePreview?: string[];\n  imageWidth?: number;\n  imageHeight?: number;\n}\n\nexport interface BrowserReplayStepArtifactPreview {\n  sequence: number;\n  artifacts: BrowserReplayArtifactPreview[];\n}\n\nexport type BrowserReplayVisualDiffStatus = BrowserVisualDiffResultStatus;\n\nexport interface BrowserReplayVisualDiffPair {\n  index: number;\n  fromSequence: number;\n  fromActionType: BrowserSessionStepRecord['actionType'];\n  toSequence: number;\n  toActionType: BrowserSessionStepRecord['actionType'];\n  fromScreenshotPath?: string;\n  toScreenshotPath?: string;\n  status: BrowserReplayVisualDiffStatus;\n  changedByteRatio?: number;\n  perceptualDiffScore?: number;\n  severity: BrowserVisualDiffSeverity;\n  regressionScore?: number;\n  regressionSignal?: BrowserVisualDiffRegressionSignal;\n}\n\ninterface BrowserReplayArtifactIndexes {\n  byId: Map<string, BrowserArtifactMetadata>;\n  byPath: Map<string, BrowserArtifactMetadata>;\n  byActionId: Map<string, BrowserArtifactMetadata[]>;\n}\n\ninterface ResolvedReplayArtifact {\n  key: string;\n  path: string;\n  absolutePath: string;\n  kind?: BrowserArtifactMetadata['kind'];\n  mimeType?: string;\n  sizeBytes?: number;\n}\n\nconst HTML_SNIPPET_LIMIT = 180;\nconst TEXT_SNIPPET_LIMIT = 180;\nconst INLINE_PREVIEW_COLUMNS = 24;\nconst INLINE_PREVIEW_ROWS = 6;\nconst INLINE_PREVIEW_PALETTE = ' .:-=+*#%@';\n\nfunction buildReplayArtifactIndexes(\n  metadata: BrowserSessionMetadata | null,\n): BrowserReplayArtifactIndexes {\n  const byId = new Map<string, BrowserArtifactMetadata>();\n  const byPath = new Map<string, BrowserArtifactMetadata>();\n  const byActionId = new Map<string, BrowserArtifactMetadata[]>();\n\n  for (const artifact of metadata?.artifacts ?? []) {\n    byId.set(artifact.id, artifact);\n    byPath.set(artifact.relativePath, artifact);\n    byPath.set(artifact.absolutePath, artifact);\n    const entries = byActionId.get(artifact.actionId) ?? [];\n    entries.push(artifact);\n    byActionId.set(artifact.actionId, entries);\n  }\n\n  return { byId, byPath, byActionId };\n}\n\nfunction resolveReplayArtifactAbsolutePath(\n  cwd: string,\n  sessionId: string,\n  artifactPath: string,\n  absolutePath?: string,\n): string {\n  if (absolutePath && absolutePath.length > 0) {\n    return absolutePath;\n  }\n  if (isAbsolute(artifactPath)) {\n    return artifactPath;\n  }\n  if (artifactPath.startsWith('.opta/')) {\n    return join(cwd, artifactPath);\n  }\n  return join(browserSessionArtifactsDir(cwd, sessionId), artifactPath);\n}\n\nfunction normalizeHtmlSnippet(value: string): string {\n  const compact = value.replace(/\\s+/g, ' ').trim();\n  if (compact.length <= HTML_SNIPPET_LIMIT) {\n    return compact;\n  }\n  return `${compact.slice(0, HTML_SNIPPET_LIMIT - 3)}...`;\n}\n\nfunction normalizeTextSnippet(value: string): string {\n  const compact = value.replace(/\\s+/g, ' ').trim();\n  if (compact.length <= TEXT_SNIPPET_LIMIT) {\n    return compact;\n  }\n  return `${compact.slice(0, TEXT_SNIPPET_LIMIT - 3)}...`;\n}\n\nfunction isHtmlArtifact(path: string, mimeType?: string): boolean {\n  if (mimeType?.toLowerCase() === 'text/html') {\n    return true;\n  }\n  return path.toLowerCase().endsWith('.html');\n}\n\nfunction isScreenshotArtifact(artifact: ResolvedReplayArtifact): boolean {\n  if (artifact.kind === 'screenshot') {\n    return true;\n  }\n  if (artifact.mimeType?.toLowerCase().startsWith('image/')) {\n    return true;\n  }\n  const lowerPath = artifact.path.toLowerCase();\n  return (\n    lowerPath.endsWith('.png') ||\n    lowerPath.endsWith('.jpg') ||\n    lowerPath.endsWith('.jpeg') ||\n    lowerPath.endsWith('.webp') ||\n    lowerPath.endsWith('.gif') ||\n    lowerPath.endsWith('.bmp')\n  );\n}\n\nfunction extractHtmlTextSnippet(html: string): string {\n  const withoutScripts = html\n    .replace(/<script[\\s\\S]*?<\\/script>/gi, ' ')\n    .replace(/<style[\\s\\S]*?<\\/style>/gi, ' ');\n  const textOnly = withoutScripts\n    .replace(/<[^>]+>/g, ' ')\n    .replace(/&nbsp;/gi, ' ')\n    .replace(/&amp;/gi, '&')\n    .replace(/&lt;/gi, '<')\n    .replace(/&gt;/gi, '>');\n  return normalizeTextSnippet(textOnly);\n}\n\nfunction parsePngDimensions(bytes: Uint8Array): { width: number; height: number } | null {\n  if (bytes.length < 24) return null;\n  const signature = [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a];\n  for (let index = 0; index < signature.length; index += 1) {\n    if (bytes[index] !== signature[index]) return null;\n  }\n  // PNG IHDR: width/height begin at byte offsets 16/20.\n  const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n  const width = view.getUint32(16);\n  const height = view.getUint32(20);\n  if (width <= 0 || height <= 0) return null;\n  return { width, height };\n}\n\nfunction buildInlineBytePreview(\n  bytes: Uint8Array,\n  columns = INLINE_PREVIEW_COLUMNS,\n  rows = INLINE_PREVIEW_ROWS,\n): string[] {\n  if (bytes.length === 0 || columns <= 0 || rows <= 0) return [];\n  const cells = columns * rows;\n  const lines: string[] = [];\n  for (let row = 0; row < rows; row += 1) {\n    let line = '';\n    for (let col = 0; col < columns; col += 1) {\n      const cellIndex = row * columns + col;\n      const start = Math.floor((cellIndex * bytes.length) / cells);\n      const end = Math.max(start + 1, Math.floor(((cellIndex + 1) * bytes.length) / cells));\n      let sum = 0;\n      for (let index = start; index < end && index < bytes.length; index += 1) {\n        sum += bytes[index] ?? 0;\n      }\n      const avg = sum / Math.max(1, end - start);\n      const paletteIndex = Math.max(\n        0,\n        Math.min(\n          INLINE_PREVIEW_PALETTE.length - 1,\n          Math.floor((avg / 255) * (INLINE_PREVIEW_PALETTE.length - 1)),\n        ),\n      );\n      line += INLINE_PREVIEW_PALETTE[paletteIndex] ?? ' ';\n    }\n    lines.push(line);\n  }\n  return lines;\n}\n\nfunction buildVisualDiffPairKey(\n  pair: Pick<BrowserVisualDiffResultEntry, 'fromSequence' | 'fromActionId' | 'toSequence' | 'toActionId'>,\n): string {\n  return `${pair.fromSequence}:${pair.fromActionId}:${pair.toSequence}:${pair.toActionId}`;\n}\n\nfunction resolveReplayStepArtifacts(\n  cwd: string,\n  step: BrowserSessionStepRecord,\n  indexes: BrowserReplayArtifactIndexes,\n): ResolvedReplayArtifact[] {\n  const resolved: ResolvedReplayArtifact[] = [];\n  const seen = new Set<string>();\n\n  const pushArtifact = (artifact: BrowserArtifactMetadata) => {\n    const key = artifact.id || artifact.relativePath || artifact.absolutePath;\n    if (!key || seen.has(key)) return;\n    seen.add(key);\n    resolved.push({\n      key,\n      path: artifact.relativePath || artifact.absolutePath,\n      absolutePath: artifact.absolutePath || resolveReplayArtifactAbsolutePath(cwd, step.sessionId, artifact.relativePath),\n      kind: artifact.kind,\n      mimeType: artifact.mimeType,\n      sizeBytes: artifact.sizeBytes,\n    });\n  };\n\n  const pushPath = (artifactPath: string) => {\n    const fromIndex = indexes.byPath.get(artifactPath);\n    if (fromIndex) {\n      pushArtifact(fromIndex);\n      return;\n    }\n    const key = artifactPath;\n    if (seen.has(key)) return;\n    seen.add(key);\n    resolved.push({\n      key,\n      path: artifactPath,\n      absolutePath: resolveReplayArtifactAbsolutePath(cwd, step.sessionId, artifactPath),\n    });\n  };\n\n  for (const artifactId of step.artifactIds) {\n    const artifact = indexes.byId.get(artifactId);\n    if (artifact) {\n      pushArtifact(artifact);\n    }\n  }\n\n  for (const artifactPath of step.artifactPaths) {\n    pushPath(artifactPath);\n  }\n\n  for (const artifact of indexes.byActionId.get(step.actionId) ?? []) {\n    pushArtifact(artifact);\n  }\n\n  return resolved;\n}\n\nexport async function readBrowserReplayStepArtifactPreview(\n  cwd: string,\n  sessionId: string,\n  step: BrowserSessionStepRecord,\n  metadata: BrowserSessionMetadata | null = null,\n): Promise<BrowserReplayStepArtifactPreview> {\n  const replayMetadata = metadata ?? await readBrowserReplay(cwd, sessionId);\n  const indexes = buildReplayArtifactIndexes(replayMetadata);\n  const artifacts = resolveReplayStepArtifacts(cwd, step, indexes);\n  const previews: BrowserReplayArtifactPreview[] = [];\n\n  for (const artifact of artifacts) {\n    let sizeBytes = artifact.sizeBytes;\n    if (typeof sizeBytes !== 'number') {\n      try {\n        const fileStat = await stat(artifact.absolutePath);\n        sizeBytes = fileStat.size;\n      } catch {\n        // Keep size undefined when unknown\n      }\n    }\n\n    let htmlSnippet: string | undefined;\n    let textSnippet: string | undefined;\n    let inlinePreview: string[] | undefined;\n    let imageWidth: number | undefined;\n    let imageHeight: number | undefined;\n\n    if (isHtmlArtifact(artifact.path, artifact.mimeType)) {\n      try {\n        const html = await readFile(artifact.absolutePath, 'utf-8');\n        htmlSnippet = normalizeHtmlSnippet(html);\n        textSnippet = extractHtmlTextSnippet(html);\n      } catch {\n        // Keep snippet undefined when file is unreadable\n      }\n    } else if (isScreenshotArtifact(artifact)) {\n      try {\n        const bytes = await readFile(artifact.absolutePath);\n        inlinePreview = buildInlineBytePreview(bytes);\n        const pngDimensions = parsePngDimensions(bytes);\n        if (pngDimensions) {\n          imageWidth = pngDimensions.width;\n          imageHeight = pngDimensions.height;\n        }\n      } catch {\n        // Keep preview undefined when file is unreadable\n      }\n    }\n\n    previews.push({\n      path: artifact.path,\n      mimeType: artifact.mimeType,\n      sizeBytes,\n      htmlSnippet,\n      textSnippet,\n      inlinePreview,\n      imageWidth,\n      imageHeight,\n    });\n  }\n\n  return {\n    sequence: step.sequence,\n    artifacts: previews,\n  };\n}\n\nexport async function deriveBrowserReplayVisualDiffPairs(\n  cwd: string,\n  sessionId: string,\n  steps: BrowserSessionStepRecord[],\n  metadata: BrowserSessionMetadata | null = null,\n): Promise<BrowserReplayVisualDiffPair[]> {\n  if (steps.length <= 1) {\n    return [];\n  }\n\n  const persistedResults = await readBrowserReplayVisualDiffResults(cwd, sessionId);\n  const persistedResultByKey = new Map<string, BrowserVisualDiffResultEntry>();\n  for (const entry of persistedResults) {\n    persistedResultByKey.set(buildVisualDiffPairKey(entry), entry);\n  }\n\n  const replayMetadata = metadata ?? await readBrowserReplay(cwd, sessionId);\n  const indexes = buildReplayArtifactIndexes(replayMetadata);\n  const screenshotsByStep = steps.map((step) => {\n    const artifacts = resolveReplayStepArtifacts(cwd, step, indexes);\n    return artifacts.find((artifact) => isScreenshotArtifact(artifact));\n  });\n  const bytesByPath = new Map<string, Uint8Array | null>();\n\n  const loadBytes = async (path: string): Promise<Uint8Array | null> => {\n    if (bytesByPath.has(path)) {\n      return bytesByPath.get(path) ?? null;\n    }\n    try {\n      const bytes = await readFile(path);\n      bytesByPath.set(path, bytes);\n      return bytes;\n    } catch {\n      bytesByPath.set(path, null);\n      return null;\n    }\n  };\n\n  const diffs: BrowserReplayVisualDiffPair[] = [];\n\n  for (let index = 1; index < steps.length; index += 1) {\n    const fromStep = steps[index - 1]!;\n    const toStep = steps[index]!;\n    const fromScreenshot = screenshotsByStep[index - 1];\n    const toScreenshot = screenshotsByStep[index];\n    const persisted = persistedResultByKey.get(\n      buildVisualDiffPairKey({\n        fromSequence: fromStep.sequence,\n        fromActionId: fromStep.actionId,\n        toSequence: toStep.sequence,\n        toActionId: toStep.actionId,\n      }),\n    );\n    let status: BrowserReplayVisualDiffStatus = persisted?.status ?? 'missing';\n    let changedByteRatio = persisted?.changedByteRatio;\n    let perceptualDiffScore = persisted?.perceptualDiffScore;\n    let severity = persisted?.severity;\n    let regressionScore = persisted?.regressionScore;\n    let regressionSignal = persisted?.regressionSignal;\n\n    const shouldComputeAssessment = (\n      (!persisted) ||\n      (\n        status === 'changed' &&\n        (\n          (typeof changedByteRatio !== 'number' || !Number.isFinite(changedByteRatio)) ||\n          (typeof perceptualDiffScore !== 'number' || !Number.isFinite(perceptualDiffScore))\n        )\n      ) ||\n      !severity ||\n      (typeof regressionScore !== 'number' || !Number.isFinite(regressionScore)) ||\n      !regressionSignal\n    ) && fromScreenshot && toScreenshot;\n\n    if (shouldComputeAssessment) {\n      const [fromBytes, toBytes] = await Promise.all([\n        loadBytes(fromScreenshot.absolutePath),\n        loadBytes(toScreenshot.absolutePath),\n      ]);\n      if (fromBytes && toBytes) {\n        const assessment = assessVisualDiffPair(fromBytes, toBytes);\n        if (!persisted) {\n          status = assessment.status;\n          changedByteRatio = assessment.changedByteRatio;\n          perceptualDiffScore = assessment.perceptualDiffScore;\n          severity = assessment.severity;\n          regressionScore = assessment.regressionScore;\n          regressionSignal = assessment.regressionSignal;\n        } else if (assessment.status === status) {\n          if (typeof changedByteRatio !== 'number' || !Number.isFinite(changedByteRatio)) {\n            changedByteRatio = assessment.changedByteRatio;\n          }\n          if (typeof perceptualDiffScore !== 'number' || !Number.isFinite(perceptualDiffScore)) {\n            perceptualDiffScore = assessment.perceptualDiffScore;\n          }\n          if (!severity) {\n            severity = assessment.severity;\n          }\n          if (typeof regressionScore !== 'number' || !Number.isFinite(regressionScore)) {\n            regressionScore = assessment.regressionScore;\n          }\n          if (!regressionSignal) {\n            regressionSignal = assessment.regressionSignal;\n          }\n        }\n      }\n    }\n\n    severity ??= inferVisualDiffSeverity(status, changedByteRatio);\n    const regression = inferVisualDiffRegression(\n      status,\n      severity,\n      changedByteRatio,\n      perceptualDiffScore,\n      regressionScore,\n    );\n    regressionScore = regression.regressionScore;\n    regressionSignal ??= regression.regressionSignal;\n\n    diffs.push({\n      index: diffs.length,\n      fromSequence: fromStep.sequence,\n      fromActionType: fromStep.actionType,\n      toSequence: toStep.sequence,\n      toActionType: toStep.actionType,\n      fromScreenshotPath: fromScreenshot?.path ?? persisted?.fromScreenshotPath,\n      toScreenshotPath: toScreenshot?.path ?? persisted?.toScreenshotPath,\n      status,\n      changedByteRatio,\n      perceptualDiffScore,\n      severity,\n      regressionScore,\n      regressionSignal,\n    });\n  }\n\n  return diffs;\n}\n\nexport async function readBrowserReplay(\n  cwd: string,\n  sessionId: string,\n): Promise<BrowserSessionMetadata | null> {\n  const path = browserSessionMetadataPath(cwd, sessionId);\n  try {\n    const raw = await readFile(path, 'utf-8');\n    const parsed = JSON.parse(raw) as BrowserSessionMetadata;\n    return parsed;\n  } catch (error) {\n    const err = error as NodeJS.ErrnoException;\n    if (err.code === 'ENOENT') return null;\n    throw error;\n  }\n}\n\nexport async function summarizeBrowserReplay(\n  cwd: string,\n  sessionId: string,\n): Promise<BrowserReplaySummary | null> {\n  const metadata = await readBrowserReplay(cwd, sessionId);\n  if (!metadata) return null;\n\n  const steps = await readBrowserReplaySteps(cwd, sessionId);\n  const recordings = steps.length === 0 || !metadata.runId\n    ? await readBrowserReplayRecordings(cwd, sessionId)\n    : [];\n  const timeline: Array<Pick<BrowserSessionStepRecord, 'timestamp' | 'ok'>> = steps.length > 0\n    ? steps\n    : recordings;\n\n  const actionCount = timeline.length > 0 ? timeline.length : metadata.actions.length;\n  const failureCount = timeline.length > 0\n    ? timeline.filter((step) => !step.ok).length\n    : metadata.actions.filter((action) => !action.ok).length;\n  const lastActionAt = timeline.length > 0\n    ? timeline.at(-1)?.timestamp ?? metadata.updatedAt\n    : metadata.actions.at(-1)?.action.createdAt ?? metadata.updatedAt;\n  const runId = metadata.runId\n    ?? steps.find((step) => typeof step.runId === 'string' && step.runId.length > 0)?.runId\n    ?? recordings.find((recording) => typeof recording.runId === 'string' && recording.runId.length > 0)?.runId;\n  const visualDiffs = steps.length > 1\n    ? await deriveBrowserReplayVisualDiffPairs(cwd, sessionId, steps, metadata)\n    : [];\n  const visualPairs = visualDiffs.filter((pair) => Boolean(pair.fromScreenshotPath || pair.toScreenshotPath));\n  const regressionPairCount = visualPairs.filter((pair) => pair.regressionSignal === 'regression').length;\n  const regressionScore = visualPairs.reduce((max, pair) => (\n    typeof pair.regressionScore === 'number' && Number.isFinite(pair.regressionScore)\n      ? Math.max(max, pair.regressionScore)\n      : max\n  ), 0);\n  const regressionSignal: BrowserVisualDiffRegressionSignal = regressionPairCount > 0\n    ? 'regression'\n    : visualPairs.some((pair) => pair.regressionSignal === 'investigate')\n      ? 'investigate'\n      : 'none';\n\n  return {\n    sessionId: metadata.sessionId,\n    runId,\n    status: metadata.status,\n    runtime: metadata.runtime,\n    actionCount,\n    artifactCount: metadata.artifacts.length,\n    failureCount,\n    lastActionAt,\n    lastUpdatedAt: metadata.updatedAt,\n    regressionScore,\n    regressionSignal,\n    regressionPairCount,\n  };\n}\n\nexport async function readBrowserReplaySteps(\n  cwd: string,\n  sessionId: string,\n): Promise<BrowserSessionStepRecord[]> {\n  const path = browserSessionStepsPath(cwd, sessionId);\n  try {\n    const raw = await readFile(path, 'utf-8');\n    const lines = raw.split(/\\r?\\n/);\n    const entries: BrowserSessionStepRecord[] = [];\n\n    for (let index = 0; index < lines.length; index += 1) {\n      const line = lines[index]?.trim();\n      if (!line) continue;\n\n      try {\n        const parsed = JSON.parse(line) as BrowserSessionStepRecord;\n        entries.push(parsed);\n      } catch (error) {\n        const isTrailingLine = index === lines.length - 1;\n        if (isTrailingLine) {\n          continue;\n        }\n        throw error;\n      }\n    }\n\n    return entries;\n  } catch (error) {\n    const err = error as NodeJS.ErrnoException;\n    if (err.code === 'ENOENT') {\n      const recordings = await readBrowserReplayRecordings(cwd, sessionId);\n      return recordings.map((recording) => ({\n        sequence: recording.sequence,\n        sessionId: recording.sessionId,\n        runId: recording.runId,\n        actionId: recording.actionId,\n        actionType: recording.actionType,\n        timestamp: recording.timestamp,\n        ok: recording.ok,\n        error: recording.error,\n        artifactIds: recording.artifactIds,\n        artifactPaths: recording.artifactPaths,\n      }));\n    }\n    throw error;\n  }\n}\n\nexport async function readBrowserReplayRecordings(\n  cwd: string,\n  sessionId: string,\n): Promise<BrowserSessionRecordingEntry[]> {\n  const path = browserSessionRecordingsPath(cwd, sessionId);\n  try {\n    const raw = await readFile(path, 'utf-8');\n    const parsed = JSON.parse(raw) as BrowserSessionRecordingIndex;\n    if (!Array.isArray(parsed.recordings)) {\n      return [];\n    }\n\n    return [...parsed.recordings].sort((left, right) => left.sequence - right.sequence);\n  } catch (error) {\n    const err = error as NodeJS.ErrnoException;\n    if (err.code === 'ENOENT') return [];\n    throw error;\n  }\n}\n\nexport async function readBrowserReplayVisualDiffManifest(\n  cwd: string,\n  sessionId: string,\n): Promise<BrowserVisualDiffManifestEntry[]> {\n  const path = browserSessionVisualDiffManifestPath(cwd, sessionId);\n  try {\n    const raw = await readFile(path, 'utf-8');\n    const lines = raw.split(/\\r?\\n/);\n    const entries: BrowserVisualDiffManifestEntry[] = [];\n\n    for (let index = 0; index < lines.length; index += 1) {\n      const line = lines[index]?.trim();\n      if (!line) continue;\n\n      try {\n        const parsed = JSON.parse(line) as BrowserVisualDiffManifestEntry;\n        entries.push(parsed);\n      } catch (error) {\n        const isTrailingLine = index === lines.length - 1;\n        if (isTrailingLine) {\n          continue;\n        }\n        throw error;\n      }\n    }\n\n    return entries;\n  } catch (error) {\n    const err = error as NodeJS.ErrnoException;\n    if (err.code === 'ENOENT') return [];\n    throw error;\n  }\n}\n\nexport async function readBrowserReplayVisualDiffResults(\n  cwd: string,\n  sessionId: string,\n): Promise<BrowserVisualDiffResultEntry[]> {\n  return readPersistedBrowserVisualDiffResults(cwd, sessionId);\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/browser/retry-taxonomy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/browser/run-corpus.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/browser/runtime-daemon.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":326,"column":24,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":326,"endColumn":55},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":614,"column":16,"nodeType":"CallExpression","messageId":"neverOptionalChain","endLine":614,"endColumn":18,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[20503,20505],"text":""},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":631,"column":16,"nodeType":"CallExpression","messageId":"neverOptionalChain","endLine":631,"endColumn":18,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[20978,20980],"text":""},"desc":"Remove unnecessary optional chain"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { randomUUID } from 'node:crypto';\nimport { join } from 'node:path';\nimport {\n  pruneBrowserArtifactSessionDirs,\n  resolveBrowserArtifactRetentionPolicy,\n  type BrowserArtifactRetentionPolicy,\n} from './artifacts.js';\nimport {\n  NativeSessionManager,\n  type NativeSessionActionOptions,\n  type NativeSessionManagerOptions,\n} from './native-session-manager.js';\nimport {\n  pruneBrowserProfileDirs,\n  resolveBrowserProfileRetentionPolicy,\n  type BrowserProfileRetentionPolicy,\n} from './profile-store.js';\nimport {\n  BrowserSessionStore,\n  type BrowserRuntimeSessionRecord,\n} from './session-store.js';\nimport { refreshBrowserRunCorpusSummary } from './run-corpus.js';\nimport { withRetryTaxonomy } from './retry-taxonomy.js';\nimport type {\n  BrowserAction,\n  BrowserActionError,\n  BrowserActionResult,\n  BrowserClickInput,\n  BrowserNavigateInput,\n  BrowserOpenSessionInput,\n  BrowserScreenshotData,\n  BrowserScreenshotInput,\n  BrowserSession,\n  BrowserSnapshotData,\n  BrowserTypeInput,\n} from './types.js';\n\nexport { browserRuntimeSessionStorePath } from './session-store.js';\n\nexport interface BrowserRuntimeDaemonOptions {\n  cwd?: string;\n  now?: () => Date;\n  maxSessions?: number;\n  persistSessions?: boolean;\n  persistProfileContinuity?: boolean;\n  profileRetentionPolicy?: Partial<BrowserProfileRetentionPolicy>;\n  profilePruneIntervalMs?: number;\n  artifactPrune?: Partial<BrowserRuntimeArtifactPruneConfig>;\n  runCorpusRefresh?: Partial<BrowserRuntimeRunCorpusRefreshConfig>;\n  idFactory?: () => string;\n  loadPlaywright?: NativeSessionManagerOptions['loadPlaywright'];\n  sessionStore?: BrowserSessionStore;\n  sessionManager?: NativeSessionManager;\n}\n\nexport interface BrowserRuntimeHealth {\n  running: boolean;\n  paused: boolean;\n  killed: boolean;\n  maxSessions: number;\n  sessionCount: number;\n  recoveredSessionIds: string[];\n  profilePrune: BrowserRuntimeProfilePruneHealth;\n  artifactPrune?: BrowserRuntimeArtifactPruneHealth;\n  runCorpusRefresh?: BrowserRuntimeRunCorpusRefreshHealth;\n  sessions: Array<{\n    sessionId: string;\n    mode: BrowserSession['mode'];\n    status: BrowserSession['status'];\n    runtime: BrowserSession['runtime'];\n    currentUrl?: string;\n    updatedAt: string;\n  }>;\n}\n\nexport type BrowserProfilePruneReason = 'startup' | 'interval';\nexport type BrowserProfilePruneStatus = 'success' | 'error';\nexport type BrowserArtifactPruneReason = 'startup' | 'interval';\nexport type BrowserArtifactPruneStatus = 'success' | 'error';\nexport type BrowserRunCorpusRefreshReason = 'startup' | 'session-close' | 'stop';\nexport type BrowserRunCorpusRefreshStatus = 'success' | 'error';\n\nexport interface BrowserRuntimeProfilePruneHealth {\n  enabled: boolean;\n  intervalMs?: number;\n  inFlight: boolean;\n  lastRunAt?: string;\n  lastReason?: BrowserProfilePruneReason;\n  lastStatus?: BrowserProfilePruneStatus;\n  lastListedCount?: number;\n  lastKeptCount?: number;\n  lastPrunedCount?: number;\n  lastError?: string;\n}\n\nexport interface BrowserRuntimeArtifactPruneHealth {\n  enabled: boolean;\n  intervalMs?: number;\n  inFlight: boolean;\n  lastRunAt?: string;\n  lastReason?: BrowserArtifactPruneReason;\n  lastStatus?: BrowserArtifactPruneStatus;\n  lastListedCount?: number;\n  lastKeptCount?: number;\n  lastPrunedCount?: number;\n  lastError?: string;\n}\n\nexport interface BrowserRuntimeRunCorpusRefreshHealth {\n  enabled: boolean;\n  windowHours?: number;\n  inFlight: boolean;\n  lastRunAt?: string;\n  lastReason?: BrowserRunCorpusRefreshReason;\n  lastStatus?: BrowserRunCorpusRefreshStatus;\n  lastError?: string;\n  lastAssessedSessionCount?: number;\n}\n\nexport interface BrowserRuntimeArtifactPruneConfig {\n  enabled: boolean;\n  policy: BrowserArtifactRetentionPolicy;\n  intervalMs: number;\n}\n\nexport interface BrowserRuntimeRunCorpusRefreshConfig {\n  enabled: boolean;\n  windowHours: number;\n}\n\ninterface StopOptions {\n  closeSessions?: boolean;\n}\n\nconst DAY_MS = 24 * 60 * 60 * 1000;\nconst DEFAULT_PROFILE_PRUNE_INTERVAL_MS = DAY_MS;\nconst DEFAULT_ARTIFACT_PRUNE_INTERVAL_MS = DAY_MS;\nconst DEFAULT_RUN_CORPUS_WINDOW_HOURS = 168;\n\nfunction cloneSession(session: BrowserSession): BrowserSession {\n  return {\n    ...session,\n    lastError: session.lastError ? { ...session.lastError } : undefined,\n  };\n}\n\nfunction cloneActionError(error: BrowserActionError | undefined): BrowserActionError | undefined {\n  if (!error) return undefined;\n  const normalized = withRetryTaxonomy(error.code, error.message);\n  return {\n    ...normalized,\n    ...error,\n    retryable: error.retryable ?? normalized.retryable,\n    retryCategory: error.retryCategory ?? normalized.retryCategory,\n    retryHint: error.retryHint ?? normalized.retryHint,\n  };\n}\n\nfunction normalizePruneIntervalMs(v: unknown, defaultMs: number): number {\n  const n = typeof v === 'number' ? v : Number(v);\n  return Number.isFinite(n) && n > 0 ? Math.max(1_000, Math.floor(n)) : defaultMs;\n}\n\nfunction normalizeRunCorpusWindowHours(value: number | undefined): number {\n  if (typeof value !== 'number' || !Number.isFinite(value) || value <= 0) {\n    return DEFAULT_RUN_CORPUS_WINDOW_HOURS;\n  }\n  return Math.max(1, Math.floor(value));\n}\n\nexport class BrowserRuntimeDaemon {\n  private readonly cwd: string;\n  private readonly now: () => Date;\n  private readonly maxSessions: number;\n  private readonly persistSessions: boolean;\n  private readonly persistProfileContinuity: boolean;\n  private readonly profileRetentionPolicy: BrowserProfileRetentionPolicy;\n  private readonly profilePruneIntervalMs: number;\n  private readonly artifactPruneEnabled: boolean;\n  private readonly artifactRetentionPolicy: BrowserArtifactRetentionPolicy;\n  private readonly artifactPruneIntervalMs: number;\n  private readonly runCorpusRefreshEnabled: boolean;\n  private readonly runCorpusWindowHours: number;\n  private readonly idFactory: () => string;\n  private readonly sessionManager: NativeSessionManager;\n  private readonly sessionStore: BrowserSessionStore;\n\n  private readonly sessions = new Map<string, BrowserSession>();\n  private readonly recoveredSessionIds = new Set<string>();\n  private readonly pendingOpenSessionIds = new Set<string>();\n  private readonly profilePruneHealth: BrowserRuntimeProfilePruneHealth;\n  private readonly artifactPruneHealth: BrowserRuntimeArtifactPruneHealth;\n  private readonly runCorpusRefreshHealth: BrowserRuntimeRunCorpusRefreshHealth;\n  private profilePruneTimer: NodeJS.Timeout | null = null;\n  private artifactPruneTimer: NodeJS.Timeout | null = null;\n  private runCorpusRefreshInFlight: Promise<void> | null = null;\n  private running = false;\n  private paused = false;\n  private killed = false;\n  private daemonActionSequence = 0;\n  private actionAbortController = new AbortController();\n\n  constructor(options: BrowserRuntimeDaemonOptions = {}) {\n    this.cwd = options.cwd ?? process.cwd();\n    this.now = options.now ?? (() => new Date());\n    this.maxSessions = Math.max(1, Math.floor(options.maxSessions ?? 3));\n    this.persistSessions = options.persistSessions !== false;\n    this.persistProfileContinuity = options.persistProfileContinuity === true;\n    this.profileRetentionPolicy = resolveBrowserProfileRetentionPolicy(options.profileRetentionPolicy);\n    this.profilePruneIntervalMs = normalizePruneIntervalMs(options.profilePruneIntervalMs, DEFAULT_PROFILE_PRUNE_INTERVAL_MS);\n    this.artifactPruneEnabled = options.artifactPrune?.enabled === true;\n    this.artifactRetentionPolicy = resolveBrowserArtifactRetentionPolicy(options.artifactPrune?.policy);\n    this.artifactPruneIntervalMs = normalizePruneIntervalMs(options.artifactPrune?.intervalMs, DEFAULT_ARTIFACT_PRUNE_INTERVAL_MS);\n    this.runCorpusRefreshEnabled = options.runCorpusRefresh?.enabled !== false;\n    this.runCorpusWindowHours = normalizeRunCorpusWindowHours(options.runCorpusRefresh?.windowHours);\n    this.idFactory = options.idFactory ?? (() => randomUUID());\n    this.sessionManager = options.sessionManager ?? new NativeSessionManager({\n      cwd: this.cwd,\n      now: this.now,\n      idFactory: this.idFactory,\n      loadPlaywright: options.loadPlaywright,\n    });\n    this.sessionStore = options.sessionStore ?? new BrowserSessionStore({\n      cwd: this.cwd,\n      now: this.now,\n    });\n    this.profilePruneHealth = {\n      enabled: this.persistProfileContinuity,\n      intervalMs: this.persistProfileContinuity ? this.profilePruneIntervalMs : undefined,\n      inFlight: false,\n    };\n    this.artifactPruneHealth = {\n      enabled: this.artifactPruneEnabled,\n      intervalMs: this.artifactPruneEnabled ? this.artifactPruneIntervalMs : undefined,\n      inFlight: false,\n    };\n    this.runCorpusRefreshHealth = {\n      enabled: this.runCorpusRefreshEnabled,\n      windowHours: this.runCorpusRefreshEnabled ? this.runCorpusWindowHours : undefined,\n      inFlight: false,\n    };\n  }\n\n  async start(): Promise<void> {\n    if (this.running) return;\n    this.running = true;\n    this.killed = false;\n    this.actionAbortController = new AbortController();\n    this.recoveredSessionIds.clear();\n    await this.recoverPersistedSessions();\n    await this.pruneProfiles('startup');\n    await this.pruneArtifacts('startup');\n    await this.refreshRunCorpus('startup');\n    this.ensureProfilePruneTimer();\n    this.ensureArtifactPruneTimer();\n  }\n\n  async stop(options: StopOptions = {}): Promise<void> {\n    this.clearProfilePruneTimer();\n    this.clearArtifactPruneTimer();\n    if (!this.running) return;\n    const closeSessions = options.closeSessions !== false;\n\n    if (closeSessions) {\n      for (const sessionId of this.sessions.keys()) {\n        await this.sessionManager.closeSession(sessionId).catch(() => {});\n      }\n      this.sessions.clear();\n      this.recoveredSessionIds.clear();\n    }\n\n    await this.persistOpenSessions();\n    await this.refreshRunCorpus('stop');\n    this.running = false;\n    this.paused = false;\n  }\n\n  pause(): void {\n    if (!this.running) return;\n    this.paused = true;\n  }\n\n  resume(): void {\n    if (!this.running || this.killed) return;\n    this.paused = false;\n  }\n\n  async kill(): Promise<void> {\n    if (!this.actionAbortController.signal.aborted) {\n      this.actionAbortController.abort();\n    }\n    await this.stop({ closeSessions: true });\n    this.killed = true;\n    this.paused = true;\n  }\n\n  health(): BrowserRuntimeHealth {\n    const sessions = [...this.sessions.values()]\n      .map((session) => ({\n        sessionId: session.id,\n        mode: session.mode,\n        status: session.status,\n        runtime: session.runtime,\n        currentUrl: session.currentUrl,\n        updatedAt: session.updatedAt,\n      }))\n      .sort((a, b) => a.sessionId.localeCompare(b.sessionId));\n\n    return {\n      running: this.running,\n      paused: this.paused,\n      killed: this.killed,\n      maxSessions: this.maxSessions,\n      sessionCount: sessions.length,\n      recoveredSessionIds: [...this.recoveredSessionIds].sort((a, b) => a.localeCompare(b)),\n      profilePrune: { ...this.profilePruneHealth },\n      artifactPrune: { ...this.artifactPruneHealth },\n      runCorpusRefresh: { ...this.runCorpusRefreshHealth },\n      sessions,\n    };\n  }\n\n  async ensureSession(input: BrowserOpenSessionInput): Promise<BrowserActionResult<BrowserSession>> {\n    const requestedId = input.sessionId?.trim();\n    if (requestedId && this.sessions.has(requestedId)) {\n      const existing = this.sessions.get(requestedId)!;\n      return {\n        ok: true,\n        action: this.createDaemonAction(requestedId, 'openSession', { reused: true }),\n        data: cloneSession(existing),\n      };\n    }\n    return this.openSession(input);\n  }\n\n  async openSession(input: BrowserOpenSessionInput = {}): Promise<BrowserActionResult<BrowserSession>> {\n    const sessionId = input.sessionId?.trim() || this.idFactory();\n    const mode = input.mode ?? 'isolated';\n    const profileDir = input.profileDir ?? this.resolveSessionProfileDir(sessionId, mode);\n    const gate = this.checkDaemonGate<BrowserSession>(sessionId, 'openSession', { ...input }, {\n      allowWhilePaused: false,\n    });\n    if (gate) return gate;\n\n    if (!this.sessions.has(sessionId) && this.pendingOpenSessionIds.has(sessionId)) {\n      return this.daemonError(\n        sessionId,\n        'openSession',\n        'SESSION_OPENING',\n        `Browser session \"${sessionId}\" is currently opening.`,\n        input as Record<string, unknown>,\n      );\n    }\n\n    const pendingCount = this.pendingOpenSessionIds.has(sessionId)\n      ? this.pendingOpenSessionIds.size - 1\n      : this.pendingOpenSessionIds.size;\n    const activeOrPendingCount = this.sessions.size + pendingCount;\n\n    if (!this.sessions.has(sessionId) && activeOrPendingCount >= this.maxSessions) {\n      return this.daemonError(\n        sessionId,\n        'openSession',\n        'MAX_SESSIONS_REACHED',\n        `Browser runtime max sessions reached (${this.maxSessions}).`,\n        input as Record<string, unknown>,\n      );\n    }\n\n    this.pendingOpenSessionIds.add(sessionId);\n    let result: BrowserActionResult<BrowserSession>;\n    try {\n      result = await this.sessionManager.openSession({\n        ...input,\n        sessionId,\n        mode,\n        profileDir,\n      }, this.actionOptions());\n\n      const keepSessionRecord = result.ok || result.error?.code === 'PLAYWRIGHT_UNAVAILABLE';\n      if (result.data && keepSessionRecord) {\n        this.sessions.set(sessionId, cloneSession(result.data));\n      } else if (result.data && !result.ok) {\n        // Failed opens should not consume daemon capacity as active sessions.\n        await this.sessionManager.closeSession(sessionId).catch(() => {});\n      }\n    } finally {\n      this.pendingOpenSessionIds.delete(sessionId);\n    }\n\n    await this.persistOpenSessions();\n    return this.cloneActionResult(result);\n  }\n\n  async closeSession(\n    sessionId: string,\n  ): Promise<BrowserActionResult<{ sessionId: string; status: 'closed' }>> {\n    const gate = this.checkDaemonGate<{ sessionId: string; status: 'closed' }>(sessionId, 'closeSession', {}, {\n      allowWhilePaused: true,\n    });\n    if (gate) return gate;\n\n    const result = await this.sessionManager.closeSession(sessionId);\n    if (result.ok) {\n      this.sessions.delete(sessionId);\n      this.recoveredSessionIds.delete(sessionId);\n    }\n\n    await this.persistOpenSessions();\n    if (result.ok) {\n      await this.refreshRunCorpus('session-close');\n    }\n    return this.cloneActionResult(result);\n  }\n\n  async navigate(\n    sessionId: string,\n    input: BrowserNavigateInput,\n  ): Promise<BrowserActionResult<{ url: string }>> {\n    const gate = this.checkDaemonGate<{ url: string }>(sessionId, 'navigate', { ...input });\n    if (gate) return gate;\n\n    const result = await this.sessionManager.navigate(sessionId, input, this.actionOptions());\n    if (result.ok) {\n      const existing = this.sessions.get(sessionId);\n      if (existing && result.data?.url) {\n        existing.currentUrl = result.data.url;\n        existing.updatedAt = this.timestamp();\n        this.sessions.set(sessionId, cloneSession(existing));\n      }\n    }\n\n    await this.persistOpenSessions();\n    return this.cloneActionResult(result);\n  }\n\n  async click(sessionId: string, input: BrowserClickInput): Promise<BrowserActionResult> {\n    const gate = this.checkDaemonGate<undefined>(sessionId, 'click', { ...input });\n    if (gate) return gate;\n\n    const result = await this.sessionManager.click(sessionId, input, this.actionOptions());\n    await this.persistOpenSessions();\n    return this.cloneActionResult(result);\n  }\n\n  async type(sessionId: string, input: BrowserTypeInput): Promise<BrowserActionResult> {\n    const gate = this.checkDaemonGate<undefined>(sessionId, 'type', { ...input });\n    if (gate) return gate;\n\n    const result = await this.sessionManager.type(sessionId, input, this.actionOptions());\n    await this.persistOpenSessions();\n    return this.cloneActionResult(result);\n  }\n\n  async snapshot(sessionId: string): Promise<BrowserActionResult<BrowserSnapshotData>> {\n    const gate = this.checkDaemonGate<BrowserSnapshotData>(sessionId, 'snapshot', {});\n    if (gate) return gate;\n\n    const result = await this.sessionManager.snapshot(sessionId, this.actionOptions());\n    await this.persistOpenSessions();\n    return this.cloneActionResult(result);\n  }\n\n  async screenshot(\n    sessionId: string,\n    input: BrowserScreenshotInput = {},\n  ): Promise<BrowserActionResult<BrowserScreenshotData>> {\n    const gate = this.checkDaemonGate<BrowserScreenshotData>(sessionId, 'screenshot', { ...input });\n    if (gate) return gate;\n\n    const result = await this.sessionManager.screenshot(sessionId, input, this.actionOptions());\n    await this.persistOpenSessions();\n    return this.cloneActionResult(result);\n  }\n\n  private async recoverPersistedSessions(): Promise<void> {\n    if (!this.persistSessions) return;\n\n    const persisted = await this.sessionStore.list();\n    for (const record of persisted) {\n      if (record.status !== 'open') continue;\n      if (this.sessions.size >= this.maxSessions) break;\n\n      try {\n        const recovered = await this.sessionManager.openSession({\n          sessionId: record.sessionId,\n          mode: record.mode,\n          wsEndpoint: record.wsEndpoint,\n          profileDir: this.resolveSessionProfileDir(record.sessionId, record.mode),\n        }, this.actionOptions());\n\n        if (!recovered.data) continue;\n\n        this.sessions.set(record.sessionId, cloneSession(recovered.data));\n        this.recoveredSessionIds.add(record.sessionId);\n      } catch (error) {\n        if (process.env.OPTA_DEBUG) {\n          console.error(`Failed to recover browser session \"${record.sessionId}\":`, error);\n        }\n      }\n    }\n\n    await this.persistOpenSessions();\n  }\n\n  private async persistOpenSessions(): Promise<void> {\n    if (!this.persistSessions) return;\n\n    const records: BrowserRuntimeSessionRecord[] = [];\n    for (const session of this.sessions.values()) {\n      if (session.status !== 'open') continue;\n\n      records.push({\n        sessionId: session.id,\n        mode: session.mode,\n        status: session.status,\n        runtime: session.runtime,\n        createdAt: session.createdAt,\n        updatedAt: session.updatedAt,\n        currentUrl: session.currentUrl,\n        wsEndpoint: session.wsEndpoint,\n        lastError: cloneActionError(session.lastError),\n        recoveredAt: this.recoveredSessionIds.has(session.id) ? this.timestamp() : undefined,\n      });\n    }\n\n    await this.sessionStore.replaceSessions(records);\n  }\n\n  private checkDaemonGate<T>(\n    sessionId: string,\n    type: BrowserAction['type'],\n    input: Record<string, unknown>,\n    options: { allowWhilePaused?: boolean } = {},\n  ): BrowserActionResult<T> | null {\n    if (!this.running || this.killed) {\n      return this.daemonError(\n        sessionId,\n        type,\n        'DAEMON_STOPPED',\n        'Browser runtime daemon is not running.',\n        input,\n      );\n    }\n\n    if (this.paused && !options.allowWhilePaused) {\n      return this.daemonError(\n        sessionId,\n        type,\n        'DAEMON_PAUSED',\n        'Browser runtime daemon is paused.',\n        input,\n      );\n    }\n\n    return null;\n  }\n\n  private createDaemonAction(\n    sessionId: string,\n    type: BrowserAction['type'],\n    input: Record<string, unknown>,\n  ): BrowserAction {\n    this.daemonActionSequence += 1;\n    return {\n      id: `daemon-action-${String(this.daemonActionSequence).padStart(6, '0')}`,\n      sessionId,\n      type,\n      createdAt: this.timestamp(),\n      input,\n    };\n  }\n\n  private daemonError<T>(\n    sessionId: string,\n    type: BrowserAction['type'],\n    code: string,\n    message: string,\n    input: Record<string, unknown>,\n  ): BrowserActionResult<T> {\n    return {\n      ok: false,\n      action: this.createDaemonAction(sessionId, type, input),\n      error: withRetryTaxonomy(code, message),\n    };\n  }\n\n  private cloneActionResult<T>(result: BrowserActionResult<T>): BrowserActionResult<T> {\n    return {\n      ...result,\n      action: { ...result.action },\n      error: cloneActionError(result.error),\n      data: result.data,\n    };\n  }\n\n  private timestamp(): string {\n    return this.now().toISOString();\n  }\n\n  private actionOptions(): NativeSessionActionOptions {\n    return {\n      signal: this.actionAbortController.signal,\n    };\n  }\n\n  private ensureProfilePruneTimer(): void {\n    this.clearProfilePruneTimer();\n    if (!this.persistProfileContinuity) return;\n\n    const timer = setInterval(() => {\n      void this.pruneProfiles('interval');\n    }, this.profilePruneIntervalMs);\n    timer.unref?.();\n    this.profilePruneTimer = timer;\n  }\n\n  private clearProfilePruneTimer(): void {\n    if (!this.profilePruneTimer) return;\n    clearInterval(this.profilePruneTimer);\n    this.profilePruneTimer = null;\n  }\n\n  private ensureArtifactPruneTimer(): void {\n    this.clearArtifactPruneTimer();\n    if (!this.artifactPruneEnabled) return;\n\n    const timer = setInterval(() => {\n      void this.pruneArtifacts('interval');\n    }, this.artifactPruneIntervalMs);\n    timer.unref?.();\n    this.artifactPruneTimer = timer;\n  }\n\n  private clearArtifactPruneTimer(): void {\n    if (!this.artifactPruneTimer) return;\n    clearInterval(this.artifactPruneTimer);\n    this.artifactPruneTimer = null;\n  }\n\n  private async pruneProfiles(reason: BrowserProfilePruneReason): Promise<void> {\n    if (!this.persistProfileContinuity) return;\n    if (this.profilePruneHealth.inFlight) return;\n\n    this.profilePruneHealth.inFlight = true;\n    this.profilePruneHealth.lastRunAt = this.timestamp();\n    this.profilePruneHealth.lastReason = reason;\n\n    try {\n      const result = await pruneBrowserProfileDirs({\n        cwd: this.cwd,\n        now: this.now,\n        policy: this.profileRetentionPolicy,\n        excludeSessionIds: [...this.sessions.keys()],\n      });\n      this.profilePruneHealth.lastStatus = 'success';\n      this.profilePruneHealth.lastListedCount = result.listed.length;\n      this.profilePruneHealth.lastKeptCount = result.kept.length;\n      this.profilePruneHealth.lastPrunedCount = result.pruned.length;\n      delete this.profilePruneHealth.lastError;\n    } catch (error) {\n      this.profilePruneHealth.lastStatus = 'error';\n      this.profilePruneHealth.lastListedCount = undefined;\n      this.profilePruneHealth.lastKeptCount = undefined;\n      this.profilePruneHealth.lastPrunedCount = undefined;\n      this.profilePruneHealth.lastError = error instanceof Error ? error.message : String(error);\n      if (process.env.OPTA_DEBUG) {\n        console.error('Browser profile auto-prune failed:', error);\n      }\n    } finally {\n      this.profilePruneHealth.inFlight = false;\n    }\n  }\n\n  private async pruneArtifacts(reason: BrowserArtifactPruneReason): Promise<void> {\n    if (!this.artifactPruneEnabled) return;\n    if (this.artifactPruneHealth.inFlight) return;\n\n    this.artifactPruneHealth.inFlight = true;\n    this.artifactPruneHealth.lastRunAt = this.timestamp();\n    this.artifactPruneHealth.lastReason = reason;\n\n    try {\n      const result = await pruneBrowserArtifactSessionDirs({\n        cwd: this.cwd,\n        now: this.now,\n        policy: this.artifactRetentionPolicy,\n        excludeSessionIds: [...this.sessions.keys()],\n      });\n      this.artifactPruneHealth.lastStatus = 'success';\n      this.artifactPruneHealth.lastListedCount = result.listed.length;\n      this.artifactPruneHealth.lastKeptCount = result.kept.length;\n      this.artifactPruneHealth.lastPrunedCount = result.pruned.length;\n      delete this.artifactPruneHealth.lastError;\n    } catch (error) {\n      this.artifactPruneHealth.lastStatus = 'error';\n      this.artifactPruneHealth.lastListedCount = undefined;\n      this.artifactPruneHealth.lastKeptCount = undefined;\n      this.artifactPruneHealth.lastPrunedCount = undefined;\n      this.artifactPruneHealth.lastError = error instanceof Error ? error.message : String(error);\n      if (process.env.OPTA_DEBUG) {\n        console.error('Browser artifact auto-prune failed:', error);\n      }\n    } finally {\n      this.artifactPruneHealth.inFlight = false;\n    }\n  }\n\n  private async refreshRunCorpus(reason: BrowserRunCorpusRefreshReason): Promise<void> {\n    if (!this.runCorpusRefreshEnabled) return;\n    if (this.runCorpusRefreshInFlight) {\n      await this.runCorpusRefreshInFlight;\n      return;\n    }\n\n    this.runCorpusRefreshHealth.inFlight = true;\n    this.runCorpusRefreshHealth.lastRunAt = this.timestamp();\n    this.runCorpusRefreshHealth.lastReason = reason;\n\n    const refreshPromise = (async () => {\n      try {\n        const refreshed = await refreshBrowserRunCorpusSummary(this.cwd, {\n          enabled: true,\n          windowHours: this.runCorpusWindowHours,\n          now: this.now,\n        });\n        this.runCorpusRefreshHealth.lastStatus = 'success';\n        this.runCorpusRefreshHealth.lastAssessedSessionCount = refreshed?.summary.assessedSessionCount;\n        delete this.runCorpusRefreshHealth.lastError;\n      } catch (error) {\n        this.runCorpusRefreshHealth.lastStatus = 'error';\n        this.runCorpusRefreshHealth.lastAssessedSessionCount = undefined;\n        this.runCorpusRefreshHealth.lastError = error instanceof Error ? error.message : String(error);\n        if (process.env.OPTA_DEBUG) {\n          console.error('Browser run-corpus auto-refresh failed:', error);\n        }\n      } finally {\n        this.runCorpusRefreshHealth.inFlight = false;\n      }\n    })();\n\n    this.runCorpusRefreshInFlight = refreshPromise;\n    try {\n      await refreshPromise;\n    } finally {\n      this.runCorpusRefreshInFlight = null;\n    }\n  }\n\n  private resolveSessionProfileDir(\n    sessionId: string,\n    mode: BrowserOpenSessionInput['mode'],\n  ): string | undefined {\n    if (!this.persistProfileContinuity) return undefined;\n    if (mode === 'attach') return undefined;\n    return join(this.cwd, '.opta', 'browser', 'profiles', sessionId);\n  }\n}\n\nlet sharedDaemon: BrowserRuntimeDaemon | null = null;\nlet sharedDaemonKey = '';\n\nexport async function getSharedBrowserRuntimeDaemon(\n  options: BrowserRuntimeDaemonOptions = {},\n): Promise<BrowserRuntimeDaemon> {\n  const cwd = options.cwd ?? process.cwd();\n  const persistSessions = options.persistSessions !== false;\n  const persistProfileContinuity = options.persistProfileContinuity === true;\n  const maxSessions = Math.max(1, Math.floor(options.maxSessions ?? 3));\n  const profileRetentionPolicy = resolveBrowserProfileRetentionPolicy(options.profileRetentionPolicy);\n  const profilePruneIntervalMs = normalizePruneIntervalMs(options.profilePruneIntervalMs, DEFAULT_PROFILE_PRUNE_INTERVAL_MS);\n  const artifactPruneEnabled = options.artifactPrune?.enabled === true;\n  const artifactRetentionPolicy = resolveBrowserArtifactRetentionPolicy(options.artifactPrune?.policy);\n  const artifactPruneIntervalMs = normalizePruneIntervalMs(options.artifactPrune?.intervalMs, DEFAULT_ARTIFACT_PRUNE_INTERVAL_MS);\n  const runCorpusRefreshEnabled = options.runCorpusRefresh?.enabled !== false;\n  const runCorpusWindowHours = normalizeRunCorpusWindowHours(options.runCorpusRefresh?.windowHours);\n  const key = [\n    cwd,\n    persistSessions ? 'persist' : 'ephemeral',\n    persistProfileContinuity ? 'profile' : 'noprof',\n    `max${maxSessions}`,\n    `ret${profileRetentionPolicy.retentionDays}`,\n    `maxprof${profileRetentionPolicy.maxPersistedProfiles}`,\n    `pprune${profilePruneIntervalMs}`,\n    artifactPruneEnabled ? 'artifact-prune' : 'artifact-keep',\n    `aret${artifactRetentionPolicy.retentionDays}`,\n    `amax${artifactRetentionPolicy.maxPersistedSessions}`,\n    `aprune${artifactPruneIntervalMs}`,\n    runCorpusRefreshEnabled ? 'run-corpus-on' : 'run-corpus-off',\n    `rwindow${runCorpusWindowHours}`,\n  ].join('::');\n\n  if (!sharedDaemon || sharedDaemonKey !== key) {\n    if (sharedDaemon) {\n      // Reconfiguration must fully close prior runtime resources; keeping sessions\n      // alive here can orphan browser contexts when the singleton is replaced.\n      await sharedDaemon.stop({ closeSessions: true }).catch(() => {});\n    }\n    sharedDaemon = new BrowserRuntimeDaemon({\n      ...options,\n      cwd,\n      persistSessions,\n      persistProfileContinuity,\n      maxSessions,\n      profileRetentionPolicy,\n      profilePruneIntervalMs,\n      artifactPrune: {\n        enabled: artifactPruneEnabled,\n        policy: artifactRetentionPolicy,\n        intervalMs: artifactPruneIntervalMs,\n      },\n      runCorpusRefresh: {\n        enabled: runCorpusRefreshEnabled,\n        windowHours: runCorpusWindowHours,\n      },\n    });\n    sharedDaemonKey = key;\n  }\n\n  return sharedDaemon;\n}\n\nexport async function resetSharedBrowserRuntimeDaemonForTests(): Promise<void> {\n  if (sharedDaemon) {\n    await sharedDaemon.stop({ closeSessions: true }).catch(() => {});\n  }\n  sharedDaemon = null;\n  sharedDaemonKey = '';\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/browser/session-store.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, value is always falsy.","line":59,"column":11,"nodeType":"UnaryExpression","messageId":"alwaysFalsy","endLine":59,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { mkdir, readFile, rename, unlink, writeFile } from 'node:fs/promises';\nimport { dirname, join } from 'node:path';\nimport type {\n  BrowserActionError,\n  BrowserMode,\n  BrowserRuntimeState,\n  BrowserSessionStatus,\n} from './types.js';\n\nexport const BROWSER_RUNTIME_SESSION_STORE_RELATIVE_PATH = join(\n  '.opta',\n  'browser',\n  'runtime-sessions.json',\n);\n\nexport interface BrowserRuntimeSessionRecord {\n  sessionId: string;\n  mode: BrowserMode;\n  status: BrowserSessionStatus;\n  runtime: BrowserRuntimeState;\n  createdAt: string;\n  updatedAt: string;\n  currentUrl?: string;\n  wsEndpoint?: string;\n  lastError?: BrowserActionError;\n  recoveredAt?: string;\n}\n\nexport interface BrowserRuntimeSessionStoreData {\n  schemaVersion: 1;\n  updatedAt: string;\n  sessions: BrowserRuntimeSessionRecord[];\n}\n\nconst EMPTY_DATA: BrowserRuntimeSessionStoreData = {\n  schemaVersion: 1,\n  updatedAt: new Date(0).toISOString(),\n  sessions: [],\n};\n\nfunction toErrorMessage(error: unknown): string {\n  if (error instanceof Error) return error.message;\n  return String(error);\n}\n\nfunction sanitizeData(input: unknown): BrowserRuntimeSessionStoreData {\n  if (\n    input === null\n    || input === undefined\n    || typeof input !== 'object'\n    || Array.isArray(input)\n  ) {\n    return { ...EMPTY_DATA };\n  }\n\n  const root = input as Partial<BrowserRuntimeSessionStoreData>;\n  const sessions = Array.isArray(root.sessions)\n    ? root.sessions.filter((item): item is BrowserRuntimeSessionRecord => {\n      if (!item || typeof item !== 'object') return false;\n      const candidate = item as Partial<BrowserRuntimeSessionRecord>;\n      return (\n        typeof candidate.sessionId === 'string'\n        && (candidate.mode === 'isolated' || candidate.mode === 'attach')\n        && (candidate.status === 'open' || candidate.status === 'closed')\n        && (candidate.runtime === 'playwright' || candidate.runtime === 'unavailable')\n        && typeof candidate.createdAt === 'string'\n        && typeof candidate.updatedAt === 'string'\n      );\n    })\n    : [];\n\n  return {\n    schemaVersion: 1,\n    updatedAt: typeof root.updatedAt === 'string' ? root.updatedAt : new Date(0).toISOString(),\n    sessions,\n  };\n}\n\nexport function browserRuntimeSessionStorePath(cwd: string): string {\n  return join(cwd, BROWSER_RUNTIME_SESSION_STORE_RELATIVE_PATH);\n}\n\nexport class BrowserSessionStore {\n  private readonly cwd: string;\n  private readonly now: () => Date;\n\n  constructor(options: { cwd?: string; now?: () => Date } = {}) {\n    this.cwd = options.cwd ?? process.cwd();\n    this.now = options.now ?? (() => new Date());\n  }\n\n  get path(): string {\n    return browserRuntimeSessionStorePath(this.cwd);\n  }\n\n  async read(): Promise<BrowserRuntimeSessionStoreData> {\n    try {\n      const raw = await readFile(this.path, 'utf-8');\n      try {\n        const parsed = JSON.parse(raw) as unknown;\n        return sanitizeData(parsed);\n      } catch (error) {\n        if (process.env.OPTA_DEBUG) {\n          console.error(\n            `Failed to parse browser runtime session store at ${this.path}; resetting store.`,\n            error,\n          );\n        }\n        return { ...EMPTY_DATA };\n      }\n    } catch (error) {\n      const err = error as NodeJS.ErrnoException;\n      if (err.code === 'ENOENT') return { ...EMPTY_DATA };\n      throw new Error(`Failed to read browser runtime session store: ${toErrorMessage(error)}`);\n    }\n  }\n\n  async write(data: BrowserRuntimeSessionStoreData): Promise<void> {\n    const dir = dirname(this.path);\n    await mkdir(dir, { recursive: true });\n\n    const normalized = sanitizeData(data);\n    const nextData: BrowserRuntimeSessionStoreData = {\n      ...normalized,\n      updatedAt: this.now().toISOString(),\n    };\n\n    const tempPath = `${this.path}.${process.pid}.${Date.now()}.tmp`;\n    await writeFile(tempPath, JSON.stringify(nextData, null, 2) + '\\n', 'utf-8');\n    try {\n      await rename(tempPath, this.path);\n    } finally {\n      await unlink(tempPath).catch(() => {});\n    }\n  }\n\n  async list(): Promise<BrowserRuntimeSessionRecord[]> {\n    const data = await this.read();\n    return [...data.sessions];\n  }\n\n  async replaceSessions(sessions: BrowserRuntimeSessionRecord[]): Promise<void> {\n    await this.write({\n      schemaVersion: 1,\n      updatedAt: this.now().toISOString(),\n      sessions: [...sessions],\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/browser/trigger-session.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-boolean-literal-compare","severity":1,"message":"This expression unnecessarily compares a boolean value to a boolean instead of using it directly.","line":68,"column":7,"nodeType":"BinaryExpression","messageId":"direct","endLine":68,"endColumn":55,"fix":{"range":[1821,1869],"text":"!options.config.browser.runtime.enabled"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import type { OptaConfig } from '../core/config.js';\nimport { getSharedBrowserRuntimeDaemon } from './runtime-daemon.js';\nimport type { BrowserMode } from './types.js';\n\nexport interface BrowserTriggerSessionEnsureResult {\n  triggered: boolean;\n  ok: boolean;\n  sessionId?: string;\n  reused?: boolean;\n  mode?: BrowserMode;\n  message: string;\n}\n\nconst DEFAULT_TRIGGER_WORDS = ['browser'];\nconst REGEX_ESCAPE_PATTERN = /[.*+?^${}()|[\\]\\\\]/g;\n\nfunction escapeRegex(value: string): string {\n  return value.replace(REGEX_ESCAPE_PATTERN, '\\\\$&');\n}\n\nfunction normalizeTriggerWords(words: string[]): string[] {\n  const seen = new Set<string>();\n  const normalized: string[] = [];\n\n  for (const raw of words) {\n    const candidate = raw.trim().toLowerCase();\n    if (!candidate || seen.has(candidate)) continue;\n    seen.add(candidate);\n    normalized.push(candidate);\n  }\n\n  return normalized;\n}\n\nexport function hasBrowserTriggerWord(\n  prompt: string,\n  triggerWords: string[] = DEFAULT_TRIGGER_WORDS,\n): boolean {\n  const normalizedPrompt = prompt.trim();\n  if (!normalizedPrompt) return false;\n\n  for (const trigger of normalizeTriggerWords(triggerWords)) {\n    const pattern = new RegExp(`\\\\b${escapeRegex(trigger)}\\\\b`, 'i');\n    if (pattern.test(normalizedPrompt)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport async function ensureBrowserSessionForTriggeredPrompt(options: {\n  prompt: string;\n  config: OptaConfig;\n  preferredSessionId?: string;\n  triggerWords?: string[];\n}): Promise<BrowserTriggerSessionEnsureResult> {\n  const triggerWords = options.triggerWords ?? DEFAULT_TRIGGER_WORDS;\n  const triggered = hasBrowserTriggerWord(options.prompt, triggerWords);\n  if (!triggered) {\n    return {\n      triggered: false,\n      ok: true,\n      message: 'No browser trigger word matched.',\n    };\n  }\n\n  if (options.config.browser.runtime.enabled === false) {\n    return {\n      triggered: true,\n      ok: false,\n      message: 'Browser trigger detected, but browser runtime is disabled (browser.runtime.enabled=false).',\n    };\n  }\n\n  const daemon = await getSharedBrowserRuntimeDaemon({\n    cwd: process.cwd(),\n    maxSessions: options.config.browser.runtime.maxSessions,\n    persistSessions: options.config.browser.runtime.persistSessions,\n    persistProfileContinuity: options.config.browser.runtime.persistProfileContinuity,\n    profileRetentionPolicy: {\n      retentionDays: options.config.browser.runtime.profileRetentionDays,\n      maxPersistedProfiles: options.config.browser.runtime.maxPersistedProfiles,\n    },\n    profilePruneIntervalMs: options.config.browser.runtime.profilePruneIntervalHours * 60 * 60 * 1_000,\n    artifactPrune: {\n      enabled: options.config.browser.artifacts.retention.enabled,\n      policy: {\n        retentionDays: options.config.browser.artifacts.retention.retentionDays,\n        maxPersistedSessions: options.config.browser.artifacts.retention.maxPersistedSessions,\n      },\n      intervalMs: options.config.browser.artifacts.retention.pruneIntervalHours * 60 * 60 * 1_000,\n    },\n    runCorpusRefresh: {\n      enabled: options.config.browser.runtime.runCorpus.enabled,\n      windowHours: options.config.browser.runtime.runCorpus.windowHours,\n    },\n  });\n\n  await daemon.start();\n  const health = daemon.health();\n  const openSessions = health.sessions.filter(\n    (session) => session.status === 'open' && session.runtime === 'playwright',\n  );\n\n  const preferred = options.preferredSessionId?.trim();\n  const reusable = preferred\n    ? openSessions.find((session) => session.sessionId === preferred)\n    : undefined;\n  const selected = reusable ?? openSessions[0];\n\n  if (selected) {\n    return {\n      triggered: true,\n      ok: true,\n      sessionId: selected.sessionId,\n      reused: true,\n      mode: selected.mode,\n      message: `Reusing active Opta Browser session ${selected.sessionId}.`,\n    };\n  }\n\n  const openResult = await daemon.openSession({\n    mode: options.config.browser.mode,\n    headless: false,\n  });\n  if (!openResult.ok || !openResult.data) {\n    return {\n      triggered: true,\n      ok: false,\n      message: `Browser trigger detected, but Opta Browser could not start: ${openResult.error?.message ?? 'Unknown error'}`,\n    };\n  }\n\n  return {\n    triggered: true,\n    ok: true,\n    sessionId: openResult.data.id,\n    reused: false,\n    mode: openResult.data.mode,\n    message: `Started visible Opta Browser session ${openResult.data.id}.`,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/browser/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/browser/visual-diff.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/commands/account.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/commands/benchmark.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/commands/chat.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":133,"column":8,"nodeType":"ChainExpression","messageId":"neverNullish","endLine":133,"endColumn":31},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":133,"column":23,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":133,"endColumn":25,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[5012,5014],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":177,"column":8,"nodeType":"ChainExpression","messageId":"neverNullish","endLine":177,"endColumn":31},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":177,"column":23,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":177,"endColumn":25,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[6689,6691],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":185,"column":59,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":185,"endColumn":61,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[7167,7169],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":282,"column":37,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":282,"endColumn":48,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[10410,10411],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":290,"column":147,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":290,"endColumn":149,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[10893,10895],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":314,"column":30,"nodeType":"ChainExpression","messageId":"neverNullish","endLine":314,"endColumn":53},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":314,"column":45,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":314,"endColumn":47,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[11807,11809],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":317,"column":30,"nodeType":"ChainExpression","messageId":"neverNullish","endLine":317,"endColumn":53},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":317,"column":45,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":317,"endColumn":47,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[11925,11927],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":340,"column":30,"nodeType":"ChainExpression","messageId":"neverNullish","endLine":340,"endColumn":53},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":340,"column":45,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":340,"endColumn":47,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[12993,12995],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":343,"column":30,"nodeType":"ChainExpression","messageId":"neverNullish","endLine":343,"endColumn":53},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":343,"column":45,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":343,"endColumn":47,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[13111,13113],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-boolean-literal-compare","severity":1,"message":"This expression unnecessarily compares a boolean value to a boolean instead of using it directly.","line":384,"column":9,"nodeType":"BinaryExpression","messageId":"direct","endLine":384,"endColumn":35,"fix":{"range":[14672,14698],"text":"!(journal?.enabled)"}},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":384,"column":16,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":384,"endColumn":18,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[14679,14681],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":389,"column":25,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":389,"endColumn":27,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[14846,14848],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":390,"column":26,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":390,"endColumn":28,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[14889,14891],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":391,"column":22,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":391,"endColumn":24,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[14922,14924],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'payload['requestId'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":502,"column":28,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":502,"endColumn":54},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'payload['toolName'] ?? 'tool'' will use Object's default stringification format ('[object Object]') when stringified.","line":503,"column":34,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":503,"endColumn":63},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":504,"column":24,"nodeType":"TSAsExpression","messageId":"neverNullish","endLine":504,"endColumn":66},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":521,"column":41,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":521,"endColumn":56},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":523,"column":41,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":523,"endColumn":61},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, value is always truthy.","line":696,"column":10,"nodeType":"Literal","messageId":"alwaysTruthy","endLine":696,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":26,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import chalk from 'chalk';\nimport { loadConfig, saveConfig } from '../core/config.js';\nimport { agentLoop, buildSystemPrompt } from '../core/agent.js';\nimport type { AgentMessage } from '../core/agent.js';\nimport { formatError, OptaError, ExitError, EXIT } from '../core/errors.js';\nimport { buildConfigOverrides } from '../utils/config-helpers.js';\nimport { errorMessage } from '../utils/errors.js';\nimport { modelIdsEqual, normalizeConfiguredModelId } from '../lmx/model-lifecycle.js';\nimport {\n  createSession,\n  loadSession,\n  saveSession,\n  generateTitle,\n  searchSessions,\n} from '../memory/store.js';\nimport { writeSessionLog } from '../journal/session-log.js';\nimport { resolveFileRefs, buildContextWithRefs, resolveImageRefs } from '../core/fileref.js';\nimport { box, kv, statusDot } from '../ui/box.js';\nimport { InputEditor, startConnectionMonitor } from '../ui/input.js';\nimport { InputHistory } from '../ui/history.js';\nimport { runConnectionDiagnostics, formatDiagnostics } from '../core/diagnostics.js';\nimport { dispatchSlashCommand } from './slash/index.js';\nimport type { Session } from '../memory/store.js';\nimport { runMenuPrompt } from '../ui/prompt-nav.js';\nimport type { TuiMessage } from '../tui/App.js';\nimport type { TuiErrorEvent, TuiErrorPayload } from '../tui/adapter.js';\n\ninterface ChatOptions {\n  resume?: string;\n  plan?: boolean;\n  review?: boolean;\n  research?: boolean;\n  model?: string;\n  initialPrompt?: string;\n  commit?: boolean;\n  checkpoints?: boolean;\n  format?: string;\n  auto?: boolean;\n  dangerous?: boolean;\n  yolo?: boolean;\n  tui?: boolean;\n}\n\nexport type OptaMode = 'normal' | 'plan' | 'review' | 'research' | 'auto-accept';\n\n/**\n * Format the last assistant message as a JSON line (JSONL) for --format json.\n * Extracts the most recent assistant message from the conversation history.\n */\nexport function formatChatJsonLine(messages: AgentMessage[]): string {\n  const assistantMsgs = messages.filter((m: AgentMessage) => m.role === 'assistant');\n  const lastMsg = assistantMsgs[assistantMsgs.length - 1];\n  return JSON.stringify({\n    role: 'assistant',\n    content: lastMsg?.content ?? '',\n    tool_calls: lastMsg?.tool_calls ?? [],\n  });\n}\n\nexport interface ChatState {\n  currentMode: OptaMode;\n  agentProfile: string;\n  lastThinkingRenderer?: import('../ui/thinking.js').ThinkingRenderer;\n  thinkingExpanded?: boolean;\n}\n\n/**\n * Truncate long stderr output to keep shell error display manageable.\n * Shows first 20 lines + last 10 lines with an omission notice in between.\n */\nfunction truncateStderr(stderr: string): string {\n  const lines = stderr.split('\\n');\n  if (lines.length <= 50) return stderr;\n  const head = lines.slice(0, 20);\n  const tail = lines.slice(-10);\n  const omitted = lines.length - 30;\n  return [...head, chalk.dim(`  ... (${omitted} lines omitted)`), ...tail].join('\\n');\n}\n\ninterface ModelPreflightStatus {\n  modelLoaded: boolean;\n  loadedModelIds: string[];\n  error?: string;\n}\n\nfunction pickModelFlavor(model: string): string {\n  const lower = model.toLowerCase();\n  if (lower.includes('qwen')) return 'I can move fast on coding and shell workflows.';\n  if (lower.includes('minimax')) return 'I can balance long-context reasoning with practical execution.';\n  if (lower.includes('kimi')) return 'I can handle broad context windows and deep planning.';\n  if (lower.includes('glm')) return 'I can keep responses concise while staying technically grounded.';\n  if (lower.includes('claude')) return 'I can help with structured reasoning and high-quality edits.';\n  return 'I can help with focused coding and terminal tasks.';\n}\n\nfunction buildStartupIntro(model: string, resumed: boolean, messageCount: number): string {\n  const contextLine = resumed\n    ? `Session resumed with ${messageCount} prior messages.`\n    : 'New session initialized.';\n  return [\n    `Connected to ${model} and ready.`,\n    pickModelFlavor(model),\n    contextLine,\n    'What do you want to do next?',\n    '- Debug a specific issue',\n    '- Load/switch models from Opta Menu',\n    '- Start a focused build task',\n  ].join('\\n');\n}\n\nfunction toTuiTurnError(payload: unknown): TuiErrorEvent {\n  if (typeof payload === 'string' && payload.length > 0) {\n    return payload;\n  }\n\n  const record = payload && typeof payload === 'object'\n    ? payload as Record<string, unknown>\n    : undefined;\n  const message = typeof record?.['message'] === 'string' && record['message'].length > 0\n    ? record['message']\n    : 'Turn failed';\n  const code = typeof record?.['code'] === 'string' && record['code'].length > 0\n    ? record['code']\n    : undefined;\n\n  const structured: TuiErrorPayload = code ? { message, code } : { message };\n  return structured;\n}\n\nasync function probeModelPreflight(config: Awaited<ReturnType<typeof loadConfig>>, modelId: string): Promise<ModelPreflightStatus> {\n  // When running on Anthropic (zero-config fallback or explicit config), the\n  // model is always \"loaded\" from the CLI's perspective  no LMX probe needed.\n  if ((config.provider?.active ?? 'lmx') === 'anthropic') {\n    return { modelLoaded: true, loadedModelIds: [modelId] };\n  }\n\n  try {\n    const { LmxClient } = await import('../lmx/client.js');\n    const lmx = new LmxClient({\n      host: config.connection.host,\n      fallbackHosts: config.connection.fallbackHosts,\n      port: config.connection.port,\n      adminKey: config.connection.adminKey,\n      timeoutMs: 8_000,\n      maxRetries: 0,\n    });\n    const loaded = await lmx.models();\n    const loadedModelIds = loaded.models.map((item) => item.model_id);\n    const modelLoaded = loadedModelIds.some((candidate) => modelIdsEqual(candidate, modelId));\n    return { modelLoaded, loadedModelIds };\n  } catch (err) {\n    return { modelLoaded: false, loadedModelIds: [], error: errorMessage(err) };\n  }\n}\n\nexport async function startChat(opts: ChatOptions): Promise<void> {\n  const overrides = buildConfigOverrides(opts);\n\n  const jsonMode = opts.format === 'json';\n  let config = await loadConfig(overrides);\n\n  // First-run onboarding\n  if (!jsonMode) {\n    const { isFirstRun, runOnboarding } = await import('./onboard.js');\n    if (await isFirstRun()) {\n      await runOnboarding();\n      // Reload config in case onboarding changed connection settings\n      config = await loadConfig(overrides);\n    }\n  }\n\n  // Zero-config fallback: probe LMX before the first turn.\n  // If LMX is unreachable and ANTHROPIC_API_KEY is set, silently switch to\n  // Anthropic so fresh installs with only an API key work out of the box.\n  // Only probe when provider is 'lmx' (default)  skip if user explicitly\n  // configured Anthropic or if we're in JSON (pipe) mode where silence matters.\n  if ((config.provider?.active ?? 'lmx') === 'lmx') {\n    try {\n      const { probeProvider } = await import('../providers/manager.js');\n      const probed = await probeProvider(config);\n      if (probed.name === 'anthropic') {\n        // LMX unreachable  route the whole session through Anthropic.\n        // Always derive the model from provider.anthropic.model (or the\n        // well-known default) so we don't keep an LMX model string.\n        const anthropicDefault = config.provider.anthropic?.model || 'claude-sonnet-4-5-20250929';\n        config = {\n          ...config,\n          provider: {\n            ...config.provider,\n            active: 'anthropic',\n          },\n          model: {\n            ...config.model,\n            default: anthropicDefault,\n            contextLimit: 200_000,\n          },\n        };\n      }\n    } catch (err) {\n      // probeProvider threw  means both LMX unreachable AND no ANTHROPIC_API_KEY.\n      // Surface the clear error and exit.\n      console.error(chalk.red('') + ' ' + errorMessage(err));\n      process.exit(1);\n    }\n  }\n\n  let effectiveModel = normalizeConfiguredModelId(config.model.default);\n  if (effectiveModel !== config.model.default) {\n    await saveConfig({\n      'model.default': effectiveModel,\n      'model.contextLimit': effectiveModel ? config.model.contextLimit : 32768,\n    }).catch(() => {});\n    config = {\n      ...config,\n      model: {\n        ...config.model,\n        default: effectiveModel,\n        contextLimit: effectiveModel ? config.model.contextLimit : 32768,\n      },\n    };\n  }\n\n  if (!effectiveModel) {\n    try {\n      const { LmxClient, lookupContextLimit } = await import('../lmx/client.js');\n      const lmx = new LmxClient({\n        host: config.connection.host,\n        fallbackHosts: config.connection.fallbackHosts,\n        port: config.connection.port,\n        adminKey: config.connection.adminKey,\n        timeoutMs: 5_000,\n        maxRetries: 0,\n      });\n      const loaded = await lmx.models();\n      const fallback = loaded.models[0]?.model_id;\n      if (fallback) {\n        effectiveModel = fallback;\n        await saveConfig({\n          'model.default': fallback,\n          'model.contextLimit': lookupContextLimit(fallback),\n        }).catch(() => {});\n        config = {\n          ...config,\n          model: {\n            ...config.model,\n            default: fallback,\n            contextLimit: lookupContextLimit(fallback),\n          },\n        };\n        if (!jsonMode) {\n          console.log(chalk.yellow('!') + ` No default model set; using loaded model ${fallback}`);\n        }\n      }\n    } catch {\n      // Ignore model discovery failures; we'll show actionable guidance below.\n    }\n  }\n\n  if (!effectiveModel) {\n    console.error(chalk.red('') + ' No model configured');\n    console.error('');\n    console.error(chalk.dim('  Fix options:'));\n    console.error(chalk.dim('    1. Set a default model:  ') + chalk.cyan('opta config set model.default <model-name>'));\n    console.error(chalk.dim('    2. Discover models:      ') + chalk.cyan('opta models'));\n    console.error(chalk.dim('    3. Check LMX status:     ') + chalk.cyan('opta status'));\n    console.error(chalk.dim('    4. Run diagnostics:      ') + chalk.cyan('opta doctor'));\n    console.error('');\n    throw new ExitError(EXIT.NO_CONNECTION);\n  }\n\n  // Create or resume session\n  let session: Session;\n  let startupModelLoaded = false;\n  let startupPreflightError: string | undefined;\n  if (opts.resume) {\n    try {\n      session = await loadSession(opts.resume);\n    } catch {\n      // Exact ID not found  try fuzzy search\n      const matches = await searchSessions(opts.resume);\n      if (matches.length === 1) {\n        session = await loadSession(matches[0]!.id);\n      } else if (matches.length > 1) {\n        try {\n          const { select } = await import('@inquirer/prompts');\n          const choice = await runMenuPrompt((context) =>\n            select({\n              message: chalk.dim(`Multiple sessions match \"${opts.resume}\"`),\n              choices: matches.slice(0, 10).map(m => ({\n                name: `${m.title || m.id.slice(0, 8)}  ${chalk.dim(m.model || '')}  ${chalk.dim(new Date(m.created).toLocaleDateString())}${m.tags?.length ? '  ' + chalk.cyan(m.tags.join(', ')) : ''}`,\n                value: m.id,\n              })),\n            }, context), 'select');\n          if (!choice) return;\n          session = await loadSession(choice);\n        } catch {\n          // Ctrl+C  exit gracefully\n          return;\n        }\n      } else {\n        console.error(\n          chalk.red('') + ` Session not found: ${opts.resume}\\n\\n` +\n          chalk.dim('Run ') + chalk.cyan('opta sessions') + chalk.dim(' to list available sessions')\n        );\n        throw new ExitError(EXIT.NOT_FOUND);\n      }\n    }\n    const startupPreflight = await probeModelPreflight(config, session.model);\n    startupModelLoaded = startupPreflight.modelLoaded;\n    startupPreflightError = startupPreflight.error;\n\n    if (!jsonMode) {\n      const msgCount = session.messages.filter(m => m.role !== 'system').length;\n      const providerLabel = (config.provider?.active ?? 'lmx') === 'anthropic'\n        ? 'Anthropic'\n        : 'LMX';\n      const providerValue = (config.provider?.active ?? 'lmx') === 'anthropic'\n        ? `api.anthropic.com ${statusDot(startupModelLoaded)}`\n        : `${config.connection.host}:${config.connection.port} ${statusDot(startupModelLoaded)}`;\n      console.log('\\n' + box('Opta', [\n        kv(providerLabel, providerValue),\n        kv('Model', session.model),\n        kv('Session', `${session.id.slice(0, 8)} ${chalk.dim('(resumed)')}`),\n        ...(session.title ? [kv('Title', chalk.italic(session.title.slice(0, 40)))] : []),\n        kv('Messages', String(msgCount)),\n      ]));\n    }\n  } else {\n    session = await createSession(config.model.default);\n    // Initialize system prompt for new session\n    const systemPrompt = await buildSystemPrompt(config);\n    session.messages = [{ role: 'system', content: systemPrompt }];\n    await saveSession(session);\n\n    const startupPreflight = await probeModelPreflight(config, session.model);\n    startupModelLoaded = startupPreflight.modelLoaded;\n    startupPreflightError = startupPreflight.error;\n\n    if (!jsonMode) {\n      const providerLabel = (config.provider?.active ?? 'lmx') === 'anthropic'\n        ? 'Anthropic'\n        : 'LMX';\n      const providerValue = (config.provider?.active ?? 'lmx') === 'anthropic'\n        ? `api.anthropic.com ${statusDot(startupModelLoaded)}`\n        : `${config.connection.host}:${config.connection.port} ${statusDot(startupModelLoaded)}`;\n      console.log('\\n' + box('Opta', [\n        kv(providerLabel, providerValue),\n        kv('Model', session.model),\n        kv('Session', `${session.id.slice(0, 8)} ${chalk.dim('(new)')}`),\n      ]));\n    }\n  }\n\n  if (!jsonMode) {\n    console.log(chalk.dim('  Type /help for commands, / to browse, /exit to quit\\n'));\n  }\n\n  // Non-blocking startup connection check (fire-and-forget)\n  if (!jsonMode) {\n    const { host, port } = config.connection;\n    runConnectionDiagnostics(host, port).then(results => {\n      const hasError = results.some(r => r.status === 'error');\n      const hasWarning = results.some(r => r.status === 'warning');\n      if (hasError || hasWarning) {\n        console.log(formatDiagnostics(results));\n        console.log('');\n      }\n    }).catch(() => {\n      // Silently ignore diagnostic failures  don't disrupt the REPL\n    });\n  }\n\n  // Mode state (shared by both TUI and REPL modes)\n  const chatState: ChatState = {\n    currentMode: opts.plan ? 'plan' : opts.review ? 'review' : opts.research ? 'research' : (opts.auto ? 'auto-accept' : 'normal'),\n    agentProfile: 'default',\n  };\n  if (opts.dangerous || opts.yolo) chatState.currentMode = 'normal'; // dangerous handled by config mode\n\n  async function saveSessionWithJournal(): Promise<string | null> {\n    await saveSession(session);\n\n    const journal = config.journal;\n    if (journal?.enabled === false) return null;\n\n    try {\n      const written = await writeSessionLog(session, {\n        cwd: session.cwd || process.cwd(),\n        logsDir: journal?.sessionLogsDir,\n        timezone: journal?.timezone,\n        user: journal?.author,\n      });\n      return written.path;\n    } catch {\n      return null;\n    }\n  }\n\n  // TUI mode: full-screen Ink rendering (--tui flag or tui.default config)\n  if (opts.tui || config.tui.default) {\n    const { renderTUI } = await import('../tui/render.js');\n    const { createTuiEmitter } = await import('../tui/adapter.js');\n    const { captureConsoleOutput } = await import('../tui/capture.js');\n    const { DaemonClient } = await import('../daemon/client.js');\n    const { nanoid } = await import('nanoid');\n\n    const emitter = createTuiEmitter();\n    const daemon = await DaemonClient.connect();\n    const clientId = `tui-${process.pid}-${nanoid(6)}`;\n    const writerId = `writer-${nanoid(6)}`;\n    const nonSystemMessageCount = session.messages.filter((m) => m.role !== 'system').length;\n    const startupMessages: TuiMessage[] = startupModelLoaded\n      ? [{\n          role: 'assistant',\n          content: buildStartupIntro(session.model, Boolean(opts.resume), nonSystemMessageCount),\n          createdAt: Date.now(),\n        }]\n      : [{\n          role: 'error',\n          content: startupPreflightError\n            ? `No Model Loaded - Use Opta Menu to begin.\\nLMX preflight failed: ${startupPreflightError}`\n            : 'No Model Loaded - Use Opta Menu to begin.',\n          createdAt: Date.now(),\n        }];\n    await daemon.createSession({\n      sessionId: session.id,\n      model: session.model,\n      title: session.title,\n      messages: session.messages,\n    });\n\n    // Track the current workflow mode set by the TUI (Shift+Tab).\n    // Updated via onModeChange callback and used on next agent call.\n    let currentTuiMode = 'normal';\n    let turnInFlight = false;\n    let activeTurnId: string | undefined;\n    let lastSeq = 0;\n    let closed = false;\n    let closeSocket = () => {};\n    let reconnectDelayMs = 500;\n    const MAX_RECONNECT_DELAY_MS = 5000;\n\n    const reconnect = () => {\n      emitter.emit('connection:status', 'reconnecting');\n      if (closed) return;\n      const conn = daemon.connectWebSocket(session.id, lastSeq, {\n        onOpen: () => {\n          reconnectDelayMs = 500;\n          emitter.emit('connection:status', 'connected');\n        },\n        onClose: () => {\n          if (closed) return;\n          emitter.emit('connection:status', 'disconnected');\n          const delay = reconnectDelayMs;\n          reconnectDelayMs = Math.min(Math.floor(reconnectDelayMs * 1.6), MAX_RECONNECT_DELAY_MS);\n          setTimeout(reconnect, delay);\n        },\n        onError: (err) => {\n          emitter.emit('error', `Daemon stream error: ${errorMessage(err)}`);\n        },\n        onEvent: (event) => {\n          lastSeq = Math.max(lastSeq, event.seq);\n          const payload = event.payload as Record<string, unknown>;\n          switch (event.event) {\n            case 'turn.queued': {\n              const turnId = typeof payload['turnId'] === 'string' ? payload['turnId'] : undefined;\n              if (turnId) activeTurnId = turnId;\n              break;\n            }\n            case 'turn.start':\n              activeTurnId = typeof payload['turnId'] === 'string' ? payload['turnId'] : activeTurnId;\n              emitter.emit('turn:start');\n              break;\n            case 'turn.token':\n              if (typeof payload['text'] === 'string') {\n                emitter.emit('token', payload['text']);\n              }\n              break;\n            case 'turn.thinking':\n              if (typeof payload['text'] === 'string') {\n                emitter.emit('thinking', payload['text']);\n              }\n              break;\n            case 'tool.start':\n              emitter.emit(\n                'tool:start',\n                typeof payload['name'] === 'string' ? payload['name'] : 'tool',\n                typeof payload['id'] === 'string' ? payload['id'] : 'tool',\n                typeof payload['args'] === 'string' ? payload['args'] : '{}'\n              );\n              break;\n            case 'tool.end':\n              emitter.emit(\n                'tool:end',\n                typeof payload['name'] === 'string' ? payload['name'] : 'tool',\n                typeof payload['id'] === 'string' ? payload['id'] : 'tool',\n                typeof payload['result'] === 'string' ? payload['result'] : ''\n              );\n              break;\n            case 'permission.request':\n              emitter.emit('permission:request', {\n                id: String(payload['requestId'] ?? ''),\n                toolName: String(payload['toolName'] ?? 'tool'),\n                args: (payload['args'] as Record<string, unknown>) ?? {},\n              });\n              break;\n            case 'turn.done': {\n              turnInFlight = false;\n              activeTurnId = undefined;\n              const stats = payload['stats'] as Record<string, unknown> | undefined;\n              emitter.emit('turn:end', {\n                tokens: Number(stats?.['tokens'] ?? 0),\n                promptTokens: Number(stats?.['promptTokens'] ?? 0),\n                completionTokens: Number(stats?.['completionTokens'] ?? 0),\n                toolCalls: Number(stats?.['toolCalls'] ?? 0),\n                elapsed: Number(stats?.['elapsed'] ?? 0),\n                speed: Number(stats?.['speed'] ?? 0),\n                firstTokenLatencyMs: stats?.['firstTokenLatencyMs'] == null ? null : Number(stats['firstTokenLatencyMs']),\n              });\n              void daemon.getSession(session.id).then((remote) => {\n                const remoteMessages = (remote.messages ?? []) as AgentMessage[];\n                session.messages = remoteMessages;\n                session.toolCallCount = remote.toolCallCount ?? session.toolCallCount;\n                return saveSession(session);\n              }).catch(() => {});\n              break;\n            }\n            case 'turn.error':\n              turnInFlight = false;\n              activeTurnId = undefined;\n              emitter.emit('error', toTuiTurnError(payload));\n              break;\n            case 'session.cancelled':\n              turnInFlight = false;\n              activeTurnId = undefined;\n              emitter.emit('error', ' Turn cancelled');\n              break;\n            default:\n              break;\n          }\n        },\n      });\n      closeSocket = conn.close;\n    };\n\n    reconnect();\n\n    const onPermissionResponse = (id: string, decision: import('../tui/PermissionPrompt.js').PermissionDecision) => {\n      const mapped = decision === 'deny' ? 'deny' : 'allow';\n      void daemon.resolvePermission(session.id, {\n        requestId: id,\n        decision: mapped,\n        decidedBy: clientId,\n      }).catch((err: unknown) => {\n        emitter.emit('error', `Permission resolution failed: ${errorMessage(err)}`);\n      });\n    };\n    emitter.on('permission:response', onPermissionResponse);\n\n    await renderTUI({\n      model: session.model,\n      sessionId: session.id,\n      emitter,\n      initialMessages: startupMessages,\n      requireLoadedModel: true,\n      initialModelLoaded: startupModelLoaded,\n      title: session.title,\n      onModeChange: (mode) => { currentTuiMode = mode; },\n      onCancelTurn: () => {\n        if (!turnInFlight) return;\n        void daemon.cancel(session.id, { turnId: activeTurnId, writerId }).then((res) => {\n          if (res.cancelled > 0) {\n            emitter.emit('error', ' Turn cancelled');\n          }\n        }).catch((err: unknown) => {\n          emitter.emit('error', `Cancel failed: ${errorMessage(err)}`);\n        });\n      },\n      onSubmit: (text: string) => {\n        if (turnInFlight) {\n          emitter.emit('error', 'A turn is already running. Wait for it to finish before sending another message.');\n          return;\n        }\n        // Fire-and-forget: the emitter events drive the TUI updates\n        (async () => {\n          turnInFlight = true;\n          // Resolve @file and @image references before sending to agent\n          const { refs } = await resolveFileRefs(text);\n          const { cleanMessage, images } = await resolveImageRefs(text);\n          const enrichedInput = buildContextWithRefs(images.length > 0 ? cleanMessage : text, refs);\n\n          // Generate session title from first user message\n          if (!session.title) {\n            session.title = generateTitle(text);\n            emitter.emit('title', session.title);\n          }\n\n          const queued = await daemon.submitTurn(session.id, {\n            clientId,\n            writerId,\n            content: enrichedInput,\n            mode: 'chat',\n            metadata: {\n              workflowMode: currentTuiMode,\n              imageCount: images.length,\n            },\n          });\n          activeTurnId = queued.turnId;\n        })().catch(() => {\n          turnInFlight = false;\n          emitter.emit('error', 'Failed to submit turn to daemon');\n        }).finally(() => {\n          // Reset happens on turn.done / turn.error to preserve in-flight guard.\n        });\n      },\n      onSlashCommand: async (input: string) => {\n        // Bare `/` opens interactive browser in REPL mode, but in TUI mode\n        // redirect to /help since @inquirer/prompts doesn't work here.\n        const effectiveInput = input.trim() === '/' ? '/help' : input;\n\n        const { result, output } = await captureConsoleOutput(async () => {\n          return dispatchSlashCommand(effectiveInput, { session, config, chatState });\n        });\n\n        // Persist session after slash command (some modify session state)\n        await saveSession(session);\n\n        // If model was switched, reload config\n        let newModel: string | undefined;\n        if (result === 'model-switched') {\n          config = await loadConfig(overrides);\n          newModel = config.model.default;\n        }\n\n        return { result, output, newModel };\n      },\n    });\n    closed = true;\n    emitter.off('permission:response', onPermissionResponse);\n    closeSocket();\n\n    const logPath = await saveSessionWithJournal();\n    if (!jsonMode) {\n      const msgCount = session.messages.filter(m => m.role !== 'system').length;\n      console.log(\n        '\\n' + chalk.green('') + chalk.dim(` Session saved: ${session.id.slice(0, 8)}  ${msgCount} msgs`)\n      );\n      if (logPath) {\n        console.log(chalk.dim(`  Session log: ${logPath}`));\n      }\n    }\n    return;\n  }\n\n  /** Map OptaMode to InputEditor mode string. */\n  function toEditorMode(mode: OptaMode): 'normal' | 'plan' | 'auto' {\n    if (mode === 'plan' || mode === 'review' || mode === 'research') return 'plan';\n    if (mode === 'auto-accept') return 'auto';\n    return 'normal';\n  }\n\n  // InputEditor for buffer management and mode detection\n  const editor = new InputEditor({\n    prompt: '>',\n    mode: toEditorMode(chatState.currentMode),\n  });\n\n  // Input history with deduplication\n  const history = new InputHistory();\n\n  function getPromptMessage(): string {\n    // Sync editor mode with chat state\n    editor.setMode(toEditorMode(chatState.currentMode));\n    return editor.getPromptDisplay();\n  }\n\n  // Start periodic connection monitor for REPL prompt indicator (text REPL only)\n  const stopConnectionMonitor = jsonMode\n    ? () => {}\n    : startConnectionMonitor(\n        config.connection.host,\n        config.connection.port,\n        config.connection.fallbackHosts,\n        config.connection.adminKey,\n      );\n\n  // Initialize slash command TAB completion cache (non-blocking)\n  import('../ui/autocomplete.js').then(({ initSlashCompletionCache }) => {\n    initSlashCompletionCache().catch(() => {});\n  }).catch(() => {});\n\n  // REPL loop\n  const { input } = await import('@inquirer/prompts');\n  let queuedInput = opts.initialPrompt?.trim() ?? '';\n\n  while (true) {\n    let userInput: string;\n    if (queuedInput) {\n      userInput = queuedInput;\n      queuedInput = '';\n      if (!jsonMode) {\n        console.log(chalk.dim(`${getPromptMessage()} ${userInput}`));\n      }\n    } else {\n      try {\n        userInput = await input({ message: getPromptMessage() });\n      } catch {\n        // Ctrl+C or EOF\n        stopConnectionMonitor();\n        const logPath = await saveSessionWithJournal();\n        if (!jsonMode) {\n          const msgCount = session.messages.filter(m => m.role !== 'system').length;\n          console.log(\n            '\\n' + chalk.green('') + chalk.dim(` Session saved: ${session.id.slice(0, 8)}  ${msgCount} msgs`)\n          );\n          if (logPath) {\n            console.log(chalk.dim(`  Session log: ${logPath}`));\n          }\n        }\n        break;\n      }\n    }\n\n    if (!userInput.trim()) continue;\n\n    // Track input in history\n    history.push(userInput);\n\n    // Slash commands\n    if (userInput.startsWith('/')) {\n      const handled = await dispatchSlashCommand(userInput, { session, config, chatState });\n      if (handled === 'exit') {\n        stopConnectionMonitor();\n        const logPath = await saveSessionWithJournal();\n        if (!jsonMode) {\n          const msgCount = session.messages.filter(m => m.role !== 'system').length;\n          console.log(\n            chalk.green('') + chalk.dim(` Session saved: ${session.id.slice(0, 8)}`) +\n            (session.title ? chalk.dim(` \"${session.title}\"`) : '') +\n            chalk.dim(`  ${msgCount} msgs`)\n          );\n          if (logPath) {\n            console.log(chalk.dim(`  Session log: ${logPath}`));\n          }\n        }\n        break;\n      }\n      if (handled === 'model-switched') {\n        // Reload config to pick up model change\n        config = await loadConfig(overrides);\n      }\n      continue;\n    }\n\n    // Shell mode: !command executes directly\n    if (userInput.startsWith('!')) {\n      const cmd = userInput.slice(1).trim();\n      if (!cmd) continue;\n      console.log(chalk.dim(`  $ ${cmd}`));\n      try {\n        const { execSync } = await import('node:child_process');\n        const output = execSync(cmd, { encoding: 'utf-8', cwd: process.cwd(), timeout: 30000 });\n        if (output.trim()) console.log(output);\n        console.log(chalk.green('') + chalk.dim(' exit 0'));\n      } catch (err: unknown) {\n        const e = err as { status?: number; stderr?: string; stdout?: string };\n        if (e.stdout) console.log(e.stdout);\n        if (e.stderr) {\n          let stderr = e.stderr;\n          // Strip ANSI codes if output is not a TTY\n          if (!process.stdout.isTTY) {\n            stderr = stderr.replace(/\\x1B\\[[0-9;]*[a-zA-Z]/g, '');\n          }\n          console.error(chalk.red(truncateStderr(stderr)));\n        }\n        console.log(chalk.red('') + chalk.dim(` exit ${e.status ?? 1}`));\n      }\n      continue;\n    }\n\n    // Show @ file autocomplete hints (lightweight  full interactive autocomplete in Phase 2)\n    if (userInput.includes('@') && !userInput.startsWith('/')) {\n      const { getProjectFiles, getCompletions } = await import('../ui/autocomplete.js');\n      const atMatch = userInput.match(/@(\\S*)$/);\n      if (atMatch?.[1]) {\n        const files = await getProjectFiles(process.cwd());\n        const matches = getCompletions(atMatch[1], files, 5);\n        if (matches.length > 0 && matches[0] !== atMatch[1]) {\n          console.log(chalk.dim('  Matches: ') + matches.map(f => chalk.cyan(`@${f}`)).join(chalk.dim(', ')));\n        }\n      }\n    }\n\n    // Resolve @file and @image references\n    const { refs } = await resolveFileRefs(userInput);\n    const { cleanMessage, images } = await resolveImageRefs(userInput);\n    const enrichedInput = buildContextWithRefs(images.length > 0 ? cleanMessage : userInput, refs);\n\n    // Set title from first user message\n    if (!session.title) {\n      session.title = generateTitle(userInput);\n    }\n\n    try {\n      const result = await agentLoop(enrichedInput, config, {\n        existingMessages: session.messages,\n        sessionId: session.id,\n        silent: jsonMode,\n        mode: chatState.currentMode !== 'normal' && chatState.currentMode !== 'auto-accept' ? chatState.currentMode : undefined,\n        profile: chatState.agentProfile !== 'default' ? chatState.agentProfile : undefined,\n        images: images.length > 0 ? images.map(img => ({ base64: img.base64, mimeType: img.mimeType, name: img.name })) : undefined,\n      });\n\n      session.messages = result.messages;\n      session.toolCallCount += result.toolCallCount;\n      // Track thinking renderer for /expand toggle\n      if (result.lastThinkingRenderer) {\n        chatState.lastThinkingRenderer = result.lastThinkingRenderer;\n        chatState.thinkingExpanded = false;\n      }\n      await saveSession(session);\n\n      if (jsonMode) {\n        console.log(formatChatJsonLine(result.messages));\n      }\n    } catch (err) {\n      if (err instanceof OptaError) {\n        console.error(formatError(err));\n      } else {\n        console.error(chalk.red('') + ` ${errorMessage(err)}`);\n      }\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/commands/completions.ts","messages":[{"ruleId":"@typescript-eslint/require-await","severity":1,"message":"Async function 'completions' has no 'await' expression.","line":4,"column":8,"nodeType":"FunctionDeclaration","messageId":"missingAwait","endLine":4,"endColumn":34,"suggestions":[{"messageId":"removeAsync","fix":{"range":[88,144],"text":"function completions(shell: string): void"},"desc":"Remove 'async'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import chalk from 'chalk';\nimport { EXIT, ExitError } from '../core/errors.js';\n\nexport async function completions(shell: string): Promise<void> {\n  switch (shell.toLowerCase()) {\n    case 'bash':\n      console.log(bashCompletions());\n      break;\n    case 'zsh':\n      console.log(zshCompletions());\n      break;\n    case 'fish':\n      console.log(fishCompletions());\n      break;\n    default:\n      console.error(chalk.red('\\u2717') + ` Unsupported shell: ${shell}\\n`);\n      console.log(chalk.dim('Supported: bash, zsh, fish'));\n      throw new ExitError(EXIT.MISUSE);\n  }\n}\n\nfunction bashCompletions(): string {\n  return `# opta bash completions\n# Add to ~/.bashrc: eval \"$(opta completions bash)\"\n\n_opta_completions() {\n  local cur prev commands\n  COMPREPLY=()\n  cur=\"\\${COMP_WORDS[COMP_CWORD]}\"\n  prev=\"\\${COMP_WORDS[COMP_CWORD-1]}\"\n  commands=\"chat tui do benchmark init doctor status models env config sessions mcp diff server daemon serve update completions\"\n\n  case \"\\${prev}\" in\n    opta)\n      COMPREPLY=( $(compgen -W \"\\${commands} --verbose --debug --version --help\" -- \"\\${cur}\") )\n      return 0\n      ;;\n    chat)\n      COMPREPLY=( $(compgen -W \"--resume --plan --review --research --model --format --no-commit --no-checkpoints --auto --dangerous --yolo --tui --help\" -- \"\\${cur}\") )\n      return 0\n      ;;\n    tui)\n      COMPREPLY=( $(compgen -W \"--resume --plan --review --research --model --format --no-commit --no-checkpoints --auto --dangerous --yolo --tui --help\" -- \"\\${cur}\") )\n      return 0\n      ;;\n    do)\n      COMPREPLY=( $(compgen -W \"--model --format --quiet --output --no-commit --no-checkpoints --auto --dangerous --yolo --help\" -- \"\\${cur}\") )\n      return 0\n      ;;\n    benchmark)\n      COMPREPLY=( $(compgen -W \"--output --query --words --max-results --provider-order --serve --host --port --force --json --help\" -- \"\\${cur}\") )\n      return 0\n      ;;\n    status)\n      COMPREPLY=( $(compgen -W \"--json --help\" -- \"\\${cur}\") )\n      return 0\n      ;;\n    models)\n      COMPREPLY=( $(compgen -W \"list manage dashboard scan use info load unload swap stop alias aliases unalias download delete benchmark predictor helpers quantize agents skills rag health browse-local browse-library --json --help\" -- \"\\${cur}\") )\n      return 0\n      ;;\n    env)\n      COMPREPLY=( $(compgen -W \"list show save use delete --host --port --admin-key --model --provider --mode --json --help\" -- \"\\${cur}\") )\n      return 0\n      ;;\n    config)\n      COMPREPLY=( $(compgen -W \"list get set reset menu --json --help\" -- \"\\${cur}\") )\n      return 0\n      ;;\n    sessions)\n      COMPREPLY=( $(compgen -W \"list resume delete export search --json --help\" -- \"\\${cur}\") )\n      return 0\n      ;;\n    mcp)\n      COMPREPLY=( $(compgen -W \"add add-playwright remove test list --help\" -- \"\\${cur}\") )\n      return 0\n      ;;\n    init)\n      COMPREPLY=( $(compgen -W \"--yes --force --help\" -- \"\\${cur}\") )\n      return 0\n      ;;\n    doctor)\n      COMPREPLY=( $(compgen -W \"--json --format --help\" -- \"\\${cur}\") )\n      return 0\n      ;;\n    diff)\n      COMPREPLY=( $(compgen -W \"--session --help\" -- \"\\${cur}\") )\n      return 0\n      ;;\n    server)\n      COMPREPLY=( $(compgen -W \"--port --host --model --help\" -- \"\\${cur}\") )\n      return 0\n      ;;\n    daemon)\n      COMPREPLY=( $(compgen -W \"start run stop status logs --host --port --token --model --json --help\" -- \"\\${cur}\") )\n      return 0\n      ;;\n    serve)\n      COMPREPLY=( $(compgen -W \"start stop restart logs --json --help\" -- \"\\${cur}\") )\n      return 0\n      ;;\n    update)\n      COMPREPLY=( $(compgen -W \"--components --target --remote-host --remote-user --identity-file --local-root --remote-root --dry-run --no-build --no-pull --json --help\" -- \"\\${cur}\") )\n      return 0\n      ;;\n    completions)\n      COMPREPLY=( $(compgen -W \"bash zsh fish\" -- \"\\${cur}\") )\n      return 0\n      ;;\n  esac\n\n  return 0\n}\ncomplete -F _opta_completions opta`;\n}\n\nfunction zshCompletions(): string {\n  return `#compdef opta\n# opta zsh completions\n# Add to ~/.zshrc: eval \"$(opta completions zsh)\"\n\n_opta() {\n  local -a commands\n  commands=(\n    'chat:Start an interactive AI chat session'\n    'tui:Start full-screen terminal UI (alias for opta chat --tui)'\n    'do:Execute a coding task using the agent loop'\n    'benchmark:Generate benchmark suite apps (landing, chess, AI news)'\n    'init:Initialize OPIS project intelligence docs'\n    'doctor:Check environment health and diagnose issues'\n    'status:Check Opta LMX server health and loaded models'\n    'models:List and manage loaded models'\n    'env:Manage named environment profiles'\n    'config:Manage configuration'\n    'sessions:Manage chat sessions'\n    'mcp:Model Context Protocol tools'\n    'diff:Show changes made in a session'\n    'server:Start an HTTP API server for non-interactive use'\n    'daemon:Manage Opta Level 3 daemon runtime'\n    'serve:Manage the remote Opta LMX inference server'\n    'update:Update Opta components on local/remote targets'\n    'completions:Generate shell completions'\n  )\n\n  _arguments -C \\\\\n    '--verbose[detailed output]' \\\\\n    '--debug[debug info including API calls]' \\\\\n    '--version[show version]' \\\\\n    '--help[show help]' \\\\\n    '1:command:->command' \\\\\n    '*::arg:->args'\n\n  case \"\\$state\" in\n    command)\n      _describe 'command' commands\n      ;;\n    args)\n      case \"\\${words[1]}\" in\n        chat)\n          _arguments \\\\\n            '--resume[resume a previous session]:session id:' \\\\\n            '--plan[plan mode  design implementation approach]' \\\\\n            '--review[code review mode  structured review output]' \\\\\n            '--research[research mode  explore ideas, gather info]' \\\\\n            '--model[override default model]:model name:' \\\\\n            '--format[output format]:format:(text json)' \\\\\n            '--no-commit[disable auto-commit]' \\\\\n            '--no-checkpoints[disable checkpoint creation]' \\\\\n            '--auto[auto-accept file edits]' \\\\\n            '--dangerous[bypass all permission prompts]' \\\\\n            '--yolo[alias for --dangerous]' \\\\\n            '--tui[use full-screen terminal UI]'\n          ;;\n        tui)\n          _arguments \\\\\n            '--resume[resume a previous session]:session id:' \\\\\n            '--plan[plan mode  design implementation approach]' \\\\\n            '--review[code review mode  structured review output]' \\\\\n            '--research[research mode  explore ideas, gather info]' \\\\\n            '--model[override default model]:model name:' \\\\\n            '--format[output format]:format:(text json)' \\\\\n            '--no-commit[disable auto-commit]' \\\\\n            '--no-checkpoints[disable checkpoint creation]' \\\\\n            '--auto[auto-accept file edits]' \\\\\n            '--dangerous[bypass all permission prompts]' \\\\\n            '--yolo[alias for --dangerous]' \\\\\n            '--tui[use full-screen terminal UI]'\n          ;;\n        do)\n          _arguments \\\\\n            '--model[use specific model]:model name:' \\\\\n            '--format[output format]:format:(text json)' \\\\\n            '--quiet[suppress output]' \\\\\n            '--output[write result to file]:file path:_files' \\\\\n            '--no-commit[disable auto-commit]' \\\\\n            '--no-checkpoints[disable checkpoint creation]' \\\\\n            '--auto[auto-accept file edits]' \\\\\n            '--dangerous[bypass all permission prompts]' \\\\\n            '--yolo[alias for --dangerous]'\n          ;;\n        benchmark)\n          _arguments \\\\\n            '--output[output directory]:dir:_files -/' \\\\\n            '--query[override AI news query]:text:' \\\\\n            '--words[minimum AI news word count]:n:' \\\\\n            '--max-results[max research results]:n:' \\\\\n            '--provider-order[provider order]:providers:(tavily gemini exa brave groq)' \\\\\n            '--serve[serve generated suite over local HTTP]' \\\\\n            '--host[host for local benchmark server]:host:' \\\\\n            '--port[port for local benchmark server]:port:' \\\\\n            '--force[allow existing output directory]' \\\\\n            '--json[machine-readable output]'\n          ;;\n        status)\n          _arguments \\\\\n            '--json[machine-readable output]'\n          ;;\n        models)\n          _arguments '1:action:(list manage dashboard scan use info load unload swap stop alias aliases unalias download delete benchmark predictor helpers quantize agents skills rag health browse-local browse-library)' '--json[machine-readable output]'\n          ;;\n        env)\n          _arguments '1:action:(list show save use delete)' \\\\\n            '--host[override host while saving]:host:' \\\\\n            '--port[override port while saving]:port:' \\\\\n            '--admin-key[override admin key while saving]:key:' \\\\\n            '--model[override model while saving]:model name:' \\\\\n            '--provider[profile provider]:provider:(lmx anthropic)' \\\\\n            '--mode[default mode]:mode:(safe auto plan review research dangerous ci)' \\\\\n            '--json[machine-readable output]'\n          ;;\n        config)\n          _arguments '1:action:(list get set reset menu)' '--json[machine-readable output]'\n          ;;\n        sessions)\n          _arguments '1:action:(list resume delete export search)' '--json[machine-readable output]'\n          ;;\n        mcp)\n          _arguments '1:action:(add add-playwright remove test list)' '--json[machine-readable output]'\n          ;;\n        init)\n          _arguments \\\\\n            '--yes[skip prompts, use defaults]' \\\\\n            '--force[overwrite existing APP.md]'\n          ;;\n        doctor)\n          _arguments \\\\\n            '--json[machine-readable output]'\n          ;;\n        diff)\n          _arguments \\\\\n            '--session[session to diff]:session id:'\n          ;;\n        server)\n          _arguments \\\\\n            '--port[server port]:port:' \\\\\n            '--host[server bind address]:host:' \\\\\n            '--model[override default model]:model name:'\n          ;;\n        daemon)\n          _arguments '1:action:(start run stop status logs)' \\\\\n            '--host[bind host]:host:' \\\\\n            '--port[preferred port]:port:' \\\\\n            '--token[daemon session token]:token:' \\\\\n            '--model[override daemon model]:model name:' \\\\\n            '--json[machine-readable output]'\n          ;;\n        serve)\n          _arguments '1:action:(start stop restart logs)' '--json[machine-readable output]'\n          ;;\n        update)\n          _arguments \\\\\n            '--components[comma-separated components]:components:(cli lmx plus web)' \\\\\n            '--target[target mode]:target:(auto local remote both)' \\\\\n            '--remote-host[override remote host]:host:' \\\\\n            '--remote-user[override SSH user]:user:' \\\\\n            '--identity-file[override SSH identity file]:file:_files' \\\\\n            '--local-root[override local apps root]:dir:_files -/' \\\\\n            '--remote-root[override remote apps root]:dir:' \\\\\n            '--dry-run[show planned commands without executing]' \\\\\n            '--no-build[skip build/install/restart steps]' \\\\\n            '--no-pull[skip git fetch/pull steps]' \\\\\n            '--json[machine-readable output]'\n          ;;\n        completions)\n          _arguments '1:shell:(bash zsh fish)'\n          ;;\n      esac\n      ;;\n  esac\n}\n\n_opta \"\\$@\"`;\n}\n\nfunction fishCompletions(): string {\n  return `# opta fish completions\n# Save to ~/.config/fish/completions/opta.fish\n\n# Disable file completions\ncomplete -c opta -f\n\n# Commands\ncomplete -c opta -n '__fish_use_subcommand' -a chat -d 'Start an interactive AI chat session'\ncomplete -c opta -n '__fish_use_subcommand' -a tui -d 'Start full-screen terminal UI (alias for chat --tui)'\ncomplete -c opta -n '__fish_use_subcommand' -a do -d 'Execute a coding task'\ncomplete -c opta -n '__fish_use_subcommand' -a benchmark -d 'Generate benchmark suite apps'\ncomplete -c opta -n '__fish_use_subcommand' -a init -d 'Initialize OPIS project intelligence docs'\ncomplete -c opta -n '__fish_use_subcommand' -a doctor -d 'Check environment health and diagnose issues'\ncomplete -c opta -n '__fish_use_subcommand' -a status -d 'Check Opta LMX server health'\ncomplete -c opta -n '__fish_use_subcommand' -a models -d 'List and manage loaded models'\ncomplete -c opta -n '__fish_use_subcommand' -a env -d 'Manage named environment profiles'\ncomplete -c opta -n '__fish_use_subcommand' -a config -d 'Manage configuration'\ncomplete -c opta -n '__fish_use_subcommand' -a sessions -d 'Manage chat sessions'\ncomplete -c opta -n '__fish_use_subcommand' -a mcp -d 'Model Context Protocol tools'\ncomplete -c opta -n '__fish_use_subcommand' -a diff -d 'Show changes made in a session'\ncomplete -c opta -n '__fish_use_subcommand' -a server -d 'Start HTTP API server'\ncomplete -c opta -n '__fish_use_subcommand' -a daemon -d 'Manage Opta daemon runtime'\ncomplete -c opta -n '__fish_use_subcommand' -a serve -d 'Manage remote Opta LMX server'\ncomplete -c opta -n '__fish_use_subcommand' -a update -d 'Update Opta components locally/remotely'\ncomplete -c opta -n '__fish_use_subcommand' -a completions -d 'Generate shell completions'\n\n# Global flags\ncomplete -c opta -l verbose -d 'Detailed output'\ncomplete -c opta -l debug -d 'Debug info including API calls'\ncomplete -c opta -l version -s V -d 'Show version'\ncomplete -c opta -l help -s h -d 'Show help'\n\n# chat flags\ncomplete -c opta -n '__fish_seen_subcommand_from chat' -l resume -s r -d 'Resume session' -x\ncomplete -c opta -n '__fish_seen_subcommand_from chat' -l plan -d 'Plan mode'\ncomplete -c opta -n '__fish_seen_subcommand_from chat' -l review -d 'Code review mode'\ncomplete -c opta -n '__fish_seen_subcommand_from chat' -l research -d 'Research mode'\ncomplete -c opta -n '__fish_seen_subcommand_from chat' -l model -s m -d 'Override model' -x\ncomplete -c opta -n '__fish_seen_subcommand_from chat' -l format -s f -d 'Output format' -x -a 'text json'\ncomplete -c opta -n '__fish_seen_subcommand_from chat' -l no-commit -d 'Disable auto-commit'\ncomplete -c opta -n '__fish_seen_subcommand_from chat' -l no-checkpoints -d 'Disable checkpoints'\ncomplete -c opta -n '__fish_seen_subcommand_from chat' -l auto -s a -d 'Auto-accept file edits'\ncomplete -c opta -n '__fish_seen_subcommand_from chat' -l dangerous -d 'Bypass permission prompts'\ncomplete -c opta -n '__fish_seen_subcommand_from chat' -l yolo -d 'Alias for --dangerous'\ncomplete -c opta -n '__fish_seen_subcommand_from chat' -l tui -d 'Full-screen terminal UI'\n\n# do flags\ncomplete -c opta -n '__fish_seen_subcommand_from do' -l model -s m -d 'Use specific model' -x\ncomplete -c opta -n '__fish_seen_subcommand_from do' -l format -s f -d 'Output format' -x -a 'text json'\ncomplete -c opta -n '__fish_seen_subcommand_from do' -l quiet -s q -d 'Suppress output'\ncomplete -c opta -n '__fish_seen_subcommand_from do' -l output -s o -d 'Write result to file' -r\ncomplete -c opta -n '__fish_seen_subcommand_from do' -l no-commit -d 'Disable auto-commit'\ncomplete -c opta -n '__fish_seen_subcommand_from do' -l no-checkpoints -d 'Disable checkpoints'\ncomplete -c opta -n '__fish_seen_subcommand_from do' -l auto -s a -d 'Auto-accept file edits'\ncomplete -c opta -n '__fish_seen_subcommand_from do' -l dangerous -d 'Bypass permission prompts'\ncomplete -c opta -n '__fish_seen_subcommand_from do' -l yolo -d 'Alias for --dangerous'\n\n# benchmark flags\ncomplete -c opta -n '__fish_seen_subcommand_from benchmark' -l output -s o -d 'Output directory' -r\ncomplete -c opta -n '__fish_seen_subcommand_from benchmark' -l query -d 'Override AI news query' -x\ncomplete -c opta -n '__fish_seen_subcommand_from benchmark' -l words -d 'Minimum AI news word count (>=500)' -x\ncomplete -c opta -n '__fish_seen_subcommand_from benchmark' -l max-results -d 'Max research results/citations' -x\ncomplete -c opta -n '__fish_seen_subcommand_from benchmark' -l provider-order -d 'Provider order (comma-separated)' -x\ncomplete -c opta -n '__fish_seen_subcommand_from benchmark' -l serve -d 'Serve benchmark over local HTTP'\ncomplete -c opta -n '__fish_seen_subcommand_from benchmark' -l host -d 'Host for benchmark server' -x\ncomplete -c opta -n '__fish_seen_subcommand_from benchmark' -l port -d 'Port for benchmark server' -x\ncomplete -c opta -n '__fish_seen_subcommand_from benchmark' -l force -d 'Allow existing output directory'\ncomplete -c opta -n '__fish_seen_subcommand_from benchmark' -l json -d 'Machine-readable output'\n\n# tui flags\ncomplete -c opta -n '__fish_seen_subcommand_from tui' -l resume -s r -d 'Resume session' -x\ncomplete -c opta -n '__fish_seen_subcommand_from tui' -l plan -d 'Plan mode'\ncomplete -c opta -n '__fish_seen_subcommand_from tui' -l review -d 'Code review mode'\ncomplete -c opta -n '__fish_seen_subcommand_from tui' -l research -d 'Research mode'\ncomplete -c opta -n '__fish_seen_subcommand_from tui' -l model -s m -d 'Override model' -x\ncomplete -c opta -n '__fish_seen_subcommand_from tui' -l format -s f -d 'Output format' -x -a 'text json'\ncomplete -c opta -n '__fish_seen_subcommand_from tui' -l no-commit -d 'Disable auto-commit'\ncomplete -c opta -n '__fish_seen_subcommand_from tui' -l no-checkpoints -d 'Disable checkpoints'\ncomplete -c opta -n '__fish_seen_subcommand_from tui' -l auto -s a -d 'Auto-accept file edits'\ncomplete -c opta -n '__fish_seen_subcommand_from tui' -l dangerous -d 'Bypass permission prompts'\ncomplete -c opta -n '__fish_seen_subcommand_from tui' -l yolo -d 'Alias for --dangerous'\ncomplete -c opta -n '__fish_seen_subcommand_from tui' -l tui -d 'Full-screen terminal UI'\n\n# status flags\ncomplete -c opta -n '__fish_seen_subcommand_from status' -l json -d 'Machine-readable output'\n\n# models subcommands and flags\ncomplete -c opta -n '__fish_seen_subcommand_from models' -a 'list manage dashboard scan use info load unload swap stop alias aliases unalias download delete benchmark predictor helpers quantize agents skills rag health browse-local browse-library' -d 'Action'\ncomplete -c opta -n '__fish_seen_subcommand_from models' -l json -d 'Machine-readable output'\n\n# env subcommands and flags\ncomplete -c opta -n '__fish_seen_subcommand_from env' -a 'list show save use delete' -d 'Action'\ncomplete -c opta -n '__fish_seen_subcommand_from env' -l host -d 'Override host when saving' -x\ncomplete -c opta -n '__fish_seen_subcommand_from env' -l port -d 'Override port when saving' -x\ncomplete -c opta -n '__fish_seen_subcommand_from env' -l admin-key -d 'Override admin key when saving' -x\ncomplete -c opta -n '__fish_seen_subcommand_from env' -l model -d 'Override model when saving' -x\ncomplete -c opta -n '__fish_seen_subcommand_from env' -l provider -d 'Provider for profile' -x -a 'lmx anthropic'\ncomplete -c opta -n '__fish_seen_subcommand_from env' -l mode -d 'Default mode for profile' -x -a 'safe auto plan review research dangerous ci'\ncomplete -c opta -n '__fish_seen_subcommand_from env' -l json -d 'Machine-readable output'\n\n# config subcommands and flags\ncomplete -c opta -n '__fish_seen_subcommand_from config' -a 'list get set reset menu' -d 'Action'\ncomplete -c opta -n '__fish_seen_subcommand_from config' -l json -d 'Machine-readable output'\n\n# sessions subcommands and flags\ncomplete -c opta -n '__fish_seen_subcommand_from sessions' -a 'list resume delete export search' -d 'Action'\ncomplete -c opta -n '__fish_seen_subcommand_from sessions' -l json -d 'Machine-readable output'\n\n# mcp subcommands\ncomplete -c opta -n '__fish_seen_subcommand_from mcp' -a 'add add-playwright remove test list' -d 'Action'\ncomplete -c opta -n '__fish_seen_subcommand_from mcp' -l json -d 'Machine-readable output'\n\n# init flags\ncomplete -c opta -n '__fish_seen_subcommand_from init' -l yes -s y -d 'Skip prompts, use defaults'\ncomplete -c opta -n '__fish_seen_subcommand_from init' -l force -d 'Overwrite existing APP.md'\n\n# doctor flags\ncomplete -c opta -n '__fish_seen_subcommand_from doctor' -l json -d 'Machine-readable output'\n\n# diff flags\ncomplete -c opta -n '__fish_seen_subcommand_from diff' -l session -s s -d 'Session to diff' -x\n\n# server flags\ncomplete -c opta -n '__fish_seen_subcommand_from server' -l port -s p -d 'Server port' -x\ncomplete -c opta -n '__fish_seen_subcommand_from server' -l host -d 'Server bind address' -x\ncomplete -c opta -n '__fish_seen_subcommand_from server' -l model -s m -d 'Override model' -x\n\n# daemon subcommands and flags\ncomplete -c opta -n '__fish_seen_subcommand_from daemon' -a 'start run stop status logs' -d 'Action'\ncomplete -c opta -n '__fish_seen_subcommand_from daemon' -l host -d 'Bind host' -x\ncomplete -c opta -n '__fish_seen_subcommand_from daemon' -l port -d 'Preferred port' -x\ncomplete -c opta -n '__fish_seen_subcommand_from daemon' -l token -d 'Daemon token' -x\ncomplete -c opta -n '__fish_seen_subcommand_from daemon' -l model -d 'Model override' -x\ncomplete -c opta -n '__fish_seen_subcommand_from daemon' -l json -d 'Machine-readable output'\n\n# serve subcommands and flags\ncomplete -c opta -n '__fish_seen_subcommand_from serve' -a 'start stop restart logs' -d 'Action'\ncomplete -c opta -n '__fish_seen_subcommand_from serve' -l json -d 'Machine-readable output'\n\n# update flags\ncomplete -c opta -n '__fish_seen_subcommand_from update' -l components -s c -d 'Components: cli,lmx,plus,web' -x -a 'cli lmx plus web'\ncomplete -c opta -n '__fish_seen_subcommand_from update' -l target -s t -d 'Target: auto|local|remote|both' -x -a 'auto local remote both'\ncomplete -c opta -n '__fish_seen_subcommand_from update' -l remote-host -d 'Override remote host' -x\ncomplete -c opta -n '__fish_seen_subcommand_from update' -l remote-user -d 'Override SSH user' -x\ncomplete -c opta -n '__fish_seen_subcommand_from update' -l identity-file -d 'Override SSH identity file' -r\ncomplete -c opta -n '__fish_seen_subcommand_from update' -l local-root -d 'Override local apps root' -r\ncomplete -c opta -n '__fish_seen_subcommand_from update' -l remote-root -d 'Override remote apps root' -x\ncomplete -c opta -n '__fish_seen_subcommand_from update' -l dry-run -d 'Show planned commands without executing'\ncomplete -c opta -n '__fish_seen_subcommand_from update' -l no-build -d 'Skip build/install/restart steps'\ncomplete -c opta -n '__fish_seen_subcommand_from update' -l no-pull -d 'Skip git fetch/pull steps'\ncomplete -c opta -n '__fish_seen_subcommand_from update' -l json -d 'Machine-readable output'\n\n# completions subcommands\ncomplete -c opta -n '__fish_seen_subcommand_from completions' -a 'bash zsh fish' -d 'Shell'`;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/commands/config.ts","messages":[{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'value ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":21,"column":22,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":21,"endColumn":33},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'val' may use Object's default stringification format ('[object Object]') when stringified.","line":116,"column":22,"nodeType":"Identifier","messageId":"baseToString","endLine":116,"endColumn":25},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'oldRaw' may use Object's default stringification format ('[object Object]') when stringified.","line":133,"column":50,"nodeType":"Identifier","messageId":"baseToString","endLine":133,"endColumn":56},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, value is always truthy.","line":201,"column":10,"nodeType":"Literal","messageId":"alwaysTruthy","endLine":201,"endColumn":14},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'current ?? chalk.dim('(unset)')' will use Object's default stringification format ('[object Object]') when stringified.","line":228,"column":20,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":228,"endColumn":51},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'current' may use Object's default stringification format ('[object Object]') when stringified.","line":261,"column":98,"nodeType":"Identifier","messageId":"baseToString","endLine":261,"endColumn":105}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import chalk from 'chalk';\nimport { loadConfig, getConfigStore, OptaConfigSchema } from '../core/config.js';\nimport { EXIT, ExitError, OptaError } from '../core/errors.js';\nimport { errorMessage } from '../utils/errors.js';\nimport { box, kv } from '../ui/box.js';\nimport type { PaneMenuSection } from '../ui/pane-menu.js';\nimport { runMenuPrompt } from '../ui/prompt-nav.js';\n\ninterface ConfigOptions {\n  json?: boolean;\n}\n\nfunction isSensitiveConfigKey(key: string): boolean {\n  const k = key.toLowerCase();\n  return k.includes('apikey') || k.includes('api_key') ||\n    k.includes('token') || k.includes('secret') || k.includes('password') ||\n    k.endsWith('.key') || k.includes('adminkey');\n}\n\nfunction maskSensitiveConfigValue(value: unknown): string {\n  const raw = String(value ?? '');\n  if (!raw || raw === 'undefined') return chalk.dim('(none)');\n  if (raw.length <= 6) return '******';\n  return `${'*'.repeat(Math.max(0, raw.length - 4))}${raw.slice(-4)}`;\n}\n\nexport async function config(\n  action?: string,\n  key?: string,\n  value?: string,\n  opts?: ConfigOptions\n): Promise<void> {\n  // Default: list\n  if (!action || action === 'list') {\n    await listConfig(opts);\n    return;\n  }\n\n  switch (action) {\n    case 'get':\n      await getConfig(key);\n      break;\n\n    case 'set':\n      await setConfig(key, value);\n      break;\n\n    case 'reset':\n      await resetConfig();\n      break;\n\n    case 'menu':\n    case 'interactive':\n      await configMenu();\n      break;\n\n    case 'settings':\n      console.log('To open settings:');\n      console.log('  1. Run: opta chat --tui');\n      console.log('  2. Press Ctrl+S to open Opta Menu');\n      console.log('  3. Select Settings from the Operations page');\n      console.log('');\n      console.log('Or press Ctrl+Shift+S directly to open settings.');\n      break;\n\n    default:\n      console.error(chalk.red('') + ` Unknown action: ${action}\\n`);\n      console.log(chalk.dim('Available actions: list, get, set, reset, menu, settings'));\n      throw new ExitError(EXIT.MISUSE);\n  }\n}\n\n// --- List ---\n\nasync function listConfig(opts?: ConfigOptions): Promise<void> {\n  const cfg = await loadConfig();\n\n  if (opts?.json) {\n    console.log(JSON.stringify(cfg, null, 2));\n    return;\n  }\n\n  const flat = flattenObject(cfg);\n\n  for (const [key, val] of Object.entries(flat)) {\n    const display = isSensitiveConfigKey(key)\n      ? maskSensitiveConfigValue(val)\n      : String(val);\n    console.log(`  ${chalk.cyan(key.padEnd(30))} ${display}`);\n  }\n}\n\n// --- Get ---\n\nasync function getConfig(key?: string): Promise<void> {\n  if (!key) {\n    console.error(chalk.red('') + ' Key required\\n');\n    console.log(chalk.dim('Usage: opta config get <key>'));\n    console.log(chalk.dim('Example: opta config get connection.host'));\n    throw new ExitError(EXIT.MISUSE);\n  }\n\n  const cfg = await loadConfig();\n  const flat = flattenObject(cfg);\n  const val = flat[key];\n\n  if (val === undefined) {\n    console.error(chalk.red('') + ` Unknown key: ${key}\\n`);\n    console.log(chalk.dim('Available keys:'));\n    for (const k of Object.keys(flat)) {\n      console.log(chalk.dim(`  ${k}`));\n    }\n    throw new ExitError(EXIT.NOT_FOUND);\n  }\n\n  console.log(String(val));\n}\n\n// --- Set ---\n\nasync function setConfig(key?: string, value?: string): Promise<void> {\n  if (!key || value === undefined) {\n    console.error(chalk.red('') + ' Key and value required\\n');\n    console.log(chalk.dim('Usage: opta config set <key> <value>'));\n    console.log(chalk.dim('Example: opta config set permissions.edit_file allow'));\n    throw new ExitError(EXIT.MISUSE);\n  }\n\n  const store = await getConfigStore();\n\n  // Capture old value for display\n  const oldRaw = store.get(key);\n  const oldValue = oldRaw !== undefined ? String(oldRaw) : chalk.dim('(default)');\n\n  // Parse value type\n  let parsed: unknown = value;\n  if (key === 'connection.fallbackHosts') {\n    const trimmed = value.trim();\n    if (trimmed.startsWith('[')) {\n      try {\n        parsed = JSON.parse(trimmed);\n      } catch {\n        throw new OptaError(\n          `Invalid value for \"${key}\": expected a JSON array or comma-separated host list`,\n          EXIT.MISUSE,\n        );\n      }\n    } else if (trimmed.length === 0) {\n      parsed = [];\n    } else {\n      parsed = trimmed\n        .split(',')\n        .map((item) => item.trim())\n        .filter((item) => item.length > 0);\n    }\n  } else if (value === 'true') parsed = true;\n  else if (value === 'false') parsed = false;\n  else if (/^\\d+$/.test(value)) parsed = parseInt(value, 10);\n  else if (/^\\d+\\.\\d+$/.test(value)) parsed = parseFloat(value);\n\n  store.set(key, parsed);\n\n  // Validate the full merged config against the Zod schema\n  try {\n    const fullConfig = store.store;\n    OptaConfigSchema.parse(fullConfig);\n  } catch (e) {\n    // Revert the change  the value is invalid\n    store.delete(key);\n    throw new OptaError(\n      `Invalid value for \"${key}\": ${errorMessage(e)}`,\n      EXIT.MISUSE,\n    );\n  }\n\n  console.log(\n    chalk.green('') + ` ${chalk.cyan(key)}: ${chalk.dim(oldValue)}  ${String(parsed)}`\n  );\n}\n\n// --- Reset ---\n\nasync function resetConfig(): Promise<void> {\n  const store = await getConfigStore();\n  store.clear();\n  console.log(chalk.green('') + ' Config reset to defaults');\n}\n\nasync function configMenu(): Promise<void> {\n  if (!process.stdin.isTTY || !process.stdout.isTTY) {\n    await listConfig();\n    return;\n  }\n\n  const { runPaneMenu } = await import('../ui/pane-menu.js');\n  const { select, input } = await import('@inquirer/prompts');\n\n  let sectionIndex = 0;\n  let itemIndex = 0;\n\n  while (true) {\n    const cfg = await loadConfig();\n    const flat = flattenObject(cfg as unknown as Record<string, unknown>);\n    const sections = buildConfigMenuSections(flat);\n    const selection = await runPaneMenu({\n      title: 'Opta Config Menu',\n      subtitle: 'Browse keys with arrows, set values with Enter',\n      instructions: '/ panes  / loop  Enter select  q exit',\n      sections,\n      initialSectionIndex: sectionIndex,\n      initialItemIndex: itemIndex,\n      loop: true,\n    });\n\n    if (!selection) return;\n    sectionIndex = selection.sectionIndex;\n    itemIndex = selection.itemIndex;\n\n    const selectedKey = selection.itemId;\n    const current = flat[selectedKey];\n\n    console.log('\\n' + box(`Config ${chalk.cyan(selectedKey)}`, [\n      kv('Key', selectedKey, 16),\n      kv(\n        'Value',\n        isSensitiveConfigKey(selectedKey)\n          ? maskSensitiveConfigValue(current)\n          : String(current ?? chalk.dim('(unset)')),\n        16\n      ),\n      '',\n      chalk.dim(`Set with: opta config set ${selectedKey} <value>`),\n    ]) + '\\n');\n\n    let action: 'back' | 'set' | 'reset' | 'exit';\n    try {\n      const picked = await runMenuPrompt((context) =>\n        select<'back' | 'set' | 'reset' | 'exit'>({\n          message: chalk.dim('Next'),\n          choices: [\n            { name: 'Back to config menu', value: 'back' },\n            { name: `Set ${selectedKey}`, value: 'set' },\n            { name: `Reset ${selectedKey} to default`, value: 'reset' },\n            { name: 'Exit config menu', value: 'exit' },\n          ],\n        }, context), 'select');\n      if (!picked) continue;\n      action = picked;\n    } catch {\n      return;\n    }\n\n    if (action === 'exit') return;\n    if (action === 'back') continue;\n\n    if (action === 'set') {\n      let nextValue = '';\n      try {\n        nextValue = await input({\n          message: chalk.dim(`Set ${selectedKey}`),\n          default: isSensitiveConfigKey(selectedKey) ? '' : (current === undefined ? '' : String(current)),\n        });\n      } catch {\n        continue;\n      }\n      try {\n        await setConfig(selectedKey, nextValue);\n      } catch (err) {\n        console.error(chalk.red('') + ` ${errorMessage(err)}`);\n      }\n      continue;\n    }\n\n    const store = await getConfigStore();\n    store.delete(selectedKey);\n    console.log(chalk.green('') + ` ${selectedKey} reset to default`);\n  }\n}\n\n// --- Helpers ---\n\nfunction flattenObject(\n  obj: Record<string, unknown>,\n  prefix = ''\n): Record<string, unknown> {\n  const result: Record<string, unknown> = {};\n\n  for (const [key, val] of Object.entries(obj)) {\n    const fullKey = prefix ? `${prefix}.${key}` : key;\n    if (val !== null && typeof val === 'object' && !Array.isArray(val)) {\n      Object.assign(result, flattenObject(val as Record<string, unknown>, fullKey));\n    } else {\n      result[fullKey] = val;\n    }\n  }\n\n  return result;\n}\n\nfunction buildConfigMenuSections(flat: Record<string, unknown>): PaneMenuSection[] {\n  const grouped = new Map<string, Array<{ key: string; value: unknown }>>();\n\n  for (const [key, value] of Object.entries(flat)) {\n    const section = key.split('.')[0] ?? 'other';\n    const items = grouped.get(section) ?? [];\n    items.push({ key, value });\n    grouped.set(section, items);\n  }\n\n  return [...grouped.entries()]\n    .sort(([a], [b]) => a.localeCompare(b))\n    .map(([section, items]) => ({\n      id: section,\n      label: section.charAt(0).toUpperCase() + section.slice(1),\n      color: '#a855f7',\n      items: items\n        .sort((a, b) => a.key.localeCompare(b.key))\n        .map((item) => ({\n          id: item.key,\n          label: item.key,\n          description: String(item.value).slice(0, 36),\n        })),\n    }));\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/commands/daemon.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-return","severity":1,"message":"Unsafe return of a value of type `any`.","line":73,"column":11,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":73,"endColumn":35}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import chalk from 'chalk';\nimport { readFile } from 'node:fs/promises';\nimport { daemonLogsPath } from '../daemon/telemetry.js';\nimport { daemonStatus, ensureDaemonRunning, stopDaemon } from '../daemon/lifecycle.js';\nimport { runDaemon } from '../daemon/main.js';\n\ninterface DaemonCmdOptions {\n  host?: string;\n  port?: string;\n  json?: boolean;\n  token?: string;\n  model?: string;\n}\n\nexport async function daemonStart(opts: DaemonCmdOptions): Promise<void> {\n  const host = opts.host;\n  const port = opts.port ? Number.parseInt(opts.port, 10) : undefined;\n  const state = await ensureDaemonRunning({ host, port });\n  if (opts.json) {\n    console.log(JSON.stringify(state, null, 2));\n    return;\n  }\n  console.log(chalk.green('') + ` daemon running at http://${state.host}:${state.port}`);\n  console.log(chalk.dim(`  pid: ${state.pid}`));\n  console.log(chalk.dim(`  logs: ${state.logsPath}`));\n}\n\nexport async function daemonRun(opts: DaemonCmdOptions): Promise<void> {\n  const host = opts.host;\n  const port = opts.port ? Number.parseInt(opts.port, 10) : undefined;\n  await runDaemon({\n    host,\n    port,\n    token: opts.token,\n    model: opts.model,\n  });\n}\n\nexport async function daemonStop(_opts: DaemonCmdOptions): Promise<void> {\n  const stopped = await stopDaemon();\n  if (stopped) {\n    console.log(chalk.green('') + ' daemon stopped');\n  } else {\n    console.log(chalk.dim('daemon is not running'));\n  }\n}\n\nexport async function daemonStatusCommand(opts: DaemonCmdOptions): Promise<void> {\n  const status = await daemonStatus();\n  if (opts.json) {\n    console.log(JSON.stringify(status, null, 2));\n    return;\n  }\n  if (!status.running || !status.state) {\n    console.log(chalk.yellow('') + ' daemon is not running');\n    return;\n  }\n  console.log(chalk.green('') + ` daemon running at http://${status.state.host}:${status.state.port}`);\n  console.log(chalk.dim(`  pid: ${status.state.pid}`));\n  console.log(chalk.dim(`  started: ${status.state.startedAt}`));\n  console.log(chalk.dim(`  logs: ${status.logsPath}`));\n}\n\nexport async function daemonLogs(opts: DaemonCmdOptions): Promise<void> {\n  const path = daemonLogsPath();\n  try {\n    const raw = await readFile(path, 'utf-8');\n    const lines = raw.trim().split('\\n').filter(Boolean);\n    const tail = lines.slice(-200);\n    if (opts.json) {\n      const parsed = tail.map((line) => {\n        try {\n          return JSON.parse(line);\n        } catch {\n          return { raw: line };\n        }\n      });\n      console.log(JSON.stringify(parsed, null, 2));\n      return;\n    }\n    console.log(tail.join('\\n'));\n  } catch {\n    if (opts.json) {\n      console.log(JSON.stringify({ logs: [] }));\n      return;\n    }\n    console.log(chalk.dim('No daemon logs yet.'));\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/commands/diff.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/commands/do.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":120,"column":19,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":120,"endColumn":38},{"ruleId":"@typescript-eslint/no-unnecessary-type-conversion","severity":1,"message":"Passing a number to Number() does not change the type or value of the number.","line":121,"column":24,"nodeType":"Identifier","messageId":"unnecessaryTypeConversion","endLine":121,"endColumn":30,"suggestions":[{"messageId":"suggestRemove","fix":{"range":[3349,3378],"text":"(stats?.toolCalls ?? 0)"},"desc":"Remove the type conversion."},{"messageId":"suggestSatisfies","data":{"type":"number"},"fix":{"range":[3349,3378],"text":"(stats?.toolCalls ?? 0) satisfies number"},"desc":"Instead, assert that the value satisfies the number type."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import chalk from 'chalk';\nimport { loadConfig } from '../core/config.js';\nimport { agentLoop } from '../core/agent.js';\nimport { formatError, OptaError, ExitError, EXIT } from '../core/errors.js';\nimport { buildConfigOverrides } from '../utils/config-helpers.js';\nimport { DaemonClient } from '../daemon/client.js';\n\n// --- Types ---\n\nexport type OutputFormat = 'json' | 'text' | 'quiet';\n\nexport interface DoResult {\n  response: string;\n  toolCallCount: number;\n  model: string;\n  exitCode: number;\n  error?: string;\n}\n\ninterface DoOptions {\n  model?: string;\n  commit?: boolean;\n  checkpoints?: boolean;\n  format?: string;\n  quiet?: boolean;\n  output?: string;\n  auto?: boolean;\n  dangerous?: boolean;\n  yolo?: boolean;\n}\n\n// --- Output Formatting (testable) ---\n\n/**\n * Determine the output format from CLI flags.\n * Priority: --quiet > --format > default (text)\n */\nexport function parseDoOutput(opts: { format?: string; quiet?: boolean }): OutputFormat {\n  if (opts.quiet) return 'quiet';\n  if (opts.format === 'json') return 'json';\n  return 'text';\n}\n\n/**\n * Format the result based on the output mode.\n */\nexport function formatDoResult(result: DoResult, format: OutputFormat): string {\n  switch (format) {\n    case 'json':\n      return JSON.stringify({\n        result: result.response,\n        tool_calls: result.toolCallCount,\n        model: result.model,\n        exit_code: result.exitCode,\n        ...(result.error ? { error: result.error } : {}),\n      });\n\n    case 'quiet':\n      // In quiet mode, only output errors\n      if (result.error) return result.error;\n      return '';\n\n    case 'text':\n    default:\n      return result.response;\n  }\n}\n\n// --- Command Implementation ---\n\nexport async function executeTask(task: string[], opts: DoOptions): Promise<void> {\n  const taskStr = task.join(' ');\n\n  const outputFormat = parseDoOutput(opts);\n\n  if (!taskStr.trim()) {\n    if (outputFormat === 'json') {\n      console.log(JSON.stringify({ error: 'No task specified', exit_code: EXIT.MISUSE }));\n    } else if (outputFormat !== 'quiet') {\n      console.error(chalk.red('\\u2717') + ' No task specified\\n');\n      console.log(chalk.dim('Usage: opta do <task...>'));\n      console.log(chalk.dim('Example: opta do \"fix the authentication bug\"'));\n    }\n    throw new ExitError(EXIT.MISUSE);\n  }\n\n  const overrides = buildConfigOverrides(opts);\n\n  const silent = outputFormat === 'json' || outputFormat === 'quiet';\n\n  try {\n    const config = await loadConfig(overrides);\n\n    if (!config.model.default) {\n      const doResult: DoResult = {\n        response: '',\n        toolCallCount: 0,\n        model: '',\n        exitCode: EXIT.NO_CONNECTION,\n        error: 'No model configured',\n      };\n      const output = formatDoResult(doResult, outputFormat);\n      if (output) console.log(output);\n      throw new ExitError(EXIT.NO_CONNECTION);\n    }\n\n    if (!silent) {\n      console.log(\n        chalk.dim(`opta \\u00b7 ${config.model.default} \\u00b7 ${config.connection.host}`)\n      );\n    }\n\n    const taskStart = Date.now();\n    let doResult: DoResult;\n    try {\n      const daemon = await DaemonClient.connect();\n      const daemonResp = await daemon.legacyChat(taskStr);\n      const stats = daemonResp.stats as { toolCalls?: number } | undefined;\n      doResult = {\n        response: daemonResp.response ?? '',\n        toolCallCount: Number(stats?.toolCalls ?? 0),\n        model: daemonResp.model ?? config.model.default,\n        exitCode: 0,\n      };\n    } catch {\n      // Compatibility fallback in case daemon bootstrap fails.\n      const result = await agentLoop(taskStr, config, { silent });\n      const assistantMsgs = result.messages.filter((m) => m.role === 'assistant');\n      const finalMsg = assistantMsgs[assistantMsgs.length - 1];\n      doResult = {\n        response: typeof finalMsg?.content === 'string' ? finalMsg.content : '',\n        toolCallCount: result.toolCallCount,\n        model: config.model.default,\n        exitCode: 0,\n      };\n    }\n\n    const output = formatDoResult(doResult, outputFormat);\n    if (output) console.log(output);\n\n    // Elapsed time footer in text mode\n    if (outputFormat === 'text') {\n      const elapsed = ((Date.now() - taskStart) / 1000).toFixed(1);\n      const toolStr = doResult.toolCallCount > 0\n        ? chalk.dim(`  ${doResult.toolCallCount} tool call${doResult.toolCallCount !== 1 ? 's' : ''}`)\n        : '';\n      console.log(chalk.dim(`\\n  Done in ${elapsed}s${toolStr}`));\n    }\n\n    // Write to file if --output specified\n    if (opts.output) {\n      const { writeFile } = await import('node:fs/promises');\n      const fullOutput = outputFormat === 'json'\n        ? formatDoResult(doResult, 'json')\n        : doResult.response;\n      await writeFile(opts.output, fullOutput, 'utf-8');\n      if (!silent) {\n        console.log(chalk.dim(`  Output written to ${opts.output}`));\n      }\n    }\n  } catch (err) {\n    if (err instanceof OptaError) {\n      if (outputFormat === 'json') {\n        console.log(JSON.stringify({ error: err.message, exit_code: err.code }));\n      } else if (outputFormat !== 'quiet') {\n        console.error(formatError(err));\n      } else {\n        console.error(err.message);\n      }\n      throw new ExitError(err.code);\n    }\n    throw err;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/commands/doctor.ts","messages":[{"ruleId":"@typescript-eslint/require-await","severity":1,"message":"Async function 'checkNode' has no 'await' expression.","line":165,"column":8,"nodeType":"FunctionDeclaration","messageId":"missingAwait","endLine":165,"endColumn":32,"suggestions":[{"messageId":"removeAsync","fix":{"range":[4721,4769],"text":"function checkNode(): CheckResult"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":303,"column":26,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":303,"endColumn":40}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import chalk from 'chalk';\nimport { readdir, stat, access } from 'node:fs/promises';\nimport { join } from 'node:path';\nimport { homedir } from 'node:os';\nimport { loadConfig } from '../core/config.js';\nimport { VERSION } from '../core/version.js';\nimport { debug } from '../core/debug.js';\nimport { errorMessage } from '../utils/errors.js';\nimport { colorizeOptaWord } from '../ui/brand.js';\n\n// --- Types ---\n\nexport interface DoctorOptions {\n  format?: string;\n}\n\nexport interface CheckResult {\n  name: string;\n  status: 'pass' | 'warn' | 'fail';\n  message: string;\n  detail?: string;\n}\n\ninterface LmxDoctorSnapshot {\n  reachable: boolean;\n  host: string;\n  source: 'primary' | 'fallback';\n  latencyMs: number;\n  loadedModelIds: string[];\n  error?: string;\n}\n\nconst FAST_DOCTOR_REQUEST_OPTS = { timeoutMs: 2_500, maxRetries: 0 } as const;\n\nfunction buildFailoverHint(fallbackHosts: string[]): string {\n  const normalized = fallbackHosts\n    .map((value) => value.trim())\n    .filter((value) => value.length > 0);\n  return normalized.length > 0\n    ? `Configured fallback hosts: ${normalized.join(', ')}.`\n    : \"Configure failover hosts: 'opta config set connection.fallbackHosts hostA,hostB'.\";\n}\n\nasync function collectLmxDoctorSnapshot(\n  host: string,\n  port: number,\n  adminKey?: string,\n  fallbackHosts: string[] = [],\n): Promise<LmxDoctorSnapshot> {\n  const start = Date.now();\n  try {\n    const [{ resolveLmxEndpoint }, { LmxClient }] = await Promise.all([\n      import('../lmx/endpoints.js'),\n      import('../lmx/client.js'),\n    ]);\n    const resolved = await resolveLmxEndpoint({\n      host,\n      port,\n      adminKey,\n      fallbackHosts,\n    }, {\n      timeoutMs: 1_500,\n    });\n    const lmx = new LmxClient({\n      host: resolved.host,\n      port,\n      adminKey,\n      fallbackHosts: [],\n      timeoutMs: 2_500,\n      maxRetries: 0,\n    });\n    await lmx.health(FAST_DOCTOR_REQUEST_OPTS);\n    const models = await lmx.models(FAST_DOCTOR_REQUEST_OPTS).catch(() => ({ models: [] }));\n    return {\n      reachable: true,\n      host: resolved.host,\n      source: resolved.source,\n      latencyMs: Date.now() - start,\n      loadedModelIds: models.models.map((model) => model.model_id),\n    };\n  } catch (err) {\n    return {\n      reachable: false,\n      host,\n      source: 'primary',\n      latencyMs: Date.now() - start,\n      loadedModelIds: [],\n      error: errorMessage(err),\n    };\n  }\n}\n\nfunction lmxConnectionResultFromSnapshot(\n  snapshot: LmxDoctorSnapshot,\n  host: string,\n  port: number,\n  fallbackHosts: string[] = [],\n): CheckResult {\n  if (snapshot.reachable) {\n    const modelCount = snapshot.loadedModelIds.length;\n    const modelSuffix = modelCount > 0 ? `, ${modelCount} model${modelCount !== 1 ? 's' : ''} loaded` : '';\n    const failoverSuffix = snapshot.source === 'fallback' ? chalk.dim(` via fallback ${snapshot.host}`) : '';\n    return {\n      name: 'LMX Connection',\n      status: 'pass',\n      message: `LMX connected at ${snapshot.host}:${port} (${snapshot.latencyMs}ms${modelSuffix})${failoverSuffix}`,\n    };\n  }\n\n  const reason = snapshot.error && snapshot.error.length > 0\n    ? snapshot.error\n    : 'unknown error';\n  const failoverHint = buildFailoverHint(fallbackHosts);\n  return {\n    name: 'LMX Connection',\n    status: 'fail',\n    message: `LMX unreachable at ${host}:${port} (${reason})`,\n    detail: [\n      `Check that LMX is running at ${host}:${port}.`,\n      \"For authenticated inference set 'connection.apiKey' (or OPTA_API_KEY).\",\n      failoverHint,\n      \"Run 'opta status' or 'opta config set connection.host <host>' to reconfigure.\",\n    ].join(' '),\n  };\n}\n\nfunction activeModelResultFromSnapshot(configModel: string, snapshot: LmxDoctorSnapshot): CheckResult {\n  if (!configModel) {\n    return {\n      name: 'Active Model',\n      status: 'warn',\n      message: 'No default model configured',\n      detail: \"Run 'opta models use <model>' to set a default\",\n    };\n  }\n\n  if (!snapshot.reachable) {\n    return {\n      name: 'Active Model',\n      status: 'pass',\n      message: `Model: ${configModel} (LMX offline, cannot verify)`,\n    };\n  }\n\n  const loadedIds = snapshot.loadedModelIds;\n  const modelCount = loadedIds.length;\n  if (loadedIds.some((id) => id === configModel || id.includes(configModel))) {\n    return {\n      name: 'Active Model',\n      status: 'pass',\n      message: `Model: ${configModel} (${modelCount} model${modelCount !== 1 ? 's' : ''} loaded)`,\n    };\n  }\n\n  return {\n    name: 'Active Model',\n    status: 'warn',\n    message: `Model \"${configModel}\" not found in loaded models`,\n    detail: `Loaded models: ${loadedIds.join(', ') || 'none'}. Run 'opta models' to see available models.`,\n  };\n}\n\n// --- Individual Checks ---\n\nexport async function checkNode(): Promise<CheckResult> {\n  const version = process.version;\n  const major = parseInt(version.slice(1).split('.')[0] ?? '0', 10);\n\n  if (major >= 20) {\n    return {\n      name: 'Node.js',\n      status: 'pass',\n      message: `Node.js ${version} (>= 20.0.0 required)`,\n    };\n  }\n\n  return {\n    name: 'Node.js',\n    status: 'fail',\n    message: `Node.js ${version} is below minimum (>= 20.0.0 required)`,\n    detail: 'Upgrade Node.js to 20+ for ESM support and native fetch',\n  };\n}\n\nexport async function checkLmxConnection(\n  host: string,\n  port: number,\n  adminKey?: string,\n  fallbackHosts: string[] = [],\n): Promise<CheckResult> {\n  const snapshot = await collectLmxDoctorSnapshot(host, port, adminKey, fallbackHosts);\n  return lmxConnectionResultFromSnapshot(snapshot, host, port, fallbackHosts);\n}\n\nexport async function checkActiveModel(\n  configModel: string,\n  host: string,\n  port: number,\n  adminKey?: string,\n  fallbackHosts: string[] = [],\n): Promise<CheckResult> {\n  const snapshot = await collectLmxDoctorSnapshot(host, port, adminKey, fallbackHosts);\n  if (!snapshot.reachable) {\n    debug('doctor: could not verify model against LMX');\n  }\n  return activeModelResultFromSnapshot(configModel, snapshot);\n}\n\nexport async function checkConfig(preloadedConfig?: Awaited<ReturnType<typeof loadConfig>>): Promise<CheckResult> {\n  try {\n    const config = preloadedConfig ?? await loadConfig();\n\n    // Check for common misconfigurations\n    const issues: string[] = [];\n\n    if (!config.connection.host) {\n      issues.push('connection.host is empty');\n    }\n    if (config.connection.port === 0) {\n      issues.push('connection.port is 0');\n    }\n\n    if (issues.length > 0) {\n      return {\n        name: 'Config',\n        status: 'warn',\n        message: `Config has issues: ${issues.join(', ')}`,\n        detail: \"Run 'opta config list' to review current settings\",\n      };\n    }\n\n    return {\n      name: 'Config',\n      status: 'pass',\n      message: 'Config valid',\n    };\n  } catch (err) {\n    const msg = errorMessage(err);\n    return {\n      name: 'Config',\n      status: 'fail',\n      message: `Config validation failed: ${msg}`,\n      detail: \"Run 'opta config reset' to restore defaults\",\n    };\n  }\n}\n\nexport async function checkOpis(cwd: string): Promise<CheckResult> {\n  const appMdPath = join(cwd, 'APP.md');\n\n  try {\n    await access(appMdPath);\n  } catch {\n    return {\n      name: 'OPIS',\n      status: 'warn',\n      message: 'OPIS not initialized (no APP.md found)',\n      detail: \"Run 'opta init' to scaffold project intelligence docs\",\n    };\n  }\n\n  // Count available OPIS docs\n  const opisFiles = [\n    'ARCHITECTURE.md', 'GUARDRAILS.md', 'DECISIONS.md',\n    'ECOSYSTEM.md', 'KNOWLEDGE.md', 'WORKFLOWS.md',\n    'ROADMAP.md', 'INDEX.md',\n  ];\n\n  let docCount = 1; // APP.md counts\n  const docsDir = join(cwd, 'docs');\n\n  for (const file of opisFiles) {\n    try {\n      await access(join(docsDir, file));\n      docCount++;\n    } catch {\n      // File doesn't exist\n    }\n  }\n\n  return {\n    name: 'OPIS',\n    status: 'pass',\n    message: `OPIS initialized (${docCount} doc${docCount !== 1 ? 's' : ''})`,\n  };\n}\n\nexport async function checkMcpServers(\n  servers: Record<string, { transport: string; command?: string; url?: string; args?: string[]; env?: Record<string, string> }>\n): Promise<CheckResult> {\n  const names = Object.keys(servers);\n\n  if (names.length === 0) {\n    return {\n      name: 'MCP',\n      status: 'pass',\n      message: 'No MCP servers configured',\n    };\n  }\n\n  const { connectMcpServer } = await import('../mcp/client.js');\n  const settled = await Promise.all(names.map(async (name) => {\n    const serverConfig = servers[name]!;\n    try {\n      const conn = await Promise.race([\n        connectMcpServer(name, serverConfig as Parameters<typeof connectMcpServer>[1]),\n        new Promise<never>((_, reject) => {\n          setTimeout(() => reject(new Error('timeout')), 5000);\n        }),\n      ]);\n      const toolCount = conn.tools.length;\n      await conn.close();\n      return { name, ok: true as const, toolCount };\n    } catch {\n      return { name, ok: false as const, toolCount: 0 };\n    }\n  }));\n\n  const connected = settled.filter((entry) => entry.ok).length;\n  const totalTools = settled.reduce((sum, entry) => sum + entry.toolCount, 0);\n  const failed = settled.filter((entry) => !entry.ok).map((entry) => entry.name);\n\n  if (failed.length === 0) {\n    return {\n      name: 'MCP',\n      status: 'pass',\n      message: `MCP: ${connected}/${names.length} servers connected (${totalTools} tool${totalTools !== 1 ? 's' : ''})`,\n    };\n  }\n\n  if (connected > 0) {\n    return {\n      name: 'MCP',\n      status: 'warn',\n      message: `MCP: ${connected}/${names.length} servers connected (${failed.join(', ')} failed)`,\n      detail: `Failed servers: ${failed.join(', ')}. Check server commands and availability.`,\n    };\n  }\n\n  return {\n    name: 'MCP',\n    status: 'fail',\n    message: `MCP: 0/${names.length} servers connected`,\n    detail: `All MCP servers failed: ${failed.join(', ')}`,\n  };\n}\n\nexport async function checkGit(cwd: string): Promise<CheckResult> {\n  try {\n    await access(join(cwd, '.git'));\n  } catch {\n    return {\n      name: 'Git',\n      status: 'warn',\n      message: 'Not a git repository',\n      detail: \"Run 'git init' to initialize version control\",\n    };\n  }\n\n  // Check for uncommitted changes\n  try {\n    const { execaCommand } = await import('execa');\n    const result = await execaCommand('git status --porcelain', {\n      cwd,\n      timeout: 5000,\n    });\n\n    const lines = result.stdout.split('\\n').filter((l) => l.trim().length > 0);\n    const changeCount = lines.length;\n\n    // Check for checkpoints directory\n    let hasCheckpoints = false;\n    try {\n      await access(join(cwd, '.opta', 'checkpoints'));\n      hasCheckpoints = true;\n    } catch {\n      // No checkpoints dir\n    }\n\n    const checkpointNote = hasCheckpoints ? ', checkpoints enabled' : '';\n\n    if (changeCount === 0) {\n      return {\n        name: 'Git',\n        status: 'pass',\n        message: `Git repository (clean${checkpointNote})`,\n      };\n    }\n\n    if (changeCount > 20) {\n      return {\n        name: 'Git',\n        status: 'warn',\n        message: `Git repository (${changeCount} uncommitted changes${checkpointNote})`,\n        detail: 'Consider committing or stashing changes',\n      };\n    }\n\n    return {\n      name: 'Git',\n      status: 'pass',\n      message: `Git repository (${changeCount} change${changeCount !== 1 ? 's' : ''}${checkpointNote})`,\n    };\n  } catch {\n    return {\n      name: 'Git',\n      status: 'pass',\n      message: 'Git repository (could not check status)',\n    };\n  }\n}\n\nexport async function checkAccount(): Promise<CheckResult> {\n  // Step 1: check whether Supabase is configured at all\n  const { resolveSupabaseAuthConfig } = await import('../accounts/supabase.js');\n  const config = resolveSupabaseAuthConfig();\n\n  if (!config) {\n    return {\n      name: 'Account',\n      status: 'warn',\n      message: 'OPTA_SUPABASE_URL not configured (account features disabled)',\n      detail: \"Set OPTA_SUPABASE_URL and OPTA_SUPABASE_ANON_KEY environment variables to enable account features.\",\n    };\n  }\n\n  // Step 2: load persisted account state\n  const { loadAccountState } = await import('../accounts/storage.js');\n  const state = await loadAccountState();\n\n  if (!state) {\n    return {\n      name: 'Account',\n      status: 'pass',\n      message: 'Not logged in (run opta account login)',\n    };\n  }\n\n  // Step 3: check session / token validity\n  if (!state.session) {\n    return {\n      name: 'Account',\n      status: 'warn',\n      message: 'Account state found but no active session',\n      detail: \"The saved token is missing or expired. Run 'opta account login' to re-authenticate.\",\n    };\n  }\n\n  const expiresAt = state.session.expires_at;\n  const identifier = state.user?.email ?? state.user?.phone ?? 'unknown user';\n\n  if (expiresAt !== undefined) {\n    const nowSecs = Date.now() / 1000;\n    const diffSecs = expiresAt - nowSecs;\n\n    if (diffSecs <= 0) {\n      return {\n        name: 'Account',\n        status: 'warn',\n        message: `Token expired (run opta account login)`,\n        detail: `Last authenticated as ${identifier} on project ${state.project}.`,\n      };\n    }\n\n    const hours = Math.floor(diffSecs / 3600);\n    const mins = Math.ceil((diffSecs % 3600) / 60);\n    const expiresSuffix = hours > 0 ? `expires in ${hours}h` : `expires in ${mins}m`;\n\n    return {\n      name: 'Account',\n      status: 'pass',\n      message: `Logged in as ${identifier} (${expiresSuffix})`,\n    };\n  }\n\n  // No expires_at  treat as valid but indeterminate expiry\n  return {\n    name: 'Account',\n    status: 'pass',\n    message: `Logged in as ${identifier}`,\n  };\n}\n\nexport async function checkDiskUsage(): Promise<CheckResult> {\n  const sessionsDir = join(homedir(), '.config', 'opta', 'sessions');\n\n  let sessionCount = 0;\n  let totalBytes = 0;\n\n  try {\n    const files = await readdir(sessionsDir);\n    const jsonFiles = files.filter((f) => f.endsWith('.json'));\n    sessionCount = jsonFiles.length;\n\n    const stats = await Promise.all(\n      jsonFiles.map(async (file) => {\n        try {\n          const s = await stat(join(sessionsDir, file));\n          return s.size;\n        } catch {\n          return 0;\n        }\n      }),\n    );\n    totalBytes = stats.reduce((sum, size) => sum + size, 0);\n  } catch {\n    // Sessions dir doesn't exist  that's fine\n    return {\n      name: 'Sessions',\n      status: 'pass',\n      message: 'Sessions: 0 (0 B)',\n    };\n  }\n\n  const sizeStr = formatBytes(totalBytes);\n\n  if (totalBytes > 100 * 1024 * 1024) {\n    return {\n      name: 'Sessions',\n      status: 'warn',\n      message: `Sessions: ${sessionCount} (${sizeStr})`,\n      detail: \"Session storage exceeds 100 MB. Run 'opta sessions' to review and delete old sessions.\",\n    };\n  }\n\n  return {\n    name: 'Sessions',\n    status: 'pass',\n    message: `Sessions: ${sessionCount} (${sizeStr})`,\n  };\n}\n\n// --- Formatting Helpers ---\n\nfunction formatBytes(bytes: number): string {\n  if (bytes === 0) return '0 B';\n  if (bytes < 1024) return `${bytes} B`;\n  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n  if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n  return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;\n}\n\nfunction statusIcon(status: 'pass' | 'warn' | 'fail'): string {\n  switch (status) {\n    case 'pass': return chalk.green('\\u2713');\n    case 'warn': return chalk.yellow('\\u26A0');\n    case 'fail': return chalk.red('\\u2717');\n  }\n}\n\n// --- Main Command ---\n\nexport async function runDoctor(options: DoctorOptions): Promise<void> {\n  const isJson = options.format === 'json';\n  const config = await loadConfig();\n\n  const { host, port, adminKey } = config.connection;\n  const cwd = process.cwd();\n\n  const [\n    nodeResult,\n    lmxSnapshot,\n    configResult,\n    opisResult,\n    mcpResult,\n    gitResult,\n    diskResult,\n    accountResult,\n  ] = await Promise.all([\n    checkNode(),\n    collectLmxDoctorSnapshot(host, port, adminKey, config.connection.fallbackHosts),\n    checkConfig(config),\n    checkOpis(cwd),\n    checkMcpServers(config.mcp.servers as Parameters<typeof checkMcpServers>[0]),\n    checkGit(cwd),\n    checkDiskUsage(),\n    checkAccount(),\n  ]);\n\n  const results: CheckResult[] = [\n    nodeResult,\n    lmxConnectionResultFromSnapshot(lmxSnapshot, host, port, config.connection.fallbackHosts),\n    activeModelResultFromSnapshot(config.model.default, lmxSnapshot),\n    configResult,\n    opisResult,\n    mcpResult,\n    gitResult,\n    diskResult,\n    accountResult,\n  ];\n\n  // Output\n  if (isJson) {\n    const passed = results.filter((r) => r.status === 'pass').length;\n    const warnings = results.filter((r) => r.status === 'warn').length;\n    const failures = results.filter((r) => r.status === 'fail').length;\n\n    console.log(JSON.stringify({\n      version: VERSION,\n      checks: results,\n      summary: { passed, warnings, failures },\n    }, null, 2));\n    return;\n  }\n\n  // Text output\n  console.log('');\n  console.log(chalk.bold(colorizeOptaWord('Opta Doctor')));\n  console.log(chalk.dim('\\u2500'.repeat(30)));\n  console.log('');\n\n  for (const result of results) {\n    const icon = statusIcon(result.status);\n    console.log(`  ${icon} ${result.message}`);\n    if (result.detail && result.status !== 'pass') {\n      console.log(`    ${chalk.dim(result.detail)}`);\n    }\n  }\n\n  const passed = results.filter((r) => r.status === 'pass').length;\n  const warnings = results.filter((r) => r.status === 'warn').length;\n  const failures = results.filter((r) => r.status === 'fail').length;\n\n  console.log('');\n\n  const parts: string[] = [];\n  parts.push(`${passed} check${passed !== 1 ? 's' : ''} passed`);\n  if (warnings > 0) parts.push(`${warnings} warning${warnings !== 1 ? 's' : ''}`);\n  if (failures > 0) parts.push(`${failures} error${failures !== 1 ? 's' : ''}`);\n\n  const summaryColor = failures > 0 ? chalk.red : warnings > 0 ? chalk.yellow : chalk.green;\n  console.log('  ' + summaryColor(parts.join(', ')));\n  console.log('');\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/commands/editor.ts","messages":[{"ruleId":"@typescript-eslint/require-await","severity":1,"message":"Async function 'editText' has no 'await' expression.","line":11,"column":8,"nodeType":"FunctionDeclaration","messageId":"missingAwait","endLine":11,"endColumn":31,"suggestions":[{"messageId":"removeAsync","fix":{"range":[334,395],"text":"function editText(initial = ''): string | null"},"desc":"Remove 'async'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { writeFileSync, readFileSync, unlinkSync } from 'node:fs';\nimport { tmpdir } from 'node:os';\nimport { join } from 'node:path';\nimport { execFileSync } from 'node:child_process';\nimport { nanoid } from 'nanoid';\n\nexport function getEditorCommand(): string {\n  return process.env.VISUAL || process.env.EDITOR || 'vi';\n}\n\nexport async function editText(initial = ''): Promise<string | null> {\n  const tmpFile = join(tmpdir(), `opta-${nanoid(6)}.md`);\n  writeFileSync(tmpFile, initial, 'utf-8');\n\n  const editor = getEditorCommand();\n  try {\n    execFileSync(editor, [tmpFile], { stdio: 'inherit' });\n    const result = readFileSync(tmpFile, 'utf-8');\n    unlinkSync(tmpFile);\n    return result.trim() || null;\n  } catch {\n    try { unlinkSync(tmpFile); } catch { /* ignore */ }\n    return null;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/commands/embed.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-type-conversion","severity":1,"message":"Passing a string to String() does not change the type or value of the string.","line":19,"column":64,"nodeType":"Identifier","messageId":"unnecessaryTypeConversion","endLine":19,"endColumn":70,"suggestions":[{"messageId":"suggestRemove","fix":{"range":[643,662],"text":"(input ?? '')"},"desc":"Remove the type conversion."},{"messageId":"suggestSatisfies","data":{"type":"string"},"fix":{"range":[643,662],"text":"((input ?? '') satisfies string)"},"desc":"Instead, assert that the value satisfies the string type."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":19,"column":71,"nodeType":"Identifier","messageId":"neverNullish","endLine":19,"endColumn":76},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":50,"column":45,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":50,"endColumn":47,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1525,1527],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":51,"column":39,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":51,"endColumn":41,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1578,1580],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":63,"column":22,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":63,"endColumn":33,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[1994,1995],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":64,"column":22,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":64,"endColumn":33,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[2091,2092],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import chalk from 'chalk';\nimport { loadConfig } from '../core/config.js';\nimport { EXIT, ExitError } from '../core/errors.js';\nimport { LmxApiError, LmxClient } from '../lmx/client.js';\nimport { errorMessage } from '../utils/errors.js';\n\ninterface EmbedOptions {\n  model?: string;\n  json?: boolean;\n}\n\nconst EMBED_REQUEST_OPTS = { timeoutMs: 30_000, maxRetries: 0 } as const;\n\nfunction usage(): void {\n  console.log(chalk.dim('Usage: opta embed <text> [--model <id>] [--json]'));\n}\n\nexport async function embed(input: string | string[], opts: EmbedOptions = {}): Promise<void> {\n  const text = Array.isArray(input) ? input.join(' ').trim() : String(input ?? '').trim();\n  if (!text) {\n    console.error(chalk.red('') + ' Text input is required.\\n');\n    usage();\n    throw new ExitError(EXIT.MISUSE);\n  }\n\n  const config = await loadConfig();\n  const resolvedModel = (opts.model?.trim() || config.model.default || 'text-embedding-3-small').trim();\n  const client = new LmxClient({\n    host: config.connection.host,\n    fallbackHosts: config.connection.fallbackHosts,\n    port: config.connection.port,\n    adminKey: config.connection.adminKey,\n  });\n\n  try {\n    const response = await client.createEmbeddings(\n      {\n        input: text,\n        model: resolvedModel,\n      },\n      EMBED_REQUEST_OPTS,\n    );\n\n    if (opts.json) {\n      console.log(JSON.stringify(response, null, 2));\n      return;\n    }\n\n    const vectors = Array.isArray(response.data) ? response.data : [];\n    const dimensions = vectors[0]?.embedding?.length ?? 0;\n    const totalTokens = response.usage?.total_tokens;\n\n    console.log(chalk.green('') + ` Embedded 1 input using ${response.model}`);\n    console.log(chalk.dim(`  vectors: ${vectors.length}`));\n    if (dimensions > 0) {\n      console.log(chalk.dim(`  dimensions: ${dimensions}`));\n    }\n    if (typeof totalTokens === 'number') {\n      console.log(chalk.dim(`  tokens: ${totalTokens}`));\n    }\n\n    if (dimensions > 0) {\n      const sample = vectors[0]!.embedding.slice(0, 8).map((value) => Number(value.toFixed(6)));\n      const suffix = vectors[0]!.embedding.length > 8 ? ', ...' : '';\n      console.log(chalk.dim(`  preview: [${sample.join(', ')}${suffix}]`));\n    }\n  } catch (err) {\n    if (err instanceof LmxApiError && err.code === 'connection_error') {\n      console.error(\n        chalk.red('')\n        + ` Unable to reach Opta LMX at ${config.connection.host}:${config.connection.port}`,\n      );\n      console.error(chalk.dim(`  ${err.message}`));\n      throw new ExitError(EXIT.NO_CONNECTION);\n    }\n\n    console.error(chalk.red('') + ` Failed to create embedding: ${errorMessage(err)}`);\n    throw new ExitError(EXIT.ERROR);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/commands/env.ts","messages":[{"ruleId":"@typescript-eslint/no-dynamic-delete","severity":1,"message":"Do not delete dynamically computed property keys.","line":347,"column":19,"nodeType":"Identifier","messageId":"dynamicDelete","endLine":347,"endColumn":30}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import chalk from 'chalk';\nimport { getConfigStore, loadConfig, saveConfig } from '../core/config.js';\nimport { EXIT, ExitError } from '../core/errors.js';\nimport { lookupContextLimit } from '../lmx/client.js';\nimport { normalizeConfiguredModelId } from '../lmx/model-lifecycle.js';\n\ninterface EnvCommandOptions {\n  json?: boolean;\n  host?: string;\n  port?: string;\n  adminKey?: string;\n  model?: string;\n  provider?: string;\n  mode?: string;\n}\n\ntype ProviderName = 'lmx' | 'anthropic';\ntype DefaultMode = 'safe' | 'auto' | 'plan' | 'review' | 'research' | 'dangerous' | 'ci';\n\nexport interface EnvProfile {\n  name: string;\n  connection: {\n    host: string;\n    port: number;\n    adminKey?: string;\n  };\n  modelDefault: string;\n  provider: ProviderName;\n  defaultMode: DefaultMode;\n  updatedAt: number;\n}\n\nconst ENV_PROFILES_KEY = 'profiles.environments';\nconst ENV_CURRENT_KEY = 'profiles.activeEnvironment';\nconst VALID_PROVIDERS = new Set<ProviderName>(['lmx', 'anthropic']);\nconst VALID_MODES = new Set<DefaultMode>([\n  'safe',\n  'auto',\n  'plan',\n  'review',\n  'research',\n  'dangerous',\n  'ci',\n]);\n\nfunction parsePort(value: string | undefined, fallback: number): number {\n  if (!value || !value.trim()) return fallback;\n  const parsed = Number.parseInt(value, 10);\n  if (!Number.isFinite(parsed) || parsed < 1 || parsed > 65535) {\n    console.error(chalk.red('') + ` Invalid port: ${value}`);\n    throw new ExitError(EXIT.MISUSE);\n  }\n  return parsed;\n}\n\nfunction parseProvider(value: string | undefined, fallback: ProviderName): ProviderName {\n  if (!value || !value.trim()) return fallback;\n  const normalized = value.trim().toLowerCase() as ProviderName;\n  if (!VALID_PROVIDERS.has(normalized)) {\n    console.error(chalk.red('') + ` Invalid provider: ${value}`);\n    throw new ExitError(EXIT.MISUSE);\n  }\n  return normalized;\n}\n\nfunction parseMode(value: string | undefined, fallback: DefaultMode): DefaultMode {\n  if (!value || !value.trim()) return fallback;\n  const normalized = value.trim().toLowerCase() as DefaultMode;\n  if (!VALID_MODES.has(normalized)) {\n    console.error(chalk.red('') + ` Invalid mode: ${value}`);\n    throw new ExitError(EXIT.MISUSE);\n  }\n  return normalized;\n}\n\nexport function normalizeEnvProfileName(name: string): string {\n  return name\n    .trim()\n    .toLowerCase()\n    .replace(/\\s+/g, '-')\n    .replace(/[^a-z0-9._-]/g, '');\n}\n\nfunction sanitizeProfiles(raw: unknown): Record<string, EnvProfile> {\n  if (!raw || typeof raw !== 'object' || Array.isArray(raw)) return {};\n\n  const out: Record<string, EnvProfile> = {};\n  for (const [key, value] of Object.entries(raw as Record<string, unknown>)) {\n    if (!value || typeof value !== 'object' || Array.isArray(value)) continue;\n    const obj = value as Record<string, unknown>;\n    const host = typeof obj.connection === 'object' && obj.connection !== null\n      ? (obj.connection as Record<string, unknown>).host\n      : undefined;\n    const port = typeof obj.connection === 'object' && obj.connection !== null\n      ? (obj.connection as Record<string, unknown>).port\n      : undefined;\n    const adminKey = typeof obj.connection === 'object' && obj.connection !== null\n      ? (obj.connection as Record<string, unknown>).adminKey\n      : undefined;\n    const modelDefault = obj.modelDefault;\n    const provider = obj.provider;\n    const defaultMode = obj.defaultMode;\n    const updatedAt = obj.updatedAt;\n\n    if (typeof host !== 'string' || !host.trim()) continue;\n    if (typeof port !== 'number' || !Number.isFinite(port)) continue;\n    if (typeof modelDefault !== 'string') continue;\n    if (provider !== 'lmx' && provider !== 'anthropic') continue;\n    if (typeof defaultMode !== 'string' || !VALID_MODES.has(defaultMode as DefaultMode)) continue;\n\n    const normalized = normalizeEnvProfileName(typeof obj.name === 'string' ? obj.name : key);\n    if (!normalized) continue;\n\n    const normalizedModelDefault = normalizeConfiguredModelId(modelDefault);\n    out[normalized] = {\n      name: normalized,\n      connection: {\n        host: host.trim(),\n        port: Math.max(1, Math.floor(port)),\n        ...(typeof adminKey === 'string' && adminKey.length > 0 ? { adminKey } : {}),\n      },\n      modelDefault: normalizedModelDefault,\n      provider,\n      defaultMode: defaultMode as DefaultMode,\n      updatedAt: typeof updatedAt === 'number' && Number.isFinite(updatedAt) ? updatedAt : Date.now(),\n    };\n  }\n\n  return out;\n}\n\nasync function readProfiles(): Promise<Record<string, EnvProfile>> {\n  const store = await getConfigStore();\n  return sanitizeProfiles(store.get(ENV_PROFILES_KEY));\n}\n\nasync function writeProfiles(profiles: Record<string, EnvProfile>): Promise<void> {\n  const store = await getConfigStore();\n  store.set(ENV_PROFILES_KEY, profiles);\n}\n\nasync function getCurrentProfileName(): Promise<string | undefined> {\n  const store = await getConfigStore();\n  const raw = store.get(ENV_CURRENT_KEY);\n  if (typeof raw !== 'string' || !raw.trim()) return undefined;\n  return normalizeEnvProfileName(raw);\n}\n\nasync function setCurrentProfileName(name: string): Promise<void> {\n  const store = await getConfigStore();\n  store.set(ENV_CURRENT_KEY, name);\n}\n\nfunction formatRelativeTime(timestampMs: number): string {\n  const diffMs = Date.now() - timestampMs;\n  const mins = Math.max(1, Math.round(diffMs / 60_000));\n  if (mins < 60) return `${mins}m ago`;\n  const hours = Math.round(mins / 60);\n  if (hours < 48) return `${hours}h ago`;\n  const days = Math.round(hours / 24);\n  return `${days}d ago`;\n}\n\nfunction printHelp(): void {\n  console.log(chalk.bold('Environment Profiles\\n'));\n  console.log(`  ${chalk.reset('opta env')}                         list profiles`);\n  console.log(`  ${chalk.reset('opta env list')}                    list profiles`);\n  console.log(`  ${chalk.reset('opta env show [name]')}             show a profile (or active one)`);\n  console.log(`  ${chalk.reset('opta env save <name>')}             save current/overridden settings as profile`);\n  console.log(`  ${chalk.reset('opta env use <name>')}              apply profile to active config`);\n  console.log(`  ${chalk.reset('opta env delete <name>')}           remove a profile`);\n  console.log('');\n  console.log(chalk.dim('Flags for save: --host --port --admin-key --model --provider --mode --json'));\n}\n\nasync function listProfiles(opts: EnvCommandOptions): Promise<void> {\n  const profiles = await readProfiles();\n  const current = await getCurrentProfileName();\n  const entries = Object.values(profiles).sort((a, b) => b.updatedAt - a.updatedAt);\n\n  if (opts.json) {\n    console.log(JSON.stringify({ current, profiles: entries }, null, 2));\n    return;\n  }\n\n  console.log(chalk.bold('Environment Profiles\\n'));\n  if (entries.length === 0) {\n    console.log(chalk.dim('  No environment profiles saved yet.'));\n    console.log(chalk.dim(`  Save one with ${chalk.reset('opta env save laptop')}`));\n    return;\n  }\n\n  for (const profile of entries) {\n    const active = current === profile.name;\n    const dot = active ? chalk.green('') : chalk.dim('');\n    const activeTag = active ? chalk.green(' active') : '';\n    const admin = profile.connection.adminKey ? 'admin-key' : 'no-admin-key';\n    console.log(\n      `  ${dot} ${chalk.bold(profile.name)}${activeTag} ` +\n      chalk.dim(`(${profile.connection.host}:${profile.connection.port}  ${profile.provider}  ${profile.defaultMode}  ${admin}  ${formatRelativeTime(profile.updatedAt)})`),\n    );\n    if (profile.modelDefault) {\n      console.log(chalk.dim(`     model ${profile.modelDefault}`));\n    }\n  }\n}\n\nasync function showProfile(name: string | undefined, opts: EnvCommandOptions): Promise<void> {\n  const profiles = await readProfiles();\n  const current = await getCurrentProfileName();\n  const resolvedName = name ? normalizeEnvProfileName(name) : current;\n\n  if (!resolvedName) {\n    console.error(chalk.red('') + ' No active environment profile');\n    throw new ExitError(EXIT.NOT_FOUND);\n  }\n\n  const profile = profiles[resolvedName];\n  if (!profile) {\n    console.error(chalk.red('') + ` Environment profile not found: ${resolvedName}`);\n    throw new ExitError(EXIT.NOT_FOUND);\n  }\n\n  if (opts.json) {\n    console.log(JSON.stringify({ current, profile }, null, 2));\n    return;\n  }\n\n  console.log(chalk.bold(`Environment  ${profile.name}\\n`));\n  console.log(`  Host:        ${profile.connection.host}`);\n  console.log(`  Port:        ${profile.connection.port}`);\n  console.log(`  Admin key:   ${profile.connection.adminKey ? chalk.green('set') : chalk.dim('not set')}`);\n  console.log(`  Provider:    ${profile.provider}`);\n  console.log(`  Mode:        ${profile.defaultMode}`);\n  console.log(`  Model:       ${profile.modelDefault || chalk.dim('(empty)')}`);\n  console.log(`  Updated:     ${new Date(profile.updatedAt).toLocaleString()}`);\n  if (current === profile.name) {\n    console.log(chalk.green('\\n  Active profile'));\n  }\n}\n\nasync function saveProfile(name: string | undefined, opts: EnvCommandOptions): Promise<void> {\n  const profileName = normalizeEnvProfileName(name ?? '');\n  if (!profileName) {\n    console.error(chalk.red('') + ' Missing profile name');\n    throw new ExitError(EXIT.MISUSE);\n  }\n\n  const config = await loadConfig();\n  const host = (opts.host ?? config.connection.host).trim();\n  if (!host) {\n    console.error(chalk.red('') + ' Host cannot be empty');\n    throw new ExitError(EXIT.MISUSE);\n  }\n\n  const profile: EnvProfile = {\n    name: profileName,\n    connection: {\n      host,\n      port: parsePort(opts.port, config.connection.port),\n      ...(opts.adminKey !== undefined\n        ? (opts.adminKey.trim() ? { adminKey: opts.adminKey.trim() } : {})\n        : (config.connection.adminKey ? { adminKey: config.connection.adminKey } : {})),\n    },\n    modelDefault: normalizeConfiguredModelId(opts.model?.trim() ?? config.model.default),\n    provider: parseProvider(opts.provider, config.provider.active),\n    defaultMode: parseMode(opts.mode, config.defaultMode),\n    updatedAt: Date.now(),\n  };\n\n  const profiles = await readProfiles();\n  profiles[profileName] = profile;\n  await writeProfiles(profiles);\n\n  const current = await getCurrentProfileName();\n  if (!current) {\n    await setCurrentProfileName(profileName);\n  }\n\n  if (opts.json) {\n    console.log(JSON.stringify({ saved: profileName, profile }, null, 2));\n    return;\n  }\n\n  console.log(chalk.green('') + ` Saved environment profile ${chalk.bold(profileName)}`);\n  console.log(chalk.dim(`  Use ${chalk.reset(`opta env use ${profileName}`)} to apply it`));\n}\n\nasync function useProfile(name: string | undefined, opts: EnvCommandOptions): Promise<void> {\n  const profileName = normalizeEnvProfileName(name ?? '');\n  if (!profileName) {\n    console.error(chalk.red('') + ' Missing profile name');\n    throw new ExitError(EXIT.MISUSE);\n  }\n\n  const profiles = await readProfiles();\n  const profile = profiles[profileName];\n  if (!profile) {\n    console.error(chalk.red('') + ` Environment profile not found: ${profileName}`);\n    throw new ExitError(EXIT.NOT_FOUND);\n  }\n\n  const effectiveModelDefault = normalizeConfiguredModelId(profile.modelDefault);\n  const updates: Record<string, unknown> = {\n    'connection.host': profile.connection.host,\n    'connection.port': profile.connection.port,\n    'provider.active': profile.provider,\n    defaultMode: profile.defaultMode,\n    'model.default': effectiveModelDefault,\n    'model.contextLimit': lookupContextLimit(effectiveModelDefault),\n  };\n\n  await saveConfig(updates);\n  const store = await getConfigStore();\n  if (profile.connection.adminKey) {\n    store.set('connection.adminKey', profile.connection.adminKey);\n  } else {\n    store.delete('connection.adminKey');\n  }\n  await setCurrentProfileName(profile.name);\n\n  if (opts.json) {\n    console.log(JSON.stringify({ active: profile.name, applied: updates }, null, 2));\n    return;\n  }\n\n  console.log(chalk.green('') + ` Activated environment ${chalk.bold(profile.name)}`);\n  console.log(chalk.dim(`  ${profile.connection.host}:${profile.connection.port}  ${profile.provider}  ${profile.defaultMode}`));\n  if (profile.modelDefault) {\n    console.log(chalk.dim(`  model ${profile.modelDefault}`));\n  }\n}\n\nasync function deleteProfile(name: string | undefined, opts: EnvCommandOptions): Promise<void> {\n  const profileName = normalizeEnvProfileName(name ?? '');\n  if (!profileName) {\n    console.error(chalk.red('') + ' Missing profile name');\n    throw new ExitError(EXIT.MISUSE);\n  }\n\n  const profiles = await readProfiles();\n  if (!profiles[profileName]) {\n    console.error(chalk.red('') + ` Environment profile not found: ${profileName}`);\n    throw new ExitError(EXIT.NOT_FOUND);\n  }\n\n  delete profiles[profileName];\n  await writeProfiles(profiles);\n\n  const current = await getCurrentProfileName();\n  const store = await getConfigStore();\n  if (current === profileName) {\n    const remaining = Object.keys(profiles).sort();\n    if (remaining.length > 0) {\n      store.set(ENV_CURRENT_KEY, remaining[0]);\n    } else {\n      store.delete(ENV_CURRENT_KEY);\n    }\n  }\n\n  if (opts.json) {\n    console.log(JSON.stringify({ deleted: profileName }, null, 2));\n    return;\n  }\n\n  console.log(chalk.green('') + ` Deleted environment ${chalk.bold(profileName)}`);\n}\n\nexport async function envCommand(\n  action?: string,\n  name?: string,\n  opts: EnvCommandOptions = {},\n): Promise<void> {\n  const normalizedAction = (action ?? 'list').toLowerCase();\n\n  switch (normalizedAction) {\n    case 'help':\n      printHelp();\n      return;\n    case 'list':\n    case 'ls':\n      await listProfiles(opts);\n      return;\n    case 'show':\n    case 'current':\n      await showProfile(name, opts);\n      return;\n    case 'save':\n    case 'set':\n      await saveProfile(name, opts);\n      return;\n    case 'use':\n    case 'switch':\n      await useProfile(name, opts);\n      return;\n    case 'delete':\n    case 'remove':\n    case 'rm':\n      await deleteProfile(name, opts);\n      return;\n    default:\n      console.error(chalk.red('') + ` Unknown env action: ${normalizedAction}`);\n      throw new ExitError(EXIT.MISUSE);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/commands/init.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/commands/key.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, value is always truthy.","line":393,"column":15,"nodeType":"MemberExpression","messageId":"alwaysTruthy","endLine":393,"endColumn":29},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":1,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":428,"column":76,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":428,"endColumn":103,"fix":{"range":[13178,13188],"text":""}},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":462,"column":14,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":462,"endColumn":16,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[14343,14345],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":470,"column":16,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":470,"endColumn":18,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[14573,14575],"text":"."},"desc":"Remove unnecessary optional chain"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { randomBytes } from 'node:crypto';\nimport chalk from 'chalk';\nimport { execa } from 'execa';\nimport { getConfigStore, loadConfig } from '../core/config.js';\nimport { ExitError, EXIT } from '../core/errors.js';\nimport { resolveRemoteHostCandidates, selectReachableRemoteHost } from './update.js';\n\nconst SSH_CONNECT_TIMEOUT_SECONDS = 25;\n\nexport type KeySource = 'env' | 'config' | 'unset';\n\ninterface ResolvedKey {\n  key: string | null;\n  source: KeySource;\n}\n\ninterface SshConfig {\n  host: string;\n  user: string;\n  identityFile?: string;\n}\n\ninterface CommandResult {\n  exitCode: number;\n  stdout: string;\n  stderr: string;\n}\n\ninterface KeyCreateOptions {\n  value?: string;\n  remote?: boolean;\n  copy?: boolean;\n  json?: boolean;\n}\n\ninterface KeyShowOptions {\n  reveal?: boolean;\n  copy?: boolean;\n  json?: boolean;\n}\n\ninterface KeyCopyOptions {\n  json?: boolean;\n}\n\ninterface ParsedRemotePath {\n  configPath: string | null;\n}\n\nfunction quoteSh(input: string): string {\n  return `'${input.replace(/'/g, `'\"'\"'`)}'`;\n}\n\nfunction expandHome(input: string): string {\n  if (!input.startsWith('~')) return input;\n  const home = process.env['HOME'] ?? '';\n  return input.replace(/^~(?=$|\\/)/, home);\n}\n\nfunction isLocalHost(host: string): boolean {\n  const lower = host.trim().toLowerCase();\n  return lower === 'localhost' || lower === '127.0.0.1';\n}\n\nfunction summarizeOutput(raw: string): string {\n  const line = raw\n    .split('\\n')\n    .map((part) => part.trim())\n    .find((part) => part.length > 0);\n  return line ?? 'unknown error';\n}\n\nexport function generateOptaInferenceKey(): string {\n  return `opta_sk_${randomBytes(24).toString('base64url')}`;\n}\n\nexport function maskKey(key: string): string {\n  if (!key) return '(none)';\n  if (key.length <= 10) return '*'.repeat(key.length);\n  return `${key.slice(0, 7)}${'*'.repeat(Math.max(0, key.length - 11))}${key.slice(-4)}`;\n}\n\nexport function resolveConfiguredInferenceKey(connection: { apiKey?: string }): ResolvedKey {\n  const envKey = process.env['OPTA_API_KEY']?.trim();\n  if (envKey) {\n    return { key: envKey, source: 'env' };\n  }\n\n  const configKey = connection.apiKey?.trim();\n  if (configKey) {\n    return { key: configKey, source: 'config' };\n  }\n\n  return { key: null, source: 'unset' };\n}\n\nfunction parseRemoteConfigPath(output: string): ParsedRemotePath {\n  for (const rawLine of output.split('\\n')) {\n    const line = rawLine.trim();\n    const match = /^__LMX_CFG_PATH__:(.+)$/.exec(line);\n    if (match) {\n      return { configPath: match[1] ?? null };\n    }\n  }\n  return { configPath: null };\n}\n\nasync function runRemoteCommand(ssh: SshConfig, command: string): Promise<CommandResult> {\n  const commandWithPath = `export PATH=/opt/homebrew/bin:/usr/local/bin:$PATH; ${command}`;\n  const args: string[] = [\n    '-o', 'BatchMode=yes',\n    '-o', `ConnectTimeout=${SSH_CONNECT_TIMEOUT_SECONDS}`,\n    '-o', 'ServerAliveInterval=5',\n    '-o', 'ServerAliveCountMax=2',\n  ];\n\n  if (ssh.identityFile) {\n    args.push('-i', ssh.identityFile);\n  }\n  args.push(`${ssh.user}@${ssh.host}`, `bash -lc ${quoteSh(commandWithPath)}`);\n\n  const result = await execa('ssh', args, { reject: false });\n  return {\n    exitCode: result.exitCode ?? 1,\n    stdout: result.stdout,\n    stderr: result.stderr,\n  };\n}\n\nasync function selectRemoteHost(\n  host: string,\n  fallbackHosts: readonly string[],\n  sshUser: string,\n  identityFile?: string,\n): Promise<{ selectedHost: string | null; detail: string }> {\n  const candidates = resolveRemoteHostCandidates(host, fallbackHosts);\n  const selection = await selectReachableRemoteHost(candidates, async (candidateHost) => {\n    return runRemoteCommand(\n      {\n        host: candidateHost,\n        user: sshUser,\n        identityFile,\n      },\n      'echo connected',\n    );\n  });\n\n  if (!selection.selectedHost) {\n    const detail = selection.probes.map((probe) => `${probe.host}: ${summarizeOutput(probe.detail)}`).join('; ');\n    return { selectedHost: null, detail: detail || 'ssh probe failed' };\n  }\n\n  return { selectedHost: selection.selectedHost, detail: 'ok' };\n}\n\nasync function applyRemoteInferenceKey(\n  ssh: SshConfig,\n  lmxPath: string,\n  key: string,\n): Promise<{ ok: boolean; configPath?: string; message: string }> {\n  const script = [\n    `OPTA_LMX_PATH=${quoteSh(lmxPath)};`,\n    `OPTA_INFERENCE_KEY=${quoteSh(key)};`,\n    'export OPTA_LMX_PATH OPTA_INFERENCE_KEY;',\n    \"python3 - <<'PY'\",\n    'import os, re, sys',\n    'from pathlib import Path',\n    '',\n    'lmx_path = Path(os.environ[\"OPTA_LMX_PATH\"]).expanduser()',\n    'key = os.environ[\"OPTA_INFERENCE_KEY\"]',\n    '',\n    'candidates = [',\n    '    lmx_path / \"config\" / \"mono512-current.yaml\",',\n    '    lmx_path / \"config\" / \"config.yaml\",',\n    '    Path.home() / \".opta-lmx\" / \"config.yaml\",',\n    '    lmx_path / \"config\" / \"default-config.yaml\",',\n    ']',\n    'target = None',\n    'for c in candidates:',\n    '    if c.exists():',\n    '        target = c',\n    '        break',\n    '',\n    'if target is None:',\n    '    print(\"__LMX_CFG_ERROR__:config_not_found\")',\n    '    sys.exit(41)',\n    '',\n    'text = target.read_text(encoding=\"utf-8\")',\n    'lines = text.splitlines()',\n    '',\n    'security_idx = None',\n    'for i, line in enumerate(lines):',\n    '    if re.match(r\"^\\\\s*security:\\\\s*$\", line):',\n    '        security_idx = i',\n    '        break',\n    '',\n    'if security_idx is None:',\n    '    lines.append(\"security:\")',\n    '    lines.append(f\\'  inference_api_key: \"{key}\"\\')',\n    'else:',\n    '    key_idx = None',\n    '    for i, line in enumerate(lines):',\n    '        if re.match(r\"^\\\\s*inference_api_key\\\\s*:\", line):',\n    '            key_idx = i',\n    '            break',\n    '    if key_idx is not None:',\n    '        m = re.match(r\"^(\\\\s*inference_api_key\\\\s*:\\\\s*)(.*?)(\\\\s*(#.*)?)$\", lines[key_idx])',\n    '        if m:',\n    '            lines[key_idx] = f\\'{m.group(1)}\"{key}\"{m.group(3) or \"\"}\\'',\n    '        else:',\n    '            lines[key_idx] = f\\'  inference_api_key: \"{key}\"\\'',\n    '    else:',\n    '        lines.insert(security_idx + 1, f\\'  inference_api_key: \"{key}\"\\')',\n    '',\n    'updated = \"\\\\n\".join(lines)',\n    'if text.endswith(\"\\\\n\"):',\n    '    updated += \"\\\\n\"',\n    'target.write_text(updated, encoding=\"utf-8\")',\n    'print(f\"__LMX_CFG_PATH__:{target}\")',\n    'PY',\n  ].join('\\n');\n\n  const result = await runRemoteCommand(ssh, script);\n  if (result.exitCode !== 0) {\n    return {\n      ok: false,\n      message: summarizeOutput(result.stderr || result.stdout),\n    };\n  }\n\n  const parsed = parseRemoteConfigPath(`${result.stdout}\\n${result.stderr}`);\n  if (!parsed.configPath) {\n    return {\n      ok: false,\n      message: 'remote config updated but path marker missing',\n    };\n  }\n\n  return {\n    ok: true,\n    configPath: parsed.configPath,\n    message: 'remote inference_api_key updated',\n  };\n}\n\nasync function reloadLmxConfig(host: string, port: number, adminKey?: string): Promise<{ ok: boolean; message: string }> {\n  if (!adminKey?.trim()) {\n    return {\n      ok: false,\n      message: \"connection.adminKey is required to trigger /admin/config/reload\",\n    };\n  }\n\n  try {\n    const response = await fetch(`http://${host}:${port}/admin/config/reload`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-Admin-Key': adminKey.trim(),\n      },\n      signal: AbortSignal.timeout(5000),\n    });\n    if (!response.ok) {\n      const body = await response.text().catch(() => '');\n      return {\n        ok: false,\n        message: `reload failed: HTTP ${response.status} ${summarizeOutput(body || response.statusText)}`,\n      };\n    }\n    return { ok: true, message: 'LMX config reloaded' };\n  } catch (err) {\n    const message = err instanceof Error ? err.message : 'reload failed';\n    return { ok: false, message };\n  }\n}\n\nasync function verifyInferenceKey(host: string, port: number, key: string): Promise<{ ok: boolean; message: string }> {\n  try {\n    const response = await fetch(`http://${host}:${port}/v1/models`, {\n      headers: {\n        Authorization: `Bearer ${key}`,\n      },\n      signal: AbortSignal.timeout(5000),\n    });\n    if (!response.ok) {\n      const body = await response.text().catch(() => '');\n      return {\n        ok: false,\n        message: `verification failed: HTTP ${response.status} ${summarizeOutput(body || response.statusText)}`,\n      };\n    }\n    return { ok: true, message: 'key accepted by /v1/models' };\n  } catch (err) {\n    return {\n      ok: false,\n      message: err instanceof Error ? err.message : 'verification failed',\n    };\n  }\n}\n\nasync function copyToClipboard(value: string): Promise<{ ok: boolean; message: string }> {\n  const text = value.trim();\n  if (!text) return { ok: false, message: 'empty key cannot be copied' };\n\n  if (process.platform === 'darwin') {\n    try {\n      const result = await execa('pbcopy', [], { input: text, reject: false });\n      return result.exitCode === 0\n        ? { ok: true, message: 'copied to clipboard (pbcopy)' }\n        : { ok: false, message: result.stderr || 'pbcopy failed' };\n    } catch (err) {\n      return {\n        ok: false,\n        message: err instanceof Error ? err.message : 'pbcopy failed',\n      };\n    }\n  }\n\n  const linuxCandidates: Array<{ cmd: string; args: string[] }> = [\n    { cmd: 'wl-copy', args: [] },\n    { cmd: 'xclip', args: ['-selection', 'clipboard'] },\n    { cmd: 'xsel', args: ['--clipboard', '--input'] },\n  ];\n  const attempts: string[] = [];\n  for (const candidate of linuxCandidates) {\n    try {\n      const result = await execa(candidate.cmd, candidate.args, {\n        input: text,\n        reject: false,\n      });\n      if (result.exitCode === 0) {\n        return { ok: true, message: `copied to clipboard (${candidate.cmd})` };\n      }\n      attempts.push(`${candidate.cmd}: ${result.stderr || `exit ${result.exitCode ?? 1}`}`);\n    } catch (err) {\n      attempts.push(\n        `${candidate.cmd}: ${err instanceof Error ? err.message : 'failed to execute'}`,\n      );\n    }\n  }\n\n  if (attempts.length > 0) {\n    return { ok: false, message: `no clipboard utility succeeded (${attempts.join('; ')})` };\n  }\n  return { ok: false, message: 'no supported clipboard utility found' };\n}\n\nexport async function keyCreate(opts?: KeyCreateOptions): Promise<void> {\n  const config = await loadConfig();\n  const key = opts?.value?.trim() || generateOptaInferenceKey();\n\n  const store = await getConfigStore();\n  store.set('connection.apiKey', key);\n\n  const remoteRequested = opts?.remote !== false;\n  const shouldCopy = opts?.copy !== false;\n  const remoteHost = config.connection.host;\n  const output: Record<string, unknown> = {\n    key,\n    source: 'config',\n    remote: null,\n    copy: null,\n  };\n\n  if (remoteRequested && !isLocalHost(remoteHost)) {\n    const selected = await selectRemoteHost(\n      remoteHost,\n      config.connection.fallbackHosts,\n      config.connection.ssh.user,\n      expandHome(config.connection.ssh.identityFile),\n    );\n    if (!selected.selectedHost) {\n      output.remote = { ok: false, message: `ssh unavailable: ${selected.detail}` };\n      if (!opts?.json) {\n        console.log(chalk.yellow('!') + ` Studio sync skipped: ${selected.detail}`);\n      }\n    } else {\n      const ssh: SshConfig = {\n        host: selected.selectedHost,\n        user: config.connection.ssh.user,\n        identityFile: expandHome(config.connection.ssh.identityFile),\n      };\n      const remoteApply = await applyRemoteInferenceKey(ssh, config.connection.ssh.lmxPath, key);\n      if (!remoteApply.ok) {\n        output.remote = { ok: false, message: remoteApply.message };\n        if (!opts?.json) {\n          console.log(chalk.red('') + ` Studio key update failed: ${remoteApply.message}`);\n        }\n      } else {\n        const reload = await reloadLmxConfig(ssh.host, config.connection.port, config.connection.adminKey);\n        const verify = await verifyInferenceKey(ssh.host, config.connection.port, key);\n        output.remote = {\n          ok: remoteApply.ok && reload.ok && verify.ok,\n          host: ssh.host,\n          configPath: remoteApply.configPath,\n          reload: reload.message,\n          verify: verify.message,\n        };\n\n        if (!opts?.json) {\n          console.log(chalk.green('') + ` Studio key synced on ${ssh.host}`);\n          console.log(chalk.dim(`  Config: ${remoteApply.configPath}`));\n          console.log(chalk.dim(`  Reload: ${reload.message}`));\n          console.log(chalk.dim(`  Verify: ${verify.message}`));\n        }\n      }\n    }\n  } else if (remoteRequested) {\n    output.remote = { ok: true, message: 'remote sync skipped for localhost' };\n  } else {\n    output.remote = { ok: true, message: 'remote sync disabled (--no-remote)' };\n  }\n\n  if (shouldCopy) {\n    const copied = await copyToClipboard(key);\n    output.copy = copied;\n    if (!opts?.json) {\n      if (copied.ok) {\n        console.log(chalk.green('') + ` ${copied.message}`);\n      } else {\n        console.log(chalk.yellow('!') + ` ${copied.message}`);\n      }\n    }\n  }\n\n  if (opts?.json) {\n    const safeOutput = { ...output };\n    if (typeof safeOutput['key'] === 'string') safeOutput['key'] = maskKey(safeOutput['key'] as string);\n    console.log(JSON.stringify(safeOutput, null, 2));\n    return;\n  }\n\n  console.log('');\n  console.log(chalk.bold('Opta Inference API Key'));\n  console.log(`Base URL: http://${config.connection.host}:${config.connection.port}/v1`);\n  console.log(`API Key:  ${maskKey(key)}`);\n  console.log(chalk.dim('(Full key was copied to clipboard  paste it now, it will not be shown again)'));\n  console.log(chalk.dim('Use in clients as Authorization: Bearer <API Key>'));\n}\n\nexport async function keyShow(opts?: KeyShowOptions): Promise<void> {\n  const config = await loadConfig();\n  const resolved = resolveConfiguredInferenceKey(config.connection);\n\n  if (!resolved.key) {\n    if (opts?.json) {\n      console.log(JSON.stringify({\n        key: null,\n        source: resolved.source,\n        configured: false,\n      }, null, 2));\n      return;\n    }\n    console.log(chalk.yellow('!') + ' No inference API key configured yet.');\n    console.log(chalk.dim('Run: opta key create'));\n    return;\n  }\n\n  const displayKey = opts?.reveal ? resolved.key : maskKey(resolved.key);\n  if (opts?.copy) {\n    const copied = await copyToClipboard(resolved.key);\n    if (!opts?.json) {\n      if (copied.ok) console.log(chalk.green('') + ` ${copied.message}`);\n      else console.log(chalk.yellow('!') + ` ${copied.message}`);\n    }\n  }\n\n  if (opts?.json) {\n    console.log(JSON.stringify({\n      key: opts?.reveal ? resolved.key : displayKey,\n      source: resolved.source,\n      configured: true,\n    }, null, 2));\n    return;\n  }\n\n  console.log(`Key (${resolved.source}): ${displayKey}`);\n  if (!opts?.reveal) {\n    console.log(chalk.dim('Tip: use --reveal to print full key, or --copy to copy.'));\n  }\n}\n\nexport async function keyCopy(opts?: KeyCopyOptions): Promise<void> {\n  const config = await loadConfig();\n  const resolved = resolveConfiguredInferenceKey(config.connection);\n  if (!resolved.key) {\n    const message = 'No inference API key configured yet. Run: opta key create';\n    if (opts?.json) {\n      console.log(JSON.stringify({ ok: false, message }, null, 2));\n    } else {\n      console.log(chalk.yellow('!') + ` ${message}`);\n    }\n    throw new ExitError(EXIT.NOT_FOUND);\n  }\n\n  const copied = await copyToClipboard(resolved.key);\n  if (opts?.json) {\n    console.log(JSON.stringify(copied, null, 2));\n  }\n\n  if (copied.ok) {\n    if (!opts?.json) {\n      console.log(chalk.green('') + ` ${copied.message}`);\n    }\n    return;\n  }\n\n  if (!opts?.json) {\n    console.log(chalk.red('') + ` Failed to copy key: ${copied.message}`);\n  }\n  throw new ExitError(EXIT.ERROR);\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/commands/keychain.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/commands/mcp.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":75,"column":15,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":75,"endColumn":24},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":116,"column":20,"nodeType":"TSAsExpression","messageId":"neverNullish","endLine":116,"endColumn":71},{"ruleId":"@typescript-eslint/no-dynamic-delete","severity":1,"message":"Do not delete dynamically computed property keys.","line":123,"column":18,"nodeType":"Identifier","messageId":"dynamicDelete","endLine":123,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import chalk from 'chalk';\nimport { loadConfig, saveConfig, getConfigStore } from '../core/config.js';\nimport { connectMcpServer } from '../mcp/client.js';\nimport { errorMessage } from '../utils/errors.js';\nimport { createPlaywrightMcpServerConfig } from '../browser/mcp-bootstrap.js';\nimport type { BrowserMode } from '../browser/types.js';\n\ninterface McpListOptions {\n  json?: boolean;\n}\n\ninterface McpAddPlaywrightOptions {\n  name?: string;\n  mode?: BrowserMode;\n  command?: string;\n  packageName?: string;\n  allowedHosts?: string[];\n  blockedOrigins?: string[];\n  env?: string;\n}\n\nconst PLAYWRIGHT_MCP_SERVER_KEY = 'playwright';\n\nfunction parseEnvPairs(raw?: string): Record<string, string> {\n  const env: Record<string, string> = {};\n  if (!raw) return env;\n\n  for (const pair of raw.split(',')) {\n    const idx = pair.indexOf('=');\n    if (idx <= 0) continue;\n\n    const key = pair.slice(0, idx).trim();\n    const value = pair.slice(idx + 1).trim();\n    if (!key || !value) continue;\n\n    env[key] = value;\n  }\n\n  return env;\n}\n\nexport async function mcpList(opts: McpListOptions): Promise<void> {\n  const config = await loadConfig();\n  const servers = config.mcp.servers;\n  const entries = Object.entries(servers);\n\n  if (entries.length === 0) {\n    console.log(chalk.dim('No MCP servers configured.'));\n    console.log(chalk.dim('\\nAdd one with: opta mcp add <name> <command>'));\n    return;\n  }\n\n  if (opts.json) {\n    console.log(JSON.stringify(servers, null, 2));\n    return;\n  }\n\n  console.log(chalk.bold(`\\n${entries.length} MCP server(s):\\n`));\n  for (const [name, cfg] of entries) {\n    const transport =\n      cfg.transport === 'stdio'\n        ? `${cfg.command} ${cfg.args.join(' ')}`.trim()\n        : cfg.url;\n    console.log(`  ${chalk.cyan(name)}  ${chalk.dim(cfg.transport)}  ${transport}`);\n  }\n  console.log();\n}\n\nexport async function mcpAdd(\n  name: string,\n  command: string,\n  opts: { env?: string }\n): Promise<void> {\n  const parts = command.split(/\\s+/);\n  const cmd = parts[0]!;\n  const args = parts.slice(1);\n\n  const env = parseEnvPairs(opts.env);\n\n  await saveConfig({\n    mcp: {\n      servers: {\n        [name]: { transport: 'stdio', command: cmd, args, env },\n      },\n    },\n  });\n\n  console.log(chalk.green('\\u2713') + ` Added MCP server: ${name}`);\n}\n\nexport async function mcpAddPlaywright(opts: McpAddPlaywrightOptions = {}): Promise<void> {\n  const name = opts.name?.trim() || PLAYWRIGHT_MCP_SERVER_KEY;\n  const env = parseEnvPairs(opts.env);\n  const serverConfig = createPlaywrightMcpServerConfig({\n    command: opts.command,\n    packageName: opts.packageName,\n    mode: opts.mode,\n    allowedHosts: opts.allowedHosts,\n    blockedOrigins: opts.blockedOrigins,\n    env,\n  });\n\n  await saveConfig({\n    mcp: {\n      servers: {\n        [name]: serverConfig,\n      },\n    },\n  });\n\n  console.log(chalk.green('\\u2713') + ` Added MCP server: ${name}`);\n}\n\nexport async function mcpRemove(name: string): Promise<void> {\n  const store = await getConfigStore();\n  const servers = (store.get('mcp.servers') as Record<string, unknown>) ?? {};\n\n  if (!(name in servers)) {\n    console.log(chalk.yellow(`MCP server \"${name}\" not found in config.`));\n    return;\n  }\n\n  delete servers[name];\n  store.set('mcp.servers', servers);\n  console.log(chalk.green('\\u2713') + ` Removed MCP server: ${name}`);\n}\n\nexport async function mcpTest(name: string): Promise<void> {\n  const config = await loadConfig();\n  const serverConfig = config.mcp.servers[name];\n\n  if (!serverConfig) {\n    console.log(chalk.red('\\u2717') + ` MCP server \"${name}\" not found in config.`);\n    return;\n  }\n\n  console.log(chalk.dim(`Connecting to ${name}...`));\n  try {\n    const conn = await connectMcpServer(name, serverConfig);\n    console.log(chalk.green('\\u2713') + ` Connected to ${name}`);\n    console.log(chalk.dim(`  ${conn.tools.length} tools available:`));\n    for (const tool of conn.tools) {\n      console.log(`    ${chalk.cyan(tool.name)}  ${tool.description}`);\n    }\n    await conn.close();\n    console.log(chalk.green('\\u2713') + ' Connection closed cleanly');\n  } catch (err) {\n    console.log(chalk.red('\\u2717') + ` Failed: ${errorMessage(err)}`);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/commands/models.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-type-conversion","severity":1,"message":"Passing a boolean to Boolean() does not change the type or value of the boolean.","line":151,"column":10,"nodeType":"Identifier","messageId":"unnecessaryTypeConversion","endLine":151,"endColumn":17,"suggestions":[{"messageId":"suggestRemove","fix":{"range":[4391,4465],"text":"(process.stdout.isTTY && process.stdin.isTTY && !process.env['CI'])"},"desc":"Remove the type conversion."},{"messageId":"suggestSatisfies","data":{"type":"boolean"},"fix":{"range":[4391,4465],"text":"(process.stdout.isTTY && process.stdin.isTTY && !process.env['CI']) satisfies boolean"},"desc":"Instead, assert that the value satisfies the boolean type."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, value is always truthy.","line":295,"column":12,"nodeType":"Literal","messageId":"alwaysTruthy","endLine":295,"endColumn":16},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe object destructuring of a property with an `any` value.","line":296,"column":15,"nodeType":"Identifier","messageId":"unsafeObjectPattern","endLine":296,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `ArrayBuffer | ArrayBufferView<ArrayBufferLike> | null | undefined`.","line":298,"column":32,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":298,"endColumn":37},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":1,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":553,"column":15,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":553,"endColumn":42,"fix":{"range":[17429,17440],"text":""}},{"ruleId":"@typescript-eslint/require-await","severity":1,"message":"Async method 'source' has no 'await' expression.","line":897,"column":9,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":897,"endColumn":23,"suggestions":[{"messageId":"removeAsync","fix":{"range":[29825,29831],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":910,"column":26,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":910,"endColumn":39},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":959,"column":30,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":959,"endColumn":40,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[31834,31835],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":959,"column":49,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":959,"endColumn":59,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[31853,31854],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":960,"column":12,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":960,"endColumn":22,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[31884,31885],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-unnecessary-template-expression","severity":1,"message":"Template literal expression is unnecessary and can be simplified.","line":1327,"column":20,"nodeType":null,"messageId":"noUnnecessaryTemplateExpression","endLine":1327,"endColumn":48,"fix":{"range":[44881,44911],"text":"chalk.dim('Refresh list')"}},{"ruleId":"@typescript-eslint/no-unnecessary-template-expression","severity":1,"message":"Template literal expression is unnecessary and can be simplified.","line":1331,"column":20,"nodeType":null,"messageId":"noUnnecessaryTemplateExpression","endLine":1331,"endColumn":40,"fix":{"range":[44983,45005],"text":"chalk.dim('Exit')"}},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":1382,"column":56,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":1382,"endColumn":72},{"ruleId":"@typescript-eslint/require-await","severity":1,"message":"Async method 'source' has no 'await' expression.","line":1400,"column":9,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":1400,"endColumn":23,"suggestions":[{"messageId":"removeAsync","fix":{"range":[47390,47396],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, value is always truthy.","line":1660,"column":10,"nodeType":"Literal","messageId":"alwaysTruthy","endLine":1660,"endColumn":14},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, comparison is always true, since `\"benchmark-chat\" === \"benchmark-chat\"` is true.","line":1702,"column":9,"nodeType":"BinaryExpression","messageId":"comparisonBetweenLiteralTypes","endLine":1702,"endColumn":36},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":1732,"column":19,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":1732,"endColumn":49},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, value is always truthy.","line":1746,"column":10,"nodeType":"Literal","messageId":"alwaysTruthy","endLine":1746,"endColumn":14},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, value is always truthy.","line":1764,"column":10,"nodeType":"Literal","messageId":"alwaysTruthy","endLine":1764,"endColumn":14},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":1,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":1796,"column":24,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":1796,"endColumn":115,"fix":{"range":[61896,61923],"text":""}},{"ruleId":"@typescript-eslint/no-dynamic-delete","severity":1,"message":"Do not delete dynamically computed property keys.","line":1967,"column":18,"nodeType":"Identifier","messageId":"dynamicDelete","endLine":1967,"endColumn":27},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, value is always truthy.","line":1991,"column":10,"nodeType":"Literal","messageId":"alwaysTruthy","endLine":1991,"endColumn":14},{"ruleId":"@typescript-eslint/no-unnecessary-template-expression","severity":1,"message":"Template literal expression is unnecessary and can be simplified.","line":2441,"column":22,"nodeType":null,"messageId":"noUnnecessaryTemplateExpression","endLine":2441,"endColumn":39,"fix":{"range":[84308,84327],"text":"bar.padEnd(20)"}},{"ruleId":"@typescript-eslint/no-unnecessary-type-conversion","severity":1,"message":"Passing a string to String() does not change the type or value of the string.","line":2564,"column":22,"nodeType":"Identifier","messageId":"unnecessaryTypeConversion","endLine":2564,"endColumn":28,"suggestions":[{"messageId":"suggestRemove","fix":{"range":[88464,88495],"text":"(job.status ?? 'unknown')"},"desc":"Remove the type conversion."},{"messageId":"suggestSatisfies","data":{"type":"string"},"fix":{"range":[88464,88495],"text":"(job.status ?? 'unknown') satisfies string"},"desc":"Instead, assert that the value satisfies the string type."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":2619,"column":21,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":2619,"endColumn":31},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":2719,"column":21,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":2719,"endColumn":31},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":2764,"column":29,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":2764,"endColumn":42},{"ruleId":"@typescript-eslint/no-unnecessary-type-conversion","severity":1,"message":"Passing a string to String() does not change the type or value of the string.","line":2770,"column":26,"nodeType":"Identifier","messageId":"unnecessaryTypeConversion","endLine":2770,"endColumn":32,"suggestions":[{"messageId":"suggestRemove","fix":{"range":[95515,95546],"text":"(run.status ?? 'unknown')"},"desc":"Remove the type conversion."},{"messageId":"suggestSatisfies","data":{"type":"string"},"fix":{"range":[95515,95546],"text":"(run.status ?? 'unknown') satisfies string"},"desc":"Instead, assert that the value satisfies the string type."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":2770,"column":33,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":2770,"endColumn":43},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":2796,"column":21,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":2796,"endColumn":31},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'request.strategy ?? strategy' will use Object's default stringification format ('[object Object]') when stringified.","line":2934,"column":39,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":2934,"endColumn":67},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":2983,"column":21,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":2983,"endColumn":31},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'parsed.error ?? 'unknown error'' will use Object's default stringification format ('[object Object]') when stringified.","line":3051,"column":42,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":3051,"endColumn":73},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":3102,"column":21,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":3102,"endColumn":31},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":3183,"column":21,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":3183,"endColumn":31},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":3251,"column":21,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":3251,"endColumn":31},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":3295,"column":21,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":3295,"endColumn":31},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":3411,"column":21,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":3411,"endColumn":31},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":3503,"column":21,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":3503,"endColumn":31},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":3664,"column":21,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":3664,"endColumn":31},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":3906,"column":21,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":3906,"endColumn":38}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":41,"fixableErrorCount":0,"fixableWarningCount":5,"source":"import chalk from 'chalk';\nimport { spawn } from 'node:child_process';\nimport { readFile } from 'node:fs/promises';\nimport { dirname } from 'node:path';\nimport { loadConfig, saveConfig, getConfigStore } from '../core/config.js';\nimport { formatError, OptaError, ExitError, EXIT } from '../core/errors.js';\nimport { createSpinner, type Spinner } from '../ui/spinner.js';\nimport { renderPercentBar } from '../ui/progress.js';\nimport { runMenuPrompt } from '../ui/prompt-nav.js';\nimport { errorMessage } from '../utils/errors.js';\nimport { LmxClient, LmxApiError, lookupContextLimit } from '../lmx/client.js';\nimport type { LmxAvailableModel, LmxMemoryResponse, LmxModelDetail, LmxRequestOptions } from '../lmx/client.js';\nimport {\n  ensureModelLoaded,\n  findMatchingModelId,\n  normalizeConfiguredModelId,\n  isPlaceholderModelId,\n  modelIdsEqual,\n  normalizeModelIdKey,\n  waitForModelUnloaded,\n  type ModelLoadProgress,\n} from '../lmx/model-lifecycle.js';\nimport {\n  scanModels as gatherScanData,\n  buildRoleMap,\n  shortId,\n  fmtGB,\n  fmtCtx,\n  summarizeScan,\n} from '../providers/model-scan.js';\nimport { getDisplayProfile, formatTagLabel } from '../core/model-display.js';\nimport type { ModelFormat } from '../core/model-display.js';\n\ninterface ModelsOptions {\n  json?: boolean;\n}\n\ninterface ModelPickerOption {\n  id: string;\n  source: 'loaded' | 'disk';\n  contextLength?: number;\n  memoryBytes?: number;\n  sizeBytes?: number;\n  requestCount?: number;\n}\n\ninterface RankedModelMatch {\n  id: string;\n  score: number;\n}\n\ntype ModelHistoryAction = 'detected' | 'downloaded' | 'loaded' | 'deleted' | 'chat';\n\nexport interface ModelHistoryEntry {\n  id: string;\n  firstSeenAt: number;\n  lastSeenAt: number;\n  lastAction: ModelHistoryAction;\n}\n\ninterface HfModelApiItem {\n  id: string;\n  downloads?: number;\n  likes?: number;\n  lastModified?: string;\n  pipeline_tag?: string;\n  tags?: string[];\n}\n\ninterface LibraryModelEntry {\n  id: string;\n  source: 'local' | 'history' | 'library';\n  loaded: boolean;\n  downloaded: boolean;\n  contextLength: number;\n  localPath?: string;\n  sizeBytes?: number;\n  downloadedAt?: number;\n  historyLastSeenAt?: number;\n  downloads?: number;\n  likes?: number;\n  lastModified?: string;\n  pipelineTag?: string;\n  tags?: string[];\n}\n\ntype ModelBrowserAction =\n  | 'info'\n  | 'use-chat'\n  | 'download'\n  | 'delete'\n  | 'open-file'\n  | 'open-download'\n  | 'benchmark-chat'\n  | 'back';\n\nconst MODEL_HISTORY_KEY = 'models.history';\nconst MODEL_ALIASES_KEY = 'models.aliases';\nconst MODEL_HISTORY_LIMIT = 800;\nconst HF_CATALOG_LIMIT = 250;\nconst HF_QUERY_LIMIT = 120;\nconst MODEL_ALIAS_LIMIT = 300;\nconst STABLE_MODEL_LOAD_TIMEOUT_MS = 300_000;\nconst STABLE_MODEL_LOAD_REQUEST_TIMEOUT_MS = 15_000;\nconst FAST_DISCOVERY_TIMEOUT_MS = 5_000;\nconst FAST_DISCOVERY_REQUEST_OPTS: LmxRequestOptions = {\n  timeoutMs: FAST_DISCOVERY_TIMEOUT_MS,\n  maxRetries: 0,\n};\nconst MODEL_INVENTORY_WARNINGS = new Set<string>();\n\ntype ModelAliasMap = Record<string, string>;\n\n/**\n * Build a user-facing warning when model inventory/admin calls fail but the command can continue.\n */\nexport function formatModelInventoryWarning(scope: string, err: unknown): string {\n  if (err instanceof LmxApiError) {\n    if (err.code === 'unauthorized' || err.status === 403) {\n      return `LMX denied access to ${scope} (403 unauthorized). Check connection.adminKey.`;\n    }\n    if (err.code === 'connection_error') {\n      return `LMX unreachable while fetching ${scope}: ${err.message}`;\n    }\n    return `Failed to fetch ${scope} from LMX: ${err.message}`;\n  }\n  if (err instanceof Error) {\n    return `Failed to fetch ${scope}: ${err.message}`;\n  }\n  return `Failed to fetch ${scope} from LMX.`;\n}\n\nfunction warnModelInventoryFallback(scope: string, err: unknown): void {\n  const message = formatModelInventoryWarning(scope, err);\n  if (MODEL_INVENTORY_WARNINGS.has(message)) return;\n  MODEL_INVENTORY_WARNINGS.add(message);\n  console.error(chalk.yellow('!') + ` ${message}`);\n}\n\n/** Colored format tag for a model's format type. */\nfunction fmtTag(format: ModelFormat): string {\n  switch (format) {\n    case 'MLX': return chalk.hex('#a855f7')(formatTagLabel(format));\n    case 'GGUF': return chalk.yellow(formatTagLabel(format));\n    case 'CLOUD': return chalk.blue(formatTagLabel(format));\n    default: return chalk.dim(formatTagLabel(format));\n  }\n}\n\nfunction isInteractiveTerminal(): boolean {\n  return Boolean(process.stdout.isTTY && process.stdin.isTTY && !process.env['CI']);\n}\n\n/**\n * Normalize user-entered model text for forgiving matching.\n */\nexport function normalizeModelKey(input: string): string {\n  return input.toLowerCase().replace(/[^a-z0-9]+/g, '');\n}\n\nfunction modelAliases(modelId: string): string[] {\n  const lower = modelId.toLowerCase();\n  const tail = lower.split('/').pop() ?? lower;\n  const dotTail = lower.split('.').pop() ?? lower;\n  const aliases = [\n    lower,\n    tail,\n    dotTail,\n    normalizeModelKey(lower),\n    normalizeModelKey(tail),\n    normalizeModelKey(dotTail),\n  ];\n  return [...new Set(aliases.filter(Boolean))];\n}\n\nfunction splitQueryTokens(text: string): string[] {\n  return (text.toLowerCase().match(/[a-z]+|\\d+/g) ?? [])\n    .map((token) => normalizeModelKey(token))\n    .filter(Boolean);\n}\n\nfunction parseShellLikeArgs(raw: string): string[] {\n  const tokens: string[] = [];\n  const pattern = /\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\"|'([^'\\\\]*(?:\\\\.[^'\\\\]*)*)'|`([^`\\\\]*(?:\\\\.[^`\\\\]*)*)`|([^\\s]+)/g;\n  let match: RegExpExecArray | null;\n\n  while ((match = pattern.exec(raw)) !== null) {\n    const captured = match[1] ?? match[2] ?? match[3] ?? match[4] ?? '';\n    tokens.push(captured.replace(/\\\\([\"'`\\\\])/g, '$1'));\n  }\n\n  return tokens;\n}\n\nasync function readStdinText(): Promise<string> {\n  if (process.stdin.isTTY) return '';\n  const chunks: Buffer[] = [];\n  for await (const chunk of process.stdin) {\n    chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(String(chunk)));\n  }\n  return Buffer.concat(chunks).toString('utf8');\n}\n\nasync function resolveDataSource(raw: string, flagName: string): Promise<string> {\n  if (raw === '-') {\n    const piped = await readStdinText();\n    if (!piped.trim()) {\n      throw new Error(`${flagName} requested stdin (\"-\"), but no stdin data was provided`);\n    }\n    return piped;\n  }\n  if (raw.startsWith('@')) {\n    const filePath = raw.slice(1).trim();\n    if (!filePath) {\n      throw new Error(`${flagName} @file path is empty`);\n    }\n    return readFile(filePath, 'utf8');\n  }\n  return raw;\n}\n\nasync function parseJsonValueOption(raw: string, flagName: string): Promise<unknown> {\n  const source = await resolveDataSource(raw, flagName);\n  try {\n    return JSON.parse(source);\n  } catch (err) {\n    throw new Error(`${flagName} must be valid JSON: ${errorMessage(err)}`);\n  }\n}\n\nasync function parseJsonObjectOption(raw: string, flagName: string): Promise<Record<string, unknown>> {\n  const parsed = await parseJsonValueOption(raw, flagName);\n  if (!parsed || typeof parsed !== 'object' || Array.isArray(parsed)) {\n    throw new Error(`${flagName} must resolve to a JSON object`);\n  }\n  return parsed as Record<string, unknown>;\n}\n\nfunction parseCsvList(raw: string | undefined): string[] {\n  if (!raw) return [];\n  return raw\n    .split(',')\n    .map((entry) => entry.trim())\n    .filter(Boolean);\n}\n\ninterface ParsedSseEvent {\n  event: string;\n  data: string;\n}\n\nasync function streamSseEvents(\n  url: string,\n  headers: Record<string, string>,\n  timeoutMs: number,\n): Promise<{ events: ParsedSseEvent[]; timedOut: boolean }> {\n  const controller = new AbortController();\n  const timer = setTimeout(() => controller.abort(), timeoutMs);\n  const events: ParsedSseEvent[] = [];\n  let timedOut = false;\n\n  const pushEvent = (eventName: string, dataLines: string[]): void => {\n    if (dataLines.length === 0) return;\n    events.push({\n      event: eventName || 'message',\n      data: dataLines.join('\\n'),\n    });\n  };\n\n  try {\n    const response = await fetch(url, {\n      method: 'GET',\n      headers,\n      signal: controller.signal,\n    });\n    if (!response.ok) {\n      const body = await response.text().catch(() => '');\n      throw new Error(`HTTP ${response.status} ${response.statusText}${body ? `: ${body.trim()}` : ''}`);\n    }\n\n    if (!response.body) {\n      const text = await response.text();\n      if (text.trim()) {\n        events.push({ event: 'message', data: text });\n      }\n      return { events, timedOut: false };\n    }\n\n    const decoder = new TextDecoder();\n    const reader = response.body.getReader();\n    let buffer = '';\n    let currentEvent = 'message';\n    let dataLines: string[] = [];\n\n    while (true) {\n      const { value, done } = await reader.read();\n      if (done) break;\n      buffer += decoder.decode(value, { stream: true });\n      let newlineIdx = buffer.search(/\\r?\\n/);\n      while (newlineIdx !== -1) {\n        const line = buffer.slice(0, newlineIdx).replace(/\\r$/, '');\n        buffer = buffer.slice(newlineIdx + (buffer[newlineIdx] === '\\r' && buffer[newlineIdx + 1] === '\\n' ? 2 : 1));\n        if (!line) {\n          pushEvent(currentEvent, dataLines);\n          currentEvent = 'message';\n          dataLines = [];\n          newlineIdx = buffer.search(/\\r?\\n/);\n          continue;\n        }\n        if (line.startsWith(':')) {\n          newlineIdx = buffer.search(/\\r?\\n/);\n          continue;\n        }\n        if (line.startsWith('event:')) {\n          currentEvent = line.slice(6).trim() || 'message';\n          newlineIdx = buffer.search(/\\r?\\n/);\n          continue;\n        }\n        if (line.startsWith('data:')) {\n          dataLines.push(line.slice(5).trimStart());\n        }\n        newlineIdx = buffer.search(/\\r?\\n/);\n      }\n    }\n\n    if (buffer.trim()) {\n      const line = buffer.replace(/\\r$/, '');\n      if (line.startsWith('event:')) currentEvent = line.slice(6).trim() || currentEvent;\n      else if (line.startsWith('data:')) dataLines.push(line.slice(5).trimStart());\n    }\n    pushEvent(currentEvent, dataLines);\n    return { events, timedOut: false };\n  } catch (err) {\n    if (err instanceof DOMException && err.name === 'AbortError') {\n      timedOut = true;\n      return { events, timedOut };\n    }\n    throw err;\n  } finally {\n    clearTimeout(timer);\n  }\n}\n\nfunction matchesTokenSequence(target: string, tokens: string[]): boolean {\n  if (tokens.length === 0) return false;\n  let position = 0;\n  for (const token of tokens) {\n    const next = target.indexOf(token, position);\n    if (next === -1) return false;\n    position = next + token.length;\n  }\n  return true;\n}\n\nfunction scoreModelMatch(\n  modelId: string,\n  rawQuery: string,\n  normalizedQuery: string,\n  queryTokens: string[],\n  extraAliases: string[] = [],\n): number | null {\n  const aliases = [...modelAliases(modelId), ...extraAliases.map((alias) => alias.toLowerCase())];\n  const normalizedAliases = [...new Set(aliases.map(normalizeModelKey).filter(Boolean))];\n\n  if (aliases.some((a) => a === rawQuery || a === normalizedQuery)) return 0;\n  if (aliases.some((a) => a.startsWith(rawQuery) || a.startsWith(normalizedQuery))) return 1;\n  if (aliases.some((a) => a.includes(rawQuery) || a.includes(normalizedQuery))) return 2;\n  if (queryTokens.length > 1 && normalizedAliases.some((alias) => matchesTokenSequence(alias, queryTokens))) return 3;\n  return null;\n}\n\n/**\n * Rank model IDs by fuzzy relevance for non-exact name input.\n */\nexport function rankModelIds(ids: string[], query: string, aliasMap: ModelAliasMap = {}): RankedModelMatch[] {\n  const raw = query.trim().toLowerCase();\n  const normalized = normalizeModelKey(raw);\n  const queryTokens = splitQueryTokens(raw);\n  if (!raw) return [];\n  const aliasEntries = Object.entries(aliasMap);\n\n  return ids\n    .map((id) => {\n      const relatedAliases = aliasEntries\n        .filter(([, target]) => modelIdsEqual(target, id))\n        .map(([alias]) => alias);\n      const score = scoreModelMatch(id, raw, normalized, queryTokens, relatedAliases);\n      return score === null ? null : { id, score };\n    })\n    .filter((v): v is RankedModelMatch => v !== null)\n    .sort((a, b) => a.score - b.score || a.id.length - b.id.length || a.id.localeCompare(b.id));\n}\n\nfunction normalizeHistoryAction(value: unknown): ModelHistoryAction {\n  if (value === 'downloaded') return 'downloaded';\n  if (value === 'loaded') return 'loaded';\n  if (value === 'deleted') return 'deleted';\n  if (value === 'chat') return 'chat';\n  return 'detected';\n}\n\nfunction normalizeAliasName(alias: string): string {\n  return alias\n    .trim()\n    .toLowerCase()\n    .replace(/\\s+/g, '-')\n    .replace(/[^a-z0-9._-]/g, '');\n}\n\nfunction normalizeModelAliasMap(raw: unknown): ModelAliasMap {\n  if (!raw || typeof raw !== 'object' || Array.isArray(raw)) return {};\n  const map: ModelAliasMap = {};\n  for (const [key, value] of Object.entries(raw as Record<string, unknown>)) {\n    if (typeof value !== 'string') continue;\n    const alias = normalizeAliasName(key);\n    const target = value.trim();\n    if (!alias || !target) continue;\n    map[alias] = target;\n  }\n  return map;\n}\n\nasync function readModelAliasMap(): Promise<ModelAliasMap> {\n  const store = await getConfigStore();\n  return normalizeModelAliasMap(store.get(MODEL_ALIASES_KEY));\n}\n\nasync function writeModelAliasMap(map: ModelAliasMap): Promise<void> {\n  const store = await getConfigStore();\n  const entries = Object.entries(map)\n    .sort((a, b) => a[0].localeCompare(b[0]))\n    .slice(0, MODEL_ALIAS_LIMIT);\n  store.set(MODEL_ALIASES_KEY, Object.fromEntries(entries));\n}\n\nfunction resolveModelAlias(query: string, aliases: ModelAliasMap): string | undefined {\n  const normalizedQuery = normalizeAliasName(query);\n  if (!normalizedQuery) return undefined;\n  return aliases[normalizedQuery];\n}\n\nfunction normalizeTimestamp(value: unknown, fallback: number): number {\n  const numeric = typeof value === 'number' && Number.isFinite(value) ? Math.floor(value) : null;\n  return numeric && numeric > 0 ? numeric : fallback;\n}\n\nexport function normalizeModelHistoryEntries(raw: unknown): ModelHistoryEntry[] {\n  if (!Array.isArray(raw)) return [];\n  const now = Date.now();\n  const byId = new Map<string, ModelHistoryEntry>();\n\n  for (const item of raw) {\n    if (!item || typeof item !== 'object') continue;\n    const idRaw = (item as { id?: unknown }).id;\n    if (typeof idRaw !== 'string') continue;\n    const id = idRaw.trim();\n    if (!id) continue;\n    const firstSeenAt = normalizeTimestamp((item as { firstSeenAt?: unknown }).firstSeenAt, now);\n    const lastSeenAt = normalizeTimestamp((item as { lastSeenAt?: unknown }).lastSeenAt, firstSeenAt);\n    const entry: ModelHistoryEntry = {\n      id,\n      firstSeenAt,\n      lastSeenAt: Math.max(lastSeenAt, firstSeenAt),\n      lastAction: normalizeHistoryAction((item as { lastAction?: unknown }).lastAction),\n    };\n\n    const existing = byId.get(id);\n    if (!existing || existing.lastSeenAt < entry.lastSeenAt) {\n      byId.set(id, entry);\n    }\n  }\n\n  return Array.from(byId.values()).sort((a, b) => b.lastSeenAt - a.lastSeenAt);\n}\n\nexport function mergeModelHistoryEntries(\n  existing: ModelHistoryEntry[],\n  modelIds: string[],\n  action: ModelHistoryAction,\n  now = Date.now(),\n): ModelHistoryEntry[] {\n  const byId = new Map(existing.map((entry) => [entry.id, entry] as const));\n\n  for (const rawId of modelIds) {\n    const id = rawId.trim();\n    if (!id) continue;\n    const current = byId.get(id);\n    if (current) {\n      byId.set(id, {\n        ...current,\n        lastSeenAt: Math.max(now, current.lastSeenAt),\n        lastAction: action,\n      });\n      continue;\n    }\n    byId.set(id, {\n      id,\n      firstSeenAt: now,\n      lastSeenAt: now,\n      lastAction: action,\n    });\n  }\n\n  return Array.from(byId.values())\n    .sort((a, b) => b.lastSeenAt - a.lastSeenAt)\n    .slice(0, MODEL_HISTORY_LIMIT);\n}\n\nasync function readModelHistory(): Promise<ModelHistoryEntry[]> {\n  const store = await getConfigStore();\n  const raw = store.get(MODEL_HISTORY_KEY);\n  return normalizeModelHistoryEntries(raw);\n}\n\nasync function writeModelHistory(entries: ModelHistoryEntry[]): Promise<void> {\n  const store = await getConfigStore();\n  store.set(MODEL_HISTORY_KEY, entries.slice(0, MODEL_HISTORY_LIMIT));\n}\n\nasync function recordModelHistory(modelIds: string[], action: ModelHistoryAction): Promise<void> {\n  if (modelIds.length === 0) return;\n  const current = await readModelHistory();\n  const merged = mergeModelHistoryEntries(current, modelIds, action);\n  await writeModelHistory(merged);\n}\n\nfunction formatCompactCount(value: number): string {\n  if (!Number.isFinite(value)) return '0';\n  if (value >= 1_000_000) return `${(value / 1_000_000).toFixed(1)}M`;\n  if (value >= 1_000) return `${(value / 1_000).toFixed(1)}K`;\n  return String(Math.round(value));\n}\n\nasync function fetchHuggingFaceModels(searchTerm?: string, limit = HF_CATALOG_LIMIT): Promise<HfModelApiItem[]> {\n  const params = new URLSearchParams();\n  params.set('limit', String(limit));\n  params.set('sort', 'downloads');\n  params.set('direction', '-1');\n  params.set('full', 'true');\n  if (searchTerm && searchTerm.trim()) {\n    params.set('search', searchTerm.trim());\n  }\n\n  const res = await fetch(`https://huggingface.co/api/models?${params.toString()}`, {\n    signal: AbortSignal.timeout(10_000),\n    headers: { 'User-Agent': 'opta-cli/0.5 model-browser' },\n  });\n\n  if (!res.ok) {\n    throw new Error(`Hugging Face catalog request failed (${res.status})`);\n  }\n\n  const raw = await res.json() as unknown;\n  if (!Array.isArray(raw)) return [];\n\n  const parsed: HfModelApiItem[] = [];\n  for (const item of raw) {\n    if (!item || typeof item !== 'object') continue;\n    const id = (item as { id?: unknown }).id;\n    if (typeof id !== 'string' || !id.trim()) continue;\n    const downloads = (item as { downloads?: unknown }).downloads;\n    const likes = (item as { likes?: unknown }).likes;\n    const lastModified = (item as { lastModified?: unknown }).lastModified;\n    const pipelineTag = (item as { pipeline_tag?: unknown }).pipeline_tag;\n    const tags = (item as { tags?: unknown }).tags;\n    parsed.push({\n      id: id.trim(),\n      downloads: typeof downloads === 'number' && Number.isFinite(downloads) ? downloads : undefined,\n      likes: typeof likes === 'number' && Number.isFinite(likes) ? likes : undefined,\n      lastModified: typeof lastModified === 'string' ? lastModified : undefined,\n      pipeline_tag: typeof pipelineTag === 'string' ? pipelineTag : undefined,\n      tags: Array.isArray(tags) ? tags.filter((t): t is string => typeof t === 'string') : undefined,\n    });\n  }\n\n  return parsed;\n}\n\ninterface LocalModelSnapshot {\n  loadedIds: Set<string>;\n  availableById: Map<string, LmxAvailableModel>;\n  historyById: Map<string, ModelHistoryEntry>;\n  downloadRoot?: string;\n}\n\nasync function loadLocalModelSnapshot(client: LmxClient): Promise<LocalModelSnapshot> {\n  const [loadedRes, availableRes, history] = await Promise.all([\n    client.models(FAST_DISCOVERY_REQUEST_OPTS).catch((err: unknown) => {\n      warnModelInventoryFallback('loaded models', err);\n      return { models: [] };\n    }),\n    client.available(FAST_DISCOVERY_REQUEST_OPTS).catch((err: unknown) => {\n      warnModelInventoryFallback('downloaded models', err);\n      return [] as LmxAvailableModel[];\n    }),\n    readModelHistory(),\n  ]);\n\n  const loadedIds = new Set(loadedRes.models.map((m) => m.model_id));\n  const availableById = new Map<string, LmxAvailableModel>();\n  for (const model of availableRes) {\n    availableById.set(model.repo_id, model);\n  }\n  if (availableRes.length > 0) {\n    await recordModelHistory(availableRes.map((m) => m.repo_id), 'detected');\n  }\n\n  const historyById = new Map<string, ModelHistoryEntry>();\n  for (const entry of history) {\n    historyById.set(entry.id, entry);\n  }\n\n  const firstPath = availableRes.find((m) => typeof m.local_path === 'string' && m.local_path.trim().length > 0)?.local_path;\n  const downloadRoot = firstPath ? dirname(firstPath) : undefined;\n\n  return { loadedIds, availableById, historyById, downloadRoot };\n}\n\nfunction mergeCatalogEntries(\n  snapshot: LocalModelSnapshot,\n  hfEntries: HfModelApiItem[],\n): LibraryModelEntry[] {\n  const byId = new Map<string, LibraryModelEntry>();\n\n  for (const item of hfEntries) {\n    byId.set(item.id, {\n      id: item.id,\n      source: 'library',\n      loaded: snapshot.loadedIds.has(item.id),\n      downloaded: snapshot.availableById.has(item.id),\n      contextLength: lookupContextLimit(item.id),\n      downloads: item.downloads,\n      likes: item.likes,\n      lastModified: item.lastModified,\n      pipelineTag: item.pipeline_tag,\n      tags: item.tags,\n    });\n  }\n\n  for (const [id, local] of snapshot.availableById.entries()) {\n    const existing = byId.get(id);\n    const base: LibraryModelEntry = existing ?? {\n      id,\n      source: 'local',\n      loaded: false,\n      downloaded: true,\n      contextLength: lookupContextLimit(id),\n    };\n    byId.set(id, {\n      ...base,\n      source: 'local',\n      loaded: snapshot.loadedIds.has(id),\n      downloaded: true,\n      localPath: local.local_path,\n      sizeBytes: local.size_bytes > 0 ? local.size_bytes : undefined,\n      downloadedAt: typeof local.downloaded_at === 'number' ? local.downloaded_at * 1000 : undefined,\n      contextLength: lookupContextLimit(id),\n    });\n  }\n\n  for (const [id, history] of snapshot.historyById.entries()) {\n    const existing = byId.get(id);\n    if (existing) {\n      byId.set(id, {\n        ...existing,\n        historyLastSeenAt: history.lastSeenAt,\n      });\n      continue;\n    }\n    byId.set(id, {\n      id,\n      source: 'history',\n      loaded: snapshot.loadedIds.has(id),\n      downloaded: false,\n      contextLength: lookupContextLimit(id),\n      historyLastSeenAt: history.lastSeenAt,\n    });\n  }\n\n  return Array.from(byId.values());\n}\n\nfunction sortCatalogEntries(entries: LibraryModelEntry[]): LibraryModelEntry[] {\n  const sourceWeight = (source: LibraryModelEntry['source']): number => {\n    if (source === 'local') return 0;\n    if (source === 'history') return 1;\n    return 2;\n  };\n\n  return entries.slice().sort((a, b) => {\n    if (a.loaded !== b.loaded) return a.loaded ? -1 : 1;\n    if (a.downloaded !== b.downloaded) return a.downloaded ? -1 : 1;\n    const sw = sourceWeight(a.source) - sourceWeight(b.source);\n    if (sw !== 0) return sw;\n    const dls = (b.downloads ?? -1) - (a.downloads ?? -1);\n    if (dls !== 0) return dls;\n    return a.id.localeCompare(b.id);\n  });\n}\n\nfunction rankCatalogEntries(entries: LibraryModelEntry[], query: string): LibraryModelEntry[] {\n  const q = query.trim();\n  if (!q) return sortCatalogEntries(entries);\n\n  const raw = q.toLowerCase();\n  const normalized = normalizeModelKey(raw);\n  const tokens = splitQueryTokens(raw);\n  const ranked = entries\n    .map((entry) => {\n      const idScore = scoreModelMatch(entry.id, raw, normalized, tokens);\n      const metaBlob = `${entry.pipelineTag ?? ''} ${(entry.tags ?? []).join(' ')}`.toLowerCase();\n      const metaMatch = normalized.length > 0 && normalizeModelKey(metaBlob).includes(normalized);\n      if (idScore === null && !metaMatch) return null;\n      return {\n        entry,\n        score: idScore ?? 5,\n        metaPenalty: metaMatch && idScore === null ? 1 : 0,\n      };\n    })\n    .filter((item): item is { entry: LibraryModelEntry; score: number; metaPenalty: number } => item !== null)\n    .sort((a, b) => {\n      if (a.score !== b.score) return a.score - b.score;\n      if (a.metaPenalty !== b.metaPenalty) return a.metaPenalty - b.metaPenalty;\n      if ((b.entry.downloads ?? -1) !== (a.entry.downloads ?? -1)) {\n        return (b.entry.downloads ?? -1) - (a.entry.downloads ?? -1);\n      }\n      return a.entry.id.localeCompare(b.entry.id);\n    });\n\n  return ranked.map((r) => r.entry);\n}\n\nfunction formatCatalogEntryLabel(entry: LibraryModelEntry, defaultModel: string): string {\n  const dot = entry.loaded\n    ? chalk.green('')\n    : entry.downloaded\n      ? chalk.cyan('')\n      : entry.source === 'history'\n        ? chalk.yellow('')\n        : chalk.dim('');\n  const defaultStar = entry.id === defaultModel ? chalk.green(' ') : '';\n  const sourceTag =\n    entry.loaded\n      ? 'loaded'\n      : entry.downloaded\n        ? 'on disk'\n        : entry.source === 'history'\n          ? 'history'\n          : 'library';\n  const metadata: string[] = [sourceTag, fmtCtx(entry.contextLength)];\n  if (entry.sizeBytes && entry.sizeBytes > 0) metadata.push(`${fmtGB(entry.sizeBytes)} disk`);\n  if (typeof entry.downloads === 'number') metadata.push(`${formatCompactCount(entry.downloads)} dl`);\n  if (typeof entry.likes === 'number') metadata.push(`${formatCompactCount(entry.likes)} likes`);\n  if (entry.pipelineTag) metadata.push(entry.pipelineTag);\n  return `${dot} ${entry.id}  ${chalk.dim(metadata.join('  '))}${defaultStar}`;\n}\n\nfunction formatModelOptionLabel(option: ModelPickerOption, defaultModel: string): string {\n  const isDefault = option.id === defaultModel;\n  const bullet = option.source === 'loaded' ? chalk.green('') : chalk.dim('');\n  const role = option.source === 'loaded' ? chalk.dim('loaded') : chalk.dim('on disk');\n  const ctx = option.contextLength ? fmtCtx(option.contextLength) : '';\n  const mem = option.memoryBytes ? fmtGB(option.memoryBytes) : '';\n  const size = option.sizeBytes ? `${fmtGB(option.sizeBytes)} disk` : '';\n  const reqs = option.requestCount ? `${option.requestCount} reqs` : '';\n  const meta = [role, ctx, mem, size, reqs].filter(Boolean).join('  ');\n  const star = isDefault ? chalk.green(' ') : '';\n  return `${bullet} ${option.id}${meta ? `  ${chalk.dim(meta)}` : ''}${star}`;\n}\n\nfunction printModelMatches(ranked: RankedModelMatch[], limit = 8): void {\n  for (const match of ranked.slice(0, limit)) {\n    console.log(`  ${match.id}`);\n  }\n}\n\nfunction progressText(action: string, percent: number, detail: string): string {\n  return `${renderPercentBar(percent, 16)} ${action}${detail ? ` ${chalk.dim(detail)}` : ''}`;\n}\n\nconst LIFECYCLE_PROGRESS_MIN_HORIZON_MS = 15_000;\nconst LIFECYCLE_PROGRESS_MAX_HORIZON_MS = 90_000;\nconst LIFECYCLE_PROGRESS_HEARTBEAT_MS = 3_000;\n\nexport function computeLifecycleStagePercent(\n  startPercent: number,\n  progress: ModelLoadProgress,\n  previousPercent?: number,\n): number {\n  const clampedStart = Math.max(0, Math.min(99, Math.round(startPercent)));\n  if (progress.status === 'ready') return 100;\n\n  const span = Math.max(1, 99 - clampedStart);\n  const effectiveTimeoutMs = progress.timeoutMs > 0\n    ? Math.max(\n        LIFECYCLE_PROGRESS_MIN_HORIZON_MS,\n        Math.min(progress.timeoutMs, LIFECYCLE_PROGRESS_MAX_HORIZON_MS),\n      )\n    : LIFECYCLE_PROGRESS_MAX_HORIZON_MS;\n  const ratio = Math.max(0, Math.min(1, progress.elapsedMs / effectiveTimeoutMs));\n  const easedByTime = clampedStart + Math.floor(Math.sqrt(ratio) * span);\n  const heartbeat = clampedStart + Math.min(span - 1, Math.floor(progress.elapsedMs / LIFECYCLE_PROGRESS_HEARTBEAT_MS));\n  const attemptBump = clampedStart\n    + Math.min(span - 1, Math.floor(Math.log2(Math.max(2, progress.attempt + 1))));\n  const target = Math.max(clampedStart + 1, easedByTime, heartbeat, attemptBump);\n  const floorPercent = previousPercent == null ? clampedStart : Math.max(clampedStart, previousPercent);\n  return Math.min(99, Math.max(floorPercent, target));\n}\n\nfunction createLifecycleProgressUpdater(\n  spinner: Spinner,\n  action: string,\n  verb: string,\n  modelId: string,\n  startPercent: number,\n): (progress: ModelLoadProgress) => void {\n  const clampedStart = Math.max(0, Math.min(99, Math.round(startPercent)));\n  let lastSecond = -1;\n  let lastRenderedPercent = clampedStart;\n\n  return (progress: ModelLoadProgress): void => {\n    if (progress.status === 'ready') return;\n    const elapsedSeconds = Math.floor(progress.elapsedMs / 1000);\n    const nextPercent = computeLifecycleStagePercent(clampedStart, progress, lastRenderedPercent);\n    if (\n      elapsedSeconds === lastSecond\n      && nextPercent === lastRenderedPercent\n      && progress.elapsedMs > 0\n    ) {\n      return;\n    }\n    lastSecond = elapsedSeconds;\n    lastRenderedPercent = nextPercent;\n\n    spinner.start(\n      progressText(\n        action,\n        nextPercent,\n        `${verb} ${modelId}  ${elapsedSeconds}s`,\n      ),\n    );\n  };\n}\n\nfunction createLoadProgressUpdater(\n  spinner: Spinner,\n  action: string,\n  modelId: string,\n  startPercent: number,\n): (progress: ModelLoadProgress) => void {\n  return createLifecycleProgressUpdater(spinner, action, 'loading', modelId, startPercent);\n}\n\nfunction createUnloadProgressUpdater(\n  spinner: Spinner,\n  action: string,\n  modelId: string,\n  startPercent: number,\n): (progress: ModelLoadProgress) => void {\n  return createLifecycleProgressUpdater(spinner, action, 'unloading', modelId, startPercent);\n}\n\nfunction throwModelCommandError(err: unknown): never {\n  if (err instanceof ExitError) throw err;\n  if (err instanceof OptaError) {\n    console.error(formatError(err));\n    throw new ExitError(err.code);\n  }\n  if (err instanceof LmxApiError) {\n    console.error(chalk.red('') + ` ${err.message}`);\n    throw new ExitError(err.code === 'not_found' ? EXIT.NOT_FOUND : EXIT.ERROR);\n  }\n  if (err instanceof Error) {\n    console.error(chalk.red('') + ` ${err.message}`);\n    throw new ExitError(EXIT.ERROR);\n  }\n  console.error(chalk.red('') + ` ${errorMessage(err)}`);\n  throw new ExitError(EXIT.ERROR);\n}\n\nasync function promptModelSearch(\n  message: string,\n  options: ModelPickerOption[],\n  defaultModel: string,\n  aliasMap: ModelAliasMap = {},\n): Promise<string | null> {\n  if (options.length === 0) return null;\n\n  const { search } = await import('@inquirer/prompts');\n  const ids = options.map((o) => o.id);\n  const byId = new Map(options.map((o) => [o.id, o] as const));\n\n  try {\n    return await runMenuPrompt((context) =>\n      search<string>({\n        message: chalk.dim(message),\n        source: async (input?: string) => {\n          const q = (input ?? '').trim();\n          const ordered = q\n            ? rankModelIds(ids, q, aliasMap).map((m) => m.id)\n            : options\n              .slice()\n              .sort((a, b) => {\n                if (a.source !== b.source) return a.source === 'loaded' ? -1 : 1;\n                return a.id.localeCompare(b.id);\n              })\n              .map((o) => o.id);\n\n          return ordered.map((id) => {\n            const item = byId.get(id)!;\n            return {\n              value: id,\n              name: formatModelOptionLabel(item, defaultModel),\n            };\n          });\n        },\n      }, context), 'search');\n  } catch {\n    return null;\n  }\n}\n\nasync function resolveModelIdFromOptions(\n  query: string | undefined,\n  options: ModelPickerOption[],\n  defaultModel: string,\n  promptMessage: string,\n  aliasMap: ModelAliasMap = {},\n): Promise<string> {\n  if (options.length === 0) {\n    throw new ExitError(EXIT.NOT_FOUND);\n  }\n\n  if (!query || query.trim() === '') {\n    if (!isInteractiveTerminal()) {\n      console.error(chalk.red('') + ' Missing model name in non-interactive terminal');\n      printModelMatches(options.map((o) => ({ id: o.id, score: 0 })));\n      throw new ExitError(EXIT.MISUSE);\n    }\n    const selected = await promptModelSearch(promptMessage, options, defaultModel, aliasMap);\n    if (!selected) throw new ExitError(EXIT.SIGINT);\n    return selected;\n  }\n\n  const ids = options.map((o) => o.id);\n  const ranked = rankModelIds(ids, query, aliasMap);\n\n  if (ranked.length === 0) {\n    console.error(chalk.red('') + ` Model \"${query}\" not found`);\n    if (!isInteractiveTerminal()) {\n      printModelMatches(options.map((o) => ({ id: o.id, score: 0 })));\n      throw new ExitError(EXIT.NOT_FOUND);\n    }\n    const selected = await promptModelSearch(promptMessage, options, defaultModel, aliasMap);\n    if (!selected) throw new ExitError(EXIT.NOT_FOUND);\n    return selected;\n  }\n\n  if (ranked.length === 1 || ranked[0]!.score < ranked[1]!.score) {\n    return ranked[0]!.id;\n  }\n\n  if (!isInteractiveTerminal()) {\n    console.error(chalk.red('') + ` Ambiguous model \"${query}\"`);\n    printModelMatches(ranked);\n    throw new ExitError(EXIT.MISUSE);\n  }\n\n  const ambiguousOptions = options.filter((o) => ranked.slice(0, 12).some((m) => m.id === o.id));\n  const selected = await promptModelSearch(\n    `Multiple matches for \"${query}\"  choose model`,\n    ambiguousOptions,\n    defaultModel,\n    aliasMap,\n  );\n  if (!selected) throw new ExitError(EXIT.SIGINT);\n  return selected;\n}\n\nasync function getModelOptions(client: LmxClient): Promise<{ loaded: ModelPickerOption[]; onDisk: ModelPickerOption[] }> {\n  const [loadedRes, availableRes] = await Promise.all([\n    client.models(FAST_DISCOVERY_REQUEST_OPTS),\n    client.available(FAST_DISCOVERY_REQUEST_OPTS).catch((err: unknown) => {\n      warnModelInventoryFallback('downloaded models', err);\n      return [] as LmxAvailableModel[];\n    }),\n  ]);\n\n  const loaded = loadedRes.models.map((m) => ({\n    id: m.model_id,\n    source: 'loaded' as const,\n    contextLength: m.context_length ?? lookupContextLimit(m.model_id),\n    memoryBytes: m.memory_bytes,\n    requestCount: m.request_count,\n  }));\n\n  const loadedIds = new Set(loaded.map((m) => normalizeModelIdKey(m.id)));\n  const onDisk = availableRes\n    .filter((m) => !loadedIds.has(normalizeModelIdKey(m.repo_id)))\n    .map((m) => ({\n      id: m.repo_id,\n      source: 'disk' as const,\n      contextLength: lookupContextLimit(m.repo_id),\n      sizeBytes: m.size_bytes,\n    }));\n\n  return { loaded, onDisk };\n}\n\nasync function resolveEffectiveDefaultModel(\n  client: LmxClient,\n  configuredDefault: string,\n  opts?: ModelsOptions,\n): Promise<string> {\n  const normalized = normalizeConfiguredModelId(configuredDefault);\n  if (normalized) {\n    if (normalized !== configuredDefault) {\n      await saveConfig({\n        'model.default': normalized,\n        'model.contextLimit': lookupContextLimit(normalized),\n      }).catch(() => {});\n    }\n    return normalized;\n  }\n\n  const loaded = await client.models(FAST_DISCOVERY_REQUEST_OPTS).catch(() => ({ models: [] as LmxModelDetail[] }));\n  const fallbackLoaded = loaded.models[0]?.model_id;\n  if (fallbackLoaded) {\n    await saveConfig({\n      'model.default': fallbackLoaded,\n      'model.contextLimit': lookupContextLimit(fallbackLoaded),\n    }).catch(() => {});\n    if (!opts?.json) {\n      console.log(chalk.yellow('!') + ` Default model was unset; using loaded model ${fallbackLoaded}`);\n    }\n    return fallbackLoaded;\n  }\n\n  const available = await client.available(FAST_DISCOVERY_REQUEST_OPTS).catch(() => [] as LmxAvailableModel[]);\n  const fallbackOnDisk = available[0]?.repo_id;\n  if (fallbackOnDisk) {\n    await saveConfig({\n      'model.default': fallbackOnDisk,\n      'model.contextLimit': lookupContextLimit(fallbackOnDisk),\n    }).catch(() => {});\n    if (!opts?.json) {\n      console.log(chalk.yellow('!') + ` Default model was unset; using on-disk model ${fallbackOnDisk}`);\n    }\n    return fallbackOnDisk;\n  }\n\n  return '';\n}\n\nexport async function models(\n  action?: string,\n  name?: string,\n  extraArg?: string,\n  opts?: ModelsOptions\n): Promise<void> {\n  const config = await loadConfig();\n  const { host, port } = config.connection;\n  const client = new LmxClient({\n    host,\n    fallbackHosts: config.connection.fallbackHosts,\n    port,\n    adminKey: config.connection.adminKey,\n  });\n  const defaultModel = await resolveEffectiveDefaultModel(client, config.model.default, opts);\n  const effectiveConfig = { ...config, model: { ...config.model, default: defaultModel } };\n  const aliasMap = await readModelAliasMap();\n  const resolveWithAlias = (input?: string): string | undefined => {\n    if (!input) return input;\n    return resolveModelAlias(input, aliasMap) ?? input;\n  };\n  const resolvedName = action === 'alias' ? name : resolveWithAlias(name);\n  const resolvedExtra = action === 'swap' ? resolveWithAlias(extraArg) : extraArg;\n\n  switch (action) {\n    case 'help':\n      printModelsHelp();\n      return;\n    case 'list':\n      await listModels(client, defaultModel, opts);\n      return;\n    case 'manage':\n    case 'interactive':\n    case 'ui':\n      await interactiveModelManager(client, effectiveConfig, opts);\n      return;\n    case 'dashboard':\n      await showModelDashboard(client, defaultModel, opts);\n      return;\n    case 'aliases':\n      await listModelAliases(opts);\n      return;\n    case 'alias':\n      await setModelAlias(name, extraArg, client, defaultModel);\n      return;\n    case 'unalias':\n      await removeModelAlias(name);\n      return;\n    case 'use':\n      await useModel(resolvedName, client, defaultModel, aliasMap);\n      return;\n    case 'info':\n      await infoModel(resolvedName, client, opts);\n      return;\n    case 'load':\n      await loadModel(resolvedName, client, aliasMap, defaultModel);\n      return;\n    case 'unload':\n      await unloadModel(resolvedName, client, aliasMap);\n      return;\n    case 'stop':\n      await stopAllModels(client);\n      return;\n    case 'swap':\n      await swapModel(resolvedName, resolvedExtra, client, aliasMap);\n      return;\n    case 'history':\n      await showModelHistory(opts);\n      return;\n    case 'download':\n      await downloadModel(resolvedName, client);\n      return;\n    case 'delete':\n    case 'remove':\n      await deleteModel(resolvedName, client);\n      return;\n    case 'benchmark':\n    case 'bench':\n      await benchmarkModel(resolvedName, client);\n      return;\n    case 'predictor':\n      await showPredictorStats(client, opts);\n      return;\n    case 'helpers':\n      await showHelpersHealth(client, opts);\n      return;\n    case 'quantize':\n      await runQuantizeCommand(resolvedName, client, opts);\n      return;\n    case 'agents':\n      await runAgentsCommand(resolvedName, client, opts, config.connection);\n      return;\n    case 'skills':\n      await runSkillsCommand(resolvedName, client, opts);\n      return;\n    case 'rag':\n      await runRagCommand(resolvedName, client, opts);\n      return;\n    case 'health':\n      await runHealthCommand(resolvedName, client, opts, config.connection);\n      return;\n    case 'scan':\n      await scanModelsCommand(client, effectiveConfig, opts);\n      return;\n    case 'browse':\n    case 'browse-local':\n      if (!isInteractiveTerminal()) {\n        console.error(chalk.red('') + ' browse-local requires an interactive terminal');\n        throw new ExitError(EXIT.MISUSE);\n      }\n      await browseLocalModels(client, defaultModel);\n      return;\n    case 'library':\n    case 'browse-library':\n      if (!isInteractiveTerminal()) {\n        console.error(chalk.red('') + ' browse-library requires an interactive terminal');\n        throw new ExitError(EXIT.MISUSE);\n      }\n      await browseFullLibrary(client, defaultModel);\n      return;\n    default:\n      if (!action && !opts?.json && isInteractiveTerminal()) {\n        await interactiveModelManager(client, effectiveConfig, opts);\n        return;\n      }\n      await listModels(client, defaultModel, opts);\n  }\n}\n\nfunction printModelsHelp(): void {\n  console.log(chalk.bold('Model Commands\\n'));\n  console.log(`  ${chalk.reset('opta models')}                     interactive manager (TTY) or list`);\n  console.log(`  ${chalk.reset('opta models list')}                list loaded models`);\n  console.log(`  ${chalk.reset('opta models history')}             show recent model activity`);\n  console.log(`  ${chalk.reset('opta models manage')}              open interactive model manager`);\n  console.log(`  ${chalk.reset('opta models use [name]')}          switch default (fuzzy + picker)`);\n  console.log(`  ${chalk.reset('opta models load [name]')}         load a downloaded model`);\n  console.log(`  ${chalk.reset('opta models unload [name]')}       unload a running model`);\n  console.log(`  ${chalk.reset('opta models swap [old] [new]')}    replace running model`);\n  console.log(`  ${chalk.reset('opta models dashboard')}           show live model inventory dashboard`);\n  console.log(`  ${chalk.reset('opta models aliases')}             list custom aliases`);\n  console.log(`  ${chalk.reset('opta models alias <a> <model>')}   map alias to a model id`);\n  console.log(`  ${chalk.reset('opta models unalias <a>')}         remove an alias`);\n  console.log(`  ${chalk.reset('opta models stop')}                unload all models`);\n  console.log(`  ${chalk.reset('opta models predictor')}           predictor stats and next-model guess`);\n  console.log(`  ${chalk.reset('opta models helpers')}             helper node health dashboard`);\n  console.log(`  ${chalk.reset('opta models quantize ...')}        start/list/check quantization jobs`);\n  console.log(`  ${chalk.reset('opta models agents ...')}          list/start/status/cancel/watch agent runs`);\n  console.log(`  ${chalk.reset('opta models skills ...')}          list/show/run/mcp-call/openclaw skills`);\n  console.log(`  ${chalk.reset('opta models rag ...')}             query/list/delete/ingest/context RAG`);\n  console.log(`  ${chalk.reset('opta models health')}              liveness/readiness/admin health checks`);\n  console.log(`  ${chalk.reset('opta models scan')}                full local/cloud inventory`);\n  console.log(`  ${chalk.reset('opta models browse-local')}        browse downloaded models + history`);\n  console.log(`  ${chalk.reset('opta models browse-library')}      browse global Hugging Face library`);\n}\n\nasync function listModels(\n  client: LmxClient,\n  defaultModel: string,\n  opts?: ModelsOptions\n): Promise<void> {\n  const spinner = opts?.json ? null : await createSpinner();\n  spinner?.start('Fetching models...');\n\n  try {\n    const result = await client.models(FAST_DISCOVERY_REQUEST_OPTS);\n    spinner?.stop();\n\n    if (opts?.json) {\n      const output = result.models.map((m) => ({\n        id: m.model_id,\n        status: m.status,\n        contextLength: m.context_length ?? lookupContextLimit(m.model_id),\n        memoryBytes: m.memory_bytes,\n        isDefault: m.model_id === defaultModel || m.is_default,\n      }));\n      console.log(JSON.stringify(output, null, 2));\n      return;\n    }\n\n    console.log(chalk.bold('Models\\n'));\n\n    for (const model of result.models) {\n      const ctx = model.context_length ?? lookupContextLimit(model.model_id);\n      const ctxStr = chalk.dim(` ${(ctx / 1000).toFixed(0)}K context`);\n      const def = (model.model_id === defaultModel || model.is_default)\n        ? chalk.green(' ')\n        : '';\n      const mem = model.memory_bytes\n        ? chalk.dim(` ${(model.memory_bytes / 1e9).toFixed(1)}GB`)\n        : '';\n      console.log(`  ${model.model_id}${ctxStr}${mem}${def}`);\n    }\n\n    if (result.models.length === 0) {\n      console.log(chalk.dim('  No models loaded'));\n    }\n\n    console.log(\n      '\\n' + chalk.dim(`Use ${chalk.reset('opta models use <name>')} to switch default`)\n    );\n    console.log(\n      chalk.dim(`Use ${chalk.reset('opta models load <name>')} to load a model`)\n    );\n  } catch (err) {\n    spinner?.stop();\n    throwModelCommandError(err);\n  }\n}\n\ntype ModelManagerAction =\n  | 'use'\n  | 'load'\n  | 'unload'\n  | 'swap'\n  | 'stop'\n  | 'dashboard'\n  | 'browse-local'\n  | 'browse-library'\n  | 'scan'\n  | 'refresh'\n  | 'exit';\n\nasync function promptManagerAction(\n  loadedCount: number,\n  onDiskCount: number,\n  defaultModel: string,\n): Promise<ModelManagerAction | null> {\n  const { select } = await import('@inquirer/prompts');\n  try {\n    return await runMenuPrompt((context) =>\n      select<ModelManagerAction>({\n        message: chalk.dim(`Model manager  default ${defaultModel}`),\n        choices: [\n          {\n            value: 'use',\n            name: `${chalk.cyan('Set default')} ${chalk.dim('pick by typing or arrows')}`,\n          },\n          {\n            value: 'load',\n            name: `${chalk.green('Load model')} ${chalk.dim(`(${onDiskCount} on disk)`)}`,\n          },\n          {\n            value: 'unload',\n            name: `${chalk.yellow('Unload model')} ${chalk.dim(`(${loadedCount} loaded)`)}`,\n          },\n          {\n            value: 'swap',\n            name: `${chalk.magenta('Swap model')} ${chalk.dim('unload one, load another')}`,\n          },\n          {\n            value: 'stop',\n            name: `${chalk.red('Stop all models')} ${chalk.dim('unload everything')}`,\n          },\n          {\n            value: 'scan',\n            name: `${chalk.blue('Run scan')} ${chalk.dim('show full model inventory')}`,\n          },\n          {\n            value: 'dashboard',\n            name: `${chalk.blue('Dashboard')} ${chalk.dim('at-a-glance model health and aliases')}`,\n          },\n          {\n            value: 'browse-local',\n            name: `${chalk.cyan('Browse Local Models')} ${chalk.dim('downloaded now + model history')}`,\n          },\n          {\n            value: 'browse-library',\n            name: `${chalk.magenta('Browse Full LLM Library')} ${chalk.dim('search all downloadable models')}`,\n          },\n          {\n            value: 'refresh',\n            name: `${chalk.dim('Refresh list')}`,\n          },\n          {\n            value: 'exit',\n            name: `${chalk.dim('Exit')}`,\n          },\n        ],\n      }, context), 'select');\n  } catch {\n    return null;\n  }\n}\n\nfunction trySpawnDetached(command: string, args: string[]): boolean {\n  try {\n    const child = spawn(command, args, { stdio: 'ignore', detached: true });\n    child.unref();\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nfunction revealPathInFileManager(path: string): boolean {\n  if (!path) return false;\n  if (process.platform === 'darwin') return trySpawnDetached('open', ['-R', path]);\n  if (process.platform === 'win32') return trySpawnDetached('explorer.exe', ['/select,', path]);\n  return trySpawnDetached('xdg-open', [dirname(path)]);\n}\n\nfunction openDirectoryInFileManager(path: string): boolean {\n  if (!path) return false;\n  if (process.platform === 'darwin') return trySpawnDetached('open', [path]);\n  if (process.platform === 'win32') return trySpawnDetached('explorer.exe', [path]);\n  return trySpawnDetached('xdg-open', [path]);\n}\n\nfunction formatRelativeTime(timestampMs: number): string {\n  const diffMs = Date.now() - timestampMs;\n  const mins = Math.max(1, Math.round(diffMs / 60000));\n  if (mins < 60) return `${mins}m ago`;\n  const hours = Math.round(mins / 60);\n  if (hours < 48) return `${hours}h ago`;\n  const days = Math.round(hours / 24);\n  return `${days}d ago`;\n}\n\nfunction formatModelComparison(entry: LibraryModelEntry, catalog: LibraryModelEntry[]): string {\n  const withDownloads = catalog\n    .map((item) => item.downloads)\n    .filter((v): v is number => typeof v === 'number' && Number.isFinite(v));\n  if (typeof entry.downloads !== 'number' || withDownloads.length < 3) {\n    return 'Comparison: not enough catalog stats yet';\n  }\n\n  const rank = withDownloads.filter((value) => value > entry.downloads!).length + 1;\n  const percentile = Math.max(1, Math.round((rank / withDownloads.length) * 100));\n  return `Downloads rank: #${rank}/${withDownloads.length} (top ${percentile}%)`;\n}\n\nasync function promptCatalogSelection(\n  message: string,\n  entries: LibraryModelEntry[],\n  defaultModel: string,\n): Promise<LibraryModelEntry | null> {\n  if (entries.length === 0) return null;\n  const { search } = await import('@inquirer/prompts');\n  const byId = new Map(entries.map((entry) => [entry.id, entry] as const));\n\n  try {\n    const selected = await runMenuPrompt((context) =>\n      search<string>({\n        message: chalk.dim(message),\n        source: async (input?: string) => {\n          const query = (input ?? '').trim();\n          const ranked = rankCatalogEntries(entries, query).slice(0, 140);\n          for (const entry of ranked) {\n            byId.set(entry.id, entry);\n          }\n          return ranked.map((entry) => ({\n            value: entry.id,\n            name: formatCatalogEntryLabel(entry, defaultModel),\n          }));\n        },\n      }, context), 'search');\n    return selected ? byId.get(selected) ?? null : null;\n  } catch {\n    return null;\n  }\n}\n\nasync function promptFullLibrarySelection(\n  snapshot: LocalModelSnapshot,\n  defaultModel: string,\n): Promise<{ entry: LibraryModelEntry; catalog: LibraryModelEntry[] } | null> {\n  const seed = await fetchHuggingFaceModels(undefined, HF_CATALOG_LIMIT).catch(() => [] as HfModelApiItem[]);\n  const fallback = sortCatalogEntries(mergeCatalogEntries(snapshot, seed));\n  const cache = new Map<string, LibraryModelEntry[]>();\n  cache.set('', fallback);\n  const byId = new Map<string, LibraryModelEntry>(fallback.map((entry) => [entry.id, entry] as const));\n  let lastCatalog = fallback;\n  const { search } = await import('@inquirer/prompts');\n\n  try {\n    const selected = await runMenuPrompt((context) =>\n      search<string>({\n        message: chalk.dim('Browse Full LLM Library (type to search Hugging Face globally)'),\n        source: async (input?: string) => {\n          const query = (input ?? '').trim();\n          const cacheKey = query.toLowerCase();\n          let entries = cache.get(cacheKey);\n          if (!entries) {\n            let remote: HfModelApiItem[] = seed;\n            if (query.length >= 2) {\n              remote = await fetchHuggingFaceModels(query, HF_QUERY_LIMIT).catch(() => [] as HfModelApiItem[]);\n            }\n            entries = rankCatalogEntries(mergeCatalogEntries(snapshot, remote), query).slice(0, 160);\n            cache.set(cacheKey, entries);\n          }\n          lastCatalog = entries;\n          for (const entry of entries) {\n            byId.set(entry.id, entry);\n          }\n          return entries.map((entry) => ({\n            value: entry.id,\n            name: formatCatalogEntryLabel(entry, defaultModel),\n          }));\n        },\n      }, context), 'search');\n    if (!selected) return null;\n    const entry = byId.get(selected);\n    return entry ? { entry, catalog: lastCatalog } : null;\n  } catch {\n    return null;\n  }\n}\n\nasync function promptBrowserAction(\n  entry: LibraryModelEntry,\n  downloadRoot?: string,\n): Promise<ModelBrowserAction | null> {\n  const { select } = await import('@inquirer/prompts');\n  const choices: Array<{ value: ModelBrowserAction; name: string }> = [\n    {\n      value: 'info',\n      name: `${chalk.blue('Info')} ${chalk.dim('specs, metadata, and comparison')}`,\n    },\n    {\n      value: 'use-chat',\n      name: `${chalk.green('Use with Opta Chat')} ${chalk.dim('load/switch model then launch chat')}`,\n    },\n  ];\n\n  if (!entry.downloaded) {\n    choices.push({\n      value: 'download',\n      name: `${chalk.cyan('Download')} ${chalk.dim('pull model from Hugging Face via LMX')}`,\n    });\n  }\n  if (entry.downloaded) {\n    choices.push({\n      value: 'delete',\n      name: `${chalk.red('Delete')} ${chalk.dim('remove model from local disk')}`,\n    });\n  }\n  if (entry.downloaded && entry.localPath) {\n    choices.push({\n      value: 'open-file',\n      name: `${chalk.magenta('Open File Location')} ${chalk.dim(entry.localPath)}`,\n    });\n  }\n  if (downloadRoot) {\n    choices.push({\n      value: 'open-download',\n      name: `${chalk.magenta('Open Download Location')} ${chalk.dim(downloadRoot)}`,\n    });\n  }\n  if (entry.downloaded) {\n    choices.push({\n      value: 'benchmark-chat',\n      name: `${chalk.yellow('Run Benchmark')} ${chalk.dim('launch chat with benchmark prompt')}`,\n    });\n  }\n\n  choices.push({ value: 'back', name: chalk.dim('Back') });\n\n  try {\n    return await runMenuPrompt((context) =>\n      select<ModelBrowserAction>({\n        message: chalk.dim(`Model actions  ${entry.id}`),\n        choices,\n      }, context), 'select');\n  } catch {\n    return null;\n  }\n}\n\nasync function promptLoadedModelConflict(\n  modelId: string,\n): Promise<'replace' | 'parallel' | 'cancel'> {\n  const { select } = await import('@inquirer/prompts');\n  try {\n    return await runMenuPrompt((context) =>\n      select<'replace' | 'parallel' | 'cancel'>({\n        message: chalk.dim(`Another model is running. How should ${modelId} launch?`),\n        choices: [\n          {\n            value: 'replace',\n            name: `${chalk.red('Kill other model(s)')} ${chalk.dim('unload current + load selected')}`,\n          },\n          {\n            value: 'parallel',\n            name: `${chalk.green('Run both simultaneously')} ${chalk.dim('keep current + load selected')}`,\n          },\n          {\n            value: 'cancel',\n            name: chalk.dim('Stop launching'),\n          },\n        ],\n      }, context), 'select') ?? 'cancel';\n  } catch {\n    return 'cancel';\n  }\n}\n\nasync function ensureModelIsDownloaded(entry: LibraryModelEntry, client: LmxClient): Promise<boolean> {\n  if (entry.downloaded || entry.loaded) return true;\n  const { confirm } = await import('@inquirer/prompts');\n  const ok = await confirm({\n    message: chalk.dim(`${entry.id} is not downloaded. Download it now?`),\n    default: true,\n  }).catch(() => false);\n  if (!ok) return false;\n  await downloadModel(entry.id, client);\n  await recordModelHistory([entry.id], 'downloaded');\n  return true;\n}\n\nasync function launchChatWithModel(modelId: string, initialPrompt?: string): Promise<void> {\n  const { startChat } = await import('./chat.js');\n  if (initialPrompt) {\n    console.log(chalk.dim('\\nBenchmark prompt queued:\\n'));\n    console.log(chalk.cyan(initialPrompt));\n    console.log('');\n  }\n  await startChat({\n    model: modelId,\n    initialPrompt,\n  });\n}\n\nasync function useModelWithChat(\n  entry: LibraryModelEntry,\n  client: LmxClient,\n  initialPrompt?: string,\n): Promise<void> {\n  const ready = await ensureModelIsDownloaded(entry, client);\n  if (!ready) return;\n\n  const loadedRes = await client.models(FAST_DISCOVERY_REQUEST_OPTS).catch((err: unknown) => {\n    warnModelInventoryFallback('loaded models', err);\n    return { models: [] };\n  });\n  const loadedIds = loadedRes.models.map((m) => m.model_id);\n  const alreadyLoadedId = findMatchingModelId(entry.id, loadedIds);\n  const otherLoaded = loadedIds.filter((id) => !modelIdsEqual(id, entry.id));\n  let activeModelId = alreadyLoadedId ?? entry.id;\n\n  if (!alreadyLoadedId) {\n    let strategy: 'replace' | 'parallel' | 'cancel' = 'parallel';\n    if (otherLoaded.length > 0) {\n      strategy = await promptLoadedModelConflict(entry.id);\n    }\n    if (strategy === 'cancel') return;\n    if (strategy === 'replace') {\n      for (const modelId of otherLoaded) {\n        await client.unloadModel(modelId).catch(() => null);\n      }\n    }\n    activeModelId = await ensureModelLoaded(client, entry.id, { timeoutMs: STABLE_MODEL_LOAD_TIMEOUT_MS });\n    await recordModelHistory([activeModelId], 'loaded');\n  }\n\n  await recordModelHistory([activeModelId], 'chat');\n  await launchChatWithModel(activeModelId, initialPrompt);\n}\n\nfunction printCatalogModelInfo(entry: LibraryModelEntry, catalog: LibraryModelEntry[]): void {\n  const profile = getDisplayProfile(entry.id);\n  const tag = fmtTag(profile.format);\n  console.log('\\n' + chalk.bold(profile.displayName) + ` ${tag} ${chalk.dim(profile.orgAbbrev)}`);\n  console.log(chalk.dim(`  ${entry.id}\\n`));\n  console.log(`  Status:    ${entry.loaded ? chalk.green('loaded') : entry.downloaded ? chalk.cyan('on disk') : chalk.dim('not downloaded')}`);\n  console.log(`  Context:   ${fmtCtx(entry.contextLength)}`);\n  if (entry.sizeBytes) console.log(`  Size:      ${fmtGB(entry.sizeBytes)}`);\n  if (typeof entry.downloads === 'number') console.log(`  Downloads: ${formatCompactCount(entry.downloads)}`);\n  if (typeof entry.likes === 'number') console.log(`  Likes:     ${formatCompactCount(entry.likes)}`);\n  if (entry.pipelineTag) console.log(`  Type:      ${entry.pipelineTag}`);\n  if (entry.lastModified) {\n    const updated = new Date(entry.lastModified);\n    if (!Number.isNaN(updated.getTime())) {\n      console.log(`  Updated:   ${chalk.dim(`${updated.toLocaleDateString()} (${formatRelativeTime(updated.getTime())})`)}`);\n    }\n  }\n  if (entry.downloadedAt) {\n    console.log(`  Downloaded:${chalk.dim(` ${new Date(entry.downloadedAt).toLocaleString()}`)}`);\n  }\n  if (entry.historyLastSeenAt) {\n    console.log(`  History:   ${chalk.dim(`seen ${formatRelativeTime(entry.historyLastSeenAt)}`)}`);\n  }\n  if (entry.localPath) {\n    console.log(`  Path:      ${chalk.dim(entry.localPath)}`);\n  }\n  const tags = (entry.tags ?? []).filter((tagName) => !tagName.startsWith('license:')).slice(0, 5);\n  if (tags.length > 0) {\n    console.log(`  Tags:      ${chalk.dim(tags.join(', '))}`);\n  }\n  console.log(`  ${chalk.dim(formatModelComparison(entry, catalog))}\\n`);\n}\n\nasync function runCatalogActionLoop(\n  entry: LibraryModelEntry,\n  client: LmxClient,\n  catalog: LibraryModelEntry[],\n  downloadRoot?: string,\n): Promise<void> {\n  const BENCHMARK_PROMPT = [\n    'Run a concise benchmark-style response.',\n    '1) Solve a 3-step reasoning task with explicit steps.',\n    '2) Generate ~120 tokens total.',\n    '3) End with: BENCHMARK_DONE.',\n  ].join(' ');\n\n  while (true) {\n    const action = await promptBrowserAction(entry, downloadRoot);\n    if (!action || action === 'back') return;\n\n    if (action === 'info') {\n      printCatalogModelInfo(entry, catalog);\n      continue;\n    }\n    if (action === 'download') {\n      await downloadModel(entry.id, client);\n      await recordModelHistory([entry.id], 'downloaded');\n      return;\n    }\n    if (action === 'delete') {\n      await deleteModel(entry.id, client);\n      await recordModelHistory([entry.id], 'deleted');\n      return;\n    }\n    if (action === 'open-file') {\n      if (!entry.localPath) {\n        console.log(chalk.dim('  No local file path is available for this model.'));\n      } else if (!revealPathInFileManager(entry.localPath)) {\n        console.log(chalk.yellow('!') + ' Could not open file manager for that path');\n      } else {\n        console.log(chalk.green('') + ' Opened file location');\n      }\n      continue;\n    }\n    if (action === 'open-download') {\n      if (!downloadRoot) {\n        console.log(chalk.dim('  Download location is unknown (no local models found yet).'));\n      } else if (!openDirectoryInFileManager(downloadRoot)) {\n        console.log(chalk.yellow('!') + ' Could not open download directory');\n      } else {\n        console.log(chalk.green('') + ' Opened download location');\n      }\n      continue;\n    }\n    if (action === 'use-chat') {\n      await useModelWithChat(entry, client);\n      return;\n    }\n    if (action === 'benchmark-chat') {\n      await useModelWithChat(entry, client, BENCHMARK_PROMPT);\n      return;\n    }\n  }\n}\n\nasync function showModelHistory(opts?: ModelsOptions): Promise<void> {\n  const history = await readModelHistory();\n  if (opts?.json) {\n    console.log(JSON.stringify({ history }, null, 2));\n    return;\n  }\n\n  console.log(chalk.bold('\\nModel History'));\n  if (history.length === 0) {\n    console.log(chalk.dim('  No recorded model activity yet.'));\n    return;\n  }\n\n  const actionLabels: Record<ModelHistoryAction, string> = {\n    detected: 'Detected',\n    downloaded: 'Downloaded',\n    loaded: 'Loaded',\n    deleted: 'Deleted',\n    chat: 'Chat activity',\n  };\n\n  const displayEntries = history.slice(0, 12);\n  for (const entry of displayEntries) {\n    const label = actionLabels[entry.lastAction] ?? entry.lastAction;\n    console.log(\n      `  ${chalk.bold(label.padEnd(13))} ${entry.id}  ${chalk.dim(formatRelativeTime(entry.lastSeenAt))}`\n    );\n  }\n\n  if (history.length > displayEntries.length) {\n    console.log(chalk.dim(`   ${history.length - displayEntries.length} more entries`));\n  }\n}\n\nasync function browseLocalModels(client: LmxClient, defaultModel: string): Promise<void> {\n  console.log(chalk.bold('\\nBrowse Local Models'));\n  console.log(chalk.dim('  Includes currently downloaded models and your model history.\\n'));\n  while (true) {\n    const snapshot = await loadLocalModelSnapshot(client);\n    const all = sortCatalogEntries(mergeCatalogEntries(snapshot, []));\n    const entries = all.filter((entry) => entry.source === 'local' || entry.source === 'history');\n    if (entries.length === 0) {\n      console.log(chalk.dim('  No local models or model history found yet.'));\n      return;\n    }\n\n    const selected = await promptCatalogSelection('Browse Local Models', entries, defaultModel);\n    if (!selected) return;\n    await runCatalogActionLoop(selected, client, entries, snapshot.downloadRoot);\n  }\n}\n\nasync function browseFullLibrary(client: LmxClient, defaultModel: string): Promise<void> {\n  console.log(chalk.bold('\\nBrowse Full LLM Library'));\n  console.log(chalk.dim('  Type to search globally. Blank query shows a top downloadable catalog plus your local models.\\n'));\n  while (true) {\n    const snapshot = await loadLocalModelSnapshot(client);\n    const selected = await promptFullLibrarySelection(snapshot, defaultModel);\n    if (!selected) return;\n    await runCatalogActionLoop(selected.entry, client, selected.catalog, snapshot.downloadRoot);\n  }\n}\n\nasync function showModelDashboard(\n  client: LmxClient,\n  defaultModel: string,\n  opts?: ModelsOptions,\n): Promise<void> {\n  const [snapshot, loadedRes, memory, aliases] = await Promise.all([\n    loadLocalModelSnapshot(client),\n    client.models(FAST_DISCOVERY_REQUEST_OPTS).catch((err: unknown) => {\n      warnModelInventoryFallback('loaded models', err);\n      return { models: [] as LmxModelDetail[] };\n    }),\n    client.memory(FAST_DISCOVERY_REQUEST_OPTS).catch((err: unknown) => {\n      warnModelInventoryFallback('memory telemetry', err);\n      return null as LmxMemoryResponse | null;\n    }),\n    readModelAliasMap(),\n  ]);\n\n  const catalog = sortCatalogEntries(mergeCatalogEntries(snapshot, []));\n  const loaded = loadedRes.models;\n  const loadedIds = new Set(loaded.map((model) => normalizeModelIdKey(model.model_id)));\n  const onDiskCount = catalog.filter((entry) => entry.downloaded).length;\n  const historyOnlyCount = catalog.filter((entry) => entry.source === 'history' && !entry.downloaded).length;\n  const defaultLoaded = loaded.some((model) => modelIdsEqual(model.model_id, defaultModel));\n  const aliasEntries = Object.entries(aliases).sort((a, b) => a[0].localeCompare(b[0])) as Array<[string, string]>;\n\n  if (opts?.json) {\n    console.log(JSON.stringify({\n      defaultModel,\n      defaultLoaded,\n      counts: {\n        loaded: loaded.length,\n        onDisk: onDiskCount,\n        historyOnly: historyOnlyCount,\n        aliases: aliasEntries.length,\n      },\n      memory: memory ? {\n        usedGb: memory.used_gb,\n        totalGb: memory.total_unified_memory_gb,\n        percent: memory.total_unified_memory_gb > 0\n          ? Math.round((memory.used_gb / memory.total_unified_memory_gb) * 100)\n          : null,\n      } : null,\n      loaded: loaded.map((model) => ({\n        id: model.model_id,\n        contextLength: model.context_length ?? lookupContextLimit(model.model_id),\n        memoryBytes: model.memory_bytes,\n        requestCount: model.request_count,\n        isDefault: modelIdsEqual(model.model_id, defaultModel),\n      })),\n      aliases: Object.fromEntries(aliasEntries),\n    }, null, 2));\n    return;\n  }\n\n  console.log(chalk.bold('\\nModel Dashboard'));\n  console.log(chalk.dim(`  default ${defaultModel}${defaultLoaded ? chalk.green(' (loaded)') : chalk.dim(' (not loaded)')}`));\n\n  if (memory) {\n    const totalGb = memory.total_unified_memory_gb;\n    const usedPct = totalGb > 0 ? Math.round((memory.used_gb / totalGb) * 100) : 0;\n    const bar = renderPercentBar(usedPct, 14);\n    console.log(chalk.dim(`  Memory ${bar} ${usedPct}%  ${memory.used_gb.toFixed(1)}/${totalGb.toFixed(1)} GB`));\n  }\n\n  console.log(chalk.dim(`  Loaded ${loaded.length}  On disk ${onDiskCount}  History only ${historyOnlyCount}  Aliases ${aliasEntries.length}\\n`));\n\n  if (loaded.length === 0) {\n    console.log(chalk.dim('  No models currently loaded.'));\n  } else {\n    console.log(chalk.bold('Loaded'));\n    for (const model of loaded.slice(0, 8)) {\n      const isDefault = modelIdsEqual(model.model_id, defaultModel);\n      const bullet = isDefault ? chalk.green('') : chalk.cyan('');\n      const ctx = fmtCtx(model.context_length ?? lookupContextLimit(model.model_id));\n      const mem = model.memory_bytes ? fmtGB(model.memory_bytes) : '';\n      const reqs = model.request_count ? `${model.request_count} reqs` : '';\n      const meta = [ctx, mem, reqs].filter(Boolean).join('  ');\n      console.log(`  ${bullet} ${model.model_id}${meta ? `  ${chalk.dim(meta)}` : ''}${isDefault ? chalk.green(' ') : ''}`);\n    }\n    if (loaded.length > 8) {\n      console.log(chalk.dim(`   ${loaded.length - 8} more loaded`));\n    }\n  }\n\n  const onDiskTop = catalog.filter((entry) => entry.downloaded && !loadedIds.has(normalizeModelIdKey(entry.id))).slice(0, 6);\n  if (onDiskTop.length > 0) {\n    console.log(chalk.bold('\\nOn Disk (Top)'));\n    for (const entry of onDiskTop) {\n      const size = entry.sizeBytes ? `${fmtGB(entry.sizeBytes)} disk` : '';\n      const dls = typeof entry.downloads === 'number' ? `${formatCompactCount(entry.downloads)} dl` : '';\n      const meta = [fmtCtx(entry.contextLength), size, dls].filter(Boolean).join('  ');\n      console.log(`  ${chalk.dim('')} ${entry.id}${meta ? `  ${chalk.dim(meta)}` : ''}`);\n    }\n  }\n\n  if (aliasEntries.length > 0) {\n    console.log(chalk.bold('\\nAliases'));\n    for (const [alias, target] of aliasEntries.slice(0, 8)) {\n      const exists = catalog.some((entry) => modelIdsEqual(entry.id, target)) || loaded.some((model) => modelIdsEqual(model.model_id, target));\n      console.log(`  ${chalk.cyan(alias)} ${chalk.dim('')} ${target}${exists ? '' : chalk.yellow(' (target not detected locally)')}`);\n    }\n    if (aliasEntries.length > 8) {\n      console.log(chalk.dim(`   ${aliasEntries.length - 8} more aliases`));\n    }\n  } else {\n    console.log(chalk.dim('\\n  No custom aliases yet. Add one with: opta models alias mini inferencelabs/GLM-5-MLX-4.8bit'));\n  }\n}\n\nasync function listModelAliases(opts?: ModelsOptions): Promise<void> {\n  const aliases = await readModelAliasMap();\n  const entries = Object.entries(aliases).sort((a, b) => a[0].localeCompare(b[0]));\n\n  if (opts?.json) {\n    console.log(JSON.stringify({ aliases: Object.fromEntries(entries) }, null, 2));\n    return;\n  }\n\n  console.log(chalk.bold('\\nModel Aliases'));\n  if (entries.length === 0) {\n    console.log(chalk.dim('  No aliases configured.'));\n    console.log(chalk.dim('  Add one with: opta models alias mini inferencelabs/GLM-5-MLX-4.8bit'));\n    return;\n  }\n\n  for (const [alias, target] of entries) {\n    console.log(`  ${chalk.cyan(alias)} ${chalk.dim('')} ${target}`);\n  }\n}\n\nasync function setModelAlias(\n  aliasInput: string | undefined,\n  targetInput: string | undefined,\n  client: LmxClient,\n  defaultModel: string,\n): Promise<void> {\n  const aliasName = normalizeAliasName(aliasInput ?? '');\n  if (!aliasName) {\n    console.error(chalk.red('') + ' Missing alias name');\n    console.log(chalk.dim('  Usage: opta models alias <alias> <model-name>'));\n    throw new ExitError(EXIT.MISUSE);\n  }\n  if (!targetInput || !targetInput.trim()) {\n    console.error(chalk.red('') + ' Missing model target');\n    console.log(chalk.dim('  Usage: opta models alias <alias> <model-name>'));\n    throw new ExitError(EXIT.MISUSE);\n  }\n\n  const aliases = await readModelAliasMap();\n  const aliasTarget = resolveModelAlias(targetInput, aliases);\n  let resolvedTarget = aliasTarget ?? targetInput.trim();\n\n  const options = await getModelOptions(client).catch((err: unknown) => {\n    warnModelInventoryFallback('model options', err);\n    return { loaded: [], onDisk: [] };\n  });\n  const candidateOptions = [...options.loaded, ...options.onDisk];\n  if (candidateOptions.length > 0) {\n    try {\n      resolvedTarget = await resolveModelIdFromOptions(\n        resolvedTarget,\n        candidateOptions,\n        defaultModel,\n        'Select model for alias',\n        aliases,\n      );\n    } catch (err) {\n      if (err instanceof ExitError && err.exitCode === EXIT.NOT_FOUND && resolvedTarget.includes('/')) {\n        // Allow aliases to point at IDs not detected locally yet.\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  aliases[aliasName] = resolvedTarget;\n  await writeModelAliasMap(aliases);\n  console.log(chalk.green('') + ` Alias ${chalk.cyan(aliasName)}  ${resolvedTarget}`);\n}\n\nasync function removeModelAlias(aliasInput: string | undefined): Promise<void> {\n  const aliasName = normalizeAliasName(aliasInput ?? '');\n  if (!aliasName) {\n    console.error(chalk.red('') + ' Missing alias name');\n    console.log(chalk.dim('  Usage: opta models unalias <alias>'));\n    throw new ExitError(EXIT.MISUSE);\n  }\n\n  const aliases = await readModelAliasMap();\n  if (!aliases[aliasName]) {\n    console.error(chalk.red('') + ` Alias \"${aliasName}\" not found`);\n    throw new ExitError(EXIT.NOT_FOUND);\n  }\n\n  delete aliases[aliasName];\n  await writeModelAliasMap(aliases);\n  console.log(chalk.green('') + ` Removed alias ${chalk.cyan(aliasName)}`);\n}\n\nasync function interactiveModelManager(\n  client: LmxClient,\n  initialConfig: Awaited<ReturnType<typeof loadConfig>>,\n  opts?: ModelsOptions,\n): Promise<void> {\n  if (opts?.json || !isInteractiveTerminal()) {\n    await listModels(client, initialConfig.model.default, opts);\n    return;\n  }\n\n  console.log(chalk.bold('\\nInteractive Model Manager'));\n  console.log(chalk.dim('Use arrows + Enter. Type in picker prompts for fuzzy matching.\\n'));\n\n  let currentDefault = initialConfig.model.default;\n  let currentConfig = {\n    ...initialConfig,\n    model: { ...initialConfig.model, default: currentDefault },\n  };\n\n  while (true) {\n    const { loaded, onDisk } = await getModelOptions(client);\n    const action = await promptManagerAction(loaded.length, onDisk.length, currentDefault);\n    if (!action || action === 'exit') return;\n    if (action === 'refresh') continue;\n\n    try {\n      switch (action) {\n        case 'use':\n          currentDefault = await useModel(undefined, client, currentDefault);\n          currentConfig = {\n            ...currentConfig,\n            model: { ...currentConfig.model, default: currentDefault },\n          };\n          break;\n        case 'load':\n          await loadModel(undefined, client, {}, currentDefault);\n          break;\n        case 'unload':\n          await unloadModel(undefined, client);\n          break;\n        case 'swap':\n          await swapModel(undefined, undefined, client);\n          break;\n        case 'stop':\n          await stopAllModels(client);\n          break;\n        case 'browse-local':\n          await browseLocalModels(client, currentDefault);\n          break;\n        case 'browse-library':\n          await browseFullLibrary(client, currentDefault);\n          break;\n        case 'scan':\n          await scanModelsCommand(client, currentConfig, opts);\n          break;\n        case 'dashboard':\n          await showModelDashboard(client, currentDefault, opts);\n          break;\n      }\n    } catch (err) {\n      if (err instanceof ExitError && err.exitCode === EXIT.SIGINT) {\n        console.log(chalk.dim('  Cancelled'));\n        continue;\n      }\n      throw err;\n    }\n  }\n}\n\nasync function useModel(\n  name: string | undefined,\n  client: LmxClient,\n  defaultModel: string,\n  aliasMap: ModelAliasMap = {},\n): Promise<string> {\n  const spinner = await createSpinner();\n  spinner.start(progressText('Set default', 15, 'fetching model catalog'));\n\n  try {\n    const { loaded, onDisk } = await getModelOptions(client);\n    spinner.stop();\n    console.log(chalk.dim(`  ${progressText('Set default', 45, 'catalog ready')}`));\n\n    const options = [...loaded, ...onDisk];\n    const selectedId = await resolveModelIdFromOptions(\n      name,\n      options,\n      defaultModel,\n      'Select default model',\n      aliasMap,\n    );\n\n    const selectedLoaded = loaded.find((m) => modelIdsEqual(m.id, selectedId));\n    const contextLimit = selectedLoaded?.contextLength ?? lookupContextLimit(selectedId);\n\n    spinner.start(progressText('Set default', 75, `saving ${selectedId}`));\n    await saveConfig({\n      model: { default: selectedId, contextLimit },\n    });\n    spinner.succeed(progressText('Set default', 100, `default set to ${selectedId}`));\n\n    if (!selectedLoaded) {\n      console.log(chalk.dim(`  ${selectedId} is on disk; run ${chalk.reset(`opta models load ${selectedId}`)} to load it now`));\n    }\n    return selectedId;\n  } catch (err) {\n    spinner.stop();\n    throwModelCommandError(err);\n  }\n}\n\nasync function infoModel(\n  name: string | undefined,\n  client: LmxClient,\n  opts?: ModelsOptions\n): Promise<void> {\n  if (!name) {\n    console.error(\n      chalk.red('') + ' Missing model name\\n\\n' +\n      chalk.dim('Usage: opta models info <name>')\n    );\n    throw new ExitError(EXIT.MISUSE);\n  }\n\n  const spinner = await createSpinner();\n  spinner.start(`Fetching info for ${name}...`);\n\n  try {\n    // Fetch basic model list + performance detail in parallel\n    const [result, perfResult] = await Promise.all([\n      client.models(FAST_DISCOVERY_REQUEST_OPTS),\n      client.modelPerformance(name).catch(() => null),\n    ]);\n    spinner.stop();\n\n    const model = result.models.find((m) => m.model_id === name);\n    if (!model && !perfResult) {\n      console.error(chalk.red('') + ` Model \"${name}\" not found or not loaded`);\n      throw new ExitError(EXIT.NOT_FOUND);\n    }\n\n    if (opts?.json) {\n      console.log(JSON.stringify({ model, performance: perfResult }, null, 2));\n      return;\n    }\n\n    const dp = getDisplayProfile(name);\n    const ctx = model?.context_length ?? perfResult?.contextLength ?? lookupContextLimit(name);\n\n    console.log('\\n' + chalk.bold(dp.displayName) + ' ' + fmtTag(dp.format) + ' ' + chalk.dim(dp.orgAbbrev));\n    console.log(chalk.dim(`  ${name}`));\n    console.log('');\n\n    if (model) {\n      console.log(`  Status:   ${chalk.green(' loaded')}`);\n    }\n\n    console.log(`  Context:  ${(ctx / 1000).toFixed(0)}K tokens`);\n\n    if (perfResult) {\n      console.log(`  Backend:  ${chalk.cyan(perfResult.backendType)}`);\n      console.log(`  Memory:   ${perfResult.memoryGb.toFixed(1)} GB`);\n      console.log(`  Batching: ${perfResult.useBatching ? chalk.green('on') : chalk.dim('off')}`);\n      console.log(`  Requests: ${perfResult.requestCount.toLocaleString()}`);\n      if (perfResult.lastUsedAt) {\n        const d = new Date(perfResult.lastUsedAt);\n        const mins = Math.round((Date.now() - d.getTime()) / 60000);\n        const agoStr = mins < 60 ? `${mins}m ago` : `${Math.floor(mins / 60)}h ago`;\n        console.log(`  Last used: ${chalk.dim(agoStr)}`);\n      }\n      console.log(`  Loaded:   ${chalk.dim(new Date(perfResult.loadedAt).toLocaleTimeString())}`);\n\n      const overrides = Object.entries(perfResult.performanceOverrides);\n      if (overrides.length > 0) {\n        console.log('');\n        console.log(chalk.dim('  Performance overrides:'));\n        for (const [k, v] of overrides) {\n          console.log(chalk.dim(`    ${k}: ${String(v)}`));\n        }\n      }\n\n      const defaults = Object.entries(perfResult.globalDefaults);\n      if (defaults.length > 0) {\n        console.log('');\n        console.log(chalk.dim('  Global defaults:'));\n        for (const [k, v] of defaults) {\n          console.log(chalk.dim(`    ${k}: ${String(v)}`));\n        }\n      }\n    } else if (model?.memory_bytes) {\n      console.log(`  Memory:   ${(model.memory_bytes / 1e9).toFixed(1)} GB`);\n    }\n\n    console.log('');\n    console.log(chalk.dim(`  Run ${chalk.reset(`opta models benchmark ${name}`)} to measure tok/s`));\n  } catch (err) {\n    spinner.stop();\n    throwModelCommandError(err);\n  }\n}\n\nasync function loadModel(\n  name: string | undefined,\n  client: LmxClient,\n  aliasMap: ModelAliasMap = {},\n  defaultModel = '',\n): Promise<void> {\n  const spinner = await createSpinner();\n  spinner.start(progressText('Load model', 15, 'fetching downloadable models'));\n\n  try {\n    const { loaded, onDisk } = await getModelOptions(client);\n    spinner.stop();\n    console.log(chalk.dim(`  ${progressText('Load model', 45, 'model catalog ready')}`));\n\n    if (onDisk.length === 0) {\n      if (loaded.length > 0) {\n        console.log(chalk.dim('  No additional models on disk to load.'));\n      } else {\n        console.log(chalk.dim('  No downloaded models found. Use `opta models download <repo>` first.'));\n      }\n      return;\n    }\n\n    if (name) {\n      const matchingLoaded = findMatchingModelId(name, loaded.map((m) => m.id));\n      if (matchingLoaded) {\n        console.log(chalk.dim(`  ${matchingLoaded} is already loaded`));\n        return;\n      }\n    }\n\n    const selectedId = await resolveModelIdFromOptions(\n      name,\n      onDisk,\n      defaultModel,\n      'Select model to load',\n      aliasMap,\n    );\n\n    spinner.start(progressText('Load model', 75, `loading ${selectedId}`));\n    const loadedId = await ensureModelLoaded(client, selectedId, {\n      timeoutMs: STABLE_MODEL_LOAD_TIMEOUT_MS,\n      loadRequestTimeoutMs: STABLE_MODEL_LOAD_REQUEST_TIMEOUT_MS,\n      onProgress: createLoadProgressUpdater(spinner, 'Load model', selectedId, 75),\n    });\n    spinner.succeed(progressText('Load model', 100, `loaded ${loadedId}`));\n    await recordModelHistory([loadedId], 'loaded');\n\n    const loadedSnapshot = await client.models(FAST_DISCOVERY_REQUEST_OPTS).catch((err: unknown) => {\n      warnModelInventoryFallback('loaded models', err);\n      return { models: [] };\n    });\n    const details = loadedSnapshot.models.find((model) => modelIdsEqual(model.model_id, loadedId));\n    if (details?.memory_bytes) {\n      console.log(chalk.dim(`  Memory: ${(details.memory_bytes / 1e9).toFixed(1)} GB`));\n    }\n  } catch (err) {\n    spinner.stop();\n    throwModelCommandError(err);\n  }\n}\n\nasync function unloadModel(\n  name: string | undefined,\n  client: LmxClient,\n  aliasMap: ModelAliasMap = {},\n): Promise<void> {\n  const spinner = await createSpinner();\n  spinner.start(progressText('Unload model', 15, 'fetching loaded models'));\n\n  try {\n    const config = await loadConfig();\n    const { loaded } = await getModelOptions(client);\n    spinner.stop();\n    console.log(chalk.dim(`  ${progressText('Unload model', 45, 'loaded model list ready')}`));\n\n    if (loaded.length === 0) {\n      console.log(chalk.dim('  No models are currently loaded.'));\n      return;\n    }\n\n    const selectedId = await resolveModelIdFromOptions(\n      name,\n      loaded,\n      config.model.default,\n      'Select model to unload',\n      aliasMap,\n    );\n\n    const loadedId = findMatchingModelId(selectedId, loaded.map((model) => model.id)) ?? selectedId;\n    spinner.start(progressText('Unload model', 75, `unloading ${loadedId}`));\n    const onProgress = createUnloadProgressUpdater(spinner, 'Unload model', loadedId, 75);\n    const result = await client.unloadModel(loadedId);\n    await waitForModelUnloaded(client, loadedId, {\n      timeoutMs: 30_000,\n      onProgress,\n    });\n    spinner.succeed(progressText('Unload model', 100, `unloaded ${result.model_id}`));\n\n    if (result.freed_bytes) {\n      console.log(chalk.dim(`  Freed: ${(result.freed_bytes / 1e9).toFixed(1)} GB`));\n    }\n  } catch (err) {\n    spinner.stop();\n    throwModelCommandError(err);\n  }\n}\n\nasync function downloadModel(\n  name: string | undefined,\n  client: LmxClient\n): Promise<void> {\n  if (!name) {\n    console.error(\n      chalk.red('') + ' Missing repo ID\\n\\n' +\n      chalk.dim('Usage: opta models download <org/model-name>')\n    );\n    throw new ExitError(EXIT.MISUSE);\n  }\n\n  const spinner = await createSpinner();\n  spinner.start(progressText('Download model', 5, `starting ${name}`));\n\n  let downloadId: string;\n  try {\n    const started = await client.downloadModel(name);\n    downloadId = started.downloadId;\n    const sizeStr = started.estimatedSizeBytes\n      ? chalk.dim(`  est. ${fmtGB(started.estimatedSizeBytes)}`)\n      : '';\n    spinner.succeed(progressText('Download model', 10, `started${sizeStr}`));\n  } catch (err) {\n    spinner.stop();\n    if (err instanceof LmxApiError) {\n      console.error(chalk.red('') + ` ${err.message}`);\n      if (err.code === 'out_of_memory') {\n        console.log(chalk.dim('  Not enough memory  unload a model first'));\n      }\n      throw new ExitError(EXIT.ERROR);\n    }\n    throw err;\n  }\n\n  // Poll progress until complete\n  console.log(chalk.dim(`  Polling progress (download ID: ${downloadId})\\n`));\n  let lastPct = -1;\n\n  const poll = async (): Promise<boolean> => {\n    try {\n      const progress = await client.downloadProgress(downloadId);\n\n      if (progress.progressPercent !== lastPct) {\n        lastPct = progress.progressPercent;\n        const bar = renderPercentBar(progress.progressPercent, 20);\n        const dlStr = progress.totalBytes > 0\n          ? `${fmtGB(progress.downloadedBytes)} / ${fmtGB(progress.totalBytes)}`\n          : fmtGB(progress.downloadedBytes);\n        console.log(\n          `  ${bar}  ${chalk.dim(dlStr)}  ` +\n          chalk.dim(`${progress.filesCompleted}/${progress.filesTotal} files`)\n        );\n      }\n\n      if (progress.status === 'completed') {\n        console.log(`  ${renderPercentBar(100, 20)}  ${chalk.dim('complete')}`);\n        console.log(chalk.green('') + ` Download complete  run ${chalk.bold(`opta models load ${name}`)} to use`);\n        return true;\n      }\n      if (progress.status === 'failed') {\n        process.stdout.write('\\n');\n        console.error(chalk.red('') + ` Download failed: ${progress.error ?? 'unknown error'}`);\n        throw new ExitError(EXIT.ERROR);\n      }\n      return false;\n    } catch (err) {\n      if (err instanceof ExitError) throw err;\n      return false; // transient error, keep polling\n    }\n  };\n\n  // Poll every 2 seconds\n  while (!(await poll())) {\n    await new Promise<void>((r) => setTimeout(r, 2000));\n  }\n  await recordModelHistory([name], 'downloaded');\n}\n\nasync function deleteModel(\n  name: string | undefined,\n  client: LmxClient\n): Promise<void> {\n  if (!name) {\n    console.error(\n      chalk.red('') + ' Missing model name\\n\\n' +\n      chalk.dim('Usage: opta models delete <model-name>')\n    );\n    throw new ExitError(EXIT.MISUSE);\n  }\n\n  const spinner = await createSpinner();\n  spinner.start(`Deleting ${name} from disk...`);\n\n  try {\n    const result = await client.deleteModel(name);\n    spinner.succeed(\n      `Deleted ${result.modelId}` +\n      (result.freedBytes > 0 ? chalk.dim(`  freed ${fmtGB(result.freedBytes)}`) : '')\n    );\n    await recordModelHistory([result.modelId], 'deleted');\n  } catch (err) {\n    spinner.stop();\n    if (err instanceof LmxApiError) {\n      if (err.code === 'conflict') {\n        console.error(chalk.red('') + ` Cannot delete  model is currently loaded`);\n        console.log(chalk.dim(`  Run ${chalk.reset(`opta models unload ${name}`)} first`));\n      } else if (err.code === 'not_found') {\n        console.error(chalk.red('') + ` Model \"${name}\" not found on disk`);\n      } else {\n        console.error(chalk.red('') + ` ${err.message}`);\n      }\n      throw new ExitError(EXIT.ERROR);\n    }\n    throw err;\n  }\n}\n\nasync function benchmarkModel(\n  name: string | undefined,\n  client: LmxClient\n): Promise<void> {\n  if (!name) {\n    console.error(\n      chalk.red('') + ' Missing model name\\n\\n' +\n      chalk.dim('Usage: opta models benchmark <model-name>')\n    );\n    throw new ExitError(EXIT.MISUSE);\n  }\n\n  const spinner = await createSpinner();\n  spinner.start(`Benchmarking ${name} (3 runs  128 tokens)...`);\n\n  try {\n    const result = await client.benchmarkModel(name);\n    spinner.succeed(`Benchmark complete`);\n\n    const dp = getDisplayProfile(result.modelId);\n    console.log('');\n    console.log(`  ${chalk.bold(dp.displayName)} ${fmtTag(dp.format)} ${chalk.dim(dp.orgAbbrev)}`);\n    console.log('');\n\n    const tpsColor = result.avgTokensPerSecond >= 30\n      ? chalk.green\n      : result.avgTokensPerSecond >= 10\n      ? chalk.yellow\n      : chalk.red;\n\n    console.log(`  ${chalk.bold('Avg tok/s')}    ${tpsColor(result.avgTokensPerSecond.toFixed(1))} tok/s`);\n    console.log(`  ${chalk.bold('Avg TTFT')}     ${result.avgTimeToFirstTokenMs.toFixed(0)} ms`);\n    console.log(`  ${chalk.bold('Avg total')}    ${result.avgTotalTimeMs.toFixed(0)} ms`);\n    console.log(`  ${chalk.bold('Backend')}      ${chalk.cyan(result.backendType)}`);\n\n    if (result.results.length > 1) {\n      console.log('');\n      console.log(chalk.dim('  Per-run:'));\n      for (const r of result.results) {\n        const bar = ''.repeat(Math.min(20, Math.round(r.tokensPerSecond / 3)));\n        console.log(\n          chalk.dim(`  Run ${r.run}  `) +\n          chalk.dim(`${bar.padEnd(20)}`) +\n          `  ${r.tokensPerSecond.toFixed(1)} tok/s` +\n          chalk.dim(`  TTFT ${r.timeToFirstTokenMs.toFixed(0)}ms`)\n        );\n      }\n    }\n    console.log('');\n  } catch (err) {\n    spinner.stop();\n    if (err instanceof LmxApiError) {\n      if (err.code === 'not_found') {\n        console.error(chalk.red('') + ` Model \"${name}\" not loaded`);\n        console.log(chalk.dim(`  Run ${chalk.reset(`opta models load ${name}`)} first`));\n      } else {\n        console.error(chalk.red('') + ` ${err.message}`);\n      }\n      throw new ExitError(EXIT.ERROR);\n    }\n    throw err;\n  }\n}\n\nasync function showPredictorStats(\n  client: LmxClient,\n  opts?: ModelsOptions,\n): Promise<void> {\n  const spinner = opts?.json ? null : await createSpinner();\n  spinner?.start('Fetching predictor stats...');\n\n  try {\n    const stats = await client.predictorStats(FAST_DISCOVERY_REQUEST_OPTS);\n    spinner?.stop();\n\n    if (opts?.json) {\n      console.log(JSON.stringify(stats, null, 2));\n      return;\n    }\n\n    const predictedNext = (stats['predicted_next'] ?? stats['predictedNext']) as string | undefined;\n    console.log(chalk.bold('Predictor Stats\\n'));\n    console.log(`  Predicted next: ${predictedNext ? chalk.cyan(predictedNext) : chalk.dim('(none)')}`);\n    for (const [key, value] of Object.entries(stats)) {\n      if (key === 'predicted_next' || key === 'predictedNext') continue;\n      if (typeof value === 'number' || typeof value === 'string' || typeof value === 'boolean') {\n        console.log(`  ${key}: ${String(value)}`);\n      }\n    }\n  } catch (err) {\n    spinner?.stop();\n    throwModelCommandError(err);\n  }\n}\n\nasync function showHelpersHealth(\n  client: LmxClient,\n  opts?: ModelsOptions,\n): Promise<void> {\n  const spinner = opts?.json ? null : await createSpinner();\n  spinner?.start('Checking helper-node health...');\n\n  try {\n    const payload = await client.helpersHealth(FAST_DISCOVERY_REQUEST_OPTS);\n    spinner?.stop();\n\n    if (opts?.json) {\n      console.log(JSON.stringify(payload, null, 2));\n      return;\n    }\n\n    const helpers = (payload.helpers ?? {}) as Record<string, Record<string, unknown>>;\n    const liveChecks = (payload.live_checks ?? payload.liveChecks ?? {}) as Record<string, unknown>;\n\n    console.log(chalk.bold('Helper Nodes\\n'));\n    console.log(`  Configured: ${payload.configured_count ?? Object.keys(helpers).length}`);\n    console.log(`  All healthy: ${payload.all_healthy ? chalk.green('yes') : chalk.yellow('no')}`);\n\n    if (Object.keys(helpers).length === 0) {\n      console.log(chalk.dim('\\n  No helper nodes configured'));\n      return;\n    }\n\n    for (const [name, stats] of Object.entries(helpers)) {\n      const healthy = Boolean(stats.healthy);\n      const live = liveChecks[name];\n      const avgLatencyMs = typeof stats.avg_latency_ms === 'number'\n        ? `${stats.avg_latency_ms.toFixed(0)}ms`\n        : null;\n      const successRate = typeof stats.success_rate === 'number'\n        ? `${(stats.success_rate * 100).toFixed(1)}%`\n        : null;\n      const meta = [avgLatencyMs, successRate, typeof live === 'boolean' ? `live:${live ? 'pass' : 'fail'}` : null]\n        .filter(Boolean)\n        .join('  ');\n      const badge = healthy ? chalk.green('healthy') : chalk.red('unhealthy');\n      console.log(`  ${name.padEnd(10)} ${badge}${meta ? chalk.dim(`  ${meta}`) : ''}`);\n    }\n  } catch (err) {\n    spinner?.stop();\n    throwModelCommandError(err);\n  }\n}\n\nasync function runQuantizeCommand(\n  args: string | undefined,\n  client: LmxClient,\n  opts?: ModelsOptions,\n): Promise<void> {\n  const tokens = parseShellLikeArgs(args ?? '');\n  const action = (tokens[0] ?? 'list').toLowerCase();\n\n  if (action === 'list') {\n    const result = await client.quantizeJobs(FAST_DISCOVERY_REQUEST_OPTS);\n    if (opts?.json) {\n      console.log(JSON.stringify(result, null, 2));\n      return;\n    }\n    console.log(chalk.bold('Quantize Jobs\\n'));\n    if (result.jobs.length === 0) {\n      console.log(chalk.dim('  No quantize jobs found'));\n      return;\n    }\n    for (const job of result.jobs.slice(0, 30)) {\n      const id = job.job_id ?? 'unknown';\n      const status = String(job.status ?? 'unknown');\n      const statusColor = status === 'completed'\n        ? chalk.green\n        : status === 'failed'\n          ? chalk.red\n          : chalk.yellow;\n      console.log(`  ${id}  ${statusColor(status)}  ${chalk.dim(job.source_model ?? '')}`);\n    }\n    return;\n  }\n\n  if (action === 'status') {\n    const jobId = tokens[1];\n    if (!jobId) {\n      console.error(chalk.red('') + ' Missing job id\\n\\n' + chalk.dim('Usage: opta models quantize status <job-id>'));\n      throw new ExitError(EXIT.MISUSE);\n    }\n    const status = await client.quantizeStatus(jobId, FAST_DISCOVERY_REQUEST_OPTS);\n    if (opts?.json) {\n      console.log(JSON.stringify(status, null, 2));\n      return;\n    }\n    console.log(chalk.bold('Quantize Status\\n'));\n    console.log(`  Job:      ${status.job_id ?? jobId}`);\n    console.log(`  Status:   ${status.status ?? 'unknown'}`);\n    if (status.source_model) console.log(`  Model:    ${status.source_model}`);\n    if (typeof status.bits === 'number') console.log(`  Bits:     ${status.bits}`);\n    if (typeof status.group_size === 'number') console.log(`  Group:    ${status.group_size}`);\n    if (status.mode) console.log(`  Mode:     ${status.mode}`);\n    if (status.output_path) console.log(`  Output:   ${status.output_path}`);\n    if (typeof status.duration_sec === 'number') console.log(`  Duration: ${status.duration_sec.toFixed(1)}s`);\n    if (status.error) console.log(chalk.red(`  Error:    ${status.error}`));\n    return;\n  }\n\n  if (action === 'start') {\n    const sourceModel = tokens[1];\n    if (!sourceModel) {\n      console.error(\n        chalk.red('') + ' Missing source model\\n\\n' +\n        chalk.dim('Usage: opta models quantize start <model-id> [--bits 4|8] [--group-size <n>] [--mode affine|symmetric] [--output <path>]'),\n      );\n      throw new ExitError(EXIT.MISUSE);\n    }\n\n    const request: {\n      sourceModel: string;\n      bits?: 4 | 8;\n      groupSize?: number;\n      mode?: 'affine' | 'symmetric';\n      outputPath?: string;\n    } = { sourceModel };\n\n    const unknown: string[] = [];\n    for (let i = 2; i < tokens.length; i += 1) {\n      const token = tokens[i]!;\n      if (!token.startsWith('--')) {\n        unknown.push(token);\n        continue;\n      }\n      if (token === '--bits') {\n        const value = tokens[i + 1];\n        if (!value || (value !== '4' && value !== '8')) {\n          console.error(chalk.red('') + ' --bits must be 4 or 8');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        request.bits = Number.parseInt(value, 10) as 4 | 8;\n        i += 1;\n        continue;\n      }\n      if (token === '--group-size') {\n        const value = tokens[i + 1];\n        const parsed = value ? Number.parseInt(value, 10) : Number.NaN;\n        if (!Number.isFinite(parsed) || parsed < 1) {\n          console.error(chalk.red('') + ' --group-size must be a positive integer');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        request.groupSize = parsed;\n        i += 1;\n        continue;\n      }\n      if (token === '--mode') {\n        const value = tokens[i + 1];\n        if (!value || (value !== 'affine' && value !== 'symmetric')) {\n          console.error(chalk.red('') + ' --mode must be affine or symmetric');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        request.mode = value;\n        i += 1;\n        continue;\n      }\n      if (token === '--output') {\n        const value = tokens[i + 1];\n        if (!value) {\n          console.error(chalk.red('') + ' Missing value for --output');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        request.outputPath = value;\n        i += 1;\n        continue;\n      }\n      unknown.push(token);\n    }\n    if (unknown.length > 0) {\n      console.error(chalk.red('') + ` Unknown options: ${unknown.join(', ')}`);\n      throw new ExitError(EXIT.MISUSE);\n    }\n\n    const spinner = opts?.json ? null : await createSpinner();\n    spinner?.start(`Starting quantize job for ${sourceModel}...`);\n    try {\n      const started = await client.quantizeStart(request, {\n        timeoutMs: 60_000,\n        maxRetries: 0,\n      });\n      spinner?.succeed(`Quantize job started (${started.job_id})`);\n      if (opts?.json) {\n        console.log(JSON.stringify(started, null, 2));\n      } else {\n        console.log(chalk.dim(`  Track with ${chalk.reset(`opta models quantize status ${started.job_id}`)}`));\n      }\n      return;\n    } catch (err) {\n      spinner?.stop();\n      throwModelCommandError(err);\n    }\n  }\n\n  console.error(\n    chalk.red('') + ` Unknown quantize action: ${action}\\n\\n` +\n    chalk.dim('Usage: opta models quantize [list|status <job-id>|start <model-id> [--bits 4|8] [--group-size <n>] [--mode affine|symmetric] [--output <path>]]'),\n  );\n  throw new ExitError(EXIT.MISUSE);\n}\n\nasync function runAgentsCommand(\n  args: string | undefined,\n  client: LmxClient,\n  opts?: ModelsOptions,\n  connection?: {\n    host: string;\n    fallbackHosts?: string[];\n    port: number;\n    adminKey?: string;\n  },\n): Promise<void> {\n  const tokens = parseShellLikeArgs(args ?? '');\n  const action = (tokens[0] ?? 'list').toLowerCase();\n\n  if (action === 'list') {\n    let limit = 20;\n    let offset = 0;\n    let status: string | undefined;\n\n    for (let i = 1; i < tokens.length; i += 1) {\n      const token = tokens[i]!;\n      if (token === '--limit') {\n        const value = tokens[i + 1];\n        const parsed = value ? Number.parseInt(value, 10) : Number.NaN;\n        if (!Number.isFinite(parsed) || parsed < 1 || parsed > 200) {\n          console.error(chalk.red('') + ' --limit must be between 1 and 200');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        limit = parsed;\n        i += 1;\n        continue;\n      }\n      if (token === '--offset') {\n        const value = tokens[i + 1];\n        const parsed = value ? Number.parseInt(value, 10) : Number.NaN;\n        if (!Number.isFinite(parsed) || parsed < 0) {\n          console.error(chalk.red('') + ' --offset must be >= 0');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        offset = parsed;\n        i += 1;\n        continue;\n      }\n      if (token === '--status') {\n        const value = tokens[i + 1];\n        if (!value) {\n          console.error(chalk.red('') + ' Missing value for --status');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        status = value;\n        i += 1;\n        continue;\n      }\n      console.error(chalk.red('') + ` Unknown option: ${token}`);\n      throw new ExitError(EXIT.MISUSE);\n    }\n\n    const payload = await client.agentRuns({ limit, offset, status }, FAST_DISCOVERY_REQUEST_OPTS);\n    if (opts?.json) {\n      console.log(JSON.stringify(payload, null, 2));\n      return;\n    }\n\n    const runs = Array.isArray(payload.data) ? payload.data : [];\n    console.log(chalk.bold('Agent Runs\\n'));\n    console.log(`  Total: ${payload.total ?? runs.length}`);\n    if (runs.length === 0) {\n      console.log(chalk.dim('  No agent runs found.'));\n      return;\n    }\n    for (const run of runs.slice(0, 30)) {\n      const statusText = String(run.status ?? 'unknown');\n      const color = statusText === 'completed'\n        ? chalk.green\n        : statusText === 'failed' || statusText === 'cancelled'\n          ? chalk.red\n          : chalk.yellow;\n      const request = (run.request ?? {}) as Record<string, unknown>;\n      const strategy = typeof request.strategy === 'string' ? request.strategy : 'unknown';\n      const prompt = typeof request.prompt === 'string' ? request.prompt.replace(/\\s+/g, ' ').trim() : '';\n      console.log(`  ${run.id}  ${color(statusText)}  ${chalk.dim(strategy)}  ${prompt.slice(0, 72)}`);\n    }\n    return;\n  }\n\n  if (action === 'start' || action === 'create') {\n    let prompt: string | undefined;\n    let strategy: 'parallel_map' | 'router' | 'handoff' = 'handoff';\n    let roles: string[] = ['default'];\n    let model: string | undefined;\n    let timeoutSec: number | undefined;\n    let priority: 'interactive' | 'normal' | 'batch' = 'normal';\n    let approvalRequired = false;\n    let metadata: Record<string, unknown> = {};\n    let idempotencyKey: string | undefined;\n\n    for (let i = 1; i < tokens.length; i += 1) {\n      const token = tokens[i]!;\n      if (!token.startsWith('--') && prompt === undefined) {\n        prompt = token;\n        continue;\n      }\n      if (token === '--prompt') {\n        const value = tokens[i + 1];\n        if (!value) {\n          console.error(chalk.red('') + ' Missing value for --prompt');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        prompt = value;\n        i += 1;\n        continue;\n      }\n      if (token === '--strategy') {\n        const value = tokens[i + 1];\n        if (!value || !['parallel_map', 'router', 'handoff'].includes(value)) {\n          console.error(chalk.red('') + ' --strategy must be parallel_map, router, or handoff');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        strategy = value as 'parallel_map' | 'router' | 'handoff';\n        i += 1;\n        continue;\n      }\n      if (token === '--roles') {\n        const value = tokens[i + 1];\n        if (!value) {\n          console.error(chalk.red('') + ' Missing value for --roles');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        const parsed = parseCsvList(value);\n        if (parsed.length === 0) {\n          console.error(chalk.red('') + ' --roles must contain at least one role');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        roles = parsed;\n        i += 1;\n        continue;\n      }\n      if (token === '--model') {\n        const value = tokens[i + 1];\n        if (!value) {\n          console.error(chalk.red('') + ' Missing value for --model');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        model = value;\n        i += 1;\n        continue;\n      }\n      if (token === '--timeout') {\n        const value = tokens[i + 1];\n        const parsed = value ? Number.parseFloat(value) : Number.NaN;\n        if (!Number.isFinite(parsed) || parsed <= 0 || parsed > 3600) {\n          console.error(chalk.red('') + ' --timeout must be > 0 and <= 3600 seconds');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        timeoutSec = parsed;\n        i += 1;\n        continue;\n      }\n      if (token === '--priority') {\n        const value = tokens[i + 1];\n        if (!value || !['interactive', 'normal', 'batch'].includes(value)) {\n          console.error(chalk.red('') + ' --priority must be interactive, normal, or batch');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        priority = value as 'interactive' | 'normal' | 'batch';\n        i += 1;\n        continue;\n      }\n      if (token === '--metadata') {\n        const value = tokens[i + 1];\n        if (!value) {\n          console.error(chalk.red('') + ' Missing value for --metadata');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        metadata = await parseJsonObjectOption(value, '--metadata');\n        i += 1;\n        continue;\n      }\n      if (token === '--approve' || token === '--approval-required') {\n        approvalRequired = true;\n        continue;\n      }\n      if (token === '--idempotency-key') {\n        const value = tokens[i + 1];\n        if (!value) {\n          console.error(chalk.red('') + ' Missing value for --idempotency-key');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        idempotencyKey = value;\n        i += 1;\n        continue;\n      }\n      console.error(chalk.red('') + ` Unknown option: ${token}`);\n      throw new ExitError(EXIT.MISUSE);\n    }\n\n    if (!prompt || !prompt.trim()) {\n      console.error(\n        chalk.red('') + ' Missing prompt\\n\\n' +\n        chalk.dim('Usage: opta models agents start --prompt \"<text>\" [--roles <a,b>] [--strategy <parallel_map|router|handoff>] [--model <id>] [--timeout <sec>] [--priority <interactive|normal|batch>] [--metadata <json|@file>] [--approve] [--idempotency-key <key>]'),\n      );\n      throw new ExitError(EXIT.MISUSE);\n    }\n\n    const created = await client.createAgentRun(\n      {\n        request: {\n          strategy,\n          prompt: prompt.trim(),\n          roles,\n          model: model ?? 'auto',\n          timeout_sec: timeoutSec,\n          priority,\n          metadata,\n          approval_required: approvalRequired,\n        },\n      },\n      {\n        timeoutMs: Math.max(10_000, timeoutSec ? Math.round(timeoutSec * 1000) : 30_000),\n        maxRetries: 0,\n        idempotencyKey,\n      },\n    );\n\n    if (opts?.json) {\n      console.log(JSON.stringify(created, null, 2));\n      return;\n    }\n\n    const request = (created.request ?? {}) as Record<string, unknown>;\n    const requestRoles = Array.isArray(request.roles)\n      ? request.roles.filter((value): value is string => typeof value === 'string')\n      : roles;\n    console.log(chalk.green('') + ` Agent run created: ${created.id}`);\n    console.log(`  Status:   ${created.status}`);\n    console.log(`  Strategy: ${String(request.strategy ?? strategy)}`);\n    console.log(`  Roles:    ${requestRoles.join(', ')}`);\n    if (created.error) console.log(chalk.red(`  Error:    ${created.error}`));\n    console.log(chalk.dim(`  Watch:    opta models agents events ${created.id}`));\n    return;\n  }\n\n  if (action === 'status') {\n    const runId = tokens[1];\n    if (!runId) {\n      console.error(chalk.red('') + ' Missing run id\\n\\n' + chalk.dim('Usage: opta models agents status <run-id>'));\n      throw new ExitError(EXIT.MISUSE);\n    }\n    const run = await client.agentRun(runId, FAST_DISCOVERY_REQUEST_OPTS);\n    if (opts?.json) {\n      console.log(JSON.stringify(run, null, 2));\n      return;\n    }\n    const request = (run.request ?? {}) as Record<string, unknown>;\n    const steps = Array.isArray(run.steps) ? run.steps : [];\n    const roles = Array.isArray(request.roles)\n      ? request.roles.filter((value): value is string => typeof value === 'string')\n      : [];\n    console.log(chalk.bold('Agent Run\\n'));\n    console.log(`  Run:      ${run.id}`);\n    console.log(`  Status:   ${run.status}`);\n    console.log(`  Strategy: ${typeof request.strategy === 'string' ? request.strategy : 'unknown'}`);\n    console.log(`  Roles:    ${roles.length > 0 ? roles.join(', ') : '(none)'}`);\n    if (run.error) console.log(chalk.red(`  Error:    ${run.error}`));\n    if (steps.length > 0) {\n      console.log('');\n      for (const step of steps) {\n        const role = typeof step.role === 'string' ? step.role : 'step';\n        const stepStatus = typeof step.status === 'string' ? step.status : 'unknown';\n        console.log(`  ${role.padEnd(12)} ${stepStatus}`);\n      }\n    }\n    return;\n  }\n\n  if (action === 'events' || action === 'watch') {\n    const runId = tokens[1];\n    if (!runId) {\n      console.error(chalk.red('') + ' Missing run id\\n\\n' + chalk.dim('Usage: opta models agents events <run-id> [--timeout <sec>] [--limit <n>]'));\n      throw new ExitError(EXIT.MISUSE);\n    }\n    let timeoutSec = 30;\n    let limit = 120;\n    for (let i = 2; i < tokens.length; i += 1) {\n      const token = tokens[i]!;\n      if (token === '--timeout') {\n        const value = tokens[i + 1];\n        const parsed = value ? Number.parseFloat(value) : Number.NaN;\n        if (!Number.isFinite(parsed) || parsed <= 0 || parsed > 900) {\n          console.error(chalk.red('') + ' --timeout must be > 0 and <= 900 seconds');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        timeoutSec = parsed;\n        i += 1;\n        continue;\n      }\n      if (token === '--limit') {\n        const value = tokens[i + 1];\n        const parsed = value ? Number.parseInt(value, 10) : Number.NaN;\n        if (!Number.isFinite(parsed) || parsed < 1 || parsed > 1000) {\n          console.error(chalk.red('') + ' --limit must be between 1 and 1000');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        limit = parsed;\n        i += 1;\n        continue;\n      }\n      console.error(chalk.red('') + ` Unknown option: ${token}`);\n      throw new ExitError(EXIT.MISUSE);\n    }\n\n    const activeHost = client.getActiveHost();\n    const host = activeHost || connection?.host || 'localhost';\n    const port = connection?.port ?? 11434;\n    const headers: Record<string, string> = {};\n    const adminKey = connection?.adminKey?.trim();\n    if (adminKey) headers['X-Admin-Key'] = adminKey;\n    const url = `http://${host}:${port}/v1/agents/runs/${encodeURIComponent(runId)}/events`;\n    const streamed = await streamSseEvents(url, headers, Math.round(timeoutSec * 1000));\n    const events = streamed.events.slice(0, limit);\n\n    if (opts?.json) {\n      console.log(JSON.stringify({\n        run_id: runId,\n        host,\n        timed_out: streamed.timedOut,\n        events,\n      }, null, 2));\n      return;\n    }\n\n    console.log(chalk.bold(`Agent Events  ${runId}\\n`));\n    if (events.length === 0) {\n      console.log(chalk.dim('  No events received yet.'));\n      if (streamed.timedOut) {\n        console.log(chalk.dim(`  Timed out after ${timeoutSec}s.`));\n      }\n      return;\n    }\n\n    for (const entry of events) {\n      if (entry.data === '[DONE]') continue;\n      let rendered = entry.data;\n      try {\n        const parsed = JSON.parse(entry.data) as Record<string, unknown>;\n        const type = typeof parsed.type === 'string' ? parsed.type : entry.event;\n        if (type === 'run.update' || type === 'run.completed') {\n          const run = parsed.run as Record<string, unknown> | undefined;\n          const status = run && typeof run.status === 'string' ? run.status : 'unknown';\n          const runIdFromEvent = run && typeof run.id === 'string' ? run.id : runId;\n          rendered = `${type}  ${runIdFromEvent}  ${status}`;\n        } else if (type === 'run.error') {\n          rendered = `${type}  ${String(parsed.error ?? 'unknown error')}`;\n        } else {\n          rendered = `${type}  ${entry.data.slice(0, 160)}`;\n        }\n      } catch {\n        rendered = `${entry.event}  ${entry.data.slice(0, 160)}`;\n      }\n      console.log(`  ${rendered}`);\n    }\n    if (streamed.timedOut) {\n      console.log(chalk.dim(`\\n  Stream timed out after ${timeoutSec}s. Re-run to continue following events.`));\n    }\n    return;\n  }\n\n  if (action === 'cancel') {\n    const runId = tokens[1];\n    if (!runId) {\n      console.error(chalk.red('') + ' Missing run id\\n\\n' + chalk.dim('Usage: opta models agents cancel <run-id>'));\n      throw new ExitError(EXIT.MISUSE);\n    }\n    const cancelled = await client.cancelAgentRun(runId, FAST_DISCOVERY_REQUEST_OPTS);\n    if (opts?.json) {\n      console.log(JSON.stringify(cancelled, null, 2));\n      return;\n    }\n    console.log(chalk.green('') + ` Agent run ${cancelled.id} status: ${cancelled.status}`);\n    if (cancelled.error) {\n      console.log(chalk.dim(`  ${cancelled.error}`));\n    }\n    return;\n  }\n\n  console.error(\n    chalk.red('') + ` Unknown agents action: ${action}\\n\\n` +\n    chalk.dim('Usage: opta models agents [list|start|status <run-id>|events <run-id>|cancel <run-id>] [--limit <n>] [--offset <n>] [--status <state>]'),\n  );\n  throw new ExitError(EXIT.MISUSE);\n}\n\nasync function runSkillsCommand(\n  args: string | undefined,\n  client: LmxClient,\n  opts?: ModelsOptions,\n): Promise<void> {\n  const tokens = parseShellLikeArgs(args ?? '');\n  const action = (tokens[0] ?? 'list').toLowerCase();\n\n  if (action === 'list') {\n    let latestOnly = true;\n    for (let i = 1; i < tokens.length; i += 1) {\n      const token = tokens[i]!;\n      if (token === '--all') {\n        latestOnly = false;\n        continue;\n      }\n      console.error(chalk.red('') + ` Unknown option: ${token}`);\n      throw new ExitError(EXIT.MISUSE);\n    }\n    const payload = await client.skillsList({ latestOnly }, FAST_DISCOVERY_REQUEST_OPTS);\n    if (opts?.json) {\n      console.log(JSON.stringify(payload, null, 2));\n      return;\n    }\n    const rows = Array.isArray(payload.data) ? payload.data : [];\n    console.log(chalk.bold('Skills Registry\\n'));\n    console.log(`  Count: ${rows.length}`);\n    if (rows.length === 0) {\n      console.log(chalk.dim('  No skills registered.'));\n      return;\n    }\n    for (const skill of rows.slice(0, 50)) {\n      const reference = skill.reference ?? skill.name ?? 'unknown';\n      const kind = skill.kind ?? 'unknown';\n      const version = skill.version ?? '';\n      const suffix = version ? chalk.dim(` v${version}`) : '';\n      console.log(`  ${chalk.cyan(reference)}  ${chalk.dim(kind)}${suffix}`);\n    }\n    return;\n  }\n\n  if (action === 'show' || action === 'get') {\n    const skillName = tokens[1];\n    if (!skillName) {\n      console.error(chalk.red('') + ' Missing skill name\\n\\n' + chalk.dim('Usage: opta models skills show <skill-name>'));\n      throw new ExitError(EXIT.MISUSE);\n    }\n    const payload = await client.skillDetail(skillName, FAST_DISCOVERY_REQUEST_OPTS);\n    if (opts?.json) {\n      console.log(JSON.stringify(payload, null, 2));\n      return;\n    }\n    console.log(chalk.bold('Skill Detail\\n'));\n    console.log(`  Name:        ${payload.name ?? skillName}`);\n    console.log(`  Reference:   ${payload.reference ?? payload.qualified_name ?? skillName}`);\n    console.log(`  Kind:        ${payload.kind ?? 'unknown'}`);\n    console.log(`  Version:     ${payload.version ?? 'unknown'}`);\n    console.log(`  Namespace:   ${payload.namespace ?? 'default'}`);\n    console.log(`  Description: ${payload.description ?? '(none)'}`);\n    return;\n  }\n\n  if (action === 'tools') {\n    const payload = await client.skillMcpTools(FAST_DISCOVERY_REQUEST_OPTS);\n    if (opts?.json) {\n      console.log(JSON.stringify(payload, null, 2));\n      return;\n    }\n    const tools = Array.isArray(payload.tools) ? payload.tools : [];\n    console.log(chalk.bold('MCP Tools\\n'));\n    console.log(`  Count: ${tools.length}`);\n    if (tools.length === 0) {\n      console.log(chalk.dim('  No MCP tools available.'));\n      return;\n    }\n    for (const tool of tools.slice(0, 50)) {\n      const description = typeof tool.description === 'string' ? tool.description : '';\n      console.log(`  ${chalk.cyan(tool.name)} ${description ? chalk.dim(`- ${description}`) : ''}`);\n    }\n    return;\n  }\n\n  if (action === 'run' || action === 'execute') {\n    const skillName = tokens[1];\n    if (!skillName) {\n      console.error(chalk.red('') + ' Missing skill name\\n\\n' + chalk.dim('Usage: opta models skills run <skill-name> [--args <json|@file>] [--approve] [--timeout <sec>]'));\n      throw new ExitError(EXIT.MISUSE);\n    }\n    let approved = false;\n    let timeoutSec: number | undefined;\n    let argumentsPayload: Record<string, unknown> = {};\n    for (let i = 2; i < tokens.length; i += 1) {\n      const token = tokens[i]!;\n      if (token === '--approve') {\n        approved = true;\n        continue;\n      }\n      if (token === '--timeout') {\n        const value = tokens[i + 1];\n        const parsed = value ? Number.parseFloat(value) : Number.NaN;\n        if (!Number.isFinite(parsed) || parsed <= 0 || parsed > 600) {\n          console.error(chalk.red('') + ' --timeout must be > 0 and <= 600 seconds');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        timeoutSec = parsed;\n        i += 1;\n        continue;\n      }\n      if (token === '--args') {\n        const value = tokens[i + 1];\n        if (!value) {\n          console.error(chalk.red('') + ' Missing value for --args');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        argumentsPayload = await parseJsonObjectOption(value, '--args');\n        i += 1;\n        continue;\n      }\n      console.error(chalk.red('') + ` Unknown option: ${token}`);\n      throw new ExitError(EXIT.MISUSE);\n    }\n\n    const payload = await client.skillExecute(\n      skillName,\n      {\n        arguments: argumentsPayload,\n        approved,\n        timeoutSec,\n      },\n      { timeoutMs: Math.max(10_000, timeoutSec ? Math.round(timeoutSec * 1000) : 30_000), maxRetries: 0 },\n    );\n\n    if (opts?.json) {\n      console.log(JSON.stringify(payload, null, 2));\n      return;\n    }\n\n    const ok = payload.ok === true;\n    console.log((ok ? chalk.green('') : chalk.red('')) + ` Skill ${skillName} ${ok ? 'completed' : 'failed'}`);\n    if (payload.error) {\n      console.log(chalk.red(`  Error: ${payload.error}`));\n    }\n    if (payload.output !== undefined) {\n      const rendered = typeof payload.output === 'string'\n        ? payload.output\n        : JSON.stringify(payload.output, null, 2);\n      console.log(chalk.dim(`  Output: ${rendered.slice(0, 320)}`));\n    }\n    return;\n  }\n\n  if (action === 'mcp-call' || action === 'mcp' || action === 'call') {\n    const toolName = tokens[1];\n    if (!toolName) {\n      console.error(chalk.red('') + ' Missing tool name\\n\\n' + chalk.dim('Usage: opta models skills mcp-call <tool-name> [--args <json|@file>] [--approve]'));\n      throw new ExitError(EXIT.MISUSE);\n    }\n    let approved = false;\n    let argumentsPayload: Record<string, unknown> = {};\n    for (let i = 2; i < tokens.length; i += 1) {\n      const token = tokens[i]!;\n      if (token === '--approve') {\n        approved = true;\n        continue;\n      }\n      if (token === '--args') {\n        const value = tokens[i + 1];\n        if (!value) {\n          console.error(chalk.red('') + ' Missing value for --args');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        argumentsPayload = await parseJsonObjectOption(value, '--args');\n        i += 1;\n        continue;\n      }\n      console.error(chalk.red('') + ` Unknown option: ${token}`);\n      throw new ExitError(EXIT.MISUSE);\n    }\n\n    const payload = await client.skillMcpCall(\n      { name: toolName, arguments: argumentsPayload, approved },\n      { timeoutMs: 30_000, maxRetries: 0 },\n    );\n\n    if (opts?.json) {\n      console.log(JSON.stringify(payload, null, 2));\n      return;\n    }\n    const ok = payload.ok === true;\n    console.log((ok ? chalk.green('') : chalk.red('')) + ` MCP tool ${toolName} ${ok ? 'completed' : 'failed'}`);\n    if (payload.error) console.log(chalk.red(`  Error: ${payload.error}`));\n    return;\n  }\n\n  if (action === 'openclaw' || action === 'invoke') {\n    const toolName = tokens[1];\n    if (!toolName) {\n      console.error(chalk.red('') + ' Missing tool name\\n\\n' + chalk.dim('Usage: opta models skills openclaw <tool-name> [--args <json|@file>] [--approve] [--timeout <sec>]'));\n      throw new ExitError(EXIT.MISUSE);\n    }\n    let approved = false;\n    let timeoutSec: number | undefined;\n    let argumentsPayload: Record<string, unknown> = {};\n    for (let i = 2; i < tokens.length; i += 1) {\n      const token = tokens[i]!;\n      if (token === '--approve') {\n        approved = true;\n        continue;\n      }\n      if (token === '--timeout') {\n        const value = tokens[i + 1];\n        const parsed = value ? Number.parseFloat(value) : Number.NaN;\n        if (!Number.isFinite(parsed) || parsed <= 0 || parsed > 600) {\n          console.error(chalk.red('') + ' --timeout must be > 0 and <= 600 seconds');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        timeoutSec = parsed;\n        i += 1;\n        continue;\n      }\n      if (token === '--args') {\n        const value = tokens[i + 1];\n        if (!value) {\n          console.error(chalk.red('') + ' Missing value for --args');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        argumentsPayload = await parseJsonObjectOption(value, '--args');\n        i += 1;\n        continue;\n      }\n      console.error(chalk.red('') + ` Unknown option: ${token}`);\n      throw new ExitError(EXIT.MISUSE);\n    }\n\n    const payload = await client.skillOpenClawInvoke(\n      {\n        name: toolName,\n        arguments: argumentsPayload,\n        approved,\n        timeoutSec,\n      },\n      { timeoutMs: Math.max(10_000, timeoutSec ? Math.round(timeoutSec * 1000) : 30_000), maxRetries: 0 },\n    );\n\n    if (opts?.json) {\n      console.log(JSON.stringify(payload, null, 2));\n      return;\n    }\n    const ok = payload.ok === true;\n    console.log((ok ? chalk.green('') : chalk.red('')) + ` OpenClaw invoke ${toolName} ${ok ? 'completed' : 'failed'}`);\n    if (payload.error) console.log(chalk.red(`  Error: ${payload.error}`));\n    return;\n  }\n\n  console.error(\n    chalk.red('') + ` Unknown skills action: ${action}\\n\\n` +\n    chalk.dim('Usage: opta models skills [list|show <skill-name>|tools|run <skill-name>|mcp-call <tool-name>|openclaw <tool-name>] [--all]'),\n  );\n  throw new ExitError(EXIT.MISUSE);\n}\n\nasync function runRagCommand(\n  args: string | undefined,\n  client: LmxClient,\n  opts?: ModelsOptions,\n): Promise<void> {\n  const tokens = parseShellLikeArgs(args ?? '');\n  const action = (tokens[0] ?? 'collections').toLowerCase();\n\n  if (action === 'collections' || action === 'list') {\n    const payload = await client.ragCollections(FAST_DISCOVERY_REQUEST_OPTS);\n    if (opts?.json) {\n      console.log(JSON.stringify(payload, null, 2));\n      return;\n    }\n    console.log(chalk.bold('RAG Collections\\n'));\n    console.log(`  Collections: ${payload.collection_count}`);\n    console.log(`  Documents:   ${payload.total_documents}`);\n    if (payload.collections.length === 0) {\n      console.log(chalk.dim('  No collections found.'));\n      return;\n    }\n    for (const collection of payload.collections) {\n      console.log(\n        `  ${chalk.cyan(collection.name)}  ${chalk.dim(`${collection.document_count} docs  ${collection.embedding_dimensions} dims`)}`,\n      );\n    }\n    return;\n  }\n\n  if (action === 'delete') {\n    const collection = tokens[1];\n    if (!collection) {\n      console.error(chalk.red('') + ' Missing collection name\\n\\n' + chalk.dim('Usage: opta models rag delete <collection>'));\n      throw new ExitError(EXIT.MISUSE);\n    }\n    await client.ragDeleteCollection(collection, FAST_DISCOVERY_REQUEST_OPTS);\n    if (opts?.json) {\n      console.log(JSON.stringify({ ok: true, deleted: collection }, null, 2));\n    } else {\n      console.log(chalk.green('') + ` Deleted collection ${chalk.cyan(collection)}`);\n    }\n    return;\n  }\n\n  if (action === 'query') {\n    const collection = tokens[1];\n    const query = tokens[2];\n    if (!collection || !query) {\n      console.error(\n        chalk.red('') + ' Missing query arguments\\n\\n' +\n        chalk.dim('Usage: opta models rag query <collection> \"<query>\" [--top-k <n>] [--min-score <n>] [--mode vector|keyword|hybrid] [--rerank]'),\n      );\n      throw new ExitError(EXIT.MISUSE);\n    }\n    let topK: number | undefined;\n    let minScore: number | undefined;\n    let searchMode: 'vector' | 'keyword' | 'hybrid' | undefined;\n    let rerank = false;\n    for (let i = 3; i < tokens.length; i += 1) {\n      const token = tokens[i]!;\n      if (token === '--top-k') {\n        const value = tokens[i + 1];\n        const parsed = value ? Number.parseInt(value, 10) : Number.NaN;\n        if (!Number.isFinite(parsed) || parsed < 1 || parsed > 50) {\n          console.error(chalk.red('') + ' --top-k must be between 1 and 50');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        topK = parsed;\n        i += 1;\n        continue;\n      }\n      if (token === '--min-score') {\n        const value = tokens[i + 1];\n        const parsed = value ? Number.parseFloat(value) : Number.NaN;\n        if (!Number.isFinite(parsed) || parsed < 0 || parsed > 1) {\n          console.error(chalk.red('') + ' --min-score must be between 0 and 1');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        minScore = parsed;\n        i += 1;\n        continue;\n      }\n      if (token === '--mode') {\n        const value = tokens[i + 1];\n        if (!value || !['vector', 'keyword', 'hybrid'].includes(value)) {\n          console.error(chalk.red('') + ' --mode must be vector, keyword, or hybrid');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        searchMode = value as 'vector' | 'keyword' | 'hybrid';\n        i += 1;\n        continue;\n      }\n      if (token === '--rerank') {\n        rerank = true;\n        continue;\n      }\n      console.error(chalk.red('') + ` Unknown option: ${token}`);\n      throw new ExitError(EXIT.MISUSE);\n    }\n    const payload = await client.ragQuery(\n      {\n        collection,\n        query,\n        topK,\n        minScore,\n        searchMode,\n        rerank,\n      },\n      { timeoutMs: 30_000, maxRetries: 0 },\n    );\n    if (opts?.json) {\n      console.log(JSON.stringify(payload, null, 2));\n      return;\n    }\n    const results = Array.isArray(payload.results) ? payload.results : [];\n    console.log(chalk.bold('RAG Query\\n'));\n    console.log(`  Collection: ${payload.collection ?? collection}`);\n    console.log(`  Query:      ${payload.query ?? query}`);\n    console.log(`  Results:    ${results.length}`);\n    if (results.length === 0) {\n      console.log(chalk.dim('  No matches found.'));\n      return;\n    }\n    for (const row of results.slice(0, 8)) {\n      const text = typeof row.text === 'string' ? row.text.replace(/\\s+/g, ' ').trim() : '';\n      const score = typeof row.score === 'number' ? row.score.toFixed(3) : 'n/a';\n      console.log(`  score=${score}  ${text.slice(0, 110)}`);\n    }\n    return;\n  }\n\n  if (action === 'ingest') {\n    const collection = tokens[1];\n    if (!collection) {\n      console.error(\n        chalk.red('') + ' Missing collection name\\n\\n' +\n        chalk.dim('Usage: opta models rag ingest <collection> (--file <path> | --text \"<content>\" | --stdin) [--metadata <json|@file>] [--chunking <auto|text|code|markdown_headers|none>] [--chunk-size <n>] [--chunk-overlap <n>] [--model <id>]'),\n      );\n      throw new ExitError(EXIT.MISUSE);\n    }\n\n    let filePath: string | undefined;\n    let inlineText: string | undefined;\n    let useStdin = false;\n    let metadataRaw: unknown;\n    let chunking: 'auto' | 'text' | 'code' | 'markdown_headers' | 'none' | undefined;\n    let chunkSize: number | undefined;\n    let chunkOverlap: number | undefined;\n    let model: string | undefined;\n\n    for (let i = 2; i < tokens.length; i += 1) {\n      const token = tokens[i]!;\n      if (token === '--file') {\n        const value = tokens[i + 1];\n        if (!value) {\n          console.error(chalk.red('') + ' Missing value for --file');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        filePath = value;\n        i += 1;\n        continue;\n      }\n      if (token === '--text') {\n        const value = tokens[i + 1];\n        if (!value) {\n          console.error(chalk.red('') + ' Missing value for --text');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        inlineText = value;\n        i += 1;\n        continue;\n      }\n      if (token === '--stdin') {\n        useStdin = true;\n        continue;\n      }\n      if (token === '--metadata') {\n        const value = tokens[i + 1];\n        if (!value) {\n          console.error(chalk.red('') + ' Missing value for --metadata');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        metadataRaw = await parseJsonValueOption(value, '--metadata');\n        i += 1;\n        continue;\n      }\n      if (token === '--chunking') {\n        const value = tokens[i + 1];\n        if (!value || !['auto', 'text', 'code', 'markdown_headers', 'none'].includes(value)) {\n          console.error(chalk.red('') + ' --chunking must be auto, text, code, markdown_headers, or none');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        chunking = value as 'auto' | 'text' | 'code' | 'markdown_headers' | 'none';\n        i += 1;\n        continue;\n      }\n      if (token === '--chunk-size') {\n        const value = tokens[i + 1];\n        const parsed = value ? Number.parseInt(value, 10) : Number.NaN;\n        if (!Number.isFinite(parsed) || parsed < 64 || parsed > 2048) {\n          console.error(chalk.red('') + ' --chunk-size must be between 64 and 2048');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        chunkSize = parsed;\n        i += 1;\n        continue;\n      }\n      if (token === '--chunk-overlap') {\n        const value = tokens[i + 1];\n        const parsed = value ? Number.parseInt(value, 10) : Number.NaN;\n        if (!Number.isFinite(parsed) || parsed < 0 || parsed > 512) {\n          console.error(chalk.red('') + ' --chunk-overlap must be between 0 and 512');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        chunkOverlap = parsed;\n        i += 1;\n        continue;\n      }\n      if (token === '--model') {\n        const value = tokens[i + 1];\n        if (!value) {\n          console.error(chalk.red('') + ' Missing value for --model');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        model = value;\n        i += 1;\n        continue;\n      }\n      console.error(chalk.red('') + ` Unknown option: ${token}`);\n      throw new ExitError(EXIT.MISUSE);\n    }\n\n    const inputModes = [Boolean(filePath), Boolean(inlineText), useStdin].filter(Boolean).length;\n    if (inputModes !== 1) {\n      console.error(chalk.red('') + ' Specify exactly one of --file, --text, or --stdin');\n      throw new ExitError(EXIT.MISUSE);\n    }\n\n    let documentText = '';\n    if (filePath) {\n      documentText = await readFile(filePath, 'utf8');\n    } else if (inlineText) {\n      documentText = inlineText;\n    } else if (useStdin) {\n      documentText = await readStdinText();\n    }\n    if (!documentText.trim()) {\n      console.error(chalk.red('') + ' Ingest content is empty');\n      throw new ExitError(EXIT.MISUSE);\n    }\n\n    let metadata: Array<Record<string, unknown>> | undefined;\n    if (metadataRaw !== undefined) {\n      if (Array.isArray(metadataRaw)) {\n        const rows = metadataRaw.filter((value): value is Record<string, unknown> => Boolean(value) && typeof value === 'object' && !Array.isArray(value));\n        if (rows.length === 0) {\n          console.error(chalk.red('') + ' --metadata array must contain at least one object');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        metadata = rows;\n      } else if (metadataRaw && typeof metadataRaw === 'object') {\n        metadata = [metadataRaw as Record<string, unknown>];\n      } else {\n        console.error(chalk.red('') + ' --metadata must be a JSON object or an array of objects');\n        throw new ExitError(EXIT.MISUSE);\n      }\n    }\n\n    const payload = await client.ragIngest(\n      {\n        collection,\n        documents: [documentText],\n        metadata,\n        chunking,\n        chunkSize,\n        chunkOverlap,\n        model,\n      },\n      { timeoutMs: 60_000, maxRetries: 0 },\n    );\n\n    if (opts?.json) {\n      console.log(JSON.stringify(payload, null, 2));\n      return;\n    }\n\n    console.log(chalk.green('') + ` Ingested into ${chalk.cyan(collection)}`);\n    console.log(`  Documents: ${payload.documents_ingested ?? 0}`);\n    console.log(`  Chunks:    ${payload.chunks_created ?? 0}`);\n    if (payload.duration_ms !== undefined) {\n      console.log(`  Duration:  ${payload.duration_ms.toFixed(1)} ms`);\n    }\n    return;\n  }\n\n  if (action === 'context') {\n    const query = tokens[1];\n    if (!query) {\n      console.error(\n        chalk.red('') + ' Missing query text\\n\\n' +\n        chalk.dim('Usage: opta models rag context \"<query>\" --collections <c1,c2> [--top-k-per-collection <n>] [--min-score <n>] [--max-context-tokens <n>] [--model <id>] [--rerank]'),\n      );\n      throw new ExitError(EXIT.MISUSE);\n    }\n    let collections: string[] = [];\n    let topKPerCollection: number | undefined;\n    let minScore: number | undefined;\n    let maxContextTokens: number | undefined;\n    let model: string | undefined;\n    let rerank = false;\n\n    for (let i = 2; i < tokens.length; i += 1) {\n      const token = tokens[i]!;\n      if (token === '--collections') {\n        const value = tokens[i + 1];\n        if (!value) {\n          console.error(chalk.red('') + ' Missing value for --collections');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        collections = parseCsvList(value);\n        i += 1;\n        continue;\n      }\n      if (token === '--top-k-per-collection') {\n        const value = tokens[i + 1];\n        const parsed = value ? Number.parseInt(value, 10) : Number.NaN;\n        if (!Number.isFinite(parsed) || parsed < 1 || parsed > 20) {\n          console.error(chalk.red('') + ' --top-k-per-collection must be between 1 and 20');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        topKPerCollection = parsed;\n        i += 1;\n        continue;\n      }\n      if (token === '--min-score') {\n        const value = tokens[i + 1];\n        const parsed = value ? Number.parseFloat(value) : Number.NaN;\n        if (!Number.isFinite(parsed) || parsed < 0 || parsed > 1) {\n          console.error(chalk.red('') + ' --min-score must be between 0 and 1');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        minScore = parsed;\n        i += 1;\n        continue;\n      }\n      if (token === '--max-context-tokens') {\n        const value = tokens[i + 1];\n        const parsed = value ? Number.parseInt(value, 10) : Number.NaN;\n        if (!Number.isFinite(parsed) || parsed < 256 || parsed > 32768) {\n          console.error(chalk.red('') + ' --max-context-tokens must be between 256 and 32768');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        maxContextTokens = parsed;\n        i += 1;\n        continue;\n      }\n      if (token === '--model') {\n        const value = tokens[i + 1];\n        if (!value) {\n          console.error(chalk.red('') + ' Missing value for --model');\n          throw new ExitError(EXIT.MISUSE);\n        }\n        model = value;\n        i += 1;\n        continue;\n      }\n      if (token === '--rerank') {\n        rerank = true;\n        continue;\n      }\n      console.error(chalk.red('') + ` Unknown option: ${token}`);\n      throw new ExitError(EXIT.MISUSE);\n    }\n\n    if (collections.length === 0) {\n      console.error(chalk.red('') + ' --collections is required for rag context');\n      throw new ExitError(EXIT.MISUSE);\n    }\n\n    const payload = await client.ragContext(\n      {\n        query,\n        collections,\n        topKPerCollection,\n        minScore,\n        maxContextTokens,\n        model,\n        rerank,\n      },\n      { timeoutMs: 60_000, maxRetries: 0 },\n    );\n\n    if (opts?.json) {\n      console.log(JSON.stringify(payload, null, 2));\n      return;\n    }\n\n    console.log(chalk.bold('RAG Context\\n'));\n    console.log(`  Chunks:  ${payload.total_chunks ?? 0}`);\n    console.log(`  Tokens:  ${payload.estimated_tokens ?? 0}`);\n    if (payload.duration_ms !== undefined) {\n      console.log(`  Time:    ${payload.duration_ms.toFixed(1)} ms`);\n    }\n    console.log('');\n    const contextPreview = (payload.context ?? '').trim();\n    if (!contextPreview) {\n      console.log(chalk.dim('  No context assembled.'));\n    } else {\n      console.log(contextPreview.slice(0, 1200));\n      if (contextPreview.length > 1200) {\n        console.log(chalk.dim('\\n  truncated'));\n      }\n    }\n    return;\n  }\n\n  console.error(\n    chalk.red('') + ` Unknown rag action: ${action}\\n\\n` +\n    chalk.dim('Usage: opta models rag [collections|delete <collection>|query <collection> \"<query>\" [--top-k <n>] [--min-score <n>] [--mode vector|keyword|hybrid] [--rerank]|ingest <collection> (--file <path>|--text \"<content>\"|--stdin)|context \"<query>\" --collections <c1,c2>]'),\n  );\n  throw new ExitError(EXIT.MISUSE);\n}\n\nasync function runHealthCommand(\n  args: string | undefined,\n  client: LmxClient,\n  opts?: ModelsOptions,\n  connection?: {\n    host: string;\n    fallbackHosts?: string[];\n    port: number;\n    adminKey?: string;\n  },\n): Promise<void> {\n  const tokens = parseShellLikeArgs(args ?? '');\n  let includeReady = false;\n  let includeAdmin = false;\n  for (const token of tokens) {\n    if (token === '--ready') {\n      includeReady = true;\n      continue;\n    }\n    if (token === '--admin') {\n      includeAdmin = true;\n      continue;\n    }\n    console.error(chalk.red('') + ` Unknown option: ${token}`);\n    throw new ExitError(EXIT.MISUSE);\n  }\n  if (!includeReady && !includeAdmin) {\n    includeReady = true;\n    includeAdmin = true;\n  }\n\n  const liveness = await client.health(FAST_DISCOVERY_REQUEST_OPTS);\n  const host = client.getActiveHost() || connection?.host || 'localhost';\n  const port = connection?.port ?? 11434;\n  const headers: Record<string, string> = {};\n  const adminKey = connection?.adminKey?.trim();\n  if (adminKey) {\n    headers['X-Admin-Key'] = adminKey;\n  }\n\n  const fetchJsonProbe = async (\n    path: string,\n    acceptedStatuses: number[],\n    authRequired: boolean,\n  ): Promise<{ status: number; body: unknown }> => {\n    const response = await fetch(`http://${host}:${port}${path}`, {\n      method: 'GET',\n      headers: authRequired ? headers : {},\n      signal: AbortSignal.timeout(FAST_DISCOVERY_TIMEOUT_MS),\n    });\n    const text = await response.text().catch(() => '');\n    let body: unknown = text;\n    if (text.trim()) {\n      try {\n        body = JSON.parse(text);\n      } catch {\n        body = text;\n      }\n    }\n    if (!acceptedStatuses.includes(response.status)) {\n      const detail = typeof body === 'string' ? body : JSON.stringify(body);\n      throw new Error(`${path} returned HTTP ${response.status}${detail ? `: ${detail}` : ''}`);\n    }\n    return { status: response.status, body };\n  };\n\n  const ready = includeReady ? await fetchJsonProbe('/readyz', [200, 503], false) : undefined;\n  const admin = includeAdmin ? await fetchJsonProbe('/admin/health', [200], true) : undefined;\n\n  if (opts?.json) {\n    console.log(JSON.stringify({\n      host,\n      port,\n      liveness,\n      ready,\n      admin,\n    }, null, 2));\n    return;\n  }\n\n  const readyStatus = ready?.status === 200 ? chalk.green('ready') : chalk.yellow('not-ready');\n  const adminStatusRaw = (admin?.body && typeof admin.body === 'object' && !Array.isArray(admin.body))\n    ? (admin.body as Record<string, unknown>).status\n    : undefined;\n  const adminStatus = typeof adminStatusRaw === 'string' && adminStatusRaw === 'ok'\n    ? chalk.green(adminStatusRaw)\n    : typeof adminStatusRaw === 'string'\n      ? chalk.yellow(adminStatusRaw)\n      : chalk.dim('(n/a)');\n\n  console.log(chalk.bold('Model Health\\n'));\n  console.log(`  Endpoint:   ${host}:${port}`);\n  console.log(`  Liveness:   ${chalk.green(liveness.status)}`);\n  if (ready) {\n    const reason = ready.body && typeof ready.body === 'object' && !Array.isArray(ready.body)\n      ? ((ready.body as Record<string, unknown>).reason as string | undefined)\n      : undefined;\n    console.log(`  Readiness:  ${readyStatus}${reason ? chalk.dim(` (${reason})`) : ''}`);\n  }\n  if (admin) {\n    const bodyObj = admin.body && typeof admin.body === 'object' && !Array.isArray(admin.body)\n      ? admin.body as Record<string, unknown>\n      : {};\n    const modelsLoaded = typeof bodyObj.models_loaded === 'number' ? bodyObj.models_loaded : undefined;\n    const inFlight = typeof bodyObj.in_flight_requests === 'number' ? bodyObj.in_flight_requests : undefined;\n    const memoryUsage = typeof bodyObj.memory_usage_percent === 'number'\n      ? `${bodyObj.memory_usage_percent.toFixed(1)}%`\n      : undefined;\n    console.log(`  Admin:      ${adminStatus}`);\n    if (modelsLoaded !== undefined) console.log(`  Models:     ${modelsLoaded}`);\n    if (inFlight !== undefined) console.log(`  In flight:  ${inFlight}`);\n    if (memoryUsage !== undefined) console.log(`  Memory:     ${memoryUsage}`);\n  }\n}\n\nasync function stopAllModels(client: LmxClient): Promise<void> {\n  const spinner = await createSpinner();\n  spinner.start(progressText('Stop models', 10, 'fetching loaded models'));\n\n  try {\n    const result = await client.models(FAST_DISCOVERY_REQUEST_OPTS);\n    if (result.models.length === 0) {\n      spinner.succeed(progressText('Stop models', 100, 'no models loaded'));\n      return;\n    }\n\n    const total = result.models.length;\n    let successCount = 0;\n    let totalFreed = 0;\n\n    for (let i = 0; i < total; i++) {\n      const model = result.models[i]!;\n      const pct = 20 + Math.round(((i + 1) / total) * 70);\n      spinner.start(progressText('Stop models', pct, `unloading ${model.model_id} (${i + 1}/${total})`));\n      const unloadResult = await client.unloadModel(model.model_id).catch(() => null);\n      if (unloadResult) {\n        successCount += 1;\n        totalFreed += unloadResult.freed_bytes ?? 0;\n      }\n    }\n\n    spinner.succeed(\n      progressText(\n        'Stop models',\n        100,\n        `unloaded ${successCount}/${total} model${total > 1 ? 's' : ''}${totalFreed > 0 ? `  freed ${fmtGB(totalFreed)}` : ''}`,\n      ),\n    );\n  } catch (err) {\n    spinner.stop();\n    throwModelCommandError(err);\n  }\n}\n\nasync function swapModel(\n  fromName: string | undefined,\n  toName: string | undefined,\n  client: LmxClient,\n  aliasMap: ModelAliasMap = {},\n): Promise<void> {\n  const spinner = await createSpinner();\n  try {\n    const config = await loadConfig();\n    const defaultModel = normalizeConfiguredModelId(config.model.default);\n    if (!defaultModel && isPlaceholderModelId(config.model.default)) {\n      await saveConfig({ 'model.default': '', 'model.contextLimit': lookupContextLimit('') }).catch(() => {});\n    }\n    spinner.start(progressText('Swap model', 12, 'fetching model catalog'));\n    const { loaded, onDisk } = await getModelOptions(client);\n    spinner.stop();\n    console.log(chalk.dim(`  ${progressText('Swap model', 40, 'model catalog ready')}`));\n\n    if (loaded.length === 0) {\n      console.error(chalk.red('') + ' No running model to swap');\n      throw new ExitError(EXIT.NOT_FOUND);\n    }\n\n    const fromId = await resolveModelIdFromOptions(\n      fromName,\n      loaded,\n      defaultModel,\n      'Select running model to swap out',\n      aliasMap,\n    );\n\n    const targetOptions = [...onDisk, ...loaded.filter((m) => !modelIdsEqual(m.id, fromId))];\n    if (targetOptions.length === 0) {\n      console.error(chalk.red('') + ' No replacement model available on disk');\n      console.log(chalk.dim(`  Download one with ${chalk.reset('opta models download <org/model>')}`));\n      throw new ExitError(EXIT.NOT_FOUND);\n    }\n\n    const toId = await resolveModelIdFromOptions(\n      toName,\n      targetOptions,\n      defaultModel,\n      'Select replacement model',\n      aliasMap,\n    );\n\n    if (modelIdsEqual(fromId, toId)) {\n      console.error(chalk.red('') + ' Source and replacement model are the same');\n      throw new ExitError(EXIT.MISUSE);\n    }\n\n    const targetAlreadyLoaded = findMatchingModelId(\n      toId,\n      loaded.filter((m) => !modelIdsEqual(m.id, fromId)).map((m) => m.id),\n    );\n\n    const fromLoadedId = findMatchingModelId(fromId, loaded.map((m) => m.id)) ?? fromId;\n    spinner.start(progressText('Swap model', 65, `unloading ${fromLoadedId}`));\n    let unloaded: { model_id: string; freed_bytes?: number; status?: string };\n    try {\n      unloaded = await client.unloadModel(fromLoadedId);\n    } catch (err) {\n      if (err instanceof LmxApiError && err.code === 'not_found') {\n        unloaded = { model_id: fromLoadedId, status: 'unloaded', freed_bytes: 0 };\n      } else {\n        throw err;\n      }\n    }\n    try {\n      await waitForModelUnloaded(client, fromLoadedId, {\n        timeoutMs: 30_000,\n        onProgress: createUnloadProgressUpdater(spinner, 'Swap model', fromLoadedId, 65),\n      });\n    } catch (err) {\n      spinner.stop();\n      console.error(chalk.red('') + ` Failed to confirm ${fromLoadedId} was unloaded: ${errorMessage(err)}`);\n      throw err;\n    }\n    const freedStr = unloaded.freed_bytes ? chalk.dim(`  freed ${fmtGB(unloaded.freed_bytes)}`) : '';\n    spinner.succeed(progressText('Swap model', targetAlreadyLoaded ? 100 : 82, `unloaded ${fromLoadedId}${freedStr}`));\n\n    if (targetAlreadyLoaded) {\n      console.log(chalk.green('') + ` ${targetAlreadyLoaded} was already loaded`);\n      return;\n    }\n\n    try {\n      spinner.start(progressText('Swap model', 88, `loading ${toId}`));\n      const loadedId = await ensureModelLoaded(client, toId, {\n        timeoutMs: STABLE_MODEL_LOAD_TIMEOUT_MS,\n        loadRequestTimeoutMs: STABLE_MODEL_LOAD_REQUEST_TIMEOUT_MS,\n        onProgress: createLoadProgressUpdater(spinner, 'Swap model', toId, 88),\n      });\n      const snapshot = await client.models(FAST_DISCOVERY_REQUEST_OPTS).catch((err: unknown) => {\n        warnModelInventoryFallback('loaded models', err);\n        return { models: [] };\n      });\n      const details = snapshot.models.find((model) => modelIdsEqual(model.model_id, loadedId));\n      const memStr = details?.memory_bytes ? chalk.dim(`  ${fmtGB(details.memory_bytes)}`) : '';\n      spinner.succeed(progressText('Swap model', 100, `loaded ${loadedId}${memStr}`));\n    } catch (loadErr) {\n      spinner.stop();\n      console.error(chalk.yellow('!') + ` Swap load failed for ${toId}; attempting rollback to ${fromLoadedId}`);\n      try {\n        const rollbackId = await ensureModelLoaded(client, fromLoadedId, {\n          timeoutMs: STABLE_MODEL_LOAD_TIMEOUT_MS,\n          loadRequestTimeoutMs: STABLE_MODEL_LOAD_REQUEST_TIMEOUT_MS,\n          onProgress: createLoadProgressUpdater(spinner, 'Swap model', fromLoadedId, 88),\n        });\n        console.log(chalk.green('') + ` Rollback restored ${rollbackId}`);\n      } catch (rollbackErr) {\n        console.error(chalk.red('') + ` Rollback failed: ${errorMessage(rollbackErr)}`);\n      }\n      throw loadErr;\n    }\n  } catch (err) {\n    spinner.stop();\n    throwModelCommandError(err);\n  }\n}\n\nasync function scanModelsCommand(\n  _client: LmxClient,\n  config: Awaited<ReturnType<typeof loadConfig>>,\n  opts?: ModelsOptions\n): Promise<void> {\n  const spinner = opts?.json ? null : await createSpinner();\n  const { host, port } = config.connection;\n  spinner?.start(progressText('Scan models', 15, `scanning LMX (${host}:${port}) + providers`));\n\n  try {\n    const scan = await gatherScanData(config);\n    spinner?.succeed(progressText('Scan models', 100, 'scan complete'));\n\n    // --- JSON output ---\n    if (opts?.json) {\n      console.log(JSON.stringify(scan, null, 2));\n      return;\n    }\n\n    // --- Build role lookup (model_id -> role names) ---\n    const roleMap = buildRoleMap(scan.roles);\n\n    // --- Build loaded set for dedup with available ---\n    const loadedIds = new Set(scan.loaded.map((m) => m.model_id));\n    const defaultModel = config.model.default;\n\n    // --- Print: Loaded ---\n    if (!scan.lmxReachable) {\n      console.log(chalk.yellow('\\n  LMX unreachable') + chalk.dim(` (${host}:${port})\\n`));\n    } else {\n      console.log(\n        chalk.bold('\\n  Loaded') +\n          chalk.dim(` \\u2500\\u2500 LMX ${host}:${port} \\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500`)\n      );\n      if (scan.loaded.length === 0) {\n        console.log(chalk.dim('  (no models loaded)'));\n      }\n      for (const m of scan.loaded) {\n        const ctx = m.context_length ?? lookupContextLimit(m.model_id);\n        const parts: string[] = [fmtCtx(ctx)];\n        if (m.memory_bytes) parts.push(fmtGB(m.memory_bytes));\n        if (m.request_count != null && m.request_count > 0) parts.push(`${m.request_count} reqs`);\n        const roles = roleMap.get(m.model_id);\n        if (roles) parts.push(roles.map((r) => `role:${r}`).join(' '));\n        const isDefault = m.model_id === defaultModel || m.is_default;\n        const star = isDefault ? chalk.green(' \\u2605') : '';\n        const dp = getDisplayProfile(m.model_id);\n        const tag = fmtTag(dp.format);\n        console.log(\n          `  ${chalk.green('\\u25cf')} ${chalk.bold(dp.displayName)} ${tag} ${chalk.dim(dp.orgAbbrev)}  ${chalk.dim(parts.join(' \\u00b7 '))}${star}`\n        );\n      }\n\n      // --- Print: Available on disk ---\n      const unloaded = scan.available.filter((a) => !loadedIds.has(a.repo_id));\n      if (unloaded.length > 0) {\n        console.log(\n          chalk.bold('\\n  On Disk') +\n            chalk.dim(' \\u2500\\u2500 downloaded, not loaded \\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500')\n        );\n        for (const a of unloaded) {\n          const ctx = lookupContextLimit(a.repo_id);\n          const parts: string[] = [fmtCtx(ctx)];\n          if (a.size_bytes > 0) parts.push(`${fmtGB(a.size_bytes)} on disk`);\n          const dp = getDisplayProfile(a.repo_id);\n          const tag = fmtTag(dp.format);\n          console.log(`  ${chalk.dim('\\u25cb')} ${dp.displayName} ${tag} ${chalk.dim(dp.orgAbbrev)}  ${chalk.dim(parts.join(' \\u00b7 '))}`);\n        }\n      }\n    }\n\n    // --- Print: Presets ---\n    if (scan.presets.length > 0) {\n      console.log(\n        chalk.bold('\\n  Presets') +\n          chalk.dim(' \\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500')\n      );\n      for (const p of scan.presets) {\n        const modelStr = shortId(p.model);\n        const isLoaded = loadedIds.has(p.model);\n        const dot = isLoaded ? chalk.green('\\u25cf') : chalk.dim('\\u25cb');\n        const aliasStr = p.routing_alias ? chalk.cyan(`alias:\"${p.routing_alias}\"`) : '';\n        const autoStr = p.auto_load ? chalk.dim('auto-load') : '';\n        const parts = [\n          `\\u2192 ${modelStr}`,\n          aliasStr,\n          autoStr,\n        ].filter(Boolean);\n        console.log(\n          `  ${dot} ${chalk.bold(p.name.padEnd(20))} ${chalk.dim(parts.join('  '))}`\n        );\n      }\n    }\n\n    // --- Print: Cloud providers ---\n    if (scan.cloud.length > 0) {\n      const statusStr = scan.cloudHealthy\n        ? chalk.green('api key \\u2713')\n        : chalk.yellow('not configured');\n      console.log(\n        chalk.bold('\\n  Cloud') +\n          chalk.dim(` \\u2500\\u2500 Anthropic \\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500 `) +\n          statusStr\n      );\n      for (const m of scan.cloud) {\n        const ctx = m.contextLength ? fmtCtx(m.contextLength) : '';\n        const name = m.name ?? m.id;\n        console.log(`  ${chalk.blue('\\u2601')} ${m.id}  ${chalk.dim(name !== m.id ? `${name}  ` : '')}${chalk.dim(ctx)}`);\n      }\n    }\n\n    // --- Print: Memory summary ---\n    if (scan.memory) {\n      const pct = Math.round((scan.memory.used_gb / scan.memory.total_unified_memory_gb) * 100);\n      const pctColor = pct > 80 ? chalk.red : pct > 60 ? chalk.yellow : chalk.green;\n      console.log(\n        chalk.bold('\\n  Memory') +\n          chalk.dim(' \\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500')\n      );\n      console.log(\n        `  ${scan.memory.used_gb.toFixed(1)} / ${scan.memory.total_unified_memory_gb.toFixed(1)} GB used ` +\n          pctColor(`(${pct}%)`) +\n          chalk.dim(` \\u00b7 threshold ${scan.memory.threshold_percent}%`)\n      );\n    }\n\n    // --- Print: Summary footer ---\n    const summary = summarizeScan(scan);\n    const counts: string[] = [];\n    if (summary.loadedCount > 0) counts.push(`${summary.loadedCount} loaded`);\n    if (summary.onDiskCount > 0) counts.push(`${summary.onDiskCount} on disk`);\n    if (summary.presetCount > 0) counts.push(`${summary.presetCount} presets`);\n    if (summary.cloudCount > 0) counts.push(`${summary.cloudCount} cloud`);\n\n    console.log(`\\n  ${chalk.dim(counts.join(' \\u00b7 '))}`);\n    console.log(chalk.dim(`  'opta models load <name>'         load from disk`));\n    console.log(chalk.dim(`  'opta models stop'                unload all models`));\n    console.log(chalk.dim(`  'opta models swap <old> <new>'    swap running model`));\n    console.log(chalk.dim(`  'opta models use <name>'          switch default\\n`));\n  } catch (err) {\n    spinner?.stop();\n    throwModelCommandError(err);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/commands/onboard.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/commands/rerank.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-type-conversion","severity":1,"message":"Passing a string to String() does not change the type or value of the string.","line":45,"column":75,"nodeType":"Identifier","messageId":"unnecessaryTypeConversion","endLine":45,"endColumn":81,"suggestions":[{"messageId":"suggestRemove","fix":{"range":[1601,1625],"text":"(queryInput ?? '')"},"desc":"Remove the type conversion."},{"messageId":"suggestSatisfies","data":{"type":"string"},"fix":{"range":[1601,1625],"text":"((queryInput ?? '') satisfies string)"},"desc":"Instead, assert that the value satisfies the string type."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":45,"column":82,"nodeType":"Identifier","messageId":"neverNullish","endLine":45,"endColumn":92}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import chalk from 'chalk';\nimport { loadConfig } from '../core/config.js';\nimport { EXIT, ExitError } from '../core/errors.js';\nimport { LmxApiError, LmxClient } from '../lmx/client.js';\nimport type { LmxRerankDocumentResult } from '../lmx/client.js';\nimport { errorMessage } from '../utils/errors.js';\n\ninterface RerankOptions {\n  documents?: string;\n  model?: string;\n  topK?: string;\n  json?: boolean;\n}\n\nconst RERANK_REQUEST_OPTS = { timeoutMs: 30_000, maxRetries: 0 } as const;\n\nfunction usage(): void {\n  console.log(\n    chalk.dim('Usage: opta rerank <query> --documents <doc1|doc2|...> [--model <id>] [--top-k <n>] [--json]'),\n  );\n}\n\nfunction parseDocuments(raw: string | undefined): string[] {\n  if (!raw) return [];\n  return raw.split('|').map((entry) => entry.trim()).filter(Boolean);\n}\n\nfunction parseTopK(raw: string | undefined): number | undefined {\n  if (!raw || !raw.trim()) return undefined;\n  const parsed = Number.parseInt(raw.trim(), 10);\n  if (!Number.isFinite(parsed) || parsed < 1) {\n    throw new Error('--top-k must be a positive integer');\n  }\n  return parsed;\n}\n\nfunction formatDocumentPreview(result: LmxRerankDocumentResult, fallbackDocuments: string[]): string {\n  const text = result.document?.text ?? fallbackDocuments[result.index] ?? '';\n  const normalized = text.replace(/\\s+/g, ' ').trim();\n  if (normalized.length <= 96) return normalized;\n  return `${normalized.slice(0, 93)}...`;\n}\n\nexport async function rerank(queryInput: string | string[], opts: RerankOptions = {}): Promise<void> {\n  const query = Array.isArray(queryInput) ? queryInput.join(' ').trim() : String(queryInput ?? '').trim();\n  if (!query) {\n    console.error(chalk.red('') + ' Query is required.\\n');\n    usage();\n    throw new ExitError(EXIT.MISUSE);\n  }\n\n  const documents = parseDocuments(opts.documents);\n  if (documents.length === 0) {\n    console.error(chalk.red('') + ' --documents is required and must include at least one document.\\n');\n    usage();\n    throw new ExitError(EXIT.MISUSE);\n  }\n\n  let topK: number | undefined;\n  try {\n    topK = parseTopK(opts.topK);\n  } catch (err) {\n    console.error(chalk.red('') + ` ${errorMessage(err)}\\n`);\n    usage();\n    throw new ExitError(EXIT.MISUSE);\n  }\n\n  const config = await loadConfig();\n  const resolvedModel = (opts.model?.trim() || config.model.default || 'rerank-v1').trim();\n  const client = new LmxClient({\n    host: config.connection.host,\n    fallbackHosts: config.connection.fallbackHosts,\n    port: config.connection.port,\n    adminKey: config.connection.adminKey,\n  });\n\n  try {\n    const response = await client.rerankDocuments(\n      {\n        model: resolvedModel,\n        query,\n        documents,\n        topN: topK,\n      },\n      RERANK_REQUEST_OPTS,\n    );\n\n    if (opts.json) {\n      console.log(JSON.stringify(response, null, 2));\n      return;\n    }\n\n    const usageTokens = response.usage?.total_tokens;\n    console.log(chalk.green('') + ` Reranked ${documents.length} document${documents.length === 1 ? '' : 's'} with ${response.model}`);\n    console.log(chalk.dim(`  query: ${query}`));\n    if (typeof usageTokens === 'number') {\n      console.log(chalk.dim(`  tokens: ${usageTokens}`));\n    }\n\n    if (!Array.isArray(response.results) || response.results.length === 0) {\n      console.log(chalk.dim('  No results returned.'));\n      return;\n    }\n\n    for (const [rank, result] of response.results.entries()) {\n      const score = Number.isFinite(result.relevance_score) ? result.relevance_score.toFixed(4) : 'n/a';\n      const preview = formatDocumentPreview(result, documents);\n      console.log(`  ${rank + 1}. [${score}] doc#${result.index + 1} ${preview}`);\n    }\n  } catch (err) {\n    if (err instanceof LmxApiError && err.code === 'connection_error') {\n      console.error(\n        chalk.red('')\n        + ` Unable to reach Opta LMX at ${config.connection.host}:${config.connection.port}`,\n      );\n      console.error(chalk.dim(`  ${err.message}`));\n      throw new ExitError(EXIT.NO_CONNECTION);\n    }\n\n    console.error(chalk.red('') + ` Failed to rerank documents: ${errorMessage(err)}`);\n    throw new ExitError(EXIT.ERROR);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/commands/serve.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":97,"column":18,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":97,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { execFileSync, spawn } from 'node:child_process';\nimport { lookup } from 'node:dns/promises';\nimport { isIP } from 'node:net';\nimport chalk from 'chalk';\nimport { loadConfig } from '../core/config.js';\nimport { OptaError, ExitError, EXIT } from '../core/errors.js';\nimport { createSpinner } from '../ui/spinner.js';\nimport { colorizeOptaWord } from '../ui/brand.js';\nimport { LmxClient } from '../lmx/client.js';\nimport { errorMessage } from '../utils/errors.js';\nimport { sleep } from '../utils/common.js';\n\ninterface ServeOptions {\n  json?: boolean;\n}\n\nconst REMOTE_LAUNCHD_LABEL = 'com.opta.lmx';\nconst STARTUP_WAIT_MS = 90_000;\nconst DEFAULT_SSH_CONNECT_TIMEOUT_SECONDS = 25;\nconst FAST_HEALTH_REQUEST_OPTS = { timeoutMs: 2_000, maxRetries: 0 } as const;\n\nexport async function serve(\n  action?: string,\n  opts?: ServeOptions,\n): Promise<void> {\n  switch (action) {\n    case 'start':\n      await serveStart(opts);\n      return;\n    case 'stop':\n      await serveStop(opts);\n      return;\n    case 'restart':\n      await serveStop(opts);\n      await serveStart(opts);\n      return;\n    case 'logs':\n      await serveLogs();\n      return;\n    default:\n      await serveStatus(opts);\n  }\n}\n\nfunction isRemoteHost(host: string): boolean {\n  return host !== '127.0.0.1' && host !== 'localhost';\n}\n\nfunction expandHome(path: string): string {\n  return path.replace('~', process.env.HOME ?? '');\n}\n\nfunction quoteSh(value: string): string {\n  return `'${value.replace(/'/g, `'\\\"'\\\"'`)}'`;\n}\n\nfunction resolveHostCandidates(primaryHost: string, fallbackHosts: readonly string[] = []): string[] {\n  const seen = new Set<string>();\n  const candidates: string[] = [];\n  for (const host of [primaryHost, ...fallbackHosts]) {\n    const value = host.trim();\n    if (!value) continue;\n    const key = value.toLowerCase();\n    if (seen.has(key)) continue;\n    seen.add(key);\n    candidates.push(value);\n  }\n  return candidates.length > 0 ? candidates : [primaryHost];\n}\n\nasync function expandSshHostCandidates(\n  primaryHost: string,\n  fallbackHosts: readonly string[] = [],\n): Promise<string[]> {\n  const base = resolveHostCandidates(primaryHost, fallbackHosts);\n  const seen = new Set<string>();\n  const candidates: string[] = [];\n\n  const pushUnique = (value: string): void => {\n    const normalized = value.trim();\n    if (!normalized) return;\n    const key = normalized.toLowerCase();\n    if (seen.has(key)) return;\n    seen.add(key);\n    candidates.push(normalized);\n  };\n\n  const lookupResults = await Promise.allSettled(\n    base.map(async (host) => {\n      if (isIP(host) !== 0) return [] as string[];\n      const addresses = await lookup(host, { all: true, verbatim: false });\n      return addresses.map((entry) => entry.address);\n    }),\n  );\n\n  for (let i = 0; i < base.length; i++) {\n    const host = base[i]!;\n    pushUnique(host);\n    const resolved = lookupResults[i];\n    if (!resolved || resolved.status !== 'fulfilled') continue;\n    for (const address of resolved.value) {\n      pushUnique(address);\n    }\n  }\n\n  return candidates.length > 0 ? candidates : base;\n}\n\nfunction resolveSshConnectTimeoutSeconds(configuredSeconds: number | undefined): number {\n  return Math.max(\n    3,\n    Math.floor(configuredSeconds || DEFAULT_SSH_CONNECT_TIMEOUT_SECONDS),\n  );\n}\n\nfunction extractExecOutput(err: unknown): string | null {\n  if (!err || typeof err !== 'object') return null;\n  const stdout = (err as { stdout?: unknown }).stdout;\n  const stderr = (err as { stderr?: unknown }).stderr;\n  const outText = typeof stdout === 'string'\n    ? stdout\n    : Buffer.isBuffer(stdout)\n      ? stdout.toString('utf8')\n      : '';\n  const errText = typeof stderr === 'string'\n    ? stderr\n    : Buffer.isBuffer(stderr)\n      ? stderr.toString('utf8')\n      : '';\n  const merged = [errText.trim(), outText.trim()].filter(Boolean).join('\\n');\n  return merged || null;\n}\n\nfunction canImportModule(python: string, moduleName: string): boolean {\n  try {\n    execFileSync(\n      python,\n      ['-c', `import ${moduleName}`],\n      { stdio: 'ignore', timeout: 4_000 },\n    );\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nfunction canRunModule(python: string, moduleName: string): boolean {\n  try {\n    execFileSync(\n      python,\n      ['-m', moduleName, '--help'],\n      { stdio: 'ignore', timeout: 6_000 },\n    );\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nfunction resolveLocalInvocation(): { python: string; module: string } {\n  const candidates = [\n    process.env['OPTA_PYTHON'],\n    '.venv/bin/python',\n    '/Users/Shared/Opta-LMX/venv/bin/python',\n    'python3',\n    'python',\n  ]\n    .filter((value): value is string => typeof value === 'string' && value.trim().length > 0)\n    .map((value) => value.trim());\n\n  for (const python of candidates) {\n    if (canImportModule(python, 'opta_lmx.main')) {\n      return { python, module: 'opta_lmx.main' };\n    }\n  }\n  for (const python of candidates) {\n    if (canRunModule(python, 'opta_lmx')) {\n      return { python, module: 'opta_lmx' };\n    }\n  }\n\n  throw new Error(\n    'No usable Python runtime found for Opta LMX. Tried .venv/bin/python, /Users/Shared/Opta-LMX/venv/bin/python, python3, python',\n  );\n}\n\nfunction buildRemoteStartScript(lmxPath: string, configuredPython: string, port: number): string {\n  const repoPython = `${lmxPath}/.venv/bin/python`;\n  const configPath = `${lmxPath}/config/mono512-current.yaml`;\n\n  return [\n    'set -e',\n    `if launchctl print gui/$(id -u)/${REMOTE_LAUNCHD_LABEL} >/dev/null 2>&1; then`,\n    `  launchctl kickstart -k gui/$(id -u)/${REMOTE_LAUNCHD_LABEL}`,\n    '  exit 0',\n    'fi',\n    `cd ${quoteSh(lmxPath)}`,\n    'PY=\"\"',\n    'ENTRY=\"\"',\n    `if [ -x ${quoteSh(repoPython)} ] && ${quoteSh(repoPython)} -c \"import opta_lmx.main\" >/dev/null 2>&1; then`,\n    `  PY=${quoteSh(repoPython)}`,\n    '  ENTRY=\"opta_lmx.main\"',\n    `elif [ -x ${quoteSh(configuredPython)} ] && ${quoteSh(configuredPython)} -c \"import opta_lmx.main\" >/dev/null 2>&1; then`,\n    `  PY=${quoteSh(configuredPython)}`,\n    '  ENTRY=\"opta_lmx.main\"',\n    `elif [ -x ${quoteSh(configuredPython)} ] && ${quoteSh(configuredPython)} -m opta_lmx --help >/dev/null 2>&1; then`,\n    `  PY=${quoteSh(configuredPython)}`,\n    '  ENTRY=\"opta_lmx\"',\n    'elif command -v python3 >/dev/null 2>&1 && python3 -c \"import opta_lmx.main\" >/dev/null 2>&1; then',\n    '  PY=\"python3\"',\n    '  ENTRY=\"opta_lmx.main\"',\n    'else',\n    `  echo \"No usable python runtime for Opta LMX. Tried ${repoPython}, ${configuredPython}, python3\" >&2`,\n    '  exit 42',\n    'fi',\n    `if [ -f ${quoteSh(configPath)} ] && [ \"$ENTRY\" = \"opta_lmx.main\" ]; then`,\n    `  nohup env LMX_LOGGING__FILE=/tmp/opta-lmx.log \"$PY\" -m \"$ENTRY\" --config ${quoteSh(configPath)} --host 0.0.0.0 --port ${port} >/tmp/opta-lmx.log 2>&1 &`,\n    'else',\n    `  nohup env LMX_LOGGING__FILE=/tmp/opta-lmx.log \"$PY\" -m \"$ENTRY\" --host 0.0.0.0 --port ${port} >/tmp/opta-lmx.log 2>&1 &`,\n    'fi',\n    'sleep 1',\n  ].join('\\n');\n}\n\nasync function serveStatus(opts?: ServeOptions): Promise<void> {\n  const config = await loadConfig();\n  const { host, port } = config.connection;\n  const client = new LmxClient({\n    host,\n    fallbackHosts: config.connection.fallbackHosts,\n    port,\n    adminKey: config.connection.adminKey,\n  });\n\n  try {\n    const health = await client.health(FAST_HEALTH_REQUEST_OPTS);\n    const status = await client.status(FAST_HEALTH_REQUEST_OPTS);\n\n    if (opts?.json) {\n      console.log(JSON.stringify({ running: true, health, status }, null, 2));\n      return;\n    }\n\n    console.log(chalk.green('') + ` ${colorizeOptaWord(`Opta LMX running at ${host}:${port}`)}`);\n    if (status.version) console.log(chalk.dim(`  Version: ${status.version}`));\n    if (status.uptime_seconds != null) console.log(chalk.dim(`  Uptime:  ${formatDuration(status.uptime_seconds)}`));\n    console.log(chalk.dim(`  Models:  ${status.models.length} loaded`));\n  } catch {\n    if (opts?.json) {\n      console.log(JSON.stringify({ running: false, host, port }, null, 2));\n      return;\n    }\n    console.log(chalk.red('') + ` ${colorizeOptaWord(`Opta LMX is not reachable at ${host}:${port}`)}`);\n    console.log(chalk.dim(`  Start it: opta serve start`));\n  }\n}\n\nasync function serveStart(opts?: ServeOptions): Promise<void> {\n  const config = await loadConfig();\n  const { host, port } = config.connection;\n  const client = new LmxClient({\n    host,\n    fallbackHosts: config.connection.fallbackHosts,\n    port,\n    adminKey: config.connection.adminKey,\n  });\n  const spinner = await createSpinner();\n\n  // Check if already running\n  try {\n    await client.health(FAST_HEALTH_REQUEST_OPTS);\n    const activeHost = client.getActiveHost();\n    console.log(chalk.yellow('!') + ` ${colorizeOptaWord(`Opta LMX is already running at ${activeHost}:${port}`)}`);\n    return;\n  } catch {\n    // Not running  proceed with start\n  }\n\n  const isRemote = isRemoteHost(host);\n  let remoteHostCandidates: string[] = [];\n\n  spinner.start(`Starting Opta LMX on ${isRemote ? host : 'localhost'}...`);\n\n  try {\n    if (isRemote) {\n      const { ssh } = config.connection;\n      const identityFile = expandHome(ssh.identityFile);\n      const remoteScript = buildRemoteStartScript(ssh.lmxPath, ssh.pythonPath, port);\n      const hostCandidates = await expandSshHostCandidates(host, config.connection.fallbackHosts);\n      remoteHostCandidates = hostCandidates;\n      const sshConnectTimeoutSec = resolveSshConnectTimeoutSeconds(ssh.connectTimeoutSec);\n      const failures: string[] = [];\n      let startedHost: string | null = null;\n\n      for (const candidate of hostCandidates) {\n        const sshTarget = `${ssh.user}@${candidate}`;\n        const args = [\n          '-o',\n          'BatchMode=yes',\n          '-o',\n          `ConnectTimeout=${sshConnectTimeoutSec}`,\n          '-i',\n          identityFile,\n          sshTarget,\n          `bash -lc ${quoteSh(remoteScript)}`,\n        ];\n        try {\n          execFileSync('ssh', args, { timeout: 25_000, stdio: 'pipe' });\n          startedHost = candidate;\n          break;\n        } catch (err) {\n          const detail = extractExecOutput(err) ?? errorMessage(err);\n          failures.push(`${candidate}: ${detail}`);\n        }\n      }\n\n      if (!startedHost) {\n        throw new OptaError(\n          `Failed to start Opta LMX on ${host}`,\n          EXIT.NO_CONNECTION,\n          [\n            'SSH launch failed on all configured hosts.',\n            ...failures.slice(0, 4),\n          ],\n          [\n            `Check SSH access: ssh -i ${config.connection.ssh.identityFile} ${config.connection.ssh.user}@${host}`,\n            config.connection.fallbackHosts.length > 0\n              ? `Try fallback hosts: ${config.connection.fallbackHosts.join(', ')}`\n              : 'Configure fallback hosts: opta config set connection.fallbackHosts hostA,hostB',\n            'Check logs: opta serve logs',\n          ],\n        );\n      }\n    } else {\n      const invocation = resolveLocalInvocation();\n      const child = spawn(\n        invocation.python,\n        ['-m', invocation.module, '--host', '0.0.0.0', '--port', String(port)],\n        { detached: true, stdio: 'ignore' },\n      );\n      child.unref();\n    }\n\n    // Poll for health (up to 90 seconds to allow remote cold starts).\n    const maxWait = STARTUP_WAIT_MS;\n    const interval = 1_000;\n    const deadline = Date.now() + maxWait;\n\n    while (Date.now() < deadline) {\n        await sleep(interval);\n      try {\n        await client.health(FAST_HEALTH_REQUEST_OPTS);\n        const activeHost = client.getActiveHost();\n        spinner.succeed(`Opta LMX started at ${activeHost}:${port}`);\n\n        if (opts?.json) {\n          console.log(JSON.stringify({ started: true, host: activeHost, port }, null, 2));\n        }\n        return;\n      } catch {\n        // Not ready yet\n      }\n    }\n\n    if (isRemote) {\n      const { ssh } = config.connection;\n      const identityFile = expandHome(ssh.identityFile);\n      const sshConnectTimeoutSec = resolveSshConnectTimeoutSeconds(ssh.connectTimeoutSec);\n      const verifyCandidates = remoteHostCandidates.length > 0\n        ? remoteHostCandidates\n        : await expandSshHostCandidates(host, config.connection.fallbackHosts);\n\n      let remotelyHealthy = false;\n      for (const candidate of verifyCandidates) {\n        const sshTarget = `${ssh.user}@${candidate}`;\n        const probe = `curl -fsS -m 4 http://127.0.0.1:${port}/healthz >/dev/null`;\n        try {\n          execFileSync(\n            'ssh',\n            ['-o', `ConnectTimeout=${sshConnectTimeoutSec}`, '-i', identityFile, sshTarget, probe],\n            { timeout: 20_000, stdio: 'pipe' },\n          );\n          remotelyHealthy = true;\n          break;\n        } catch {\n          // Try next candidate.\n        }\n      }\n\n      if (remotelyHealthy) {\n        spinner.fail(`Opta LMX started on ${host} but is not reachable from this machine`);\n        throw new OptaError(\n          `Opta LMX started remotely but LAN access failed at ${host}:${port}`,\n          EXIT.NO_CONNECTION,\n          [\n            'Remote daemon health check succeeded via SSH localhost probe.',\n            'Direct HTTP health checks from local machine timed out.',\n          ],\n          [\n            `Check remote firewall rules for TCP ${port}`,\n            `Confirm bind host in remote config includes 0.0.0.0`,\n            `Temporary workaround: ssh -N -L ${port}:127.0.0.1:${port} ${ssh.user}@${host}`,\n            'Then retry: opta status',\n          ],\n        );\n      }\n    }\n\n    spinner.fail(`Opta LMX did not start within ${Math.round(maxWait / 1000)} seconds`);\n    console.log(chalk.dim(`  Check logs: opta serve logs`));\n    throw new ExitError(EXIT.ERROR);\n  } catch (err) {\n    spinner.fail('Failed to start Opta LMX');\n    if (err instanceof OptaError) {\n      throw err;\n    }\n    const detail = extractExecOutput(err);\n    throw new OptaError(\n      `Failed to start Opta LMX on ${host}`,\n      EXIT.ERROR,\n      [detail ?? errorMessage(err)],\n      [\n        isRemote ? `Check SSH access: ssh -i ${config.connection.ssh.identityFile} ${config.connection.ssh.user}@${host}` : 'Check Python environment',\n        isRemote ? `SSH config: opta config set connection.ssh.user <user>` : '',\n        isRemote ? `Verify remote runtime: opta config get connection.ssh.pythonPath` : '',\n        `Verify install: pip show opta-lmx`,\n        `Check logs: opta serve logs`,\n      ].filter(Boolean),\n    );\n  }\n}\n\nasync function serveStop(_opts?: ServeOptions): Promise<void> {\n  const config = await loadConfig();\n  const { host } = config.connection;\n  const isRemote = isRemoteHost(host);\n  const spinner = await createSpinner();\n\n  spinner.start(`Stopping Opta LMX on ${isRemote ? host : 'localhost'}...`);\n\n  try {\n    if (isRemote) {\n      try {\n        const { ssh } = config.connection;\n        const identityFile = expandHome(ssh.identityFile);\n        const sshConnectTimeoutSec = resolveSshConnectTimeoutSeconds(ssh.connectTimeoutSec);\n        const hostCandidates = await expandSshHostCandidates(host, config.connection.fallbackHosts);\n        const stopScript = [\n          `launchctl kill SIGTERM gui/$(id -u)/${REMOTE_LAUNCHD_LABEL} >/dev/null 2>&1 || true`,\n          'pkill -f \"python -m opta_lmx.main\" >/dev/null 2>&1 || true',\n          'pkill -f \"python -m opta_lmx\" >/dev/null 2>&1 || true',\n        ].join('; ');\n        for (const candidate of hostCandidates) {\n          const sshTarget = `${ssh.user}@${candidate}`;\n          try {\n            execFileSync(\n              'ssh',\n              ['-o', `ConnectTimeout=${sshConnectTimeoutSec}`, '-i', identityFile, sshTarget, stopScript],\n              { timeout: 20_000 },\n            );\n            break;\n          } catch {\n            // Try next host candidate.\n          }\n        }\n      } catch {\n        // pkill returns non-zero when no process found  that's fine\n      }\n    } else {\n      try {\n        execFileSync('pkill', ['-f', 'python -m opta_lmx.main'], { timeout: 5_000 });\n      } catch {\n        // No process to kill\n      }\n      try {\n        execFileSync('pkill', ['-f', 'python -m opta_lmx'], { timeout: 5_000 });\n      } catch {\n        // No process to kill\n      }\n    }\n\n    spinner.succeed('Opta LMX stopped');\n\n    if (_opts?.json) {\n      console.log(JSON.stringify({ stopped: true, host }, null, 2));\n    }\n  } catch (err) {\n    spinner.fail('Failed to stop Opta LMX');\n    throw new OptaError(\n      `Failed to stop Opta LMX on ${host}`,\n      EXIT.ERROR,\n      [errorMessage(err)],\n      [\n        isRemote ? `SSH manually: ssh ${host}` : 'Check running processes',\n      ],\n    );\n  }\n}\n\nasync function serveLogs(): Promise<void> {\n  const config = await loadConfig();\n  const { host } = config.connection;\n  const isRemote = isRemoteHost(host);\n\n  try {\n    let output: string;\n    if (isRemote) {\n      const { ssh } = config.connection;\n      const identityFile = expandHome(ssh.identityFile);\n      const sshConnectTimeoutSec = resolveSshConnectTimeoutSeconds(ssh.connectTimeoutSec);\n      const hostCandidates = await expandSshHostCandidates(host, config.connection.fallbackHosts);\n      const logsScript = [\n        'set -e',\n        'printed=0',\n        'for f in /tmp/opta-lmx.log /tmp/opta-lmx-service.log; do',\n        '  if [ -f \"$f\" ]; then',\n        '    if [ \"$printed\" = \"1\" ]; then printf \"\\\\n\"; fi',\n        '    echo \"=== $f ===\"',\n        '    tail -50 \"$f\"',\n        '    printed=1',\n        '  fi',\n        'done',\n        'if [ \"$printed\" = \"0\" ]; then echo \"No Opta LMX logs found under /tmp.\"; fi',\n      ].join('\\n');\n      const failures: string[] = [];\n      let logsOutput: string | null = null;\n      for (const candidate of hostCandidates) {\n        const sshTarget = `${ssh.user}@${candidate}`;\n        try {\n          logsOutput = execFileSync(\n            'ssh',\n            [\n              '-o',\n              `ConnectTimeout=${sshConnectTimeoutSec}`,\n              '-i',\n              identityFile,\n              sshTarget,\n              `bash -lc ${quoteSh(logsScript)}`,\n            ],\n            {\n              timeout: 30_000,\n              encoding: 'utf8',\n            },\n          );\n          break;\n        } catch (err) {\n          failures.push(`${candidate}: ${extractExecOutput(err) ?? errorMessage(err)}`);\n        }\n      }\n      if (logsOutput === null) {\n        throw new OptaError(\n          'Failed to read Opta LMX logs',\n          EXIT.ERROR,\n          failures.slice(0, 4),\n          [`SSH manually: ssh ${host}`],\n        );\n      }\n      output = logsOutput;\n    } else {\n      const localScript = [\n        'set -e',\n        'printed=0',\n        'for f in /tmp/opta-lmx.log /tmp/opta-lmx-service.log; do',\n        '  if [ -f \"$f\" ]; then',\n        '    if [ \"$printed\" = \"1\" ]; then printf \"\\\\n\"; fi',\n        '    echo \"=== $f ===\"',\n        '    tail -50 \"$f\"',\n        '    printed=1',\n        '  fi',\n        'done',\n        'if [ \"$printed\" = \"0\" ]; then echo \"No Opta LMX logs found under /tmp.\"; fi',\n      ].join('\\n');\n      output = execFileSync('bash', ['-lc', localScript], {\n        timeout: 8_000,\n        encoding: 'utf8',\n      });\n    }\n    console.log(output);\n  } catch (err) {\n    if (err instanceof OptaError) {\n      throw err;\n    }\n    throw new OptaError(\n      'Failed to read Opta LMX logs',\n      EXIT.ERROR,\n      [errorMessage(err)],\n      [isRemote ? `SSH manually: ssh ${host}` : 'Check /tmp/opta-lmx.log'],\n    );\n  }\n}\n\nfunction formatDuration(seconds: number): string {\n  if (seconds < 60) return `${seconds}s`;\n  if (seconds < 3600) return `${Math.floor(seconds / 60)}m`;\n  const hours = Math.floor(seconds / 3600);\n  const mins = Math.floor((seconds % 3600) / 60);\n  return `${hours}h ${mins}m`;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/commands/server.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/commands/sessions.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":93,"column":37,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":93,"endColumn":39,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[2590,2592],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":93,"column":48,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":93,"endColumn":57},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":124,"column":24,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":124,"endColumn":26,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[3531,3533],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":160,"column":68,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":160,"endColumn":79,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[4714,4715],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":172,"column":29,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":172,"endColumn":46},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":173,"column":18,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":173,"endColumn":35}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import chalk from 'chalk';\nimport {\n  listSessions,\n  deleteSession,\n  exportSession,\n  searchSessions,\n} from '../memory/store.js';\nimport { EXIT, ExitError } from '../core/errors.js';\n\ninterface SessionsOptions {\n  json?: boolean;\n  model?: string;\n  since?: string;\n  tag?: string;\n  limit?: string;\n}\n\nexport async function sessions(\n  action?: string,\n  id?: string,\n  opts?: SessionsOptions\n): Promise<void> {\n  // Default: list sessions\n  if (!action || action === 'list') {\n    await listSessionsFormatted(opts);\n    return;\n  }\n\n  switch (action) {\n    case 'resume':\n      if (!id) {\n        console.error(chalk.red('') + ' Session ID required\\n');\n        console.log(chalk.dim('Usage: opta sessions resume <id>'));\n        throw new ExitError(EXIT.MISUSE);\n      }\n      // Delegate to chat --resume\n      const { startChat } = await import('./chat.js');\n      await startChat({ resume: id });\n      break;\n\n    case 'delete':\n    case 'rm':\n      if (!id) {\n        console.error(chalk.red('') + ' Session ID required\\n');\n        console.log(chalk.dim('Usage: opta sessions delete <id>'));\n        throw new ExitError(EXIT.MISUSE);\n      }\n      await deleteSession(id);\n      console.log(chalk.green('') + ` Deleted session ${id}`);\n      break;\n\n    case 'search':\n    case 'find':\n      if (!id) {\n        console.error(chalk.red('') + ' Search query required\\n');\n        console.log(chalk.dim('Usage: opta sessions search <query>'));\n        throw new ExitError(EXIT.MISUSE);\n      }\n      await searchSessionsFormatted(id, opts?.json);\n      break;\n\n    case 'export':\n      if (!id) {\n        console.error(chalk.red('') + ' Session ID required\\n');\n        console.log(chalk.dim('Usage: opta sessions export <id>'));\n        throw new ExitError(EXIT.MISUSE);\n      }\n      try {\n        const json = await exportSession(id);\n        console.log(json);\n      } catch {\n        console.error(chalk.red('') + ` Session not found: ${id}`);\n        throw new ExitError(EXIT.NOT_FOUND);\n      }\n      break;\n\n    default:\n      console.error(chalk.red('') + ` Unknown action: ${action}\\n`);\n      console.log(chalk.dim('Available actions: list, resume, delete, export, search'));\n      throw new ExitError(EXIT.MISUSE);\n  }\n}\n\nasync function listSessionsFormatted(opts?: SessionsOptions): Promise<void> {\n  let items = await listSessions();\n\n  // Apply filters\n  if (opts?.model) {\n    const modelFilter = opts.model.toLowerCase();\n    items = items.filter(s => s.model.toLowerCase().includes(modelFilter));\n  }\n  if (opts?.tag) {\n    items = items.filter(s => s.tags?.includes(opts.tag!));\n  }\n  if (opts?.since) {\n    const sinceDate = parseSinceDate(opts.since);\n    items = items.filter(s => new Date(s.created) >= sinceDate);\n  }\n\n  const limit = opts?.limit ? parseInt(opts.limit, 10) : 20;\n  items = items.slice(0, limit);\n\n  if (items.length === 0) {\n    console.log(chalk.dim('No sessions found. Start one with ') + chalk.cyan('opta chat'));\n    return;\n  }\n\n  if (opts?.json) {\n    console.log(JSON.stringify(items, null, 2));\n    return;\n  }\n\n  // Table header\n  console.log(\n    chalk.bold('  ID        Title                          Model           Date         Messages')\n  );\n\n  for (const s of items) {\n    const shortId = s.id.slice(0, 8).padEnd(8);\n    const titleStr = s.title.slice(0, 30).padEnd(30);\n    const model = s.model.slice(0, 15).padEnd(15);\n    const date = formatRelativeDate(s.created).padEnd(12);\n    const count = String(s.messageCount).padStart(4);\n    const tags = s.tags?.length ? chalk.dim(` [${s.tags.join(', ')}]`) : '';\n\n    console.log(`  ${shortId}  ${titleStr} ${model} ${date} ${count}${tags}`);\n  }\n}\n\nasync function searchSessionsFormatted(query: string, json?: boolean): Promise<void> {\n  const matches = await searchSessions(query);\n\n  if (matches.length === 0) {\n    console.log(chalk.dim(`No sessions matching \"${query}\"`));\n    return;\n  }\n\n  if (json) {\n    console.log(JSON.stringify(matches, null, 2));\n    return;\n  }\n\n  console.log(chalk.dim(`  Found ${matches.length} session${matches.length === 1 ? '' : 's'} matching \"${query}\":\\n`));\n\n  console.log(\n    chalk.bold('  ID        Title                          Model           Date         Messages')\n  );\n\n  for (const s of matches) {\n    const shortId = s.id.slice(0, 8).padEnd(8);\n    const title = s.title.slice(0, 30).padEnd(30);\n    const model = s.model.slice(0, 15).padEnd(15);\n    const date = formatRelativeDate(s.created).padEnd(12);\n    const count = String(s.messageCount).padStart(4);\n\n    console.log(`  ${shortId}  ${title} ${model} ${date} ${count}`);\n  }\n\n  if (matches.length === 1) {\n    console.log(chalk.dim(`\\n  Resume with: opta sessions resume ${matches[0]!.id}`));\n  }\n}\n\n/**\n * Parse a date filter string. Supports:\n * - ISO dates: \"2025-01-15\"\n * - Relative: \"7d\" (7 days ago), \"2w\" (2 weeks ago), \"1m\" (1 month ago)\n */\nfunction parseSinceDate(input: string): Date {\n  const relativeMatch = input.match(/^(\\d+)([dwm])$/);\n  if (relativeMatch) {\n    const amount = parseInt(relativeMatch[1]!, 10);\n    const unit = relativeMatch[2]!;\n    const now = new Date();\n    switch (unit) {\n      case 'd':\n        now.setDate(now.getDate() - amount);\n        break;\n      case 'w':\n        now.setDate(now.getDate() - amount * 7);\n        break;\n      case 'm':\n        now.setMonth(now.getMonth() - amount);\n        break;\n    }\n    return now;\n  }\n  // Assume ISO date string\n  const parsed = new Date(input);\n  if (isNaN(parsed.getTime())) {\n    throw new Error(`Invalid date format: \"${input}\". Use ISO (2025-01-15) or relative (7d, 2w, 1m).`);\n  }\n  return parsed;\n}\n\nfunction formatRelativeDate(iso: string): string {\n  const now = Date.now();\n  const then = new Date(iso).getTime();\n  const diffMs = now - then;\n\n  const minutes = Math.floor(diffMs / 60000);\n  if (minutes < 1) return 'just now';\n  if (minutes < 60) return `${minutes}m ago`;\n\n  const hours = Math.floor(minutes / 60);\n  if (hours < 24) return `${hours}h ago`;\n\n  const days = Math.floor(hours / 24);\n  if (days === 1) return 'yesterday';\n  if (days < 7) return `${days}d ago`;\n\n  return new Date(iso).toLocaleDateString();\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/commands/share.ts","messages":[{"ruleId":"@typescript-eslint/no-redundant-type-constituents","severity":1,"message":"'unknown' overrides all other types in this union type.","line":6,"column":53,"nodeType":"TSUnknownKeyword","messageId":"overrides","endLine":6,"endColumn":60}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export type ExportFormat = 'markdown' | 'json' | 'text';\n\ninterface ExportInput {\n  id: string;\n  model: string;\n  messages: Array<{ role: string; content: string | unknown }>;\n  title?: string;\n  created?: string;\n  toolCallCount?: number;\n}\n\nexport function formatSessionExport(session: ExportInput, format: ExportFormat): string {\n  switch (format) {\n    case 'json':\n      return JSON.stringify({\n        id: session.id,\n        model: session.model,\n        title: session.title,\n        created: session.created ?? new Date().toISOString(),\n        messages: session.messages\n          .filter(m => m.role !== 'system')\n          .map(m => ({\n            role: m.role,\n            content: typeof m.content === 'string' ? m.content : '[multimodal]',\n          })),\n        toolCallCount: session.toolCallCount ?? 0,\n      }, null, 2);\n\n    case 'text': {\n      const lines: string[] = [];\n      lines.push(`Session: ${session.id}`);\n      lines.push(`Model: ${session.model}`);\n      lines.push(`Date: ${session.created ?? new Date().toISOString()}`);\n      lines.push('');\n      for (const m of session.messages) {\n        if (m.role === 'system') continue;\n        const content = typeof m.content === 'string' ? m.content : '[multimodal]';\n        const label = m.role === 'user' ? 'User' : 'Assistant';\n        lines.push(`${label}: ${content}`);\n        // Preserve image references in export\n        if (Array.isArray(m.content)) {\n          for (const part of m.content as Array<{ type: string; image_url?: { url?: string } }>) {\n            if (part.type === 'image_url') {\n              const url = part.image_url?.url;\n              lines.push(`[Image: ${url?.startsWith('data:') ? 'embedded base64' : url || 'unknown'}]`);\n            }\n          }\n        }\n        lines.push('');\n      }\n      return lines.join('\\n');\n    }\n\n    case 'markdown':\n    default: {\n      let md = `# Opta CLI Session\\n\\n`;\n      md += `- **Session:** ${session.id}\\n`;\n      md += `- **Model:** ${session.model}\\n`;\n      md += `- **Date:** ${session.created ?? new Date().toISOString()}\\n\\n---\\n\\n`;\n      for (const m of session.messages) {\n        if (m.role === 'system') continue;\n        const content = typeof m.content === 'string' ? m.content : '[multimodal]';\n        md += m.role === 'user' ? `## User\\n\\n${content}\\n\\n` : `## Assistant\\n\\n${content}\\n\\n`;\n        // Preserve image references in export\n        if (Array.isArray(m.content)) {\n          for (const part of m.content as Array<{ type: string; image_url?: { url?: string } }>) {\n            if (part.type === 'image_url') {\n              const url = part.image_url?.url;\n              md += `> [Image: ${url?.startsWith('data:') ? 'embedded base64' : url || 'unknown'}]\\n\\n`;\n            }\n          }\n        }\n      }\n      return md;\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/commands/slash/account.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/commands/slash/browser.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-template-expression","severity":1,"message":"Template literal expression is unnecessary and can be simplified.","line":71,"column":22,"nodeType":null,"messageId":"noUnnecessaryTemplateExpression","endLine":71,"endColumn":40,"fix":{"range":[2931,2951],"text":"session.runtime"}},{"ruleId":"@typescript-eslint/no-unnecessary-template-expression","severity":1,"message":"Template literal expression is unnecessary and can be simplified.","line":72,"column":21,"nodeType":null,"messageId":"noUnnecessaryTemplateExpression","endLine":72,"endColumn":38,"fix":{"range":[2983,3002],"text":"session.status"}},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":131,"column":61,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":131,"endColumn":63,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[5448,5450],"text":"."},"desc":"Remove unnecessary optional chain"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import chalk from 'chalk';\nimport {\n  browserApprovalLogPath,\n  readRecentBrowserApprovalEvents,\n} from '../../browser/approval-log.js';\nimport {\n  browserCanaryEvidenceFileSize,\n  browserCanaryLatestPath,\n  buildBrowserCanaryEvidence,\n  updateBrowserCanaryRollbackDrill,\n  writeBrowserCanaryEvidence,\n} from '../../browser/canary-evidence.js';\nimport {\n  buildBrowserRunCorpusSummary,\n  writeBrowserRunCorpusSummary,\n} from '../../browser/run-corpus.js';\nimport { DEFAULT_BROWSER_BENCHMARK_THRESHOLDS } from '../../browser/quality-gates.js';\nimport {\n  BROWSER_CONTROL_ACTIONS,\n  runBrowserControlAction,\n  type BrowserControlAction,\n} from '../../browser/control-surface.js';\nimport {\n  browserProfilesRootPath,\n  listBrowserProfileDirs,\n  pruneBrowserProfileDirs,\n  resolveBrowserProfileRetentionPolicy,\n  type BrowserProfileRetentionPolicy,\n} from '../../browser/profile-store.js';\nimport { summarizeBrowserReplay } from '../../browser/replay.js';\nimport type { BrowserRuntimeProfilePruneHealth } from '../../browser/runtime-daemon.js';\nimport type { SlashCommandDef, SlashContext, SlashResult } from './types.js';\n\nfunction printBrowserUsage(): void {\n  console.log(chalk.dim('  Usage: /browser [status|pause|resume|stop|kill|replay <session_id>|approvals [limit]|profiles [prune [session_id]]|trends [hours] [limit]|canary [hours]|canary rollback <pass|fail> [notes]]'));\n  console.log(chalk.dim('    /browser status'));\n  console.log(chalk.dim('    /browser pause'));\n  console.log(chalk.dim('    /browser resume'));\n  console.log(chalk.dim('    /browser stop'));\n  console.log(chalk.dim('    /browser kill'));\n  console.log(chalk.dim('    /browser replay <session_id>'));\n  console.log(chalk.dim('    /browser approvals'));\n  console.log(chalk.dim('    /browser approvals 20'));\n  console.log(chalk.dim('    /browser profiles'));\n  console.log(chalk.dim('    /browser profiles prune'));\n  console.log(chalk.dim('    /browser profiles prune <session_id>'));\n  console.log(chalk.dim('    /browser trends'));\n  console.log(chalk.dim('    /browser trends 24 10'));\n  console.log(chalk.dim('    /browser canary'));\n  console.log(chalk.dim('    /browser canary 24'));\n  console.log(chalk.dim('    /browser canary rollback pass Rehearsal completed.'));\n}\n\nfunction printStatus(result: Awaited<ReturnType<typeof runBrowserControlAction>>): void {\n  const health = result.health;\n  const marker = result.ok ? chalk.green('\\u2713') : chalk.yellow('!');\n  console.log(marker + ` ${result.message}`);\n  console.log(\n    chalk.dim(\n      `  running=${health.running} paused=${health.paused} killed=${health.killed} sessions=${health.sessionCount}/${health.maxSessions}`,\n    ),\n  );\n  console.log(chalk.dim(formatProfilePruneStatus(health.profilePrune)));\n\n  if (health.sessions.length === 0) {\n    console.log(chalk.dim('  No active browser sessions.'));\n    return;\n  }\n\n  for (const session of health.sessions) {\n    const runtime = `${session.runtime}`.padEnd(11);\n    const status = `${session.status}`.padEnd(6);\n    const url = session.currentUrl ?? '(none)';\n    console.log(`  ${chalk.cyan(session.sessionId)}  ${chalk.dim(status)}  ${chalk.dim(runtime)}  ${url}`);\n  }\n}\n\nfunction formatProfilePruneStatus(prune: BrowserRuntimeProfilePruneHealth): string {\n  if (!prune.enabled) {\n    return '  profile_prune=disabled';\n  }\n  const base = `  profile_prune=enabled interval_ms=${prune.intervalMs ?? '-'} in_flight=${String(prune.inFlight)}`;\n  if (!prune.lastRunAt || !prune.lastStatus) {\n    return `${base} last_run=never`;\n  }\n  const counts = (\n    typeof prune.lastListedCount === 'number' &&\n    typeof prune.lastKeptCount === 'number' &&\n    typeof prune.lastPrunedCount === 'number'\n  )\n    ? ` listed=${prune.lastListedCount} kept=${prune.lastKeptCount} pruned=${prune.lastPrunedCount}`\n    : '';\n  const error = prune.lastError ? ` error=${prune.lastError}` : '';\n  return `${base} last_run=${prune.lastRunAt} reason=${prune.lastReason ?? '-'} status=${prune.lastStatus}${counts}${error}`;\n}\n\nfunction parseApprovalsLimit(raw: string | undefined): number | null {\n  if (!raw) return 10;\n  const parsed = Number(raw);\n  if (!Number.isInteger(parsed) || parsed <= 0) return null;\n  return Math.min(parsed, 200);\n}\n\nfunction profilePolicyLine(policy: BrowserProfileRetentionPolicy): string {\n  return `  policy: retentionDays=${policy.retentionDays} maxPersistedProfiles=${policy.maxPersistedProfiles}`;\n}\n\nasync function printApprovals(limit: number): Promise<void> {\n  const cwd = process.cwd();\n  const events = await readRecentBrowserApprovalEvents(cwd, limit);\n  const path = browserApprovalLogPath(cwd);\n\n  if (events.length === 0) {\n    console.log(chalk.dim('  No browser approval events found.'));\n    console.log(chalk.dim(`  Log: ${path}`));\n    return;\n  }\n\n  console.log(chalk.green('\\u2713') + ` Recent browser approvals (${events.length}/${limit})`);\n  console.log(chalk.dim(`  Log: ${path}`));\n  for (const event of events) {\n    const decision = event.decision === 'approved' ? chalk.green('approved') : chalk.red('denied');\n    const sessionId = event.sessionId ?? '-';\n    const risk = event.risk ? ` risk=${event.risk}` : '';\n    const action = event.actionKey ? ` action=${event.actionKey}` : '';\n    const target = event.targetHost\n      ? ` target=${event.targetHost}`\n      : event.target_origin\n        ? ` target=${event.target_origin}`\n        : '';\n    const signalSummary = event.riskEvidence?.matchedSignals?.length\n      ? ` signals=${event.riskEvidence.matchedSignals.slice(0, 3).join('|')}`\n      : '';\n    console.log(\n      `  ${chalk.dim(event.timestamp)}  ${decision}  ${chalk.cyan(event.tool)}  session=${chalk.dim(sessionId)}${risk}${action}${target}${signalSummary}`,\n    );\n    if (event.policyReason) {\n      console.log(chalk.dim(`    reason=${event.policyReason}`));\n    }\n  }\n}\n\nasync function printProfiles(ctx: SlashContext): Promise<void> {\n  const cwd = process.cwd();\n  const profiles = await listBrowserProfileDirs(cwd);\n  const root = browserProfilesRootPath(cwd);\n  const policy = resolveBrowserProfileRetentionPolicy({\n    retentionDays: ctx.config.browser.runtime.profileRetentionDays,\n    maxPersistedProfiles: ctx.config.browser.runtime.maxPersistedProfiles,\n  });\n\n  if (profiles.length === 0) {\n    console.log(chalk.dim('  No persisted browser profiles found.'));\n    console.log(chalk.dim(`  Root: ${root}`));\n    console.log(chalk.dim(profilePolicyLine(policy)));\n    return;\n  }\n\n  console.log(chalk.green('\\u2713') + ` Persisted browser profiles (${profiles.length})`);\n  console.log(chalk.dim(`  Root: ${root}`));\n  console.log(chalk.dim(profilePolicyLine(policy)));\n  for (const profile of profiles) {\n    console.log(\n      `  ${chalk.cyan(profile.sessionId)}  ${chalk.dim(profile.modifiedAt)}  ${chalk.dim(profile.relativePath)}`,\n    );\n  }\n}\n\nasync function pruneProfiles(ctx: SlashContext, sessionId: string | undefined): Promise<void> {\n  const policy = resolveBrowserProfileRetentionPolicy({\n    retentionDays: ctx.config.browser.runtime.profileRetentionDays,\n    maxPersistedProfiles: ctx.config.browser.runtime.maxPersistedProfiles,\n  });\n\n  const result = await pruneBrowserProfileDirs({\n    cwd: process.cwd(),\n    sessionId,\n    policy,\n  });\n\n  if (result.pruned.length === 0) {\n    if (sessionId) {\n      console.log(chalk.dim(`  No persisted browser profile found for session \"${sessionId}\".`));\n    } else {\n      console.log(chalk.dim('  No browser profiles matched the prune policy.'));\n    }\n    console.log(chalk.dim(profilePolicyLine(result.policy)));\n    console.log(chalk.dim(`  kept=${result.kept.length} root=${result.rootDir}`));\n    return;\n  }\n\n  console.log(chalk.green('\\u2713') + ` Pruned browser profiles (${result.pruned.length})`);\n  for (const profile of result.pruned) {\n    console.log(`  ${chalk.cyan(profile.sessionId)}  ${chalk.dim(profile.relativePath)}`);\n  }\n  console.log(chalk.dim(profilePolicyLine(result.policy)));\n  console.log(chalk.dim(`  kept=${result.kept.length} root=${result.rootDir}`));\n}\n\nfunction parseCanaryWindowHours(raw: string | undefined): number | null {\n  if (!raw) return 24;\n  const parsed = Number(raw);\n  if (!Number.isInteger(parsed) || parsed < 1 || parsed > 168) return null;\n  return parsed;\n}\n\nfunction parseTrendsWindowHours(raw: string | undefined): number | null {\n  if (!raw) return 168;\n  const parsed = Number(raw);\n  if (!Number.isInteger(parsed) || parsed < 1 || parsed > 720) return null;\n  return parsed;\n}\n\nfunction parseTrendsLimit(raw: string | undefined): number | null {\n  if (!raw) return 10;\n  const parsed = Number(raw);\n  if (!Number.isInteger(parsed) || parsed < 1 || parsed > 50) return null;\n  return parsed;\n}\n\nasync function runTrendsCapture(hoursToken: string | undefined, limitToken: string | undefined): Promise<void> {\n  const windowHours = parseTrendsWindowHours(hoursToken);\n  const limit = parseTrendsLimit(limitToken);\n  if (windowHours === null || limit === null) {\n    printBrowserUsage();\n    return;\n  }\n\n  const summary = await buildBrowserRunCorpusSummary(process.cwd(), {\n    windowHours,\n  });\n  const paths = await writeBrowserRunCorpusSummary(process.cwd(), summary);\n\n  console.log(chalk.green('\\u2713') + ' Browser run trends captured.');\n  console.log(chalk.dim(`  latest=${paths.latestPath}`));\n  console.log(chalk.dim(`  snapshot=${paths.snapshotPath}`));\n  console.log(chalk.dim(`  window_hours=${summary.windowHours} sessions=${summary.assessedSessionCount}`));\n  console.log(\n    chalk.dim(\n      `  regression=${summary.regressionSessionCount} investigate=${summary.investigateSessionCount} max=${(summary.maxRegressionScore * 100).toFixed(1)}% mean=${(summary.meanRegressionScore * 100).toFixed(1)}%`,\n    ),\n  );\n\n  if (summary.entries.length === 0) {\n    console.log(chalk.dim('  No browser sessions in the selected window.'));\n    return;\n  }\n\n  const ranked = [...summary.entries]\n    .sort((left, right) => (\n      right.regressionScore - left.regressionScore\n      || Date.parse(right.updatedAt) - Date.parse(left.updatedAt)\n      || left.sessionId.localeCompare(right.sessionId)\n    ))\n    .slice(0, limit);\n\n  console.log(chalk.dim(`  top_sessions=${ranked.length}`));\n  for (const entry of ranked) {\n    const runSegment = entry.runId ? ` run=${entry.runId}` : '';\n    console.log(\n      `  ${chalk.cyan(entry.sessionId)}${runSegment} ${chalk.dim(\n        `regression=${entry.regressionSignal}:${(entry.regressionScore * 100).toFixed(1)}% failures=${entry.failureCount} actions=${entry.actionCount} updated=${entry.updatedAt}`,\n      )}`,\n    );\n  }\n}\n\nasync function runCanaryCapture(hoursToken: string | undefined): Promise<void> {\n  const windowHours = parseCanaryWindowHours(hoursToken);\n  if (windowHours === null) {\n    printBrowserUsage();\n    return;\n  }\n\n  const evidence = await buildBrowserCanaryEvidence(process.cwd(), {\n    windowHours,\n    thresholds: DEFAULT_BROWSER_BENCHMARK_THRESHOLDS,\n  });\n  const paths = await writeBrowserCanaryEvidence(process.cwd(), evidence);\n  const [latestBytes, snapshotBytes] = await Promise.all([\n    browserCanaryEvidenceFileSize(paths.latestPath),\n    browserCanaryEvidenceFileSize(paths.snapshotPath),\n  ]);\n\n  const statusColor = evidence.overallStatus === 'pass' ? chalk.green : chalk.red;\n  console.log(chalk.green('\\u2713') + ' Browser canary evidence captured.');\n  console.log(chalk.dim(`  latest=${paths.latestPath}`));\n  console.log(chalk.dim(`  snapshot=${paths.snapshotPath}`));\n  console.log(chalk.dim(`  window_hours=${evidence.windowHours} sessions=${evidence.assessedSessionCount}`));\n  console.log(statusColor(`  overall=${evidence.overallStatus} pass=${evidence.passCount} fail=${evidence.failCount}`));\n  console.log(chalk.dim(`  rollback_drill=${evidence.rollbackDrill.status}`));\n  console.log(chalk.dim(`  proof latest_bytes=${latestBytes ?? '-'} snapshot_bytes=${snapshotBytes ?? '-'}`));\n}\n\nasync function runCanaryRollback(\n  statusToken: string | undefined,\n  notesTokens: string[],\n): Promise<void> {\n  const normalizedStatus = (statusToken ?? '').toLowerCase();\n  if (normalizedStatus !== 'pass' && normalizedStatus !== 'fail') {\n    printBrowserUsage();\n    return;\n  }\n\n  const updated = await updateBrowserCanaryRollbackDrill(process.cwd(), {\n    status: normalizedStatus,\n    notes: notesTokens.join(' ').trim() || undefined,\n  });\n\n  if (!updated) {\n    console.log(chalk.dim('  No canary evidence found. Run /browser canary first.'));\n    console.log(chalk.dim(`  Expected: ${browserCanaryLatestPath(process.cwd())}`));\n    return;\n  }\n\n  const latestPath = browserCanaryLatestPath(process.cwd());\n  const latestBytes = await browserCanaryEvidenceFileSize(latestPath);\n\n  const statusColor = normalizedStatus === 'pass' ? chalk.green : chalk.red;\n  console.log(chalk.green('\\u2713') + ' Canary rollback drill updated.');\n  console.log(chalk.dim(`  latest=${latestPath}`));\n  console.log(statusColor(`  rollback_drill=${normalizedStatus}`));\n  if (updated.rollbackDrill.executedAt) {\n    console.log(chalk.dim(`  executed_at=${updated.rollbackDrill.executedAt}`));\n  }\n  if (updated.rollbackDrill.notes) {\n    console.log(chalk.dim(`  notes=${updated.rollbackDrill.notes}`));\n  }\n  console.log(chalk.dim(`  proof latest_bytes=${latestBytes ?? '-'}`));\n}\n\nconst browserHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const tokens = args.trim().split(/\\s+/).filter(Boolean);\n  const action = (tokens[0] ?? 'status').toLowerCase();\n\n  if (action === 'profiles') {\n    const subcommand = (tokens[1] ?? '').toLowerCase();\n\n    if (!subcommand) {\n      await printProfiles(ctx);\n      return 'handled';\n    }\n\n    if (subcommand !== 'prune' || tokens.length > 3) {\n      printBrowserUsage();\n      return 'handled';\n    }\n\n    const sessionId = tokens[2];\n    if (sessionId && (sessionId.includes('/') || sessionId.includes('\\\\'))) {\n      printBrowserUsage();\n      return 'handled';\n    }\n\n    try {\n      await pruneProfiles(ctx, sessionId);\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      if (message.includes('Invalid browser profile session id')) {\n        printBrowserUsage();\n        return 'handled';\n      }\n      throw error;\n    }\n    return 'handled';\n  }\n\n  if (action === 'approvals') {\n    if (tokens.length > 2) {\n      printBrowserUsage();\n      return 'handled';\n    }\n\n    const limit = parseApprovalsLimit(tokens[1]);\n    if (limit === null) {\n      printBrowserUsage();\n      return 'handled';\n    }\n\n    await printApprovals(limit);\n    return 'handled';\n  }\n\n  if (action === 'canary') {\n    const subcommand = (tokens[1] ?? '').toLowerCase();\n    if (!subcommand) {\n      await runCanaryCapture(undefined);\n      return 'handled';\n    }\n\n    if (subcommand === 'rollback') {\n      await runCanaryRollback(tokens[2], tokens.slice(3));\n      return 'handled';\n    }\n\n    await runCanaryCapture(subcommand);\n    return 'handled';\n  }\n\n  if (action === 'trends') {\n    if (tokens.length > 3) {\n      printBrowserUsage();\n      return 'handled';\n    }\n    await runTrendsCapture(tokens[1], tokens[2]);\n    return 'handled';\n  }\n\n  if (action === 'replay') {\n    const sessionId = tokens[1];\n    if (!sessionId) {\n      printBrowserUsage();\n      return 'handled';\n    }\n\n    const replay = await summarizeBrowserReplay(process.cwd(), sessionId);\n    if (!replay) {\n      console.log(chalk.yellow(`  Replay not found for browser session \"${sessionId}\".`));\n      return 'handled';\n    }\n\n    console.log(chalk.green('\\u2713') + ` Replay summary for ${chalk.cyan(replay.sessionId)}`);\n    const runSegment = replay.runId ? ` run=${replay.runId}` : '';\n    console.log(chalk.dim(`  status=${replay.status} runtime=${replay.runtime}${runSegment}`));\n    console.log(chalk.dim(`  actions=${replay.actionCount} failures=${replay.failureCount} artifacts=${replay.artifactCount}`));\n    const regressionScorePct = `${(replay.regressionScore * 100).toFixed(1)}%`;\n    console.log(chalk.dim(`  regression=${replay.regressionSignal} score=${regressionScorePct} pairs=${replay.regressionPairCount}`));\n    console.log(chalk.dim(`  last_action=${replay.lastActionAt}`));\n    console.log(chalk.dim(`  updated=${replay.lastUpdatedAt}`));\n    return 'handled';\n  }\n\n  if (!BROWSER_CONTROL_ACTIONS.includes(action as BrowserControlAction)) {\n    printBrowserUsage();\n    return 'handled';\n  }\n\n  const result = await runBrowserControlAction(action as BrowserControlAction, ctx.config);\n  printStatus(result);\n  return 'handled';\n};\n\nexport const browserCommands: SlashCommandDef[] = [\n  {\n    command: 'browser',\n    aliases: ['br'],\n    description: 'Browser runtime controls and approval log view',\n    handler: browserHandler,\n    category: 'tools',\n    usage: '/browser [status|pause|resume|stop|kill|replay <session_id>|approvals [limit]|profiles [prune [session_id]]|trends [hours] [limit]|canary [hours]|canary rollback <pass|fail> [notes]]',\n    examples: [\n      '/browser',\n      '/browser status',\n      '/browser pause',\n      '/browser resume',\n      '/browser kill',\n      '/browser replay sess-001',\n      '/browser approvals',\n      '/browser approvals 20',\n      '/browser profiles',\n      '/browser profiles prune',\n      '/browser profiles prune sess-001',\n      '/browser trends',\n      '/browser trends 24 10',\n      '/browser canary',\n      '/browser canary 24',\n      '/browser canary rollback pass Rehearsal completed in 3m',\n    ],\n  },\n];\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/commands/slash/debug.ts","messages":[{"ruleId":"@typescript-eslint/require-await","severity":1,"message":"Async arrow function 'historyHandler' has no 'await' expression.","line":12,"column":87,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":12,"endColumn":89,"suggestions":[{"messageId":"removeAsync","fix":{"range":[443,505],"text":"(_args: string, ctx: SlashContext): SlashResult"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":1,"message":"Async arrow function 'costHandler' has no 'await' expression.","line":33,"column":84,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":33,"endColumn":86,"suggestions":[{"messageId":"removeAsync","fix":{"range":[1335,1397],"text":"(_args: string, ctx: SlashContext): SlashResult"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":43,"column":24,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":43,"endColumn":53},{"ruleId":"@typescript-eslint/no-deprecated","severity":1,"message":"`fmtTokens` is deprecated. Use `formatTokens` from `../utils/tokens.js` directly.","line":47,"column":22,"nodeType":"Identifier","messageId":"deprecatedWithReason","endLine":47,"endColumn":31},{"ruleId":"@typescript-eslint/no-deprecated","severity":1,"message":"`fmtTokens` is deprecated. Use `formatTokens` from `../utils/tokens.js` directly.","line":48,"column":26,"nodeType":"Identifier","messageId":"deprecatedWithReason","endLine":48,"endColumn":35},{"ruleId":"@typescript-eslint/no-deprecated","severity":1,"message":"`fmtTokens` is deprecated. Use `formatTokens` from `../utils/tokens.js` directly.","line":49,"column":21,"nodeType":"Identifier","messageId":"deprecatedWithReason","endLine":49,"endColumn":30},{"ruleId":"@typescript-eslint/no-deprecated","severity":1,"message":"`fmtTokens` is deprecated. Use `formatTokens` from `../utils/tokens.js` directly.","line":50,"column":66,"nodeType":"Identifier","messageId":"deprecatedWithReason","endLine":50,"endColumn":75},{"ruleId":"@typescript-eslint/no-deprecated","severity":1,"message":"`fmtTokens` is deprecated. Use `formatTokens` from `../utils/tokens.js` directly.","line":50,"column":86,"nodeType":"Identifier","messageId":"deprecatedWithReason","endLine":50,"endColumn":95}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Debug and info slash commands: /history, /cost, /stats\n */\n\nimport chalk from 'chalk';\nimport { box, kv, fmtTokens, progressBar } from '../../ui/box.js';\nimport { estimateTokens } from '../../utils/tokens.js';\nimport { estimateCost, formatCost } from '../../utils/pricing.js';\nimport type { AgentMessage } from '../../core/agent.js';\nimport type { SlashCommandDef, SlashContext, SlashResult } from './types.js';\n\nconst historyHandler = async (_args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const userMessages = ctx.session.messages.filter(\n    (m: AgentMessage) => m.role === 'user' || m.role === 'assistant'\n  );\n  if (userMessages.length === 0) {\n    console.log(chalk.dim('  No messages yet'));\n    return 'handled';\n  }\n  console.log();\n  userMessages.forEach((m: AgentMessage, i: number) => {\n    const role = m.role === 'user' ? chalk.cyan('user') : chalk.green('assistant');\n    const rawContent = typeof m.content === 'string' ? m.content : Array.isArray(m.content) ? '[multimodal]' : '';\n    const content = rawContent.slice(0, 80).replace(/\\n/g, ' ');\n    const toolCount = m.tool_calls?.length;\n    const suffix = toolCount ? chalk.dim(` (${toolCount} tool calls)`) : '';\n    console.log(`  ${i + 1}. [${role}] ${content}${suffix}`);\n  });\n  console.log();\n  return 'handled';\n};\n\nconst costHandler = async (_args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const msgs = ctx.session.messages;\n  let promptTok = 0;\n  let completionTok = 0;\n  for (const m of msgs) {\n    const tok = estimateTokens(typeof m.content === 'string' ? m.content : '');\n    if (m.role === 'assistant') completionTok += tok;\n    else promptTok += tok;\n  }\n  const total = promptTok + completionTok;\n  const contextLimit = ctx.config.model.contextLimit ?? 128000;\n  const usageRatio = total / contextLimit;\n\n  console.log('\\n' + box('Token Usage', [\n    kv('Prompt', `~${fmtTokens(promptTok)} tokens`),\n    kv('Completion', `~${fmtTokens(completionTok)} tokens`),\n    kv('Total', `~${fmtTokens(total)} tokens`),\n    kv('Context', `${progressBar(usageRatio, 16)} ${chalk.dim(`${fmtTokens(total)}/${fmtTokens(contextLimit)}`)}`),\n    '',\n    kv('Messages', String(msgs.length)),\n    kv('Tool calls', String(ctx.session.toolCallCount)),\n    (() => {\n      const provider = ctx.config.provider.active;\n      const model = provider === 'lmx' ? ctx.config.model.default : ctx.config.provider.anthropic.model;\n      const cost = estimateCost(promptTok, completionTok, provider, model);\n      if (cost.isLocal) return kv('Cost', chalk.green('Free') + chalk.dim(' (local inference)'));\n      return kv('Cost', chalk.yellow(formatCost(cost) + ' USD'));\n    })(),\n  ]));\n  return 'handled';\n};\n\nconst statsHandler = async (_args: string, _ctx: SlashContext): Promise<SlashResult> => {\n  const { listSessions } = await import('../../memory/store.js');\n  const { SessionAnalytics } = await import('../../memory/analytics.js');\n  const allSessions = await listSessions();\n  const analytics = new SessionAnalytics(allSessions);\n\n  const modelLines = Object.entries(analytics.modelBreakdown)\n    .sort(([, a], [, b]) => b - a)\n    .map(([model, count]) => kv(model, `${count} sessions`, 20));\n\n  console.log('\\n' + box('Session Analytics', [\n    kv('Total', `${analytics.totalSessions} sessions`, 14),\n    kv('Messages', `${analytics.totalMessages} total`, 14),\n    kv('Tool Calls', `${analytics.totalToolCalls} total`, 14),\n    kv('Avg/Session', `${analytics.avgMessagesPerSession.toFixed(1)} msgs`, 14),\n    kv('Today', `${analytics.sessionsToday()} sessions`, 14),\n    '',\n    chalk.dim('Model Usage:'),\n    ...modelLines,\n    '',\n    kv('Cost', chalk.green('Free') + chalk.dim(' (aggregate cost tracked per-turn)'), 14),\n  ]));\n  return 'handled';\n};\n\nexport const debugCommands: SlashCommandDef[] = [\n  {\n    command: 'history',\n    description: 'Conversation summary',\n    handler: historyHandler,\n    category: 'info',\n  },\n  {\n    command: 'cost',\n    description: 'Token usage breakdown',\n    handler: costHandler,\n    category: 'info',\n  },\n  {\n    command: 'stats',\n    aliases: ['analytics'],\n    description: 'Session analytics',\n    handler: statsHandler,\n    category: 'info',\n  },\n];\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/commands/slash/display.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, value is always truthy.","line":107,"column":10,"nodeType":"Literal","messageId":"alwaysTruthy","endLine":107,"endColumn":14},{"ruleId":"@typescript-eslint/require-await","severity":1,"message":"Async arrow function 'expandHandler' has no 'await' expression.","line":197,"column":86,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":197,"endColumn":88,"suggestions":[{"messageId":"removeAsync","fix":{"range":[6885,6947],"text":"(_args: string, ctx: SlashContext): SlashResult"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":1,"message":"Async arrow function 'sidebarHandler' has no 'await' expression.","line":234,"column":88,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":234,"endColumn":90,"suggestions":[{"messageId":"removeAsync","fix":{"range":[8245,8308],"text":"(_args: string, _ctx: SlashContext): SlashResult"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":244,"column":8,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":244,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of an `any` typed value.","line":244,"column":8,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":244,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .key on an `any` value.","line":244,"column":16,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":244,"endColumn":19},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .description on an `any` value.","line":244,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":244,"endColumn":54},{"ruleId":"@typescript-eslint/require-await","severity":1,"message":"Async arrow function 'formatHandler' has no 'await' expression.","line":251,"column":85,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":251,"endColumn":87,"suggestions":[{"messageId":"removeAsync","fix":{"range":[8964,9025],"text":"(args: string, ctx: SlashContext): SlashResult"},"desc":"Remove 'async'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Display-related slash commands: /help, /expand, /theme, /sidebar, /keys\n */\n\nimport chalk from 'chalk';\nimport { box, kv } from '../../ui/box.js';\nimport { optaWord } from '../../ui/brand.js';\nimport { runMenuPrompt } from '../../ui/prompt-nav.js';\nimport type { SlashCommandDef, SlashContext, SlashResult } from './types.js';\nimport type { PaneMenuSection } from '../../ui/pane-menu.js';\n\nconst HELP_AREA_ORDER = [\n  { id: 'models', label: 'Models & LMX', color: '#a855f7' },\n  { id: 'coding', label: 'Coding Commands', color: '#22d3ee' },\n  { id: 'session', label: 'Session Flow', color: '#3b82f6' },\n  { id: 'management', label: 'Management', color: '#f59e0b' },\n  { id: 'all', label: 'All Commands', color: '#10b981' },\n] as const;\n\nconst MODEL_COMMANDS = new Set([\n  'model', 'models', 'scan', 'load', 'unload', 'serve', 'memory', 'metrics', 'benchmark',\n]);\n\nconst CODING_COMMANDS = new Set([\n  'plan', 'review', 'research', 'agent', 'format', 'editor', 'image', 'undo', 'checkpoint', 'compact',\n]);\n\nconst SESSION_COMMANDS = new Set([\n  'exit', 'clear', 'save', 'share', 'export', 'sessions', 'init', 'tag', 'rename',\n]);\n\nconst MANAGEMENT_COMMANDS = new Set([\n  'config', 'doctor', 'mcp', 'quickfix', 'permissions', 'skills', 'keys', 'theme', 'sidebar',\n  'update', 'server', 'daemon', 'completions',\n]);\n\nfunction classifyHelpArea(def: SlashCommandDef): string {\n  if (MODEL_COMMANDS.has(def.command)) return 'models';\n  if (CODING_COMMANDS.has(def.command)) return 'coding';\n  if (SESSION_COMMANDS.has(def.command)) return 'session';\n  if (MANAGEMENT_COMMANDS.has(def.command)) return 'management';\n  if (def.category === 'server') return 'models';\n  if (def.category === 'tools') return 'coding';\n  if (def.category === 'session') return 'session';\n  return 'management';\n}\n\nexport function buildHelpSections(commands: SlashCommandDef[]): PaneMenuSection[] {\n  const unique = new Map<string, SlashCommandDef>();\n  for (const def of commands) {\n    if (!unique.has(def.command)) unique.set(def.command, def);\n  }\n\n  const defs = [...unique.values()].sort((a, b) => a.command.localeCompare(b.command));\n\n  const base = HELP_AREA_ORDER.map((area) => ({\n    id: area.id,\n    label: area.label,\n    color: area.color,\n    items: (area.id === 'all'\n      ? defs\n      : defs.filter((def) => classifyHelpArea(def) === area.id)\n    ).map((def) => ({\n      id: def.command,\n      label: `/${def.command}`,\n      description: def.description,\n    })),\n  }));\n\n  return base.filter((s) => s.items.length > 0);\n}\n\nfunction printCommandHelpCard(def: SlashCommandDef): void {\n  const lines: string[] = [\n    `${chalk.cyan(`/${def.command}`)} ${chalk.dim('')} ${def.description}`,\n    '',\n  ];\n  if (def.usage) {\n    lines.push(`${chalk.dim('Usage:')} ${chalk.cyan(def.usage)}`);\n  }\n  if (def.examples && def.examples.length > 0) {\n    lines.push(chalk.dim('Examples:'));\n    for (const ex of def.examples) lines.push(`  ${chalk.cyan(ex)}`);\n  }\n  if (def.aliases && def.aliases.length > 0) {\n    lines.push(`${chalk.dim('Aliases:')} ${def.aliases.map((a) => `/${a}`).join(', ')}`);\n  }\n  console.log('\\n' + box(`Command ${chalk.cyan(`/${def.command}`)}`, lines) + '\\n');\n}\n\nasync function interactiveHelpBrowser(ctx: SlashContext): Promise<boolean> {\n  if (!process.stdin.isTTY || !process.stdout.isTTY) {\n    return false;\n  }\n\n  const { getAllCommands, dispatchSlashCommand } = await import('./index.js');\n  const { runPaneMenu } = await import('../../ui/pane-menu.js');\n  const { select } = await import('@inquirer/prompts');\n\n  const commands = getAllCommands();\n  const commandMap = new Map(commands.map((c) => [c.command, c] as const));\n  const sections = buildHelpSections(commands);\n\n  let sectionIndex = 0;\n  let itemIndex = 0;\n\n  while (true) {\n    const selection = await runPaneMenu({\n      title: `${optaWord()} Help Navigator`,\n      subtitle: 'Finder-style menu with infinite scrolling',\n      instructions: '/ switch panes  / scroll (loop)  Enter select  q exit',\n      sections,\n      initialSectionIndex: sectionIndex,\n      initialItemIndex: itemIndex,\n      loop: true,\n    });\n\n    if (!selection) return true;\n    sectionIndex = selection.sectionIndex;\n    itemIndex = selection.itemIndex;\n\n    const selected = commandMap.get(selection.itemId);\n    if (!selected) continue;\n\n    printCommandHelpCard(selected);\n\n    let next: 'back' | 'cmd-help' | 'exit';\n    try {\n      const picked = await runMenuPrompt((context) =>\n        select<'back' | 'cmd-help' | 'exit'>({\n          message: chalk.dim('Next'),\n          choices: [\n            { name: 'Back to navigator', value: 'back' },\n            { name: `Show /${selected.command} --help`, value: 'cmd-help' },\n            { name: 'Exit help', value: 'exit' },\n          ],\n        }, context), 'select');\n      if (!picked) continue;\n      next = picked;\n    } catch {\n      return true;\n    }\n\n    if (next === 'exit') return true;\n    if (next === 'cmd-help') {\n      await dispatchSlashCommand(`/${selected.command} --help`, ctx);\n    }\n  }\n}\n\n/**\n * Build the /help output dynamically. This is called by the help handler\n * and needs access to the full registry, so it receives a callback to get\n * command descriptions.\n *\n * NOTE: The /help handler is registered here with a static layout matching\n * the original chat.ts output. The interactive browser (`/` with no args)\n * is handled in index.ts where it has access to the full registry.\n */\nconst helpHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const mode = args.trim().toLowerCase();\n  if (mode === 'menu' || mode === 'interactive' || mode === 'nav' || mode === 'browser') {\n    const opened = await interactiveHelpBrowser(ctx);\n    if (opened) return 'handled';\n  }\n\n  const { getAllCommands } = await import('./index.js');\n  const defs = getAllCommands().sort((a, b) => a.command.localeCompare(b.command));\n\n  const groups: Array<{ label: string; category: SlashCommandDef['category'] }> = [\n    { label: 'Session', category: 'session' },\n    { label: 'Tools', category: 'tools' },\n    { label: 'Info', category: 'info' },\n    { label: 'Server', category: 'server' },\n  ];\n\n  const cmdLine = (cmd: string, desc: string) =>\n    chalk.cyan(cmd.padEnd(18)) + chalk.dim(desc);\n\n  const lines: string[] = [];\n  for (const group of groups) {\n    const commands = defs.filter((def) => def.category === group.category);\n    if (commands.length === 0) continue;\n    lines.push(chalk.dim(group.label));\n    for (const def of commands) {\n      lines.push(cmdLine(`/${def.command}`, def.description));\n    }\n    lines.push('');\n  }\n  if (lines[lines.length - 1] === '') lines.pop();\n\n  console.log('\\n' + box('Commands', lines));\n  console.log(chalk.dim(`  Tip: type / to browse commands interactively, or ${chalk.cyan('/help menu')} for area-first navigation\\n`));\n  return 'handled';\n};\n\nconst expandHandler = async (_args: string, ctx: SlashContext): Promise<SlashResult> => {\n  if (!ctx.chatState.lastThinkingRenderer?.hasThinking()) {\n    console.log(chalk.dim('  No thinking to display'));\n    return 'handled';\n  }\n  if (ctx.chatState.thinkingExpanded) {\n    console.log(ctx.chatState.lastThinkingRenderer.getCollapsedSummary());\n    ctx.chatState.thinkingExpanded = false;\n  } else {\n    console.log(ctx.chatState.lastThinkingRenderer.getExpandedView());\n    ctx.chatState.thinkingExpanded = true;\n  }\n  return 'handled';\n};\n\nconst themeHandler = async (args: string, _ctx: SlashContext): Promise<SlashResult> => {\n  const { getTheme, setTheme, listThemes } = await import('../../ui/theme.js');\n  if (!args) {\n    const themes = listThemes();\n    const current = getTheme();\n    console.log('\\n' + box('Themes', themes.map(t =>\n      (t.name === current.name ? chalk.green('\\u25cf ') : chalk.dim('  ')) +\n      chalk.cyan(t.name.padEnd(14)) + chalk.dim(t.description)\n    )));\n    console.log(chalk.dim('  Usage: /theme <name>\\n'));\n    return 'handled';\n  }\n  setTheme(args);\n  const theme = getTheme();\n  if (theme.name === args) {\n    console.log(chalk.green('\\u2713') + ` Theme: ${theme.primary(theme.name)}`);\n  } else {\n    console.log(chalk.yellow(`  Unknown theme: ${args}. Try /theme to see options.`));\n  }\n  return 'handled';\n};\n\nconst sidebarHandler = async (_args: string, _ctx: SlashContext): Promise<SlashResult> => {\n  // Toggle sidebar visibility (TUI mode only)\n  console.log(chalk.dim('  Sidebar toggle: Ctrl+B in TUI mode'));\n  return 'handled';\n};\n\nconst keysHandler = async (_args: string, _ctx: SlashContext): Promise<SlashResult> => {\n  const { defaultKeybindings } = await import('../../tui/keybindings.js');\n  const bindings = defaultKeybindings();\n  const lines = Object.entries(bindings).map(([action, binding]) =>\n    kv(binding.key.padEnd(14), `${binding.description} (${action})`, 14)\n  );\n  console.log('\\n' + box('Keybindings', lines));\n  console.log(chalk.dim('  Customize: .opta/keybindings.json\\n'));\n  return 'handled';\n};\n\nconst formatHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const validFormats = ['text', 'json', 'markdown'];\n  const state = ctx.chatState as unknown as Record<string, unknown>;\n  const current = (state.outputFormat as string) || 'text';\n\n  if (!args) {\n    console.log(`  Output format: ${chalk.cyan(current)}`);\n    console.log(chalk.dim(`  Usage: /format <${validFormats.join('|')}>`));\n    return 'handled';\n  }\n\n  if (!validFormats.includes(args)) {\n    console.log(chalk.yellow(`  Unknown format: ${args}`) + chalk.dim(` (try: ${validFormats.join(', ')})`));\n    return 'handled';\n  }\n\n  state.outputFormat = args;\n  console.log(chalk.green('\\u2713') + ` Output format: ${chalk.cyan(args)}`);\n  return 'handled';\n};\n\nexport const displayCommands: SlashCommandDef[] = [\n  {\n    command: 'help',\n    aliases: ['h', '?'],\n    description: 'Show available commands (/help menu for interactive navigator)',\n    handler: helpHandler,\n    category: 'info',\n  },\n  {\n    command: 'expand',\n    aliases: ['think'],\n    description: 'Toggle thinking display',\n    handler: expandHandler,\n    category: 'info',\n  },\n  {\n    command: 'theme',\n    description: 'Change UI theme',\n    handler: themeHandler,\n    category: 'session',\n  },\n  {\n    command: 'sidebar',\n    description: 'Toggle sidebar (TUI mode)',\n    handler: sidebarHandler,\n    category: 'session',\n  },\n  {\n    command: 'keys',\n    aliases: ['keybindings'],\n    description: 'Show keybindings',\n    handler: keysHandler,\n    category: 'info',\n  },\n  {\n    command: 'format',\n    description: 'Toggle output format',\n    handler: formatHandler,\n    category: 'session',\n    usage: '/format [text|json|markdown]',\n    examples: ['/format', '/format json', '/format text'],\n  },\n];\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/commands/slash/index.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":96,"column":18,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":96,"endColumn":27,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[3022,3023],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":120,"column":23,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":120,"endColumn":54},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":169,"column":32,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":169,"endColumn":38},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":170,"column":32,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":170,"endColumn":38},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":175,"column":7,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":175,"endColumn":13},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":176,"column":9,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":176,"endColumn":23},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":176,"column":9,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":176,"endColumn":19,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[5587,5588],"text":"?."},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":177,"column":9,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":177,"endColumn":23},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":177,"column":9,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":177,"endColumn":15,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[5628,5629],"text":"?."},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":178,"column":9,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":178,"endColumn":27},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":178,"column":9,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":178,"endColumn":19,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[5678,5679],"text":"?."},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":183,"column":10,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":183,"endColumn":20},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":183,"column":10,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":183,"endColumn":16,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[5745,5746],"text":"?."},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/return-await","severity":1,"message":"Returning an awaited promise is required in this context.","line":219,"column":12,"nodeType":"CallExpression","messageId":"requiredPromiseAwait","endLine":219,"endColumn":47,"suggestions":[{"messageId":"requiredPromiseAwaitSuggestion","fix":{"range":[7186,7186],"text":"await "},"desc":"Add `await` before the expression. Use caution as this may impact control flow."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Slash command registry.\n *\n * Collects all command definitions from the handler modules into a single\n * Map<string, SlashCommandDef>. Provides:\n *\n *   - dispatchSlashCommand(input, ctx)  parse and dispatch a slash command\n *   - getAllCommands()  returns all registered commands (for /help, browser)\n *   - getCommandMap()  returns the raw lookup map\n */\n\nimport chalk from 'chalk';\nimport type { SlashCommandDef, SlashContext, SlashResult } from './types.js';\nimport { runMenuPrompt } from '../../ui/prompt-nav.js';\n\n// Re-export types for convenience\nexport type { SlashCommandDef, SlashContext, SlashResult, SlashHandler } from './types.js';\n\n// --- Import all handler modules ---\n\nimport { sessionCommands } from './session.js';\nimport { modelCommands } from './model.js';\nimport { displayCommands } from './display.js';\nimport { workflowCommands } from './workflow.js';\nimport { debugCommands } from './debug.js';\nimport { reviewCommands } from './review.js';\nimport { researchCommands } from './research.js';\nimport { lmxCommands } from './lmx.js';\nimport { manageCommands } from './manage.js';\nimport { browserCommands } from './browser.js';\nimport { accountCommands } from './account.js';\n\n// --- Build the registry ---\n\nconst allCommandDefs: SlashCommandDef[] = [\n  ...sessionCommands,\n  ...modelCommands,\n  ...displayCommands,\n  ...workflowCommands,\n  ...debugCommands,\n  ...reviewCommands,\n  ...researchCommands,\n  ...lmxCommands,\n  ...manageCommands,\n  ...browserCommands,\n  ...accountCommands,\n];\n\n/** Map from command/alias name (without slash) to the command definition. */\nconst commandMap = new Map<string, SlashCommandDef>();\n\nfor (const def of allCommandDefs) {\n  commandMap.set(def.command, def);\n  if (def.aliases) {\n    for (const alias of def.aliases) {\n      commandMap.set(alias, def);\n    }\n  }\n}\n\n/**\n * Returns all unique command definitions (no duplicates from aliases).\n */\nexport function getAllCommands(): SlashCommandDef[] {\n  // De-duplicate by command while preserving dispatch precedence.\n  // commandMap registration runs in source order and later handlers win,\n  // so we mirror that behavior here for UI surfaces (/help, browser).\n  const lastByCommand = new Map<string, SlashCommandDef>();\n  for (const def of allCommandDefs) {\n    lastByCommand.set(def.command, def);\n  }\n  return [...lastByCommand.values()];\n}\n\n/**\n * Returns the raw lookup map (command/alias -> definition).\n */\nexport function getCommandMap(): ReadonlyMap<string, SlashCommandDef> {\n  return commandMap;\n}\n\n/**\n * Parse a slash command string and dispatch it to the matching handler.\n *\n * Handles the special case of bare `/` (interactive command browser) by\n * building a picker from the registry and recursively dispatching the\n * selected command.\n *\n * Returns a SlashResult telling the chat loop what to do next.\n */\nexport async function dispatchSlashCommand(\n  input: string,\n  ctx: SlashContext\n): Promise<SlashResult> {\n  const parts = input.trim().split(/\\s+/);\n  const rawCmd = parts[0]!.toLowerCase();\n  const args = parts.slice(1).join(' ');\n\n  // Strip leading slash\n  const cmd = rawCmd.startsWith('/') ? rawCmd.slice(1) : rawCmd;\n\n  // Special: bare `/` opens the interactive command browser\n  if (cmd === '') {\n    return browseCommands(ctx);\n  }\n\n  const def = commandMap.get(cmd);\n  if (!def) {\n    // Fuzzy match: find closest command names by Levenshtein distance\n    let bestMatch: { name: string; distance: number } | null = null;\n    for (const key of commandMap.keys()) {\n      const dist = levenshtein(cmd, key);\n      if (!bestMatch || dist < bestMatch.distance) {\n        bestMatch = { name: key, distance: dist };\n      }\n    }\n\n    if (bestMatch && bestMatch.distance <= 2) {\n      // Close enough  auto-execute with a hint\n      const matched = commandMap.get(bestMatch.name)!;\n      console.log(chalk.dim(`  Auto-corrected: /${bestMatch.name}`));\n      return matched.handler(args, ctx);\n    }\n\n    if (bestMatch && bestMatch.distance === 3) {\n      console.log(\n        chalk.yellow(`  Unknown command: ${rawCmd}`) +\n        chalk.dim(`  did you mean /${bestMatch.name}? (try /help)`)\n      );\n      return 'handled';\n    }\n\n    console.log(chalk.yellow(`  Unknown command: ${rawCmd}`) + chalk.dim(' (try /help)'));\n    return 'handled';\n  }\n\n  // Per-command help: /cmd --help or /cmd -h\n  if (args === '--help' || args === '-h') {\n    console.log();\n    console.log(`  ${chalk.cyan(`/${def.command}`)} ${chalk.dim('\\u2014')} ${def.description}`);\n    if (def.usage) {\n      console.log(`  ${chalk.dim('Usage:')} ${def.usage}`);\n    }\n    if (def.examples && def.examples.length > 0) {\n      console.log(`  ${chalk.dim('Examples:')}`);\n      for (const ex of def.examples) {\n        console.log(`    ${chalk.cyan(ex)}`);\n      }\n    }\n    if (def.aliases && def.aliases.length > 0) {\n      console.log(`  ${chalk.dim('Aliases:')} ${def.aliases.map(a => `/${a}`).join(', ')}`);\n    }\n    console.log();\n    return 'handled';\n  }\n\n  return def.handler(args, ctx);\n}\n\n/**\n * Compute the Levenshtein distance between two strings.\n * Used for fuzzy matching of slash commands.\n */\nfunction levenshtein(a: string, b: string): number {\n  const m = a.length;\n  const n = b.length;\n  const dp: number[][] = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0) as number[]);\n\n  for (let i = 0; i <= m; i++) dp[i]![0] = i;\n  for (let j = 0; j <= n; j++) dp[0]![j] = j;\n\n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      const cost = a[i - 1] === b[j - 1] ? 0 : 1;\n      dp[i]![j] = Math.min(\n        dp[i - 1]![j]! + 1,      // deletion\n        dp[i]![j - 1]! + 1,      // insertion\n        dp[i - 1]![j - 1]! + cost // substitution\n      );\n    }\n  }\n\n  return dp[m]![n]!;\n}\n\n/**\n * Interactive command browser  shown when user types bare `/`.\n * Reads all commands from the registry and presents an inquirer select picker.\n */\nasync function browseCommands(ctx: SlashContext): Promise<SlashResult> {\n  const { select, Separator } = await import('@inquirer/prompts');\n  const defs = getAllCommands();\n\n  // Group commands by category for the browser display\n  const infoCommands = defs.filter(c => c.category === 'info');\n  const sessionCmds = defs.filter(c => c.category === 'session');\n  const toolsCmds = defs.filter(c => c.category === 'tools');\n  const serverCmds = defs.filter(c => c.category === 'server');\n\n  const formatChoice = (def: SlashCommandDef) => ({\n    name: `/${def.command.padEnd(14)}${def.description}`,\n    value: `/${def.command}`,\n  });\n\n  const commands = [\n    ...infoCommands.map(formatChoice),\n    new Separator(chalk.dim('\\u2500\\u2500\\u2500\\u2500 Session \\u2500\\u2500\\u2500\\u2500')),\n    ...sessionCmds.map(formatChoice),\n    new Separator(chalk.dim('\\u2500\\u2500\\u2500\\u2500 Tools \\u2500\\u2500\\u2500\\u2500')),\n    ...toolsCmds.map(formatChoice),\n    new Separator(chalk.dim('\\u2500\\u2500\\u2500\\u2500 Server \\u2500\\u2500\\u2500\\u2500')),\n    ...serverCmds.map(formatChoice),\n  ];\n\n  try {\n    const selected = await runMenuPrompt((context) =>\n      select({ message: chalk.dim('\\u203a'), choices: commands }, context), 'select');\n    if (!selected) return 'handled';\n    return dispatchSlashCommand(selected, ctx);\n  } catch {\n    return 'handled';\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/commands/slash/lmx.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":310,"column":19,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":310,"endColumn":29},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":559,"column":19,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":559,"endColumn":29},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":761,"column":18,"nodeType":"ChainExpression","messageId":"neverNullish","endLine":761,"endColumn":45},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":761,"column":37,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":761,"endColumn":39,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[26667,26669],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":762,"column":20,"nodeType":"ChainExpression","messageId":"neverNullish","endLine":762,"endColumn":58},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":762,"column":39,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":762,"endColumn":41,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[26724,26726],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":766,"column":49,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":766,"endColumn":51,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[26966,26968],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":766,"column":60,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":766,"endColumn":62,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[26977,26979],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":861,"column":19,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":861,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe object destructuring of a property with an `any` value.","line":951,"column":15,"nodeType":"Identifier","messageId":"unsafeObjectPattern","endLine":951,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `ArrayBuffer | ArrayBufferView<ArrayBufferLike> | null | undefined`.","line":953,"column":33,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":953,"endColumn":38},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":1158,"column":19,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":1158,"endColumn":29},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":1251,"column":19,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":1251,"endColumn":29},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":1576,"column":21,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":1576,"endColumn":31},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":1740,"column":19,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":1740,"endColumn":43},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":1752,"column":22,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":1752,"endColumn":24,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[61901,61903],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":1752,"column":33,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":1752,"endColumn":35,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[61912,61914],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":1955,"column":19,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":1955,"endColumn":29},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":2044,"column":19,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":2044,"endColumn":29},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":2191,"column":19,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":2191,"endColumn":29},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":2338,"column":19,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":2338,"endColumn":29}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":21,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * LMX server management slash commands: /scan, /load, /unload, /serve, /memory, /metrics, /benchmark, /embed, /rerank\n */\n\nimport chalk from 'chalk';\nimport { box, kv, progressBar } from '../../ui/box.js';\nimport { errorMessage } from '../../utils/errors.js';\nimport { getDisplayProfile, formatTagLabel } from '../../core/model-display.js';\nimport type { ModelFormat } from '../../core/model-display.js';\nimport type { SlashCommandDef, SlashContext, SlashResult } from './types.js';\n\nconst STABLE_MODEL_LOAD_TIMEOUT_MS = 300_000;\nconst FAST_SLASH_REQUEST_OPTS = { timeoutMs: 5_000, maxRetries: 0 } as const;\n\n/** Colored format tag  mirrors commands/models.ts fmtTag() */\nfunction fmtTag(format: ModelFormat): string {\n  switch (format) {\n    case 'MLX': return chalk.hex('#a855f7')(formatTagLabel(format));\n    case 'GGUF': return chalk.yellow(formatTagLabel(format));\n    case 'CLOUD': return chalk.blue(formatTagLabel(format));\n    default: return chalk.dim(formatTagLabel(format));\n  }\n}\n\nfunction parseSlashArgs(raw: string): string[] {\n  const tokens: string[] = [];\n  const pattern = /\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\"|'([^'\\\\]*(?:\\\\.[^'\\\\]*)*)'|`([^`\\\\]*(?:\\\\.[^`\\\\]*)*)`|([^\\s]+)/g;\n  let match: RegExpExecArray | null;\n\n  while ((match = pattern.exec(raw)) !== null) {\n    const captured = match[1] ?? match[2] ?? match[3] ?? match[4] ?? '';\n    tokens.push(captured.replace(/\\\\([\"'`\\\\])/g, '$1'));\n  }\n\n  return tokens;\n}\n\nfunction parseBooleanLiteral(raw: string | undefined): boolean | undefined {\n  if (raw === undefined) return undefined;\n  const normalized = raw.trim().toLowerCase();\n  if (['true', '1', 'yes', 'y', 'on'].includes(normalized)) return true;\n  if (['false', '0', 'no', 'n', 'off'].includes(normalized)) return false;\n  return undefined;\n}\n\nfunction renderJson(obj: unknown): string {\n  return JSON.stringify(obj, null, 2);\n}\n\nfunction asObject(value: unknown): Record<string, unknown> {\n  if (!value || typeof value !== 'object' || Array.isArray(value)) return {};\n  return value as Record<string, unknown>;\n}\n\nfunction readString(record: Record<string, unknown>, ...keys: string[]): string | undefined {\n  for (const key of keys) {\n    const value = record[key];\n    if (typeof value === 'string' && value.trim().length > 0) return value;\n  }\n  return undefined;\n}\n\nfunction readNumber(record: Record<string, unknown>, ...keys: string[]): number | undefined {\n  for (const key of keys) {\n    const value = record[key];\n    if (typeof value === 'number' && Number.isFinite(value)) return value;\n  }\n  return undefined;\n}\n\nfunction readBoolean(record: Record<string, unknown>, ...keys: string[]): boolean | undefined {\n  for (const key of keys) {\n    const value = record[key];\n    if (typeof value === 'boolean') return value;\n    if (typeof value === 'number') {\n      if (value === 1) return true;\n      if (value === 0) return false;\n    }\n    if (typeof value === 'string') {\n      const parsed = parseBooleanLiteral(value);\n      if (parsed !== undefined) return parsed;\n    }\n  }\n  return undefined;\n}\n\nfunction readArray(record: Record<string, unknown>, ...keys: string[]): unknown[] {\n  for (const key of keys) {\n    const value = record[key];\n    if (Array.isArray(value)) return value;\n  }\n  return [];\n}\n\nfunction classifyOutcome(raw: string | undefined): 'success' | 'failure' | 'unknown' {\n  if (!raw) return 'unknown';\n  const value = raw.trim().toLowerCase();\n  if (['ok', 'pass', 'passed', 'success', 'compatible'].includes(value)) return 'success';\n  if (['fail', 'failed', 'failure', 'error', 'incompatible'].includes(value)) return 'failure';\n  return 'unknown';\n}\n\nfunction adminEndpointUrl(ctx: SlashContext, path: string): string {\n  return `http://${ctx.config.connection.host}:${ctx.config.connection.port}${path}`;\n}\n\nasync function fetchAdminText(ctx: SlashContext, path: string, timeoutMs: number): Promise<string> {\n  const headers: Record<string, string> = {};\n  if (ctx.config.connection.adminKey?.trim()) {\n    headers['X-Admin-Key'] = ctx.config.connection.adminKey.trim();\n  }\n  const response = await fetch(adminEndpointUrl(ctx, path), {\n    method: 'GET',\n    headers,\n    signal: AbortSignal.timeout(timeoutMs),\n  });\n  if (!response.ok) {\n    throw new Error(`HTTP ${response.status} ${response.statusText}`);\n  }\n  return response.text();\n}\n\nconst modelsHandler = async (args: string, _ctx: SlashContext): Promise<SlashResult> => {\n  const tokens = parseSlashArgs(args);\n  const json = tokens.includes('--json');\n  const positional = tokens.filter((token) => token !== '--json');\n  const knownActions = new Set([\n    'help',\n    'list',\n    'manage',\n    'interactive',\n    'ui',\n    'use',\n    'info',\n    'load',\n    'unload',\n    'stop',\n    'swap',\n    'download',\n    'delete',\n    'remove',\n    'benchmark',\n    'bench',\n    'predictor',\n    'helpers',\n    'quantize',\n    'agents',\n    'skills',\n    'rag',\n    'health',\n    'scan',\n    'browse',\n    'browse-local',\n    'library',\n    'browse-library',\n  ]);\n\n  let action = positional[0]?.toLowerCase();\n  let name: string | undefined;\n  let extraArg: string | undefined;\n\n  if (action && !knownActions.has(action)) {\n    name = positional.join(' ');\n    action = 'use';\n  } else if (action === 'swap') {\n    name = positional[1];\n    extraArg = positional.slice(2).join(' ').trim() || undefined;\n  } else {\n    name = positional.slice(1).join(' ').trim() || undefined;\n  }\n\n  try {\n    const { models } = await import('../models.js');\n    await models(action, name, extraArg, { json });\n  } catch (err) {\n    console.error(chalk.red('\\u2717') + ` models command failed: ${errorMessage(err)}`);\n  }\n\n  return 'handled';\n};\n\nconst scanHandler = async (_args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const { lookupContextLimit } = await import('../../lmx/client.js');\n  const {\n    scanModels,\n    buildRoleMap,\n    shortId,\n    fmtGB,\n    fmtCtx,\n    summarizeScan,\n  } = await import('../../providers/model-scan.js');\n  // (shortId kept for presets display)\n\n  console.log(chalk.dim(`  Scanning ${ctx.config.connection.host}:${ctx.config.connection.port}...`));\n\n  const scan = await scanModels(ctx.config);\n\n  if (!scan.lmxReachable && scan.cloud.length === 0) {\n    console.log(chalk.yellow('  LMX unreachable, no cloud providers configured'));\n    return 'handled';\n  }\n\n  const roleMap = buildRoleMap(scan.roles);\n  const loadedIds = new Set(scan.loaded.map(m => m.model_id));\n\n  const lines: string[] = [];\n\n  // Loaded\n  if (scan.lmxReachable) {\n    lines.push(chalk.bold('Loaded') + chalk.dim(` \\u2500 ${ctx.config.connection.host}:${ctx.config.connection.port}`));\n    if (scan.loaded.length === 0) {\n      lines.push(chalk.dim('  (no models loaded)'));\n    }\n    for (const m of scan.loaded) {\n      const parts: string[] = [fmtCtx(m.context_length ?? lookupContextLimit(m.model_id))];\n      if (m.memory_bytes) parts.push(fmtGB(m.memory_bytes));\n      if (m.request_count) parts.push(`${m.request_count} reqs`);\n      const roles = roleMap.get(m.model_id);\n      if (roles) parts.push(roles.map(r => `role:${r}`).join(' '));\n      const isCurrent = m.model_id === ctx.config.model.default;\n      const star = isCurrent ? chalk.green(' \\u2605') : '';\n      const dp = getDisplayProfile(m.model_id);\n      lines.push(`  ${chalk.green('\\u25cf')} ${chalk.bold(dp.displayName)} ${fmtTag(dp.format)} ${chalk.dim(dp.orgAbbrev)}  ${chalk.dim(parts.join(' \\u00b7 '))}${star}`);\n    }\n  }\n\n  // On disk\n  const onDisk = scan.available.filter(a => !loadedIds.has(a.repo_id));\n  if (onDisk.length > 0) {\n    lines.push('');\n    lines.push(chalk.bold('On Disk') + chalk.dim(' \\u2500 not loaded'));\n    for (const a of onDisk) {\n      const size = a.size_bytes > 0 ? fmtGB(a.size_bytes) : '';\n      const dp = getDisplayProfile(a.repo_id);\n      lines.push(`  ${chalk.dim('\\u25cb')} ${dp.displayName} ${fmtTag(dp.format)} ${chalk.dim(dp.orgAbbrev)}  ${chalk.dim([fmtCtx(lookupContextLimit(a.repo_id)), size].filter(Boolean).join(' \\u00b7 '))}`);\n    }\n  }\n\n  // Presets\n  if (scan.presets.length > 0) {\n    lines.push('');\n    lines.push(chalk.bold('Presets'));\n    for (const p of scan.presets) {\n      const model = shortId(p.model);\n      const alias = p.routing_alias ? chalk.cyan(`alias:\"${p.routing_alias}\"`) : '';\n      const auto = p.auto_load ? chalk.dim('auto-load') : '';\n      lines.push(`  ${chalk.magenta('\\u2666')} ${chalk.bold(p.name.padEnd(18))} \\u2192 ${chalk.dim(model)}  ${alias}  ${auto}`);\n    }\n  }\n\n  // Cloud\n  if (scan.cloud.length > 0) {\n    lines.push('');\n    lines.push(chalk.bold('Cloud') + chalk.dim(' \\u2500 Anthropic'));\n    for (const m of scan.cloud) {\n      const ctxStr = m.contextLength ? fmtCtx(m.contextLength) : '';\n      lines.push(`  ${chalk.blue('\\u2601')} ${m.id}  ${chalk.dim([m.name ?? '', ctxStr].filter(Boolean).join(' \\u00b7 '))}`);\n    }\n  }\n\n  // Memory\n  if (scan.memory) {\n    lines.push('');\n    const pct = Math.round((scan.memory.used_gb / scan.memory.total_unified_memory_gb) * 100);\n    const pctColor = pct > 80 ? chalk.red : pct > 60 ? chalk.yellow : chalk.green;\n    lines.push(`Memory: ${scan.memory.used_gb.toFixed(1)} / ${scan.memory.total_unified_memory_gb.toFixed(1)} GB ${pctColor(`(${pct}%)`)}` +\n      chalk.dim(` \\u00b7 threshold ${scan.memory.threshold_percent}%`));\n  }\n\n  // Footer\n  const summary = summarizeScan(scan);\n  const counts: string[] = [];\n  if (summary.loadedCount > 0) counts.push(`${summary.loadedCount} loaded`);\n  if (summary.onDiskCount > 0) counts.push(`${summary.onDiskCount} on disk`);\n  if (summary.presetCount > 0) counts.push(`${summary.presetCount} presets`);\n  if (summary.cloudCount > 0) counts.push(`${summary.cloudCount} cloud`);\n  if (counts.length > 0) {\n    lines.push('');\n    lines.push(chalk.dim(counts.join(' \\u00b7 ')));\n  }\n\n  console.log('\\n' + box('Model Scan', lines));\n  return 'handled';\n};\n\nconst loadHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const tokens = parseSlashArgs(args);\n  const modelToken = tokens.find((token) => !token.startsWith('--'));\n  if (!modelToken) {\n    console.log(chalk.dim('  Usage: /load <model-id> [--backend <name>] [--auto-download] [--keep-alive <sec>] [--allow-unsupported]'));\n    console.log(chalk.dim('         [--kv-bits <n>] [--kv-group-size <n>] [--prefix-cache <true|false>] [--memory-estimate-gb <n>] [--perf-json <json>]'));\n    console.log(chalk.dim('  Run /scan to see available models'));\n    return 'handled';\n  }\n\n  const advanced: {\n    backend?: 'vllm-mlx' | 'mlx-lm' | 'gguf';\n    autoDownload?: boolean;\n    keepAliveSec?: number;\n    allowUnsupportedRuntime?: boolean;\n    performanceOverrides?: Record<string, unknown>;\n  } = {};\n\n  const perfOverrides: Record<string, unknown> = {};\n  let hasPerfOverride = false;\n  let hasAdvancedOption = false;\n\n  const unknown: string[] = [];\n  for (let i = 0; i < tokens.length; i += 1) {\n    const token = tokens[i]!;\n    if (!token.startsWith('--')) continue;\n\n    if (token === '--backend') {\n      const value = tokens[i + 1];\n      if (!value) {\n        console.log(chalk.dim('  Missing value for --backend (expected: vllm-mlx|mlx-lm|gguf)'));\n        return 'handled';\n      }\n      i += 1;\n      if (value !== 'vllm-mlx' && value !== 'mlx-lm' && value !== 'gguf') {\n        console.log(chalk.yellow(`  Invalid backend: ${value}`));\n        return 'handled';\n      }\n      advanced.backend = value;\n      hasAdvancedOption = true;\n      continue;\n    }\n\n    if (token === '--auto-download') {\n      advanced.autoDownload = true;\n      hasAdvancedOption = true;\n      continue;\n    }\n\n    if (token === '--allow-unsupported') {\n      advanced.allowUnsupportedRuntime = true;\n      hasAdvancedOption = true;\n      continue;\n    }\n\n    if (token === '--keep-alive') {\n      const value = tokens[i + 1];\n      if (!value) {\n        console.log(chalk.dim('  Missing value for --keep-alive'));\n        return 'handled';\n      }\n      i += 1;\n      const parsed = Number.parseInt(value, 10);\n      if (!Number.isFinite(parsed) || parsed < 0) {\n        console.log(chalk.yellow(`  Invalid --keep-alive value: ${value}`));\n        return 'handled';\n      }\n      advanced.keepAliveSec = parsed;\n      hasAdvancedOption = true;\n      continue;\n    }\n\n    if (token === '--perf-json') {\n      const value = tokens[i + 1];\n      if (!value) {\n        console.log(chalk.dim('  Missing value for --perf-json'));\n        return 'handled';\n      }\n      i += 1;\n      try {\n        const parsed = JSON.parse(value) as unknown;\n        if (!parsed || typeof parsed !== 'object' || Array.isArray(parsed)) {\n          console.log(chalk.yellow('  --perf-json must be a JSON object'));\n          return 'handled';\n        }\n        Object.assign(perfOverrides, parsed);\n        hasPerfOverride = true;\n        hasAdvancedOption = true;\n      } catch (err) {\n        console.log(chalk.yellow(`  Invalid --perf-json: ${errorMessage(err)}`));\n        return 'handled';\n      }\n      continue;\n    }\n\n    if (token === '--kv-bits') {\n      const value = tokens[i + 1];\n      if (!value) {\n        console.log(chalk.dim('  Missing value for --kv-bits'));\n        return 'handled';\n      }\n      i += 1;\n      const parsed = Number.parseInt(value, 10);\n      if (!Number.isFinite(parsed) || parsed <= 0) {\n        console.log(chalk.yellow(`  Invalid --kv-bits value: ${value}`));\n        return 'handled';\n      }\n      perfOverrides['kv_bits'] = parsed;\n      hasPerfOverride = true;\n      hasAdvancedOption = true;\n      continue;\n    }\n\n    if (token === '--kv-group-size') {\n      const value = tokens[i + 1];\n      if (!value) {\n        console.log(chalk.dim('  Missing value for --kv-group-size'));\n        return 'handled';\n      }\n      i += 1;\n      const parsed = Number.parseInt(value, 10);\n      if (!Number.isFinite(parsed) || parsed <= 0) {\n        console.log(chalk.yellow(`  Invalid --kv-group-size value: ${value}`));\n        return 'handled';\n      }\n      perfOverrides['kv_group_size'] = parsed;\n      hasPerfOverride = true;\n      hasAdvancedOption = true;\n      continue;\n    }\n\n    if (token === '--memory-estimate-gb') {\n      const value = tokens[i + 1];\n      if (!value) {\n        console.log(chalk.dim('  Missing value for --memory-estimate-gb'));\n        return 'handled';\n      }\n      i += 1;\n      const parsed = Number.parseFloat(value);\n      if (!Number.isFinite(parsed) || parsed <= 0) {\n        console.log(chalk.yellow(`  Invalid --memory-estimate-gb value: ${value}`));\n        return 'handled';\n      }\n      perfOverrides['memory_estimate_gb'] = parsed;\n      hasPerfOverride = true;\n      hasAdvancedOption = true;\n      continue;\n    }\n\n    if (token === '--prefix-cache') {\n      const value = tokens[i + 1];\n      if (!value) {\n        console.log(chalk.dim('  Missing value for --prefix-cache (true|false)'));\n        return 'handled';\n      }\n      i += 1;\n      const parsed = parseBooleanLiteral(value);\n      if (parsed === undefined) {\n        console.log(chalk.yellow(`  Invalid --prefix-cache value: ${value}`));\n        return 'handled';\n      }\n      perfOverrides['prefix_cache'] = parsed;\n      hasPerfOverride = true;\n      hasAdvancedOption = true;\n      continue;\n    }\n\n    unknown.push(token);\n  }\n\n  if (unknown.length > 0) {\n    console.log(chalk.yellow(`  Unknown options: ${unknown.join(', ')}`));\n    console.log(chalk.dim('  Usage: /load <model-id> [--backend <name>] [--auto-download] [--keep-alive <sec>] [--allow-unsupported]'));\n    return 'handled';\n  }\n\n  if (hasPerfOverride) {\n    advanced.performanceOverrides = perfOverrides;\n  }\n\n  const { LmxClient } = await import('../../lmx/client.js');\n  const { ensureModelLoaded, findMatchingModelId } = await import('../../lmx/model-lifecycle.js');\n  const lmx = new LmxClient({\n    host: ctx.config.connection.host,\n    fallbackHosts: ctx.config.connection.fallbackHosts,\n    port: ctx.config.connection.port,\n    adminKey: ctx.config.connection.adminKey,\n  });\n\n  try {\n    const [loadedRes, availableRes] = await Promise.all([\n      lmx.models(FAST_SLASH_REQUEST_OPTS).catch(() => ({ models: [] })),\n      lmx.available(FAST_SLASH_REQUEST_OPTS).catch(() => []),\n    ]);\n    const loadedIds = loadedRes.models.map((m) => m.model_id);\n    const alreadyLoaded = findMatchingModelId(modelToken, loadedIds);\n    if (alreadyLoaded) {\n      console.log(chalk.dim(`  ${alreadyLoaded} is already loaded`));\n      if (hasAdvancedOption) {\n        console.log(chalk.dim('  Unload first if you want to apply new load-time backend/performance options.'));\n      }\n      return 'handled';\n    }\n\n    const resolved = findMatchingModelId(modelToken, availableRes.map((m) => m.repo_id)) ?? modelToken;\n    console.log(chalk.dim(`  Loading ${resolved}...`));\n\n    const loadedId = await ensureModelLoaded(lmx, resolved, {\n      timeoutMs: STABLE_MODEL_LOAD_TIMEOUT_MS,\n      loadOptions: hasAdvancedOption ? advanced : undefined,\n    });\n\n    console.log(chalk.green('\\u2713') + ` Loaded ${loadedId}`);\n\n    const refreshed = await lmx.models(FAST_SLASH_REQUEST_OPTS).catch(() => ({ models: [] }));\n    const details = refreshed.models.find((model) => findMatchingModelId(loadedId, [model.model_id]));\n    if (details?.memory_bytes) {\n      console.log(chalk.dim(`  Memory: ${(details.memory_bytes / 1e9).toFixed(1)} GB`));\n    }\n  } catch (err) {\n    console.error(chalk.red('\\u2717') + ` Failed to load: ${errorMessage(err)}`);\n  }\n  return 'handled';\n};\n\nconst unloadHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  if (!args) {\n    console.log(chalk.dim('  Usage: /unload <model-id>'));\n    return 'handled';\n  }\n\n  const { LmxClient } = await import('../../lmx/client.js');\n  const { findMatchingModelId, waitForModelUnloaded } = await import('../../lmx/model-lifecycle.js');\n  const lmx = new LmxClient({\n    host: ctx.config.connection.host,\n    fallbackHosts: ctx.config.connection.fallbackHosts,\n    port: ctx.config.connection.port,\n    adminKey: ctx.config.connection.adminKey,\n  });\n\n  try {\n    const loadedRes = await lmx.models(FAST_SLASH_REQUEST_OPTS).catch(() => ({ models: [] }));\n    const resolved = findMatchingModelId(args, loadedRes.models.map((m) => m.model_id));\n    if (!resolved) {\n      console.log(chalk.dim(`  ${args} is not currently loaded`));\n      return 'handled';\n    }\n\n    const result = await lmx.unloadModel(resolved);\n    await waitForModelUnloaded(lmx, resolved, { timeoutMs: 30_000 });\n    console.log(chalk.green('\\u2713') + ` Unloaded ${result.model_id}`);\n    if (result.freed_bytes) {\n      console.log(chalk.dim(`  Freed: ${(result.freed_bytes / 1e9).toFixed(1)} GB`));\n    }\n  } catch (err) {\n    console.error(chalk.red('\\u2717') + ` Failed to unload: ${errorMessage(err)}`);\n  }\n  return 'handled';\n};\n\nconst serveHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const tokens = parseSlashArgs(args);\n  let action = 'status';\n  let startIndex = 0;\n  const maybeAction = tokens[0]?.toLowerCase();\n  if (maybeAction && !maybeAction.startsWith('-')) {\n    action = maybeAction;\n    startIndex = 1;\n  }\n\n  let json = false;\n  const unknown: string[] = [];\n  for (let i = startIndex; i < tokens.length; i += 1) {\n    const token = tokens[i]!;\n    if (token === '--json') {\n      json = true;\n      continue;\n    }\n    unknown.push(token);\n  }\n\n  if (unknown.length > 0) {\n    console.log(chalk.yellow(`  Unknown options: ${unknown.join(', ')}`));\n    console.log(chalk.dim('  Usage: /serve [start|stop|restart|reload|logs] [--json]'));\n    console.log(chalk.dim('  No args: show LMX server status'));\n    return 'handled';\n  }\n\n  const { host, port } = ctx.config.connection;\n\n  if (action === 'status') {\n    if (json) {\n      const { serve } = await import('../serve.js');\n      await serve(undefined, { json: true });\n      return 'handled';\n    }\n\n    const { LmxClient } = await import('../../lmx/client.js');\n    const lmx = new LmxClient({\n      host,\n      fallbackHosts: ctx.config.connection.fallbackHosts,\n      port,\n      adminKey: ctx.config.connection.adminKey,\n    });\n\n    try {\n      await lmx.health(FAST_SLASH_REQUEST_OPTS);\n      const status = await lmx.status(FAST_SLASH_REQUEST_OPTS);\n      const lines: string[] = [\n        kv('Status', chalk.green('running')),\n        kv('Address', `${host}:${port}`),\n      ];\n      if (status.version) lines.push(kv('Version', status.version));\n      if (status.uptime_seconds != null) {\n        const mins = Math.floor(status.uptime_seconds / 60);\n        lines.push(kv('Uptime', mins < 60 ? `${mins}m` : `${Math.floor(mins / 60)}h ${mins % 60}m`));\n      }\n      lines.push(kv('Models', `${status.models.length} loaded`));\n      if (status.memory) {\n        const usedGB = (status.memory.used_bytes / 1e9).toFixed(1);\n        const totalGB = (status.memory.total_bytes / 1e9).toFixed(1);\n        const ratio = status.memory.used_bytes / status.memory.total_bytes;\n        lines.push(kv('Memory', `${usedGB}/${totalGB} GB ${progressBar(ratio, 12)}`));\n      }\n      console.log('\\n' + box('LMX Server', lines));\n    } catch {\n      console.log(chalk.red('  \\u25cf LMX is not reachable') + chalk.dim(` at ${host}:${port}`));\n      console.log(chalk.dim('  Start it: /serve start'));\n    }\n    return 'handled';\n  }\n\n  if (action === 'reload') {\n    const { LmxClient } = await import('../../lmx/client.js');\n    const { host, port } = ctx.config.connection;\n    const lmx = new LmxClient({\n      host,\n      fallbackHosts: ctx.config.connection.fallbackHosts,\n      port,\n      adminKey: ctx.config.connection.adminKey,\n    });\n    try {\n      const result = await lmx.reloadConfig(FAST_SLASH_REQUEST_OPTS);\n      if (json) {\n        console.log(JSON.stringify({ ok: true, updated: result.updated }, null, 2));\n        return 'handled';\n      }\n      console.log(chalk.green('') + ' Config reloaded');\n      console.log(chalk.dim('  Updated: ' + result.updated.join(', ')));\n    } catch (err) {\n      if (json) {\n        console.log(JSON.stringify({ ok: false, error: errorMessage(err) }, null, 2));\n        return 'handled';\n      }\n      console.error(chalk.red('') + ` Config reload failed: ${errorMessage(err)}`);\n    }\n    return 'handled';\n  }\n\n  if (action === 'start' || action === 'stop' || action === 'restart' || action === 'logs') {\n    try {\n      const { serve } = await import('../serve.js');\n      await serve(action, json ? { json: true } : undefined);\n    } catch (err) {\n      console.error(chalk.red('\\u2717') + ` serve ${action} failed: ${errorMessage(err)}`);\n    }\n    return 'handled';\n  }\n\n  console.log(chalk.dim('  Usage: /serve [start|stop|restart|reload|logs] [--json]'));\n  console.log(chalk.dim('  No args: show LMX server status'));\n  return 'handled';\n};\n\nconst memoryHandler = async (_args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const { LmxClient } = await import('../../lmx/client.js');\n  const lmx = new LmxClient({\n    host: ctx.config.connection.host,\n    fallbackHosts: ctx.config.connection.fallbackHosts,\n    port: ctx.config.connection.port,\n    adminKey: ctx.config.connection.adminKey,\n  });\n\n  try {\n    const mem = await lmx.memory(FAST_SLASH_REQUEST_OPTS);\n    const pct = Math.round((mem.used_gb / mem.total_unified_memory_gb) * 100);\n    const lines: string[] = [\n      kv('Total', `${mem.total_unified_memory_gb.toFixed(1)} GB`),\n      kv('Used', `${mem.used_gb.toFixed(1)} GB ${progressBar(pct / 100, 16)}`),\n      kv('Available', `${mem.available_gb.toFixed(1)} GB`),\n      kv('Threshold', `${mem.threshold_percent}%`),\n    ];\n\n    const modelEntries = Object.entries(mem.models);\n    if (modelEntries.length > 0) {\n      lines.push('');\n      lines.push(chalk.dim('Per-model:'));\n      for (const [id, info] of modelEntries) {\n        const shortName = id.replace(/^(mlx|huggingface)-community\\//, '');\n        const loadedStr = info.loaded ? chalk.green('\\u25cf') : chalk.dim('\\u25cb');\n        lines.push(`  ${loadedStr} ${shortName.padEnd(35)} ${chalk.dim(`${info.memory_gb.toFixed(1)} GB`)}`);\n      }\n    }\n\n    console.log('\\n' + box('LMX Memory', lines));\n  } catch {\n    console.log(chalk.red('  \\u25cf LMX unreachable') + chalk.dim(` \\u2014 ${ctx.config.connection.host}:${ctx.config.connection.port}`));\n  }\n  return 'handled';\n};\n\nconst diagnoseHandler = async (_args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const { LmxClient } = await import('../../lmx/client.js');\n  const { getProvider } = await import('../../providers/manager.js');\n  const { host, port } = ctx.config.connection;\n\n  console.log(chalk.dim('  Running diagnostics...\\n'));\n  const checks: string[] = [];\n  const lmx = new LmxClient({\n    host,\n    fallbackHosts: ctx.config.connection.fallbackHosts,\n    port,\n    adminKey: ctx.config.connection.adminKey,\n  });\n\n  // 1. Server reachability + latency\n  const healthStart = Date.now();\n  let serverOk = false;\n  try {\n    await lmx.health(FAST_SLASH_REQUEST_OPTS);\n    const latency = Date.now() - healthStart;\n    serverOk = true;\n    const latColor = latency < 50 ? chalk.green : latency < 200 ? chalk.yellow : chalk.red;\n    checks.push(`${chalk.green('\\u2713')} Server reachable at ${host}:${port} ${latColor(`(${latency}ms)`)}`);\n  } catch (err) {\n    checks.push(`${chalk.red('\\u2717')} Server unreachable at ${host}:${port}`);\n    checks.push(`  ${chalk.dim(errorMessage(err))}`);\n  }\n\n  // 2. Models loaded\n  if (serverOk) {\n    try {\n      const models = await lmx.models(FAST_SLASH_REQUEST_OPTS);\n      const count = models.models.length;\n      checks.push(count > 0\n        ? `${chalk.green('\\u2713')} ${count} model${count !== 1 ? 's' : ''} loaded`\n        : `${chalk.yellow('\\u26a0')} No models loaded  run /load <model-id>`);\n    } catch {\n      checks.push(`${chalk.yellow('\\u26a0')} Could not query loaded models`);\n    }\n  }\n\n  // 3. Memory utilization\n  if (serverOk) {\n    try {\n      const mem = await lmx.memory(FAST_SLASH_REQUEST_OPTS);\n      const pct = Math.round((mem.used_gb / mem.total_unified_memory_gb) * 100);\n      const pctColor = pct > 80 ? chalk.red : pct > 60 ? chalk.yellow : chalk.green;\n      checks.push(`${chalk.green('\\u2713')} Memory: ${mem.used_gb.toFixed(1)}/${mem.total_unified_memory_gb.toFixed(1)} GB ${pctColor(`(${pct}%)`)}`);\n    } catch {\n      checks.push(`${chalk.yellow('\\u26a0')} Could not query memory`);\n    }\n  }\n\n  // 4. Admin API\n  if (serverOk) {\n    try {\n      await lmx.status(FAST_SLASH_REQUEST_OPTS);\n      checks.push(`${chalk.green('\\u2713')} Admin API responding`);\n    } catch {\n      checks.push(`${chalk.yellow('\\u26a0')} Admin API not available (check admin key)`);\n    }\n  }\n\n  // 5. Provider config\n  const active = ctx.config.provider?.active ?? 'lmx';\n  const fallback = ctx.config.provider?.fallbackOnFailure ?? false;\n  checks.push(`${chalk.green('\\u2713')} Provider: ${chalk.bold(active)}${fallback ? chalk.cyan(' + Anthropic fallback') : ''}`);\n\n  // 6. Anthropic fallback status\n  const hasAnthropicKey = !!(ctx.config.provider?.anthropic?.apiKey || process.env['ANTHROPIC_API_KEY']);\n  if (fallback && hasAnthropicKey) {\n    try {\n      const cfg = { ...ctx.config, provider: { ...ctx.config.provider, active: 'anthropic' as const } };\n      const anthropic = await getProvider(cfg);\n      const aHealth = await anthropic.health();\n      checks.push(aHealth.ok\n        ? `${chalk.green('\\u2713')} Anthropic fallback ready ${chalk.dim(`(${aHealth.latencyMs}ms)`)}`\n        : `${chalk.red('\\u2717')} Anthropic fallback unhealthy: ${aHealth.error}`);\n    } catch {\n      checks.push(`${chalk.yellow('\\u26a0')} Could not verify Anthropic fallback`);\n    }\n  } else if (fallback && !hasAnthropicKey) {\n    checks.push(`${chalk.yellow('\\u26a0')} Fallback enabled but no Anthropic API key configured`);\n  } else if (!fallback && hasAnthropicKey) {\n    checks.push(`${chalk.dim('\\u2139')} Anthropic key present but fallback disabled  set provider.fallbackOnFailure: true to enable`);\n  }\n\n  // 7. Inference timeout\n  const timeout = ctx.config.connection.inferenceTimeout;\n  checks.push(`${chalk.green('\\u2713')} Inference timeout: ${(timeout / 1000).toFixed(0)}s`);\n\n  console.log(box('LMX Diagnostics', checks));\n  return 'handled';\n};\n\nconst metricsHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const tokens = parseSlashArgs(args);\n  const json = tokens.includes('--json');\n  const prom = tokens.includes('--prom');\n  const unknown = tokens.filter((token) => token.startsWith('--') && token !== '--json' && token !== '--prom');\n  if (unknown.length > 0) {\n    console.log(chalk.yellow(`  Unknown options: ${unknown.join(', ')}`));\n    console.log(chalk.dim('  Usage: /metrics [--prom|--json]'));\n    return 'handled';\n  }\n\n  if (prom) {\n    try {\n      const text = await fetchAdminText(ctx, '/admin/metrics', 10_000);\n      if (json) {\n        console.log(renderJson({ format: 'prometheus', content: text }));\n      } else {\n        console.log(text.trimEnd());\n      }\n    } catch (err) {\n      console.error(chalk.red('') + ` Metrics fetch failed: ${errorMessage(err)}`);\n    }\n    return 'handled';\n  }\n\n  const { LmxClient } = await import('../../lmx/client.js');\n  const lmx = new LmxClient({\n    host: ctx.config.connection.host,\n    fallbackHosts: ctx.config.connection.fallbackHosts,\n    port: ctx.config.connection.port,\n    adminKey: ctx.config.connection.adminKey,\n  });\n\n  try {\n    const m = await lmx.metricsJson(FAST_SLASH_REQUEST_OPTS);\n    if (json) {\n      console.log(renderJson(m));\n      return 'handled';\n    }\n    const lines: string[] = [];\n\n    // Show all top-level numeric/string fields\n    for (const [key, val] of Object.entries(m)) {\n      if (typeof val === 'number') {\n        const label = key.replace(/_/g, ' ').replace(/\\b\\w/g, (c) => c.toUpperCase());\n        const formatted = Number.isInteger(val) ? val.toLocaleString() : val.toFixed(2);\n        lines.push(kv(label, formatted));\n      }\n    }\n\n    if (lines.length === 0) {\n      lines.push(chalk.dim('No metrics available yet  make some requests first'));\n    }\n\n    console.log('\\n' + box('LMX Metrics', lines));\n  } catch {\n    console.log(chalk.red('   LMX unreachable') + chalk.dim(`  ${ctx.config.connection.host}:${ctx.config.connection.port}`));\n  }\n  return 'handled';\n};\n\nconst eventsHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const tokens = parseSlashArgs(args);\n  let limit = 20;\n  let timeoutSec = 20;\n  const json = tokens.includes('--json');\n  const unknown: string[] = [];\n\n  for (let i = 0; i < tokens.length; i += 1) {\n    const token = tokens[i]!;\n    if (!token.startsWith('--')) {\n      unknown.push(token);\n      continue;\n    }\n    if (token === '--json') continue;\n    if (token === '--limit') {\n      const value = tokens[i + 1];\n      if (!value) {\n        console.log(chalk.dim('  Missing value for --limit'));\n        return 'handled';\n      }\n      i += 1;\n      const parsed = Number.parseInt(value, 10);\n      if (!Number.isFinite(parsed) || parsed < 1 || parsed > 500) {\n        console.log(chalk.yellow(`  Invalid --limit value: ${value} (expected 1..500)`));\n        return 'handled';\n      }\n      limit = parsed;\n      continue;\n    }\n    if (token === '--timeout') {\n      const value = tokens[i + 1];\n      if (!value) {\n        console.log(chalk.dim('  Missing value for --timeout'));\n        return 'handled';\n      }\n      i += 1;\n      const parsed = Number.parseInt(value, 10);\n      if (!Number.isFinite(parsed) || parsed < 1 || parsed > 300) {\n        console.log(chalk.yellow(`  Invalid --timeout value: ${value} (expected 1..300)`));\n        return 'handled';\n      }\n      timeoutSec = parsed;\n      continue;\n    }\n    unknown.push(token);\n  }\n\n  if (unknown.length > 0) {\n    console.log(chalk.yellow(`  Unknown options: ${unknown.join(', ')}`));\n    console.log(chalk.dim('  Usage: /events [--limit <n>] [--timeout <sec>] [--json]'));\n    return 'handled';\n  }\n\n  const headers: Record<string, string> = {\n    Accept: 'text/event-stream',\n  };\n  if (ctx.config.connection.adminKey?.trim()) {\n    headers['X-Admin-Key'] = ctx.config.connection.adminKey.trim();\n  }\n\n  const controller = new AbortController();\n  const killTimer = setTimeout(() => controller.abort(), timeoutSec * 1000);\n  type EventRow = { event: string; data: unknown };\n  const rows: EventRow[] = [];\n  let partial = '';\n  let eventName = 'message';\n  let dataLines: string[] = [];\n\n  const flushEvent = () => {\n    if (dataLines.length === 0) return;\n    const raw = dataLines.join('\\n');\n    let parsed: unknown = raw;\n    try {\n      parsed = JSON.parse(raw);\n    } catch {\n      parsed = raw;\n    }\n    rows.push({ event: eventName || 'message', data: parsed });\n    eventName = 'message';\n    dataLines = [];\n  };\n\n  try {\n    const response = await fetch(adminEndpointUrl(ctx, '/admin/events'), {\n      method: 'GET',\n      headers,\n      signal: controller.signal,\n    });\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status} ${response.statusText}`);\n    }\n    if (!response.body) {\n      throw new Error('No response stream available');\n    }\n\n    const reader = response.body.getReader();\n    const decoder = new TextDecoder();\n    while (rows.length < limit) {\n      const { value, done } = await reader.read();\n      if (done) break;\n      partial += decoder.decode(value, { stream: true });\n      const lines = partial.split(/\\r?\\n/);\n      partial = lines.pop() ?? '';\n      for (const line of lines) {\n        if (line.startsWith('event:')) {\n          eventName = line.slice(6).trim() || 'message';\n          continue;\n        }\n        if (line.startsWith('data:')) {\n          dataLines.push(line.slice(5).trim());\n          continue;\n        }\n        if (line.trim() === '') {\n          flushEvent();\n          if (rows.length >= limit) {\n            controller.abort();\n            break;\n          }\n        }\n      }\n    }\n    flushEvent();\n  } catch (err) {\n    if (!(err instanceof DOMException && err.name === 'AbortError')) {\n      console.error(chalk.red('') + ` Events stream failed: ${errorMessage(err)}`);\n      return 'handled';\n    }\n  } finally {\n    clearTimeout(killTimer);\n  }\n\n  if (json) {\n    console.log(renderJson({\n      count: rows.length,\n      timeoutSec,\n      limit,\n      events: rows,\n    }));\n    return 'handled';\n  }\n\n  const lines: string[] = [\n    kv('Captured', String(rows.length)),\n    kv('Timeout', `${timeoutSec}s`),\n  ];\n  if (rows.length > 0) {\n    lines.push('');\n    for (const row of rows) {\n      const payload = typeof row.data === 'string' ? row.data : renderJson(row.data);\n      const inline = payload.replace(/\\s+/g, ' ').trim();\n      lines.push(`  ${chalk.cyan(row.event.padEnd(18))} ${inline.slice(0, 120)}`);\n    }\n  } else {\n    lines.push(chalk.dim('No events captured in this window.'));\n  }\n  console.log('\\n' + box('LMX Events', lines));\n  return 'handled';\n};\n\nconst benchmarkHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const tokens = parseSlashArgs(args);\n  const first = tokens[0]?.toLowerCase();\n  if (first === 'results') {\n    const json = tokens.slice(1).includes('--json');\n    const unknown = tokens.slice(1).filter((token) => token !== '--json');\n    if (unknown.length > 0) {\n      console.log(chalk.yellow(`  Unknown options: ${unknown.join(', ')}`));\n      console.log(chalk.dim('  Usage: /benchmark results [--json]'));\n      return 'handled';\n    }\n\n    const { LmxClient } = await import('../../lmx/client.js');\n    const lmx = new LmxClient({\n      host: ctx.config.connection.host,\n      fallbackHosts: ctx.config.connection.fallbackHosts,\n      port: ctx.config.connection.port,\n      adminKey: ctx.config.connection.adminKey,\n    });\n\n    try {\n      const listBenchmarkResults = (lmx as unknown as {\n        listBenchmarkResults: () => Promise<unknown>;\n      }).listBenchmarkResults;\n      const payload = await listBenchmarkResults.call(lmx);\n\n      if (json) {\n        console.log(renderJson(payload));\n        return 'handled';\n      }\n\n      const rows = Array.isArray(payload)\n        ? payload\n        : readArray(asObject(payload), 'results', 'rows', 'items');\n      const lines: string[] = [kv('Stored Results', String(rows.length))];\n\n      if (rows.length > 0) {\n        lines.push('');\n        for (const row of rows.slice(0, 20)) {\n          const entry = asObject(row);\n          const modelId = readString(entry, 'model_id', 'modelId') ?? '(unknown)';\n          const backend = readString(entry, 'backend', 'backend_type', 'backendType') ?? 'unknown';\n          const ts = readString(entry, 'timestamp', 'ts');\n          const statusRaw = readString(entry, 'status');\n          const status = classifyOutcome(statusRaw) === 'success'\n            ? chalk.green(statusRaw ?? 'ok')\n            : classifyOutcome(statusRaw) === 'failure'\n              ? chalk.red(statusRaw ?? 'failed')\n              : chalk.dim(statusRaw ?? 'unknown');\n          const stats = asObject(entry.stats);\n          const tokPerSec = readNumber(stats, 'toks_per_sec_mean', 'avg_tokens_per_second', 'tokens_per_second_mean')\n            ?? readNumber(entry, 'avg_tokens_per_second', 'tokens_per_second');\n          const ttftMs = readNumber(stats, 'ttft_ms_mean', 'avg_time_to_first_token_ms')\n            ?? readNumber(entry, 'avg_time_to_first_token_ms');\n          const perf = [\n            tokPerSec !== undefined ? `${tokPerSec.toFixed(1)} tok/s` : undefined,\n            ttftMs !== undefined ? `TTFT ${ttftMs.toFixed(0)}ms` : undefined,\n          ].filter(Boolean).join('  ');\n          const suffix = [chalk.dim(backend), status, perf ? chalk.dim(perf) : undefined]\n            .filter(Boolean)\n            .join('  ');\n          lines.push(`  ${chalk.cyan(modelId)} ${suffix ? ` ${suffix}` : ''}`);\n          if (ts) {\n            lines.push(chalk.dim(`    ${ts}`));\n          }\n        }\n        if (rows.length > 20) {\n          lines.push(chalk.dim(`   ${rows.length - 20} more`));\n        }\n      } else {\n        lines.push(chalk.dim('No benchmark results recorded yet.'));\n      }\n\n      console.log('\\n' + box('Benchmark Results', lines));\n    } catch (err) {\n      console.error(chalk.red('') + ` Benchmark results failed: ${errorMessage(err)}`);\n    }\n    return 'handled';\n  }\n\n  const modelId = tokens.join(' ').trim() || ctx.config.model.default;\n\n  if (!modelId) {\n    console.log(chalk.dim('  Usage: /benchmark <model-id>'));\n    console.log(chalk.dim('  No model specified and no default set'));\n    return 'handled';\n  }\n\n  const { LmxClient } = await import('../../lmx/client.js');\n  const lmx = new LmxClient({\n    host: ctx.config.connection.host,\n    fallbackHosts: ctx.config.connection.fallbackHosts,\n    port: ctx.config.connection.port,\n    adminKey: ctx.config.connection.adminKey,\n  });\n\n  console.log(chalk.dim(`  Benchmarking ${modelId} (3 runs  128 tokens)...`));\n\n  try {\n    const result = await lmx.benchmarkModel(modelId);\n    const dp = getDisplayProfile(result.modelId);\n\n    const tpsColor = result.avgTokensPerSecond >= 30\n      ? chalk.green\n      : result.avgTokensPerSecond >= 10\n      ? chalk.yellow\n      : chalk.red;\n\n    const lines: string[] = [\n      kv('Model', `${chalk.bold(dp.displayName)} ${fmtTag(dp.format)} ${chalk.dim(dp.orgAbbrev)}`),\n      kv('Backend', chalk.cyan(result.backendType)),\n      '',\n      kv('Avg tok/s', tpsColor(`${result.avgTokensPerSecond.toFixed(1)} tok/s`)),\n      kv('Avg TTFT', `${result.avgTimeToFirstTokenMs.toFixed(0)} ms`),\n      kv('Avg total', `${result.avgTotalTimeMs.toFixed(0)} ms`),\n    ];\n\n    if (result.results.length > 1) {\n      lines.push('');\n      lines.push(chalk.dim('Per-run:'));\n      for (const r of result.results) {\n        const bar = ''.repeat(Math.min(20, Math.round(r.tokensPerSecond / 3)));\n        lines.push(\n          chalk.dim(`  Run ${r.run}  ${bar.padEnd(20)}`) +\n          `  ${r.tokensPerSecond.toFixed(1)} tok/s` +\n          chalk.dim(`  TTFT ${r.timeToFirstTokenMs.toFixed(0)}ms`)\n        );\n      }\n    }\n\n    console.log('\\n' + box('Benchmark', lines));\n  } catch (err) {\n    console.error(chalk.red('') + ` Benchmark failed: ${errorMessage(err)}`);\n    console.log(chalk.dim(`  Is \"${modelId}\" loaded? Run /scan to check`));\n  }\n  return 'handled';\n};\n\nconst embedHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const tokens = parseSlashArgs(args);\n  const positional: string[] = [];\n  const unknown: string[] = [];\n  let model: string | undefined;\n  let json = false;\n\n  for (let i = 0; i < tokens.length; i += 1) {\n    const token = tokens[i]!;\n    if (!token.startsWith('--')) {\n      positional.push(token);\n      continue;\n    }\n    if (token === '--json') {\n      json = true;\n      continue;\n    }\n    if (token === '--model') {\n      const value = tokens[i + 1];\n      if (!value) {\n        console.log(chalk.dim('  Missing value for --model'));\n        console.log(chalk.dim('  Usage: /embed <text> [--model <id>] [--json]'));\n        return 'handled';\n      }\n      model = value;\n      i += 1;\n      continue;\n    }\n    unknown.push(token);\n  }\n\n  if (unknown.length > 0 || positional.length === 0) {\n    if (unknown.length > 0) {\n      console.log(chalk.yellow(`  Unknown options: ${unknown.join(', ')}`));\n    }\n    console.log(chalk.dim('  Usage: /embed <text> [--model <id>] [--json]'));\n    return 'handled';\n  }\n\n  const input = positional.join(' ').trim();\n  if (!input) {\n    console.log(chalk.dim('  Usage: /embed <text> [--model <id>] [--json]'));\n    return 'handled';\n  }\n\n  const { LmxClient } = await import('../../lmx/client.js');\n  const lmx = new LmxClient({\n    host: ctx.config.connection.host,\n    fallbackHosts: ctx.config.connection.fallbackHosts,\n    port: ctx.config.connection.port,\n    adminKey: ctx.config.connection.adminKey,\n  });\n\n  try {\n    const request: { input: string; model?: string } = { input };\n    if (model) request.model = model;\n\n    const createEmbeddings = (lmx as unknown as {\n      createEmbeddings: (payload: { input: string; model?: string }) => Promise<unknown>;\n    }).createEmbeddings;\n    const payload = await createEmbeddings.call(lmx, request);\n\n    if (json) {\n      console.log(renderJson(payload));\n      return 'handled';\n    }\n\n    const response = asObject(payload);\n    const vectors = readArray(response, 'data', 'embeddings', 'results');\n    const first = asObject(vectors[0]);\n    const embedding = Array.isArray(first.embedding) ? first.embedding : [];\n    const usage = asObject(response.usage);\n    const lines: string[] = [\n      kv('Model', readString(response, 'model') ?? model ?? chalk.dim('(default)')),\n      kv('Input Chars', String(input.length)),\n      kv('Vectors', String(vectors.length)),\n      kv('Dimensions', embedding.length > 0 ? String(embedding.length) : chalk.dim('(unknown)')),\n    ];\n\n    const promptTokens = readNumber(usage, 'prompt_tokens', 'promptTokens');\n    if (promptTokens !== undefined) {\n      lines.push(kv('Prompt Tokens', String(promptTokens)));\n    }\n\n    console.log('\\n' + box('Embeddings', lines));\n  } catch (err) {\n    console.error(chalk.red('') + ` Embedding request failed: ${errorMessage(err)}`);\n  }\n  return 'handled';\n};\n\nconst rerankHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const tokens = parseSlashArgs(args);\n  const positional: string[] = [];\n  const unknown: string[] = [];\n  let model: string | undefined;\n  let documentsRaw: string | undefined;\n  let topK: number | undefined;\n  let json = false;\n\n  for (let i = 0; i < tokens.length; i += 1) {\n    const token = tokens[i]!;\n    if (!token.startsWith('--')) {\n      positional.push(token);\n      continue;\n    }\n    if (token === '--json') {\n      json = true;\n      continue;\n    }\n    if (token === '--model') {\n      const value = tokens[i + 1];\n      if (!value) {\n        console.log(chalk.dim('  Missing value for --model'));\n        console.log(chalk.dim('  Usage: /rerank <query> --documents <doc1|doc2|...> [--model <id>] [--top-k <n>] [--json]'));\n        return 'handled';\n      }\n      model = value;\n      i += 1;\n      continue;\n    }\n    if (token === '--documents') {\n      const value = tokens[i + 1];\n      if (!value) {\n        console.log(chalk.dim('  Missing value for --documents'));\n        console.log(chalk.dim('  Usage: /rerank <query> --documents <doc1|doc2|...> [--model <id>] [--top-k <n>] [--json]'));\n        return 'handled';\n      }\n      documentsRaw = value;\n      i += 1;\n      continue;\n    }\n    if (token === '--top-k') {\n      const value = tokens[i + 1];\n      if (!value) {\n        console.log(chalk.dim('  Missing value for --top-k'));\n        console.log(chalk.dim('  Usage: /rerank <query> --documents <doc1|doc2|...> [--model <id>] [--top-k <n>] [--json]'));\n        return 'handled';\n      }\n      const parsed = Number.parseInt(value, 10);\n      if (!Number.isFinite(parsed) || parsed < 1) {\n        console.log(chalk.yellow(`  Invalid --top-k value: ${value}`));\n        console.log(chalk.dim('  Usage: /rerank <query> --documents <doc1|doc2|...> [--model <id>] [--top-k <n>] [--json]'));\n        return 'handled';\n      }\n      topK = parsed;\n      i += 1;\n      continue;\n    }\n    unknown.push(token);\n  }\n\n  if (unknown.length > 0) {\n    console.log(chalk.yellow(`  Unknown options: ${unknown.join(', ')}`));\n    console.log(chalk.dim('  Usage: /rerank <query> --documents <doc1|doc2|...> [--model <id>] [--top-k <n>] [--json]'));\n    return 'handled';\n  }\n\n  const query = positional.join(' ').trim();\n  const documents = (documentsRaw ?? '')\n    .split('|')\n    .map((doc) => doc.trim())\n    .filter((doc) => doc.length > 0);\n\n  if (!query || documents.length === 0) {\n    console.log(chalk.dim('  Usage: /rerank <query> --documents <doc1|doc2|...> [--model <id>] [--top-k <n>] [--json]'));\n    return 'handled';\n  }\n\n  const { LmxClient } = await import('../../lmx/client.js');\n  const lmx = new LmxClient({\n    host: ctx.config.connection.host,\n    fallbackHosts: ctx.config.connection.fallbackHosts,\n    port: ctx.config.connection.port,\n    adminKey: ctx.config.connection.adminKey,\n  });\n\n  try {\n    const request: {\n      query: string;\n      documents: string[];\n      model?: string;\n      topK?: number;\n    } = { query, documents };\n    if (model) request.model = model;\n    if (topK !== undefined) request.topK = topK;\n\n    const rerankDocuments = (lmx as unknown as {\n      rerankDocuments: (payload: {\n        query: string;\n        documents: string[];\n        model?: string;\n        topK?: number;\n      }) => Promise<unknown>;\n    }).rerankDocuments;\n    const payload = await rerankDocuments.call(lmx, request);\n\n    if (json) {\n      console.log(renderJson(payload));\n      return 'handled';\n    }\n\n    const response = asObject(payload);\n    const results = readArray(response, 'results', 'data', 'items');\n    const usage = asObject(response.usage);\n    const lines: string[] = [\n      kv('Model', readString(response, 'model') ?? model ?? chalk.dim('(default)')),\n      kv('Documents', String(documents.length)),\n      kv('Matches', String(results.length)),\n      kv('Top K', topK === undefined ? chalk.dim('(default)') : String(topK)),\n    ];\n\n    const totalTokens = readNumber(usage, 'total_tokens', 'totalTokens');\n    if (totalTokens !== undefined) {\n      lines.push(kv('Total Tokens', String(totalTokens)));\n    }\n\n    if (results.length > 0) {\n      lines.push('');\n      lines.push(chalk.dim('Top matches:'));\n      for (const raw of results.slice(0, 10)) {\n        const row = asObject(raw);\n        const idx = readNumber(row, 'index');\n        const score = readNumber(row, 'relevance_score', 'relevanceScore', 'score');\n        const doc = asObject(row.document);\n        const text = readString(doc, 'text') ?? (idx !== undefined ? documents[idx] : undefined) ?? '';\n        const preview = text.length > 80 ? `${text.slice(0, 77)}...` : text;\n        const scoreLabel = score === undefined ? 'n/a' : score.toFixed(4);\n        lines.push(`  [${idx ?? '?'}] ${scoreLabel} ${chalk.dim(preview)}`);\n      }\n    }\n\n    console.log('\\n' + box('Rerank Results', lines));\n  } catch (err) {\n    console.error(chalk.red('') + ` Rerank request failed: ${errorMessage(err)}`);\n  }\n  return 'handled';\n};\n\nconst predictorHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const tokens = parseSlashArgs(args);\n  const json = tokens.includes('--json');\n  const unknown = tokens.filter((token) => token.startsWith('--') && token !== '--json');\n  if (unknown.length > 0) {\n    console.log(chalk.yellow(`  Unknown options: ${unknown.join(', ')}`));\n    console.log(chalk.dim('  Usage: /predictor [--json]'));\n    return 'handled';\n  }\n\n  const { LmxClient } = await import('../../lmx/client.js');\n  const lmx = new LmxClient({\n    host: ctx.config.connection.host,\n    fallbackHosts: ctx.config.connection.fallbackHosts,\n    port: ctx.config.connection.port,\n    adminKey: ctx.config.connection.adminKey,\n  });\n\n  try {\n    const stats = asObject(await lmx.predictorStats(FAST_SLASH_REQUEST_OPTS));\n    if (json) {\n      console.log(renderJson(stats));\n      return 'handled';\n    }\n\n    const predictedNext = readString(stats, 'predicted_next', 'predictedNext');\n    const lines: string[] = [\n      kv('Predicted Next', predictedNext ?? chalk.dim('(none)')),\n    ];\n    for (const [key, value] of Object.entries(stats)) {\n      if (key === 'predicted_next' || key === 'predictedNext') continue;\n      if (typeof value === 'number' || typeof value === 'string' || typeof value === 'boolean') {\n        const label = key.replace(/_/g, ' ').replace(/\\b\\w/g, (c) => c.toUpperCase());\n        lines.push(kv(label, String(value)));\n      }\n    }\n\n    console.log('\\n' + box('Predictor Stats', lines));\n  } catch (err) {\n    console.error(chalk.red('') + ` Predictor stats failed: ${errorMessage(err)}`);\n  }\n  return 'handled';\n};\n\nconst helpersHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const tokens = parseSlashArgs(args);\n  const json = tokens.includes('--json');\n  const unknown = tokens.filter((token) => token.startsWith('--') && token !== '--json');\n  if (unknown.length > 0) {\n    console.log(chalk.yellow(`  Unknown options: ${unknown.join(', ')}`));\n    console.log(chalk.dim('  Usage: /helpers [--json]'));\n    return 'handled';\n  }\n\n  const { LmxClient } = await import('../../lmx/client.js');\n  const lmx = new LmxClient({\n    host: ctx.config.connection.host,\n    fallbackHosts: ctx.config.connection.fallbackHosts,\n    port: ctx.config.connection.port,\n    adminKey: ctx.config.connection.adminKey,\n  });\n\n  try {\n    const payload = asObject(await lmx.helpersHealth(FAST_SLASH_REQUEST_OPTS));\n    if (json) {\n      console.log(renderJson(payload));\n      return 'handled';\n    }\n\n    const helpers = asObject(payload.helpers);\n    const liveChecks = asObject(payload.live_checks ?? payload.liveChecks);\n    const configuredCount = readNumber(payload, 'configured_count', 'configuredCount') ?? Object.keys(helpers).length;\n    const allHealthy = readBoolean(payload, 'all_healthy', 'allHealthy');\n    const lines: string[] = [\n      kv('Configured', String(configuredCount)),\n      kv('All Healthy', String(allHealthy ?? false)),\n    ];\n\n    if (Object.keys(helpers).length > 0) {\n      lines.push('');\n      lines.push(chalk.dim('Nodes:'));\n      for (const [name, rawStats] of Object.entries(helpers)) {\n        const stats = asObject(rawStats);\n        const healthy = readBoolean(stats, 'healthy');\n        const latencyMs = readNumber(stats, 'avg_latency_ms', 'latency_ms', 'latencyMs');\n        const successRate = readNumber(stats, 'success_rate', 'successRate');\n        const live = readBoolean(liveChecks, name);\n        const healthBadge = healthy ? chalk.green('healthy') : chalk.red('unhealthy');\n        const meta = [\n          latencyMs !== undefined ? `${latencyMs.toFixed(0)}ms` : undefined,\n          successRate !== undefined ? `${(successRate * 100).toFixed(1)}% ok` : undefined,\n          live !== undefined ? `live:${live ? 'pass' : 'fail'}` : undefined,\n        ].filter(Boolean).join('  ');\n        lines.push(`  ${name.padEnd(10)} ${healthBadge}${meta ? chalk.dim(`  ${meta}`) : ''}`);\n      }\n    }\n\n    console.log('\\n' + box('Helper Nodes', lines));\n  } catch (err) {\n    console.error(chalk.red('') + ` Helper health failed: ${errorMessage(err)}`);\n  }\n  return 'handled';\n};\n\nconst quantizeHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const tokens = parseSlashArgs(args);\n  const actionToken = tokens[0]?.toLowerCase();\n  const action = actionToken && !actionToken.startsWith('--') ? actionToken : 'list';\n  const startAt = actionToken === action ? 1 : 0;\n\n  const { LmxClient } = await import('../../lmx/client.js');\n  const lmx = new LmxClient({\n    host: ctx.config.connection.host,\n    fallbackHosts: ctx.config.connection.fallbackHosts,\n    port: ctx.config.connection.port,\n    adminKey: ctx.config.connection.adminKey,\n  });\n\n  if (action === 'list') {\n    try {\n      const result = await lmx.quantizeJobs(FAST_SLASH_REQUEST_OPTS);\n      const lines: string[] = [kv('Jobs', String(result.count))];\n      if (result.jobs.length === 0) {\n        lines.push(chalk.dim('No quantization jobs found.'));\n      } else {\n        lines.push('');\n        for (const job of result.jobs.slice(0, 20)) {\n          const id = job.job_id ?? 'unknown';\n          const status = (job.status ?? 'unknown').toLowerCase();\n          const statusText = status === 'completed'\n            ? chalk.green(status)\n            : status === 'failed'\n              ? chalk.red(status)\n              : chalk.yellow(status);\n          const source = job.source_model ?? 'unknown-model';\n          lines.push(`  ${id}  ${statusText}  ${chalk.dim(source)}`);\n        }\n      }\n      console.log('\\n' + box('Quantize Jobs', lines));\n    } catch (err) {\n      console.error(chalk.red('') + ` Quantize jobs query failed: ${errorMessage(err)}`);\n    }\n    return 'handled';\n  }\n\n  if (action === 'status') {\n    const jobId = tokens[startAt];\n    if (!jobId || jobId.startsWith('--')) {\n      console.log(chalk.dim('  Usage: /quantize status <job-id>'));\n      return 'handled';\n    }\n    try {\n      const job = asObject(await lmx.quantizeStatus(jobId, FAST_SLASH_REQUEST_OPTS));\n      const lines: string[] = [\n        kv('Job ID', readString(job, 'job_id') ?? jobId),\n        kv('Status', readString(job, 'status') ?? 'unknown'),\n        kv('Model', readString(job, 'source_model') ?? chalk.dim('(unknown)')),\n        kv('Bits', String(readNumber(job, 'bits') ?? 'n/a')),\n      ];\n      const error = readString(job, 'error');\n      if (error) lines.push(kv('Error', chalk.red(error)));\n      const duration = readNumber(job, 'duration_sec');\n      if (duration !== undefined) lines.push(kv('Duration', `${duration.toFixed(1)}s`));\n      const outputPath = readString(job, 'output_path');\n      if (outputPath) lines.push(kv('Output', outputPath));\n      console.log('\\n' + box('Quantize Status', lines));\n    } catch (err) {\n      console.error(chalk.red('') + ` Quantize status failed: ${errorMessage(err)}`);\n    }\n    return 'handled';\n  }\n\n  if (action === 'start') {\n    const sourceModel = tokens[startAt];\n    if (!sourceModel || sourceModel.startsWith('--')) {\n      console.log(chalk.dim('  Usage: /quantize start <model-id> [--bits 4|8] [--group-size <n>] [--mode affine|symmetric] [--output <path>]'));\n      return 'handled';\n    }\n    const request: {\n      sourceModel: string;\n      bits?: 4 | 8;\n      groupSize?: number;\n      mode?: 'affine' | 'symmetric';\n      outputPath?: string;\n    } = { sourceModel };\n    const unknown: string[] = [];\n    for (let i = startAt + 1; i < tokens.length; i += 1) {\n      const token = tokens[i]!;\n      if (!token.startsWith('--')) {\n        unknown.push(token);\n        continue;\n      }\n      if (token === '--bits') {\n        const value = tokens[i + 1];\n        if (!value) {\n          console.log(chalk.dim('  Missing value for --bits'));\n          return 'handled';\n        }\n        i += 1;\n        if (value !== '4' && value !== '8') {\n          console.log(chalk.yellow(`  Invalid --bits value: ${value}`));\n          return 'handled';\n        }\n        request.bits = Number.parseInt(value, 10) as 4 | 8;\n        continue;\n      }\n      if (token === '--group-size') {\n        const value = tokens[i + 1];\n        if (!value) {\n          console.log(chalk.dim('  Missing value for --group-size'));\n          return 'handled';\n        }\n        i += 1;\n        const parsed = Number.parseInt(value, 10);\n        if (!Number.isFinite(parsed) || parsed < 1) {\n          console.log(chalk.yellow(`  Invalid --group-size value: ${value}`));\n          return 'handled';\n        }\n        request.groupSize = parsed;\n        continue;\n      }\n      if (token === '--mode') {\n        const value = tokens[i + 1];\n        if (!value) {\n          console.log(chalk.dim('  Missing value for --mode'));\n          return 'handled';\n        }\n        i += 1;\n        if (value !== 'affine' && value !== 'symmetric') {\n          console.log(chalk.yellow(`  Invalid --mode value: ${value}`));\n          return 'handled';\n        }\n        request.mode = value;\n        continue;\n      }\n      if (token === '--output') {\n        const value = tokens[i + 1];\n        if (!value) {\n          console.log(chalk.dim('  Missing value for --output'));\n          return 'handled';\n        }\n        i += 1;\n        request.outputPath = value;\n        continue;\n      }\n      unknown.push(token);\n    }\n    if (unknown.length > 0) {\n      console.log(chalk.yellow(`  Unknown arguments: ${unknown.join(', ')}`));\n      console.log(chalk.dim('  Usage: /quantize start <model-id> [--bits 4|8] [--group-size <n>] [--mode affine|symmetric] [--output <path>]'));\n      return 'handled';\n    }\n    try {\n      const started = await lmx.quantizeStart(request, {\n        timeoutMs: 60_000,\n        maxRetries: 0,\n      });\n      const lines = [\n        kv('Job ID', started.job_id),\n        kv('Model', started.source_model),\n        kv('Bits', String(started.bits)),\n        kv('Mode', started.mode),\n        kv('Status', started.status),\n      ];\n      console.log('\\n' + box('Quantize Started', lines));\n      console.log(chalk.dim(`  Track progress: /quantize status ${started.job_id}`));\n    } catch (err) {\n      console.error(chalk.red('') + ` Quantize start failed: ${errorMessage(err)}`);\n    }\n    return 'handled';\n  }\n\n  console.log(chalk.dim('  Usage: /quantize [list|status <job-id>|start <model-id> [--bits 4|8] [--group-size <n>] [--mode affine|symmetric] [--output <path>]]'));\n  return 'handled';\n};\n\nconst lmxStatusHandler = async (_args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const { LmxClient } = await import('../../lmx/client.js');\n  const { host, port } = ctx.config.connection;\n  const lmx = new LmxClient({\n    host,\n    fallbackHosts: ctx.config.connection.fallbackHosts,\n    port,\n    adminKey: ctx.config.connection.adminKey,\n  });\n\n  const [healthResult, statusResult] = await Promise.all([\n    lmx.health(FAST_SLASH_REQUEST_OPTS).catch(() => null),\n    lmx.status(FAST_SLASH_REQUEST_OPTS).catch(() => null),\n  ]);\n\n  const activeHost = lmx.getActiveHost();\n  const isFallback = activeHost !== host;\n\n  if (!healthResult || !statusResult) {\n    console.log(chalk.red('\\u2717') + ` LMX unreachable at ${host}:${port}`);\n    return 'handled';\n  }\n\n  const lines: string[] = [];\n\n  if (statusResult.version) {\n    lines.push(kv('Version', statusResult.version));\n  }\n\n  if (statusResult.uptime_seconds != null) {\n    const mins = Math.floor(statusResult.uptime_seconds / 60);\n    const uptime = mins < 60 ? `${mins}m` : `${Math.floor(mins / 60)}h ${mins % 60}m`;\n    lines.push(kv('Uptime', uptime));\n  }\n\n  if (statusResult.memory) {\n    const usedGB = (statusResult.memory.used_bytes / 1e9).toFixed(1);\n    const totalGB = (statusResult.memory.total_bytes / 1e9).toFixed(1);\n    const ratio = statusResult.memory.used_bytes / statusResult.memory.total_bytes;\n    lines.push(kv('Memory', `${usedGB}/${totalGB} GB ${progressBar(ratio, 12)}`));\n  }\n\n  const hostLabel = isFallback\n    ? `${activeHost}:${port} ${chalk.cyan('(fallback)')}`\n    : `${activeHost}:${port}`;\n  lines.push(kv('Host', hostLabel));\n\n  if (statusResult.models.length > 0) {\n    lines.push('');\n    lines.push(chalk.bold(`Loaded Models`) + chalk.dim(` \\u2500 ${statusResult.models.length}`));\n    for (const m of statusResult.models) {\n      const ctxK = m.context_length != null ? `${Math.round(m.context_length / 1024)}K` : '';\n      const memGB = m.memory_bytes != null ? `${(m.memory_bytes / 1e9).toFixed(1)}GB` : '';\n      const parts = [ctxK, memGB].filter(Boolean).join('  ');\n      lines.push(`  ${chalk.green('\\u25cf')} ${m.model_id}  ${chalk.dim(parts)}`);\n    }\n  } else {\n    lines.push(kv('Models', chalk.dim('(none loaded)')));\n  }\n\n  console.log('\\n' + box('LMX Status', lines));\n  return 'handled';\n};\n\nconst lmxReconnectHandler = async (_args: string, ctx: SlashContext): Promise<SlashResult> => {\n  console.log(chalk.dim('  Reconnecting to LMX...'));\n\n  try {\n    const { resetClientCache } = await import('../../core/agent-setup.js');\n    await resetClientCache();\n\n    const { probeProvider } = await import('../../providers/manager.js');\n    const provider = await probeProvider(ctx.config);\n\n    const providerName: string = (provider as unknown as { name?: string }).name ?? 'unknown';\n    const model = ctx.config.model.default ?? '';\n    const display = model ? `${model} via ${providerName}` : providerName;\n\n    if (model) {\n      ctx.session.model = model;\n    }\n\n    console.log(chalk.green('\\u2713') + ` Connected to ${display}`);\n    return 'model-switched';\n  } catch (err) {\n    const { config } = ctx;\n    const hasAnthropicFallback = !!(\n      config.provider?.anthropic?.apiKey || process.env['ANTHROPIC_API_KEY']\n    );\n\n    console.log(chalk.red('\\u2717') + ' LMX unreachable');\n\n    if (hasAnthropicFallback) {\n      console.log(chalk.dim('  Anthropic fallback is configured'));\n    }\n\n    console.log(chalk.dim(`  ${errorMessage(err)}`));\n    return 'handled';\n  }\n};\n\nconst lmxCommandHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const tokens = parseSlashArgs(args);\n  const action = tokens[0]?.toLowerCase();\n\n  if (action === 'status') {\n    const remainingArgs = tokens.slice(1).join(' ');\n    return lmxStatusHandler(remainingArgs, ctx);\n  }\n\n  if (action === 'reconnect') {\n    const remainingArgs = tokens.slice(1).join(' ');\n    return lmxReconnectHandler(remainingArgs, ctx);\n  }\n\n  // Delegate all other actions (start, stop, restart, reload, logs) to serveHandler\n  return serveHandler(args, ctx);\n};\n\nconst runModelsProxyAction = async (\n  action: string,\n  args: string,\n  _ctx: SlashContext,\n): Promise<void> => {\n  const tokens = parseSlashArgs(args);\n  const json = tokens.includes('--json');\n  const forwarded = tokens.filter((token) => token !== '--json').join(' ').trim() || undefined;\n  const { models } = await import('../models.js');\n  await models(action, forwarded, undefined, { json });\n};\n\nconst agentsHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  try {\n    await runModelsProxyAction('agents', args, ctx);\n  } catch (err) {\n    console.error(chalk.red('') + ` agents command failed: ${errorMessage(err)}`);\n  }\n  return 'handled';\n};\n\nconst skillsHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  try {\n    await runModelsProxyAction('skills', args, ctx);\n  } catch (err) {\n    console.error(chalk.red('') + ` skills command failed: ${errorMessage(err)}`);\n  }\n  return 'handled';\n};\n\nconst ragHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  try {\n    await runModelsProxyAction('rag', args, ctx);\n  } catch (err) {\n    console.error(chalk.red('') + ` rag command failed: ${errorMessage(err)}`);\n  }\n  return 'handled';\n};\n\nconst presetHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const name = args.trim();\n  if (!name) {\n    console.log(chalk.dim('  Usage: /preset <name>'));\n    return 'handled';\n  }\n\n  const { LmxClient } = await import('../../lmx/client.js');\n  const lmx = new LmxClient({\n    host: ctx.config.connection.host,\n    fallbackHosts: ctx.config.connection.fallbackHosts,\n    port: ctx.config.connection.port,\n    adminKey: ctx.config.connection.adminKey,\n  });\n\n  try {\n    const preset = asObject(await lmx.presetDetail(name, FAST_SLASH_REQUEST_OPTS));\n    const presetName = readString(preset, 'name') ?? name;\n    const presetModel = readString(preset, 'model') ?? chalk.dim('(unknown)');\n    const presetAlias = readString(preset, 'routing_alias', 'routingAlias');\n    const presetAutoLoad = readBoolean(preset, 'auto_load', 'autoLoad');\n    const presetDescription = readString(preset, 'description');\n    const defaultPromptProfile = readString(preset, 'default_prompt_profile', 'defaultPromptProfile');\n    const performance = asObject(preset.performance);\n    const parameters = asObject(preset.parameters);\n    const promptProfiles = asObject(preset.prompt_profiles ?? preset.promptProfiles);\n\n    const lines: string[] = [\n      kv('Name', presetName),\n      kv('Model', presetModel),\n      kv('Alias', presetAlias ?? chalk.dim('(none)')),\n      kv('Auto-load', String(presetAutoLoad ?? false)),\n      kv('Description', presetDescription ?? chalk.dim('(none)')),\n      kv('Default Prompt Profile', defaultPromptProfile ?? chalk.dim('(none)')),\n    ];\n\n    if (Object.keys(performance).length > 0) {\n      lines.push('');\n      lines.push(chalk.dim('Performance:'));\n      lines.push(chalk.dim(renderJson(performance)));\n    }\n    if (Object.keys(parameters).length > 0) {\n      lines.push('');\n      lines.push(chalk.dim('Parameters:'));\n      lines.push(chalk.dim(renderJson(parameters)));\n    }\n    if (Object.keys(promptProfiles).length > 0) {\n      lines.push('');\n      lines.push(chalk.dim('Prompt Profiles:'));\n      lines.push(chalk.dim(renderJson(promptProfiles)));\n    }\n\n    console.log('\\n' + box(`Preset ${presetName}`, lines));\n  } catch (err) {\n    console.error(chalk.red('') + ` Failed to fetch preset: ${errorMessage(err)}`);\n  }\n  return 'handled';\n};\n\nconst presetsHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const tokens = parseSlashArgs(args);\n  const action = (tokens[0] ?? 'list').toLowerCase();\n\n  const { LmxClient } = await import('../../lmx/client.js');\n  const lmx = new LmxClient({\n    host: ctx.config.connection.host,\n    fallbackHosts: ctx.config.connection.fallbackHosts,\n    port: ctx.config.connection.port,\n    adminKey: ctx.config.connection.adminKey,\n  });\n\n  if (action === 'reload') {\n    try {\n      const result = asObject(await lmx.reloadPresets(FAST_SLASH_REQUEST_OPTS));\n      const loaded = readNumber(result, 'presets_loaded', 'presetsLoaded', 'count');\n      const suffix = loaded === undefined ? '' : ` (${loaded} loaded)`;\n      console.log(chalk.green('') + ` Presets reloaded${suffix}`);\n    } catch (err) {\n      console.error(chalk.red('') + ` Preset reload failed: ${errorMessage(err)}`);\n    }\n    return 'handled';\n  }\n\n  if (tokens.length === 1 && action !== 'list') {\n    return presetHandler(action, ctx);\n  }\n\n  if (tokens.length > 1) {\n    console.log(chalk.dim('  Usage: /presets [list|reload|<preset-name>]'));\n    return 'handled';\n  }\n\n  try {\n    const presets = await lmx.presets(FAST_SLASH_REQUEST_OPTS);\n    const lines: string[] = [\n      kv('Count', String(presets.count)),\n    ];\n    if (presets.presets.length === 0) {\n      lines.push(chalk.dim('No presets loaded.'));\n    } else {\n      lines.push('');\n      for (const preset of presets.presets) {\n        const alias = preset.routing_alias ? chalk.cyan(`alias:${preset.routing_alias}`) : '';\n        const auto = preset.auto_load ? chalk.dim('auto-load') : '';\n        lines.push(\n          `  ${chalk.magenta('')} ${chalk.bold(preset.name.padEnd(20))}  ${chalk.dim(preset.model)} ${alias} ${auto}`.trimEnd(),\n        );\n      }\n    }\n    lines.push('');\n    lines.push(chalk.dim('Tip: /preset <name> for full details  /presets reload to re-read from disk.'));\n\n    console.log('\\n' + box('LMX Presets', lines));\n  } catch (err) {\n    console.error(chalk.red('') + ` Failed to list presets: ${errorMessage(err)}`);\n  }\n  return 'handled';\n};\n\nconst probeHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const tokens = parseSlashArgs(args);\n  const modelId = tokens.find((token) => !token.startsWith('--'));\n  if (!modelId) {\n    console.log(chalk.dim('  Usage: /probe <model-id> [--timeout <sec>] [--allow-unsupported]'));\n    return 'handled';\n  }\n\n  let timeoutSec: number | undefined;\n  let allowUnsupportedRuntime = false;\n  const unknown: string[] = [];\n\n  for (let i = 0; i < tokens.length; i += 1) {\n    const token = tokens[i]!;\n    if (!token.startsWith('--')) continue;\n    if (token === '--allow-unsupported') {\n      allowUnsupportedRuntime = true;\n      continue;\n    }\n    if (token === '--timeout') {\n      const value = tokens[i + 1];\n      if (!value) {\n        console.log(chalk.dim('  Missing value for --timeout'));\n        return 'handled';\n      }\n      i += 1;\n      const parsed = Number.parseFloat(value);\n      if (!Number.isFinite(parsed) || parsed < 1 || parsed > 900) {\n        console.log(chalk.yellow(`  Invalid --timeout value: ${value} (expected 1..900)`));\n        return 'handled';\n      }\n      timeoutSec = parsed;\n      continue;\n    }\n    unknown.push(token);\n  }\n\n  if (unknown.length > 0) {\n    console.log(chalk.yellow(`  Unknown options: ${unknown.join(', ')}`));\n    console.log(chalk.dim('  Usage: /probe <model-id> [--timeout <sec>] [--allow-unsupported]'));\n    return 'handled';\n  }\n\n  const { LmxClient } = await import('../../lmx/client.js');\n  const lmx = new LmxClient({\n    host: ctx.config.connection.host,\n    fallbackHosts: ctx.config.connection.fallbackHosts,\n    port: ctx.config.connection.port,\n    adminKey: ctx.config.connection.adminKey,\n  });\n\n  try {\n    const result = asObject(await lmx.probeModel(\n      {\n        modelId,\n        timeoutSec,\n        allowUnsupportedRuntime,\n      },\n      { timeoutMs: Math.round((timeoutSec ?? 90) * 1000), maxRetries: 0 },\n    ));\n    const recommendedBackend = readString(result, 'recommendedBackend', 'recommended_backend');\n    const candidates = readArray(result, 'candidates').map((entry) => asObject(entry));\n    const lines: string[] = [\n      kv('Model', readString(result, 'modelId', 'model_id') ?? modelId),\n      kv('Recommended', recommendedBackend ?? chalk.dim('(none)')),\n      kv('Candidates', String(candidates.length)),\n    ];\n    if (candidates.length > 0) {\n      lines.push('');\n      for (const candidate of candidates) {\n        const backend = readString(candidate, 'backend') ?? 'unknown';\n        const outcomeRaw = readString(candidate, 'outcome') ?? 'unknown';\n        const reason = readString(candidate, 'reason', 'detail', 'message');\n        const classed = classifyOutcome(outcomeRaw);\n        const color = classed === 'success'\n          ? chalk.green\n          : classed === 'failure'\n            ? chalk.red\n            : chalk.yellow;\n        lines.push(`  ${color(backend.padEnd(12))} ${outcomeRaw}${reason ? chalk.dim(`  ${reason}`) : ''}`);\n      }\n    }\n    console.log('\\n' + box('Model Probe', lines));\n  } catch (err) {\n    console.error(chalk.red('') + ` Probe failed: ${errorMessage(err)}`);\n  }\n  return 'handled';\n};\n\nconst compatibilityHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const tokens = parseSlashArgs(args);\n  const options: {\n    modelId?: string;\n    backend?: string;\n    outcome?: string;\n    sinceTs?: number;\n    limit?: number;\n    includeSummary?: boolean;\n  } = {};\n  const unknown: string[] = [];\n\n  for (let i = 0; i < tokens.length; i += 1) {\n    const token = tokens[i]!;\n    if (!token.startsWith('--')) {\n      unknown.push(token);\n      continue;\n    }\n    if (token === '--summary') {\n      options.includeSummary = true;\n      continue;\n    }\n    if (token === '--model') {\n      const value = tokens[i + 1];\n      if (!value) {\n        console.log(chalk.dim('  Missing value for --model'));\n        return 'handled';\n      }\n      i += 1;\n      options.modelId = value;\n      continue;\n    }\n    if (token === '--backend') {\n      const value = tokens[i + 1];\n      if (!value) {\n        console.log(chalk.dim('  Missing value for --backend'));\n        return 'handled';\n      }\n      i += 1;\n      options.backend = value;\n      continue;\n    }\n    if (token === '--outcome') {\n      const value = tokens[i + 1];\n      if (!value) {\n        console.log(chalk.dim('  Missing value for --outcome'));\n        return 'handled';\n      }\n      i += 1;\n      options.outcome = value;\n      continue;\n    }\n    if (token === '--since') {\n      const value = tokens[i + 1];\n      if (!value) {\n        console.log(chalk.dim('  Missing value for --since'));\n        return 'handled';\n      }\n      i += 1;\n      const parsed = Number.parseFloat(value);\n      if (!Number.isFinite(parsed)) {\n        console.log(chalk.yellow(`  Invalid --since value: ${value}`));\n        return 'handled';\n      }\n      options.sinceTs = parsed;\n      continue;\n    }\n    if (token === '--limit') {\n      const value = tokens[i + 1];\n      if (!value) {\n        console.log(chalk.dim('  Missing value for --limit'));\n        return 'handled';\n      }\n      i += 1;\n      const parsed = Number.parseInt(value, 10);\n      if (!Number.isFinite(parsed) || parsed < 1 || parsed > 2000) {\n        console.log(chalk.yellow(`  Invalid --limit value: ${value} (expected 1..2000)`));\n        return 'handled';\n      }\n      options.limit = parsed;\n      continue;\n    }\n    unknown.push(token);\n  }\n\n  if (unknown.length > 0) {\n    console.log(chalk.yellow(`  Unknown arguments: ${unknown.join(', ')}`));\n    console.log(chalk.dim('  Usage: /compatibility [--model <id>] [--backend <name>] [--outcome <value>] [--since <ts>] [--limit <n>] [--summary]'));\n    return 'handled';\n  }\n\n  const { LmxClient } = await import('../../lmx/client.js');\n  const lmx = new LmxClient({\n    host: ctx.config.connection.host,\n    fallbackHosts: ctx.config.connection.fallbackHosts,\n    port: ctx.config.connection.port,\n    adminKey: ctx.config.connection.adminKey,\n  });\n\n  try {\n    const result = asObject(await lmx.modelCompatibility(options, FAST_SLASH_REQUEST_OPTS));\n    const rows = readArray(result, 'rows', 'items').map((entry) => asObject(entry));\n    const summary = asObject(result.summary);\n    const totalRows = readNumber(result, 'total', 'count') ?? rows.length;\n\n    const lines: string[] = [\n      kv('Rows', String(totalRows)),\n    ];\n    if (Object.keys(summary).length > 0) {\n      lines.push('');\n      lines.push(chalk.dim('Summary by model:'));\n      lines.push(chalk.dim(renderJson(summary)));\n    }\n    if (rows.length > 0) {\n      lines.push('');\n      lines.push(chalk.dim('Latest rows:'));\n      const slice = rows.slice(0, 20);\n      for (const row of slice) {\n        const outcomeRaw = readString(row, 'outcome') ?? 'unknown';\n        const backendName = readString(row, 'backend') ?? 'unknown';\n        const modelName = readString(row, 'modelId', 'model_id', 'model') ?? 'unknown';\n        const tsRaw = readNumber(row, 'ts', 'timestamp');\n        const tsSeconds = tsRaw === undefined ? undefined : tsRaw > 1e11 ? tsRaw / 1000 : tsRaw;\n        const tsLabel = tsSeconds === undefined ? 'unknown-time' : new Date(tsSeconds * 1000).toISOString();\n        const classed = classifyOutcome(outcomeRaw);\n        const outcome = classed === 'success'\n          ? chalk.green(outcomeRaw)\n          : classed === 'failure'\n            ? chalk.red(outcomeRaw)\n            : chalk.yellow(outcomeRaw);\n        lines.push(`  ${tsLabel}  ${backendName.padEnd(10)}  ${outcome}  ${chalk.dim(modelName)}`);\n      }\n    }\n    console.log('\\n' + box('Model Compatibility', lines));\n  } catch (err) {\n    console.error(chalk.red('') + ` Compatibility query failed: ${errorMessage(err)}`);\n  }\n  return 'handled';\n};\n\nconst autotuneHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const tokens = parseSlashArgs(args);\n  const modelId = tokens.find((token) => !token.startsWith('--'));\n  if (!modelId) {\n    console.log(chalk.dim('  Usage: /autotune <model-id> [--prompt \\\"...\\\"] [--max-tokens <n>] [--temperature <n>] [--runs <n>] [--profiles-json <json>] [--allow-unsupported]'));\n    return 'handled';\n  }\n\n  const payload: {\n    modelId: string;\n    prompt?: string;\n    maxTokens?: number;\n    temperature?: number;\n    runs?: number;\n    profiles?: Array<Record<string, unknown>>;\n    allowUnsupportedRuntime?: boolean;\n  } = { modelId };\n  const unknown: string[] = [];\n\n  for (let i = 0; i < tokens.length; i += 1) {\n    const token = tokens[i]!;\n    if (!token.startsWith('--')) continue;\n    if (token === '--allow-unsupported') {\n      payload.allowUnsupportedRuntime = true;\n      continue;\n    }\n    if (token === '--prompt') {\n      const value = tokens[i + 1];\n      if (!value) {\n        console.log(chalk.dim('  Missing value for --prompt'));\n        return 'handled';\n      }\n      i += 1;\n      payload.prompt = value;\n      continue;\n    }\n    if (token === '--max-tokens') {\n      const value = tokens[i + 1];\n      if (!value) {\n        console.log(chalk.dim('  Missing value for --max-tokens'));\n        return 'handled';\n      }\n      i += 1;\n      const parsed = Number.parseInt(value, 10);\n      if (!Number.isFinite(parsed) || parsed < 1 || parsed > 4096) {\n        console.log(chalk.yellow(`  Invalid --max-tokens value: ${value}`));\n        return 'handled';\n      }\n      payload.maxTokens = parsed;\n      continue;\n    }\n    if (token === '--temperature') {\n      const value = tokens[i + 1];\n      if (!value) {\n        console.log(chalk.dim('  Missing value for --temperature'));\n        return 'handled';\n      }\n      i += 1;\n      const parsed = Number.parseFloat(value);\n      if (!Number.isFinite(parsed) || parsed < 0 || parsed > 2) {\n        console.log(chalk.yellow(`  Invalid --temperature value: ${value}`));\n        return 'handled';\n      }\n      payload.temperature = parsed;\n      continue;\n    }\n    if (token === '--runs') {\n      const value = tokens[i + 1];\n      if (!value) {\n        console.log(chalk.dim('  Missing value for --runs'));\n        return 'handled';\n      }\n      i += 1;\n      const parsed = Number.parseInt(value, 10);\n      if (!Number.isFinite(parsed) || parsed < 1 || parsed > 5) {\n        console.log(chalk.yellow(`  Invalid --runs value: ${value}`));\n        return 'handled';\n      }\n      payload.runs = parsed;\n      continue;\n    }\n    if (token === '--profiles-json') {\n      const value = tokens[i + 1];\n      if (!value) {\n        console.log(chalk.dim('  Missing value for --profiles-json'));\n        return 'handled';\n      }\n      i += 1;\n      try {\n        const parsed = JSON.parse(value) as unknown;\n        if (!Array.isArray(parsed)) {\n          console.log(chalk.yellow('  --profiles-json must be a JSON array'));\n          return 'handled';\n        }\n        const profiles = parsed.filter((entry) => entry && typeof entry === 'object' && !Array.isArray(entry)) as Array<Record<string, unknown>>;\n        payload.profiles = profiles;\n      } catch (err) {\n        console.log(chalk.yellow(`  Invalid --profiles-json: ${errorMessage(err)}`));\n        return 'handled';\n      }\n      continue;\n    }\n    unknown.push(token);\n  }\n\n  if (unknown.length > 0) {\n    console.log(chalk.yellow(`  Unknown options: ${unknown.join(', ')}`));\n    console.log(chalk.dim('  Usage: /autotune <model-id> [--prompt \\\"...\\\"] [--max-tokens <n>] [--temperature <n>] [--runs <n>] [--profiles-json <json>] [--allow-unsupported]'));\n    return 'handled';\n  }\n\n  const { LmxClient } = await import('../../lmx/client.js');\n  const lmx = new LmxClient({\n    host: ctx.config.connection.host,\n    fallbackHosts: ctx.config.connection.fallbackHosts,\n    port: ctx.config.connection.port,\n    adminKey: ctx.config.connection.adminKey,\n  });\n\n  console.log(chalk.dim(`  Running autotune for ${modelId}...`));\n\n  try {\n    const result = asObject(await lmx.autotuneModel(payload, { timeoutMs: 180_000, maxRetries: 0 }));\n    const candidates = readArray(result, 'candidates');\n    const bestProfile = asObject(result.bestProfile ?? result.best_profile);\n    const bestMetrics = asObject(result.bestMetrics ?? result.best_metrics);\n    const effectiveBestProfile = Object.keys(bestProfile).length > 0\n      ? bestProfile\n      : asObject(asObject(candidates[0]).profile);\n    const effectiveBestMetrics = Object.keys(bestMetrics).length > 0\n      ? bestMetrics\n      : asObject(asObject(candidates[0]).metrics);\n    const bestScore = readNumber(result, 'bestScore', 'best_score', 'score');\n\n    const lines: string[] = [\n      kv('Model', readString(result, 'modelId', 'model_id') ?? modelId),\n      kv('Backend', readString(result, 'backend') ?? chalk.dim('(unknown)')),\n      kv('Backend Version', readString(result, 'backendVersion', 'backend_version') ?? chalk.dim('(unknown)')),\n      kv('Best Score', bestScore === undefined ? chalk.dim('(unknown)') : bestScore.toFixed(4)),\n      kv('Candidates', String(candidates.length)),\n      '',\n      chalk.dim('Best Profile:'),\n      chalk.dim(renderJson(effectiveBestProfile)),\n      '',\n      chalk.dim('Best Metrics:'),\n      chalk.dim(renderJson(effectiveBestMetrics)),\n    ];\n    console.log('\\n' + box('Autotune Result', lines));\n  } catch (err) {\n    console.error(chalk.red('') + ` Autotune failed: ${errorMessage(err)}`);\n  }\n  return 'handled';\n};\n\nconst autotuneStatusHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const tokens = parseSlashArgs(args);\n  const modelId = tokens.find((token) => !token.startsWith('--'));\n  if (!modelId) {\n    console.log(chalk.dim('  Usage: /autotune-status <model-id> [--backend <name>] [--backend-version <version>]'));\n    return 'handled';\n  }\n\n  let backend: string | undefined;\n  let backendVersion: string | undefined;\n  const unknown: string[] = [];\n\n  for (let i = 0; i < tokens.length; i += 1) {\n    const token = tokens[i]!;\n    if (!token.startsWith('--')) continue;\n    if (token === '--backend') {\n      const value = tokens[i + 1];\n      if (!value) {\n        console.log(chalk.dim('  Missing value for --backend'));\n        return 'handled';\n      }\n      i += 1;\n      backend = value;\n      continue;\n    }\n    if (token === '--backend-version') {\n      const value = tokens[i + 1];\n      if (!value) {\n        console.log(chalk.dim('  Missing value for --backend-version'));\n        return 'handled';\n      }\n      i += 1;\n      backendVersion = value;\n      continue;\n    }\n    unknown.push(token);\n  }\n\n  if (unknown.length > 0) {\n    console.log(chalk.yellow(`  Unknown options: ${unknown.join(', ')}`));\n    console.log(chalk.dim('  Usage: /autotune-status <model-id> [--backend <name>] [--backend-version <version>]'));\n    return 'handled';\n  }\n\n  const { LmxClient } = await import('../../lmx/client.js');\n  const lmx = new LmxClient({\n    host: ctx.config.connection.host,\n    fallbackHosts: ctx.config.connection.fallbackHosts,\n    port: ctx.config.connection.port,\n    adminKey: ctx.config.connection.adminKey,\n  });\n\n  try {\n    const result = asObject(await lmx.autotuneRecord(modelId, { backend, backendVersion }, FAST_SLASH_REQUEST_OPTS));\n    const score = readNumber(result, 'score', 'best_score');\n    const tsRaw = readNumber(result, 'ts', 'timestamp');\n    const tsSeconds = tsRaw === undefined ? undefined : tsRaw > 1e11 ? tsRaw / 1000 : tsRaw;\n    const profile = asObject(result.profile);\n    const metrics = asObject(result.metrics);\n    const lines: string[] = [\n      kv('Model', readString(result, 'modelId', 'model_id') ?? modelId),\n      kv('Backend', readString(result, 'backend') ?? chalk.dim('(unknown)')),\n      kv('Backend Version', readString(result, 'backendVersion', 'backend_version') ?? chalk.dim('(unknown)')),\n      kv('Score', score === undefined ? chalk.dim('(unknown)') : score.toFixed(4)),\n      kv('Timestamp', tsSeconds === undefined ? chalk.dim('(unknown)') : new Date(tsSeconds * 1000).toISOString()),\n      '',\n      chalk.dim('Profile:'),\n      chalk.dim(renderJson(profile)),\n      '',\n      chalk.dim('Metrics:'),\n      chalk.dim(renderJson(metrics)),\n    ];\n    console.log('\\n' + box('Autotune Profile', lines));\n  } catch (err) {\n    console.error(chalk.red('') + ` Failed to fetch autotune profile: ${errorMessage(err)}`);\n  }\n  return 'handled';\n};\n\nexport const lmxCommands: SlashCommandDef[] = [\n  {\n    command: 'models',\n    description: 'Full models manager (use/load/swap/scan/browse/library)',\n    handler: modelsHandler,\n    category: 'server',\n    usage: '/models [action] [args] [--json]',\n    examples: ['/models', '/models use minimax', '/models swap current replacement', '/models browse-library'],\n  },\n  {\n    command: 'scan',\n    aliases: ['model-scan'],\n    description: 'Scan all available models',\n    handler: scanHandler,\n    category: 'server',\n    usage: '/scan',\n    examples: ['/scan'],\n  },\n  {\n    command: 'load',\n    description: 'Load model into LMX memory',\n    handler: loadHandler,\n    category: 'server',\n    usage: '/load <model-id> [--backend <name>] [--auto-download] [--keep-alive <sec>] [--allow-unsupported]',\n    examples: [\n      '/load mlx-community/Llama-3-8B-Instruct-4bit',\n      '/load inferencelabs/GLM-5-MLX-4.8bit --backend mlx-lm --kv-bits 4 --prefix-cache true',\n    ],\n  },\n  {\n    command: 'unload',\n    description: 'Unload model (free memory)',\n    handler: unloadHandler,\n    category: 'server',\n    usage: '/unload <model-id>',\n    examples: ['/unload mlx-community/Llama-3-8B-Instruct-4bit'],\n  },\n  {\n    command: 'serve',\n    description: 'LMX server start/stop/status',\n    handler: serveHandler,\n    category: 'server',\n    usage: '/serve [start|stop|restart|reload|logs] [--json]',\n    examples: ['/serve', '/serve --json', '/serve start', '/serve reload', '/serve logs'],\n  },\n  {\n    command: 'lmx',\n    description: 'LMX runtime control: status, reconnect, start/stop/restart/reload/logs',\n    handler: lmxCommandHandler,\n    category: 'server',\n    usage: '/lmx [status|reconnect|start|stop|restart|reload|logs] [--json]',\n    examples: ['/lmx status', '/lmx reconnect', '/lmx start', '/lmx reload'],\n  },\n  {\n    command: 'memory',\n    aliases: ['mem'],\n    description: 'LMX memory breakdown',\n    handler: memoryHandler,\n    category: 'server',\n    usage: '/memory',\n    examples: ['/memory'],\n  },\n  {\n    command: 'diagnose',\n    aliases: ['diag'],\n    description: 'Run LMX provider diagnostics',\n    handler: diagnoseHandler,\n    category: 'server',\n    usage: '/diagnose',\n    examples: ['/diagnose'],\n  },\n  {\n    command: 'metrics',\n    aliases: ['stats'],\n    description: 'LMX request metrics summary',\n    handler: metricsHandler,\n    category: 'server',\n    usage: '/metrics [--prom|--json]',\n    examples: ['/metrics', '/metrics --prom', '/metrics --json'],\n  },\n  {\n    command: 'events',\n    aliases: ['stream'],\n    description: 'Tail recent admin SSE events',\n    handler: eventsHandler,\n    category: 'server',\n    usage: '/events [--limit <n>] [--timeout <sec>] [--json]',\n    examples: ['/events', '/events --limit 30 --timeout 45', '/events --json'],\n  },\n  {\n    command: 'benchmark',\n    aliases: ['bench'],\n    description: 'Benchmark loaded model or view benchmark results',\n    handler: benchmarkHandler,\n    category: 'server',\n    usage: '/benchmark [model-id|results [--json]]',\n    examples: ['/benchmark', '/benchmark mlx-community/MiniMax-M2.5-4bit', '/benchmark results --json'],\n  },\n  {\n    command: 'embed',\n    description: 'Create embeddings for input text',\n    handler: embedHandler,\n    category: 'server',\n    usage: '/embed <text> [--model <id>] [--json]',\n    examples: ['/embed \"hello world\"', '/embed \"semantic search query\" --model snowflake/arctic-embed-m-v2.0'],\n  },\n  {\n    command: 'rerank',\n    description: 'Rerank documents against a query',\n    handler: rerankHandler,\n    category: 'server',\n    usage: '/rerank <query> --documents <doc1|doc2|...> [--model <id>] [--top-k <n>] [--json]',\n    examples: ['/rerank \"what changed?\" --documents \"release notes|commit log|meeting notes\" --top-k 2'],\n  },\n  {\n    command: 'predictor',\n    description: 'Show model-predictor usage stats and next-model prediction',\n    handler: predictorHandler,\n    category: 'server',\n    usage: '/predictor [--json]',\n    examples: ['/predictor', '/predictor --json'],\n  },\n  {\n    command: 'helpers',\n    description: 'Show helper-node health (embedding/reranking)',\n    handler: helpersHandler,\n    category: 'server',\n    usage: '/helpers [--json]',\n    examples: ['/helpers', '/helpers --json'],\n  },\n  {\n    command: 'quantize',\n    aliases: ['qz'],\n    description: 'Start/list/check LMX quantization jobs',\n    handler: quantizeHandler,\n    category: 'server',\n    usage: '/quantize [list|status <job-id>|start <model-id> [--bits 4|8] [--group-size <n>] [--mode affine|symmetric] [--output <path>]]',\n    examples: ['/quantize', '/quantize status job_abc123', '/quantize start mistralai/Mistral-7B-Instruct-v0.3 --bits 4'],\n  },\n  {\n    command: 'agents',\n    description: 'Inspect and control LMX agent runs',\n    handler: agentsHandler,\n    category: 'server',\n    usage: '/agents [list|start|status <run-id>|events <run-id>|cancel <run-id>] [--limit <n>] [--offset <n>] [--status <state>] [--json]',\n    examples: [\n      '/agents',\n      '/agents start --prompt \"Draft incident triage\" --roles planner,executor',\n      '/agents events run_abc123 --timeout 30',\n      '/agents cancel run_abc123',\n    ],\n  },\n  {\n    command: 'lmx-skills',\n    aliases: ['skill-registry'],\n    description: 'Inspect skill registry and MCP tool catalog',\n    handler: skillsHandler,\n    category: 'server',\n    usage: '/lmx-skills [list|show <skill-name>|tools|run <skill-name>|mcp-call <tool-name>|openclaw <tool-name>] [--all] [--json]',\n    examples: [\n      '/lmx-skills',\n      '/lmx-skills run ai26-3c-productivity-writing-plans --args \"{\\\"topic\\\":\\\"routing\\\"}\"',\n      '/lmx-skills mcp-call linear.search_issues --args \"{\\\"query\\\":\\\"status:in_progress\\\"}\"',\n    ],\n  },\n  {\n    command: 'rag',\n    description: 'Query and manage RAG collections',\n    handler: ragHandler,\n    category: 'server',\n    usage: '/rag [collections|delete <collection>|query <collection> \\\"<query>\\\" [--top-k <n>] [--min-score <n>] [--mode vector|keyword|hybrid] [--rerank]|ingest <collection> (--file <path>|--text \\\"<content>\\\"|--stdin)|context \\\"<query>\\\" --collections <c1,c2>] [--json]',\n    examples: [\n      '/rag',\n      '/rag ingest docs --file ./README.md --chunking markdown_headers',\n      '/rag context \"what changed?\" --collections docs,notes --rerank',\n      '/rag delete scratch',\n    ],\n  },\n  {\n    command: 'preset',\n    description: 'Show full details for one preset',\n    handler: presetHandler,\n    category: 'server',\n    usage: '/preset <name>',\n    examples: ['/preset coder-fast'],\n  },\n  {\n    command: 'presets',\n    description: 'List presets or reload presets from disk',\n    handler: presetsHandler,\n    category: 'server',\n    usage: '/presets [list|reload|<name>]',\n    examples: ['/presets', '/presets reload', '/presets coder-fast'],\n  },\n  {\n    command: 'probe',\n    description: 'Probe model backend compatibility before loading',\n    handler: probeHandler,\n    category: 'server',\n    usage: '/probe <model-id> [--timeout <sec>] [--allow-unsupported]',\n    examples: ['/probe inferencelabs/GLM-5-MLX-4.8bit', '/probe model --timeout 120 --allow-unsupported'],\n  },\n  {\n    command: 'compatibility',\n    aliases: ['compat'],\n    description: 'Show model compatibility ledger and optional summary',\n    handler: compatibilityHandler,\n    category: 'server',\n    usage: '/compatibility [--model <id>] [--backend <name>] [--outcome <value>] [--since <ts>] [--limit <n>] [--summary]',\n    examples: ['/compatibility --summary', '/compatibility --model inferencelabs/GLM-5-MLX-4.8bit --limit 30'],\n  },\n  {\n    command: 'autotune',\n    description: 'Benchmark candidate performance profiles and persist best settings',\n    handler: autotuneHandler,\n    category: 'server',\n    usage: '/autotune <model-id> [--prompt \\\"...\\\"] [--max-tokens <n>] [--temperature <n>] [--runs <n>] [--profiles-json <json>] [--allow-unsupported]',\n    examples: ['/autotune inferencelabs/GLM-5-MLX-4.8bit', '/autotune model --runs 3 --profiles-json \\\"[{\\\\\\\"kv_bits\\\\\\\":4}]\\\"'],\n  },\n  {\n    command: 'autotune-status',\n    aliases: ['tuned'],\n    description: 'Show stored autotune profile for a model/backend',\n    handler: autotuneStatusHandler,\n    category: 'server',\n    usage: '/autotune-status <model-id> [--backend <name>] [--backend-version <version>]',\n    examples: ['/autotune-status inferencelabs/GLM-5-MLX-4.8bit', '/tuned model --backend mlx-lm'],\n  },\n];\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/commands/slash/manage.ts","messages":[{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'value' will use Object's default stringification format ('[object Object]') when stringified.","line":40,"column":24,"nodeType":"Identifier","messageId":"baseToString","endLine":40,"endColumn":29},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'value' will use Object's default stringification format ('[object Object]') when stringified.","line":48,"column":17,"nodeType":"Identifier","messageId":"baseToString","endLine":48,"endColumn":22},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, value is always truthy.","line":147,"column":10,"nodeType":"Literal","messageId":"alwaysTruthy","endLine":147,"endColumn":14},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'currentValue' may use Object's default stringification format ('[object Object]') when stringified.","line":199,"column":69,"nodeType":"Identifier","messageId":"baseToString","endLine":199,"endColumn":81},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'val' may use Object's default stringification format ('[object Object]') when stringified.","line":319,"column":75,"nodeType":"Identifier","messageId":"baseToString","endLine":319,"endColumn":78},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":424,"column":23,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":424,"endColumn":33},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":441,"column":26,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":441,"endColumn":43},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":466,"column":23,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":466,"endColumn":33},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":600,"column":19,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":600,"endColumn":29},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":724,"column":19,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":724,"endColumn":29},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":794,"column":19,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":794,"endColumn":29},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":949,"column":38,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":949,"endColumn":44},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":970,"column":23,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":970,"endColumn":31},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, value is always truthy.","line":1051,"column":19,"nodeType":"MemberExpression","messageId":"alwaysTruthy","endLine":1051,"endColumn":41},{"ruleId":"@typescript-eslint/require-await","severity":1,"message":"Async arrow function 'keysHandler' has no 'await' expression.","line":1110,"column":84,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":1110,"endColumn":86,"suggestions":[{"messageId":"removeAsync","fix":{"range":[35683,35745],"text":"(_args: string, ctx: SlashContext): SlashResult"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":1116,"column":9,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":1116,"endColumn":60},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1116,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1116,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[35986,35989],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[35986,35989],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":1117,"column":9,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":1117,"endColumn":78},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1117,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1117,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[36046,36049],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[36046,36049],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .telegram on an `any` value.","line":1117,"column":60,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":1117,"endColumn":68},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string | undefined`.","line":1122,"column":31,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":1122,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .GEMINI_API_KEY on an `any` value.","line":1122,"column":35,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":1122,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string | undefined`.","line":1123,"column":29,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":1123,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .GROQ_API_KEY on an `any` value.","line":1123,"column":33,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":1123,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string | undefined`.","line":1124,"column":29,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":1124,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .KIMI_API_KEY on an `any` value.","line":1124,"column":33,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":1124,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string | undefined`.","line":1125,"column":32,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":1125,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .MINIMAX_API_KEY on an `any` value.","line":1125,"column":36,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":1125,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string | undefined`.","line":1126,"column":33,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":1126,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .OPENCODE_API_KEY on an `any` value.","line":1126,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":1126,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string | undefined`.","line":1127,"column":35,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":1127,"endColumn":37},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":1154,"column":13,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":1154,"endColumn":21},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":1159,"column":19,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":1159,"endColumn":41}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":33,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Management slash commands: /config, /doctor, /mcp, /quickfix\n */\n\nimport chalk from 'chalk';\nimport { box, kv } from '../../ui/box.js';\nimport { runMenuPrompt } from '../../ui/prompt-nav.js';\nimport { errorMessage } from '../../utils/errors.js';\nimport { formatAutonomySlider } from '../../core/autonomy.js';\nimport type { SlashCommandDef, SlashContext, SlashResult } from './types.js';\nimport type { PaneMenuSection } from '../../ui/pane-menu.js';\nimport type { UpdateOptions } from '../update.js';\n\nconst CONFIG_SECTION_COLORS: Record<string, string> = {\n  connection: '#a855f7',\n  model: '#22d3ee',\n  autonomy: '#0ea5e9',\n  provider: '#3b82f6',\n  research: '#0ea5e9',\n  browser: '#14b8a6',\n  learning: '#f97316',\n  policy: '#ef4444',\n  permissions: '#f59e0b',\n  git: '#10b981',\n  tui: '#8b5cf6',\n  mcp: '#06b6d4',\n  default: '#64748b',\n};\n\nfunction isSensitiveConfigKey(key: string): boolean {\n  const k = key.toLowerCase();\n  return k.includes('apikey') || k.includes('api_key') ||\n    k.includes('token') || k.includes('secret') || k.includes('password') ||\n    k.endsWith('.key') || k.includes('adminkey');\n}\n\nfunction formatConfigValueForDisplay(value: unknown, key = ''): string {\n  if (value === undefined || value === null) return chalk.dim('(unset)');\n  if (key && isSensitiveConfigKey(key)) {\n    const raw = String(value);\n    if (!raw) return chalk.dim('(none)');\n    return '(set)';\n  }\n  if (typeof value === 'string') return value.length === 0 ? chalk.dim('(empty)') : value;\n  if (typeof value === 'number' || typeof value === 'boolean') return String(value);\n  if (Array.isArray(value)) return JSON.stringify(value);\n  if (typeof value === 'object') return chalk.dim('{...}');\n  return String(value);\n}\n\nfunction summarizeConfigValue(value: unknown, maxWidth = 40, key = ''): string {\n  const rendered = formatConfigValueForDisplay(value, key);\n  const plain = rendered.replace(/\\x1B\\[[0-9;]*m/g, '');\n  if (plain.length <= maxWidth) return rendered;\n  return `${plain.slice(0, maxWidth - 1)}`;\n}\n\nfunction parseSlashArgs(raw: string): string[] {\n  const tokens: string[] = [];\n  const pattern = /\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\"|'([^'\\\\]*(?:\\\\.[^'\\\\]*)*)'|`([^`\\\\]*(?:\\\\.[^`\\\\]*)*)`|([^\\s]+)/g;\n  let match: RegExpExecArray | null;\n\n  while ((match = pattern.exec(raw)) !== null) {\n    const captured = match[1] ?? match[2] ?? match[3] ?? match[4] ?? '';\n    tokens.push(captured.replace(/\\\\([\"'`\\\\])/g, '$1'));\n  }\n\n  return tokens;\n}\n\nfunction printMcpUsage(): void {\n  console.log(chalk.dim('  Usage: /mcp [list|add|add-playwright|remove|test]'));\n  console.log(chalk.dim('    /mcp list'));\n  console.log(chalk.dim('    /mcp add myserver \"npx @modelcontextprotocol/server-filesystem /tmp\" --env FOO=bar'));\n  console.log(chalk.dim('    /mcp add-playwright --mode attach --allowed-hosts localhost,127.0.0.1'));\n  console.log(chalk.dim('    /mcp remove myserver'));\n  console.log(chalk.dim('    /mcp test myserver'));\n}\n\nfunction printUpdateUsage(): void {\n  console.log(chalk.dim('  Usage: /update [options]'));\n  console.log(chalk.dim('    --components|-c cli,lmx,plus,web'));\n  console.log(chalk.dim('    --target|-t auto|local|remote|both'));\n  console.log(chalk.dim('    --remote-host <host> --remote-user <user> --identity-file <path>'));\n  console.log(chalk.dim('    --local-root <path> --remote-root <path>'));\n  console.log(chalk.dim('    --dry-run --no-build --no-pull --json'));\n}\n\nfunction printDaemonUsage(): void {\n  console.log(chalk.dim('  Usage: /daemon [start|stop|status|logs|run] [options]'));\n  console.log(chalk.dim('    --host <host> --port <port> --json'));\n  console.log(chalk.dim('    --token <token> --model <name> (run only)'));\n}\n\nfunction printKeyUsage(): void {\n  console.log(chalk.dim('  Usage: /key [create|show|copy] [options]'));\n  console.log(chalk.dim('    /key show [--reveal] [--copy] [--json]'));\n  console.log(chalk.dim('    /key create [--value <key>] [--no-remote] [--no-copy] [--json]'));\n  console.log(chalk.dim('    /key copy [--json]'));\n}\n\nfunction printServerUsage(): void {\n  console.log(chalk.dim('  Usage: /server [start|stop|status|logs] [--host <host>] [--port <port>] [--json]'));\n  console.log(chalk.dim('  Notes: /server is chat-safe and maps to daemon lifecycle commands.'));\n}\n\nexport function buildConfigSections(config: Record<string, unknown>): PaneMenuSection[] {\n  const entries = flattenConfig(config);\n  const grouped = new Map<string, Array<{ key: string; value: unknown }>>();\n\n  for (const [key, value] of entries) {\n    const section = key.split('.')[0] ?? 'other';\n    const bucket = grouped.get(section) ?? [];\n    bucket.push({ key, value });\n    grouped.set(section, bucket);\n  }\n\n  return [...grouped.entries()]\n    .sort(([a], [b]) => a.localeCompare(b))\n    .map(([section, pairs]) => ({\n      id: section,\n      label: section.charAt(0).toUpperCase() + section.slice(1),\n      color: CONFIG_SECTION_COLORS[section] ?? CONFIG_SECTION_COLORS.default,\n      items: pairs\n        .sort((a, b) => a.key.localeCompare(b.key))\n        .map((pair) => ({\n          id: pair.key,\n          label: pair.key,\n          description: summarizeConfigValue(pair.value, 40, pair.key),\n        })),\n    }))\n    .filter((section) => section.items.length > 0);\n}\n\nasync function interactiveConfigMenu(ctx: SlashContext): Promise<boolean> {\n  if (!process.stdin.isTTY || !process.stdout.isTTY) {\n    return false;\n  }\n\n  const { loadConfig, saveConfig, getConfigStore } = await import('../../core/config.js');\n  const { runPaneMenu } = await import('../../ui/pane-menu.js');\n  const { input, select } = await import('@inquirer/prompts');\n\n  let sectionIndex = 0;\n  let itemIndex = 0;\n\n  while (true) {\n    const latest = await loadConfig();\n    const sections = buildConfigSections(latest as unknown as Record<string, unknown>);\n    if (sections.length === 0) return true;\n\n    const selection = await runPaneMenu({\n      title: 'Opta Config Navigator',\n      subtitle: 'Finder-style browser for config keys',\n      instructions: '/ panes  / loop  Enter select  q exit',\n      sections,\n      initialSectionIndex: sectionIndex,\n      initialItemIndex: itemIndex,\n      loop: true,\n    });\n\n    if (!selection) return true;\n    sectionIndex = selection.sectionIndex;\n    itemIndex = selection.itemIndex;\n\n    const selectedKey = selection.itemId;\n    const currentValue = getNestedValue(latest as Record<string, unknown>, selectedKey);\n\n    console.log('\\n' + box(`Config ${chalk.cyan(selectedKey)}`, [\n      kv('Key', selectedKey, 16),\n      kv('Value', formatConfigValueForDisplay(currentValue, selectedKey), 16),\n      kv('Type', currentValue === null ? 'null' : typeof currentValue, 16),\n      '',\n      chalk.dim(`Set with: /config set ${selectedKey} <value>`),\n    ]) + '\\n');\n\n    let action: 'back' | 'set' | 'clear' | 'exit';\n    try {\n      const picked = await runMenuPrompt((context) =>\n        select<'back' | 'set' | 'clear' | 'exit'>({\n          message: chalk.dim('Next'),\n          choices: [\n            { name: 'Back to config navigator', value: 'back' },\n            { name: `Set ${selectedKey}`, value: 'set' },\n            { name: `Reset ${selectedKey} to default`, value: 'clear' },\n            { name: 'Exit config menu', value: 'exit' },\n          ],\n        }, context), 'select');\n      if (!picked) continue;\n      action = picked;\n    } catch {\n      return true;\n    }\n\n    if (action === 'exit') return true;\n    if (action === 'back') continue;\n\n    if (action === 'set') {\n      const defaultValue = currentValue === undefined ? '' : String(currentValue);\n      let valueInput = '';\n      try {\n        valueInput = await input({\n          message: chalk.dim(`Set ${selectedKey}`),\n          default: defaultValue,\n        });\n      } catch {\n        continue;\n      }\n\n      try {\n        const nested = buildNestedObject(selectedKey, valueInput);\n        await saveConfig(nested);\n        Object.assign(ctx.config, await loadConfig());\n        console.log(chalk.green('') + ` ${selectedKey} = ${valueInput}`);\n      } catch (err) {\n        console.error(chalk.red('\\u2717') + ` Failed to save: ${errorMessage(err)}`);\n      }\n      continue;\n    }\n\n    try {\n      const store = await getConfigStore();\n      store.delete(selectedKey);\n      Object.assign(ctx.config, await loadConfig());\n      console.log(chalk.green('') + ` Reset ${selectedKey} to default`);\n    } catch (err) {\n      console.error(chalk.red('\\u2717') + ` Failed to reset: ${errorMessage(err)}`);\n    }\n  }\n}\n\nconst configHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const parts = args.trim().split(/\\s+/);\n  const rawAction = (parts[0] || 'list').toLowerCase();\n  const key = parts[1];\n  const value = parts.slice(2).join(' ');\n  const menuActions = new Set(['menu', 'interactive', 'nav', 'browser']);\n\n  if (menuActions.has(rawAction)) {\n    const opened = await interactiveConfigMenu(ctx);\n    if (opened) return 'handled';\n  }\n\n  const action = menuActions.has(rawAction) ? 'list' : rawAction;\n\n  if (action === 'list') {\n    const lines: string[] = [\n      chalk.dim('Connection'),\n      kv('host', ctx.config.connection.host, 20),\n      kv('port', String(ctx.config.connection.port), 20),\n      kv('adminKey', ctx.config.connection.adminKey ? '(set)' : chalk.dim('(none)'), 20),\n      '',\n      chalk.dim('Model'),\n      kv('default', ctx.config.model.default || chalk.dim('(none)'), 20),\n      kv('contextLimit', String(ctx.config.model.contextLimit), 20),\n      '',\n      chalk.dim('Autonomy'),\n      kv('level', `${ctx.config.autonomy.level} ${formatAutonomySlider(ctx.config.autonomy.level)}`, 20),\n      kv('mode', ctx.config.autonomy.mode, 20),\n      kv('enforceProfile', String(ctx.config.autonomy.enforceProfile), 20),\n      kv('objectiveReassessment', String(ctx.config.autonomy.objectiveReassessment), 20),\n      kv('requireLiveData', String(ctx.config.autonomy.requireLiveData), 20),\n      kv('reportStyle', ctx.config.autonomy.reportStyle, 20),\n      '',\n      chalk.dim('Provider'),\n      kv('active', ctx.config.provider.active, 20),\n      kv('anthropic.apiKey', ctx.config.provider.anthropic.apiKey ? '(set)' : chalk.dim('(none)'), 20),\n      '',\n      chalk.dim('Research'),\n      kv('enabled', String(ctx.config.research.enabled), 20),\n      kv('defaultProvider', ctx.config.research.defaultProvider, 20),\n      kv('alwaysIncludeDocs', String(ctx.config.research.alwaysIncludeDocumentation), 20),\n      kv('tavily.apiKey', ctx.config.research.providers.tavily.apiKey ? '(set)' : chalk.dim('(none)'), 20),\n      kv('gemini.apiKey', ctx.config.research.providers.gemini.apiKey ? '(set)' : chalk.dim('(none)'), 20),\n      kv('exa.apiKey', ctx.config.research.providers.exa.apiKey ? '(set)' : chalk.dim('(none)'), 20),\n      kv('brave.apiKey', ctx.config.research.providers.brave.apiKey ? '(set)' : chalk.dim('(none)'), 20),\n      kv('groq.apiKey', ctx.config.research.providers.groq.apiKey ? '(set)' : chalk.dim('(none)'), 20),\n      '',\n      chalk.dim('Browser'),\n      kv('enabled', String(ctx.config.browser.enabled), 20),\n      kv('mode', ctx.config.browser.mode, 20),\n      kv('attach.enabled', String(ctx.config.browser.attach.enabled), 20),\n      kv('attach.requireApproval', String(ctx.config.browser.attach.requireApproval), 20),\n      '',\n      chalk.dim('Learning'),\n      kv('enabled', String(ctx.config.learning.enabled), 20),\n      kv('captureLevel', ctx.config.learning.captureLevel, 20),\n      kv('governor.autoCalibrate', String(ctx.config.learning.governor.autoCalibrate), 20),\n      '',\n      chalk.dim('Policy'),\n      kv('enabled', String(ctx.config.policy.enabled), 20),\n      kv('mode', ctx.config.policy.mode, 20),\n      kv('failureMode', ctx.config.policy.failureMode, 20),\n      kv('gateAllAutonomy', String(ctx.config.policy.gateAllAutonomy), 20),\n      '',\n      chalk.dim('Features'),\n      kv('defaultMode', ctx.config.defaultMode, 20),\n      kv('git.autoCommit', String(ctx.config.git.autoCommit), 20),\n      kv('git.checkpoints', String(ctx.config.git.checkpoints), 20),\n      kv('insights.enabled', String(ctx.config.insights.enabled), 20),\n      kv('tui.default', String(ctx.config.tui.default), 20),\n    ];\n    console.log('\\n' + box('Config', lines));\n    console.log(chalk.dim('  /config menu                \\u2014  interactive key navigator'));\n    console.log(chalk.dim('  /config set <key> <value>  \\u2014  change a setting'));\n    console.log(chalk.dim('  /config get <key>          \\u2014  read a setting\\n'));\n    return 'handled';\n  }\n\n  if (action === 'get') {\n    if (!key) {\n      console.log(chalk.dim('  Usage: /config get <key>'));\n      return 'handled';\n    }\n    try {\n      const { loadConfig } = await import('../../core/config.js');\n      const config = await loadConfig();\n      const val = getNestedValue(config, key);\n      console.log(`  ${chalk.dim(key + ':')} ${val !== undefined ? String(val) : chalk.dim('(not set)')}`);\n    } catch (err) {\n      console.error(chalk.red('\\u2717') + ` ${errorMessage(err)}`);\n    }\n    return 'handled';\n  }\n\n  if (action === 'set') {\n    if (!key || !value) {\n      console.log(chalk.dim('  Usage: /config set <key> <value>'));\n      console.log(chalk.dim('  Example: /config set connection.port 1234'));\n      return 'handled';\n    }\n\n    try {\n      const { saveConfig } = await import('../../core/config.js');\n      const nested = buildNestedObject(key, value);\n      await saveConfig(nested);\n      console.log(chalk.green('\\u2713') + ` ${key} = ${value}`);\n    } catch (err) {\n      console.error(chalk.red('\\u2717') + ` Failed to save: ${errorMessage(err)}`);\n    }\n    return 'handled';\n  }\n\n  if (action === 'reset') {\n    try {\n      const { getConfigStore } = await import('../../core/config.js');\n      const store = await getConfigStore();\n      store.clear();\n      console.log(chalk.green('\\u2713') + ' Config reset to defaults');\n    } catch (err) {\n      console.error(chalk.red('\\u2717') + ` ${errorMessage(err)}`);\n    }\n    return 'handled';\n  }\n\n  if (action === 'search') {\n    if (!key) {\n      console.log(chalk.dim('  Usage: /config search <pattern>'));\n      return 'handled';\n    }\n    const { loadConfig } = await import('../../core/config.js');\n    const config = await loadConfig();\n    const pattern = key.toLowerCase();\n    const matches = flattenConfig(config)\n      .filter(([k]) => k.toLowerCase().includes(pattern));\n\n    if (matches.length === 0) {\n      console.log(chalk.dim(`  No config keys matching \"${key}\"`));\n      return 'handled';\n    }\n\n    const lines = matches.map(([k, v]) => kv(k, String(v), 30));\n    console.log('\\n' + box(`Config: \"${key}\" (${matches.length} matches)`, lines));\n    return 'handled';\n  }\n\n  console.log(chalk.dim('  Usage: /config [list|get|set|reset|search|menu]'));\n  return 'handled';\n};\n\nconst doctorHandler = async (_args: string, _ctx: SlashContext): Promise<SlashResult> => {\n  try {\n    const { runDoctor } = await import('../doctor.js');\n    await runDoctor({});\n  } catch (err) {\n    console.error(chalk.red('\\u2717') + ` Doctor failed: ${errorMessage(err)}`);\n  }\n  return 'handled';\n};\n\nconst mcpHandler = async (args: string, _ctx: SlashContext): Promise<SlashResult> => {\n  const tokens = parseSlashArgs(args);\n  const action = (tokens[0] ?? 'list').toLowerCase();\n\n  try {\n    const {\n      mcpList,\n      mcpAdd,\n      mcpAddPlaywright,\n      mcpRemove,\n      mcpTest,\n    } = await import('../mcp.js');\n\n    if (action === '--help' || action === '-h' || action === 'help') {\n      printMcpUsage();\n      return 'handled';\n    }\n\n    if (action === 'list' || action === 'ls') {\n      await mcpList({ json: tokens.includes('--json') });\n      return 'handled';\n    }\n\n    if (action === 'add') {\n      const name = tokens[1];\n      if (!name) {\n        console.log(chalk.dim('  Usage: /mcp add <name> <command> [--env KEY=VAL,...]'));\n        return 'handled';\n      }\n\n      let env: string | undefined;\n      let envIndex = -1;\n      for (let i = 2; i < tokens.length; i += 1) {\n        const token = tokens[i]!;\n        if (token === '--env' || token.startsWith('--env=')) {\n          envIndex = i;\n          break;\n        }\n      }\n\n      const commandTokens = envIndex === -1\n        ? tokens.slice(2)\n        : tokens.slice(2, envIndex);\n\n      if (commandTokens.length === 0) {\n        console.log(chalk.dim('  Usage: /mcp add <name> <command> [--env KEY=VAL,...]'));\n        return 'handled';\n      }\n\n      if (envIndex !== -1) {\n        const envToken = tokens[envIndex]!;\n        if (envToken === '--env') {\n          env = tokens[envIndex + 1];\n        } else {\n          env = envToken.slice('--env='.length);\n        }\n      }\n\n      await mcpAdd(name, commandTokens.join(' '), { env });\n      return 'handled';\n    }\n\n    if (action === 'add-playwright') {\n      const opts: {\n        name?: string;\n        mode?: 'attach' | 'isolated';\n        command?: string;\n        packageName?: string;\n        allowedHosts?: string[];\n        blockedOrigins?: string[];\n        env?: string;\n      } = {};\n\n      const unknown: string[] = [];\n      for (let i = 1; i < tokens.length; i += 1) {\n        const token = tokens[i]!;\n        if (token === '--name') {\n          opts.name = tokens[i + 1];\n          i += 1;\n          continue;\n        }\n        if (token.startsWith('--name=')) {\n          opts.name = token.slice('--name='.length);\n          continue;\n        }\n        if (token === '--mode') {\n          const value = tokens[i + 1];\n          if (value === 'attach' || value === 'isolated') {\n            opts.mode = value;\n          }\n          i += 1;\n          continue;\n        }\n        if (token.startsWith('--mode=')) {\n          const value = token.slice('--mode='.length);\n          if (value === 'attach' || value === 'isolated') {\n            opts.mode = value;\n          }\n          continue;\n        }\n        if (token === '--command') {\n          opts.command = tokens[i + 1];\n          i += 1;\n          continue;\n        }\n        if (token.startsWith('--command=')) {\n          opts.command = token.slice('--command='.length);\n          continue;\n        }\n        if (token === '--package') {\n          opts.packageName = tokens[i + 1];\n          i += 1;\n          continue;\n        }\n        if (token.startsWith('--package=')) {\n          opts.packageName = token.slice('--package='.length);\n          continue;\n        }\n        if (token === '--allowed-hosts') {\n          const raw = tokens[i + 1];\n          opts.allowedHosts = raw?.split(',').map((v) => v.trim()).filter(Boolean);\n          i += 1;\n          continue;\n        }\n        if (token.startsWith('--allowed-hosts=')) {\n          opts.allowedHosts = token\n            .slice('--allowed-hosts='.length)\n            .split(',')\n            .map((v) => v.trim())\n            .filter(Boolean);\n          continue;\n        }\n        if (token === '--blocked-origins') {\n          const raw = tokens[i + 1];\n          opts.blockedOrigins = raw?.split(',').map((v) => v.trim()).filter(Boolean);\n          i += 1;\n          continue;\n        }\n        if (token.startsWith('--blocked-origins=')) {\n          opts.blockedOrigins = token\n            .slice('--blocked-origins='.length)\n            .split(',')\n            .map((v) => v.trim())\n            .filter(Boolean);\n          continue;\n        }\n        if (token === '--env') {\n          opts.env = tokens[i + 1];\n          i += 1;\n          continue;\n        }\n        if (token.startsWith('--env=')) {\n          opts.env = token.slice('--env='.length);\n          continue;\n        }\n        unknown.push(token);\n      }\n\n      if (unknown.length > 0) {\n        console.log(chalk.yellow(`  Unknown options: ${unknown.join(', ')}`));\n        printMcpUsage();\n        return 'handled';\n      }\n\n      await mcpAddPlaywright(opts);\n      return 'handled';\n    }\n\n    if (action === 'remove' || action === 'rm') {\n      const name = tokens[1];\n      if (!name) {\n        console.log(chalk.dim('  Usage: /mcp remove <name>'));\n        return 'handled';\n      }\n      await mcpRemove(name);\n      return 'handled';\n    }\n\n    if (action === 'test') {\n      const name = tokens[1];\n      if (!name) {\n        console.log(chalk.dim('  Usage: /mcp test <name>'));\n        return 'handled';\n      }\n      await mcpTest(name);\n      return 'handled';\n    }\n\n    console.log(chalk.yellow(`  Unknown MCP action: ${action}`));\n    printMcpUsage();\n  } catch (err) {\n    console.error(chalk.red('\\u2717') + ` MCP command failed: ${errorMessage(err)}`);\n  }\n\n  return 'handled';\n};\n\nconst updateHandler = async (args: string, _ctx: SlashContext): Promise<SlashResult> => {\n  const tokens = parseSlashArgs(args);\n\n  if (tokens.includes('--help') || tokens.includes('-h') || tokens.includes('help')) {\n    printUpdateUsage();\n    return 'handled';\n  }\n\n  const opts: UpdateOptions = {};\n  const unknown: string[] = [];\n\n  for (let i = 0; i < tokens.length; i += 1) {\n    const token = tokens[i]!;\n    if (token === '--components' || token === '-c') {\n      opts.components = tokens[i + 1];\n      i += 1;\n      continue;\n    }\n    if (token.startsWith('--components=')) {\n      opts.components = token.slice('--components='.length);\n      continue;\n    }\n    if (token === '--target' || token === '-t') {\n      opts.target = tokens[i + 1] as UpdateOptions['target'];\n      i += 1;\n      continue;\n    }\n    if (token.startsWith('--target=')) {\n      opts.target = token.slice('--target='.length) as UpdateOptions['target'];\n      continue;\n    }\n    if (token === '--remote-host') {\n      opts.remoteHost = tokens[i + 1];\n      i += 1;\n      continue;\n    }\n    if (token.startsWith('--remote-host=')) {\n      opts.remoteHost = token.slice('--remote-host='.length);\n      continue;\n    }\n    if (token === '--remote-user') {\n      opts.remoteUser = tokens[i + 1];\n      i += 1;\n      continue;\n    }\n    if (token.startsWith('--remote-user=')) {\n      opts.remoteUser = token.slice('--remote-user='.length);\n      continue;\n    }\n    if (token === '--identity-file') {\n      opts.identityFile = tokens[i + 1];\n      i += 1;\n      continue;\n    }\n    if (token.startsWith('--identity-file=')) {\n      opts.identityFile = token.slice('--identity-file='.length);\n      continue;\n    }\n    if (token === '--local-root') {\n      opts.localRoot = tokens[i + 1];\n      i += 1;\n      continue;\n    }\n    if (token.startsWith('--local-root=')) {\n      opts.localRoot = token.slice('--local-root='.length);\n      continue;\n    }\n    if (token === '--remote-root') {\n      opts.remoteRoot = tokens[i + 1];\n      i += 1;\n      continue;\n    }\n    if (token.startsWith('--remote-root=')) {\n      opts.remoteRoot = token.slice('--remote-root='.length);\n      continue;\n    }\n    if (token === '--dry-run') {\n      opts.dryRun = true;\n      continue;\n    }\n    if (token === '--no-build') {\n      opts.build = false;\n      continue;\n    }\n    if (token === '--no-pull') {\n      opts.pull = false;\n      continue;\n    }\n    if (token === '--json') {\n      opts.json = true;\n      continue;\n    }\n    unknown.push(token);\n  }\n\n  if (unknown.length > 0) {\n    console.log(chalk.yellow(`  Unknown options: ${unknown.join(', ')}`));\n    printUpdateUsage();\n    return 'handled';\n  }\n\n  try {\n    const { updateCommand } = await import('../update.js');\n    await updateCommand(opts);\n  } catch (err) {\n    console.error(chalk.red('\\u2717') + ` Update failed: ${errorMessage(err)}`);\n  }\n\n  return 'handled';\n};\n\nconst serverHandler = async (args: string, _ctx: SlashContext): Promise<SlashResult> => {\n  const tokens = parseSlashArgs(args);\n  if (tokens.includes('--help') || tokens.includes('-h') || tokens.includes('help')) {\n    printServerUsage();\n    return 'handled';\n  }\n\n  let action = 'status';\n  let startIndex = 0;\n  const maybeAction = tokens[0]?.toLowerCase();\n  if (maybeAction && !maybeAction.startsWith('-')) {\n    if (['start', 'stop', 'status', 'logs'].includes(maybeAction)) {\n      action = maybeAction;\n      startIndex = 1;\n    } else {\n      console.log(chalk.yellow(`  Unknown /server action: ${tokens[0]}`));\n      printServerUsage();\n      return 'handled';\n    }\n  }\n\n  const daemonOpts: { host?: string; port?: string; json?: boolean } = {};\n  const unknown: string[] = [];\n\n  for (let i = startIndex; i < tokens.length; i += 1) {\n    const token = tokens[i]!;\n    if (token === '--host') {\n      daemonOpts.host = tokens[i + 1];\n      i += 1;\n      continue;\n    }\n    if (token.startsWith('--host=')) {\n      daemonOpts.host = token.slice('--host='.length);\n      continue;\n    }\n    if (token === '--port') {\n      daemonOpts.port = tokens[i + 1];\n      i += 1;\n      continue;\n    }\n    if (token.startsWith('--port=')) {\n      daemonOpts.port = token.slice('--port='.length);\n      continue;\n    }\n    if (token === '--json') {\n      daemonOpts.json = true;\n      continue;\n    }\n    unknown.push(token);\n  }\n\n  if (unknown.length > 0) {\n    console.log(chalk.yellow(`  Unknown options: ${unknown.join(', ')}`));\n    printServerUsage();\n    return 'handled';\n  }\n\n  try {\n    const { daemonStart, daemonStop, daemonStatusCommand, daemonLogs } = await import('../daemon.js');\n    if (action === 'start') await daemonStart(daemonOpts);\n    else if (action === 'stop') await daemonStop(daemonOpts);\n    else if (action === 'logs') await daemonLogs(daemonOpts);\n    else await daemonStatusCommand(daemonOpts);\n  } catch (err) {\n    console.error(chalk.red('\\u2717') + ` Server command failed: ${errorMessage(err)}`);\n  }\n\n  return 'handled';\n};\n\nconst daemonHandler = async (args: string, _ctx: SlashContext): Promise<SlashResult> => {\n  const tokens = parseSlashArgs(args);\n  if (tokens.includes('--help') || tokens.includes('-h') || tokens.includes('help')) {\n    printDaemonUsage();\n    return 'handled';\n  }\n\n  let action = 'status';\n  let startIndex = 0;\n  const maybeAction = tokens[0]?.toLowerCase();\n  if (maybeAction && !maybeAction.startsWith('-')) {\n    action = maybeAction;\n    startIndex = 1;\n  }\n\n  const daemonOpts: {\n    host?: string;\n    port?: string;\n    json?: boolean;\n    token?: string;\n    model?: string;\n  } = {};\n  const unknown: string[] = [];\n\n  for (let i = startIndex; i < tokens.length; i += 1) {\n    const token = tokens[i]!;\n    if (token === '--host') {\n      daemonOpts.host = tokens[i + 1];\n      i += 1;\n      continue;\n    }\n    if (token.startsWith('--host=')) {\n      daemonOpts.host = token.slice('--host='.length);\n      continue;\n    }\n    if (token === '--port') {\n      daemonOpts.port = tokens[i + 1];\n      i += 1;\n      continue;\n    }\n    if (token.startsWith('--port=')) {\n      daemonOpts.port = token.slice('--port='.length);\n      continue;\n    }\n    if (token === '--json') {\n      daemonOpts.json = true;\n      continue;\n    }\n    if (token === '--token') {\n      daemonOpts.token = tokens[i + 1];\n      i += 1;\n      continue;\n    }\n    if (token.startsWith('--token=')) {\n      daemonOpts.token = token.slice('--token='.length);\n      continue;\n    }\n    if (token === '--model') {\n      daemonOpts.model = tokens[i + 1];\n      i += 1;\n      continue;\n    }\n    if (token.startsWith('--model=')) {\n      daemonOpts.model = token.slice('--model='.length);\n      continue;\n    }\n    unknown.push(token);\n  }\n\n  if (unknown.length > 0) {\n    console.log(chalk.yellow(`  Unknown options: ${unknown.join(', ')}`));\n    printDaemonUsage();\n    return 'handled';\n  }\n\n  try {\n    const {\n      daemonStart,\n      daemonRun,\n      daemonStop,\n      daemonStatusCommand,\n      daemonLogs,\n    } = await import('../daemon.js');\n\n    if (action === 'start') {\n      await daemonStart(daemonOpts);\n      return 'handled';\n    }\n    if (action === 'run') {\n      await daemonRun(daemonOpts);\n      return 'handled';\n    }\n    if (action === 'stop') {\n      await daemonStop(daemonOpts);\n      return 'handled';\n    }\n    if (action === 'logs') {\n      await daemonLogs(daemonOpts);\n      return 'handled';\n    }\n    if (action === 'status') {\n      await daemonStatusCommand(daemonOpts);\n      return 'handled';\n    }\n\n    console.log(chalk.yellow(`  Unknown daemon action: ${action}`));\n    printDaemonUsage();\n  } catch (err) {\n    console.error(chalk.red('\\u2717') + ` Daemon command failed: ${errorMessage(err)}`);\n  }\n\n  return 'handled';\n};\n\nconst completionsHandler = async (args: string, _ctx: SlashContext): Promise<SlashResult> => {\n  const tokens = parseSlashArgs(args);\n  const shell = tokens[0]?.toLowerCase();\n  if (!shell || !['bash', 'zsh', 'fish'].includes(shell)) {\n    console.log(chalk.dim('  Usage: /completions <bash|zsh|fish>'));\n    return 'handled';\n  }\n\n  try {\n    const { completions } = await import('../completions.js');\n    await completions(shell);\n  } catch (err) {\n    console.error(chalk.red('\\u2717') + ` Completions failed: ${errorMessage(err)}`);\n  }\n\n  return 'handled';\n};\n\nconst quickfixHandler = async (_args: string, _ctx: SlashContext): Promise<SlashResult> => {\n  try {\n    const { healConfig } = await import('../../core/config.js');\n    const issues = await healConfig();\n\n    if (issues.length === 0) {\n      console.log(chalk.green('\\u2713') + ' Config is healthy  no issues found');\n      return 'handled';\n    }\n\n    const fixed = issues.filter(i => i.autoFixed);\n    const manual = issues.filter(i => !i.autoFixed);\n\n    const lines: string[] = [];\n    for (const issue of issues) {\n      const icon = issue.autoFixed\n        ? chalk.green('\\u2713')\n        : chalk.yellow('\\u26a0');\n      const status = issue.autoFixed\n        ? chalk.dim('(auto-fixed)')\n        : chalk.yellow('(manual fix needed)');\n      lines.push(`${icon} ${chalk.bold(issue.path)} ${status}`);\n      lines.push(`  ${issue.message}`);\n      if (!issue.autoFixed) {\n        lines.push(`  ${chalk.dim(issue.suggestion)}`);\n      }\n    }\n\n    console.log('\\n' + box('Config Health', lines));\n    console.log(\n      `  Fixed ${chalk.green(String(fixed.length))} issue${fixed.length === 1 ? '' : 's'}` +\n      (manual.length > 0\n        ? `, ${chalk.yellow(String(manual.length))} require${manual.length === 1 ? 's' : ''} manual attention`\n        : '') +\n      '\\n',\n    );\n  } catch (err) {\n    console.error(\n      chalk.red('\\u2717') + ` Quickfix failed: ${errorMessage(err)}`,\n    );\n  }\n  return 'handled';\n};\n\nconst keyHandler = async (args: string, _ctx: SlashContext): Promise<SlashResult> => {\n  const tokens = parseSlashArgs(args);\n  const first = tokens[0]?.toLowerCase();\n  const hasExplicitAction = Boolean(first && !first.startsWith('-'));\n  const action = hasExplicitAction ? first! : 'show';\n  const rest = hasExplicitAction ? tokens.slice(1) : tokens;\n\n  if (action === 'help' || rest.includes('--help') || rest.includes('-h')) {\n    printKeyUsage();\n    return 'handled';\n  }\n\n  try {\n    const { keyCreate, keyShow, keyCopy } = await import('../key.js');\n\n    if (action === 'create' || action === 'rotate') {\n      const opts: {\n        value?: string;\n        remote?: boolean;\n        copy?: boolean;\n        json?: boolean;\n      } = {};\n      const unknown: string[] = [];\n\n      for (let i = 0; i < rest.length; i += 1) {\n        const token = rest[i]!;\n        if (token === '--value') {\n          opts.value = rest[i + 1];\n          i += 1;\n          continue;\n        }\n        if (token.startsWith('--value=')) {\n          opts.value = token.slice('--value='.length);\n          continue;\n        }\n        if (token === '--no-remote') {\n          opts.remote = false;\n          continue;\n        }\n        if (token === '--no-copy') {\n          opts.copy = false;\n          continue;\n        }\n        if (token === '--json') {\n          opts.json = true;\n          continue;\n        }\n        unknown.push(token);\n      }\n\n      if (unknown.length > 0) {\n        console.log(chalk.yellow(`  Unknown options: ${unknown.join(', ')}`));\n        printKeyUsage();\n        return 'handled';\n      }\n\n      await keyCreate(opts);\n      return 'handled';\n    }\n\n    if (action === 'show') {\n      const opts: { reveal?: boolean; copy?: boolean; json?: boolean } = {};\n      const unknown: string[] = [];\n      for (const token of rest) {\n        if (token === '--reveal') opts.reveal = true;\n        else if (token === '--copy') opts.copy = true;\n        else if (token === '--json') opts.json = true;\n        else unknown.push(token);\n      }\n      if (unknown.length > 0) {\n        console.log(chalk.yellow(`  Unknown options: ${unknown.join(', ')}`));\n        printKeyUsage();\n        return 'handled';\n      }\n      await keyShow(opts);\n      return 'handled';\n    }\n\n    if (action === 'copy') {\n      const unknown = rest.filter((token) => token !== '--json');\n      if (unknown.length > 0) {\n        console.log(chalk.yellow(`  Unknown options: ${unknown.join(', ')}`));\n        printKeyUsage();\n        return 'handled';\n      }\n      await keyCopy({ json: rest.includes('--json') });\n      return 'handled';\n    }\n\n    console.log(chalk.yellow(`  Unknown key action: ${action}`));\n    printKeyUsage();\n  } catch (err) {\n    console.error(chalk.red('\\u2717') + ` Key command failed: ${errorMessage(err)}`);\n  }\n\n  return 'handled';\n};\n\nconst permissionsHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  // Show current permissions or set one\n  const parts = args.trim().split(/\\s+/);\n  const toolName = parts[0];\n  const newPerm = parts[1];\n\n  if (!toolName) {\n    // List all tool permissions\n    const perms = ctx.config.permissions || {};\n    const defaults: Record<string, string> = {\n      read_file: 'allow', write_file: 'ask', edit_file: 'ask',\n      run_command: 'ask', ask_user: 'allow', list_dir: 'allow',\n      search_files: 'allow', find_files: 'allow',\n    };\n    const lines: string[] = [];\n    for (const [tool, defaultVal] of Object.entries(defaults)) {\n      const current = (perms as Record<string, string>)[tool] || defaultVal;\n      const color = current === 'allow' ? chalk.green : current === 'deny' ? chalk.red : chalk.yellow;\n      lines.push(`  ${chalk.dim(tool.padEnd(16))} ${color(current)}`);\n    }\n    console.log('\\n' + box('Tool Permissions', lines));\n    console.log(chalk.dim('  /permissions <tool> <allow|ask|deny>  \\u2014  change\\n'));\n    return 'handled';\n  }\n\n  if (!newPerm || !['allow', 'ask', 'deny'].includes(newPerm)) {\n    console.log(chalk.dim(`  Usage: /permissions ${toolName} <allow|ask|deny>`));\n    return 'handled';\n  }\n\n  try {\n    const { saveConfig } = await import('../../core/config.js');\n    await saveConfig({ permissions: { [toolName]: newPerm } });\n    const color = newPerm === 'allow' ? chalk.green : newPerm === 'deny' ? chalk.red : chalk.yellow;\n    console.log(chalk.green('\\u2713') + ` ${toolName}: ${color(newPerm)}`);\n  } catch (err) {\n    console.error(chalk.red('\\u2717') + ` Failed: ${errorMessage(err)}`);\n  }\n  return 'handled';\n};\n\n\n\nconst skillsHandler = async (_args: string, _ctx: SlashContext): Promise<SlashResult> => {\n  try {\n    const { TOOL_SCHEMAS } = await import('../../core/tools/schemas.js');\n    const { getAllCommands } = await import('./index.js');\n\n    const tools = TOOL_SCHEMAS.map(t => t.function.name).sort();\n    const slash = getAllCommands().map(c => `/${c.command}`).sort();\n\n    const lines: string[] = [\n      chalk.dim('Tool Skills'),\n      ...tools.map(t => `  ${chalk.cyan(t)}`),\n      '',\n      chalk.dim(`Slash Commands (${slash.length})`),\n      ...slash.slice(0, 20).map(c => `  ${chalk.green(c)}`),\n    ];\n    if (slash.length > 20) lines.push(chalk.dim(`  ... ${slash.length - 20} more`));\n\n    console.log(\"\\n\" + box(\"Skills\", lines));\n  } catch (err) {\n    console.error(chalk.red('') + ` ${errorMessage(err)}`);\n  }\n  return 'handled';\n};\n\nconst keysHandler = async (_args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const mask = (v?: string) => {\n    if (!v) return chalk.dim('(missing)');\n    if (v.length <= 10) return chalk.yellow(v);\n    return chalk.yellow(`${v.slice(0, 6)}...${v.slice(-4)}`);\n  };\n  const env = (ctx.config as Record<string, any>).env || {};\n  const tg = (ctx.config as Record<string, any>).channels?.telegram?.botToken;\n\n  const rows: string[] = [\n    kv('OPTA_API_KEY(env)', mask(process.env['OPTA_API_KEY']), 24),\n    kv('connection.apiKey', mask(ctx.config.connection.apiKey), 24),\n    kv('GEMINI_API_KEY', mask(env.GEMINI_API_KEY), 24),\n    kv('GROQ_API_KEY', mask(env.GROQ_API_KEY), 24),\n    kv('KIMI_API_KEY', mask(env.KIMI_API_KEY), 24),\n    kv('MINIMAX_API_KEY', mask(env.MINIMAX_API_KEY), 24),\n    kv('OPENCODE_API_KEY', mask(env.OPENCODE_API_KEY), 24),\n    kv('TELEGRAM_BOT_TOKEN', mask(tg), 24),\n  ];\n\n  console.log(\"\\n\" + box(\"Key Status (masked)\", rows));\n  console.log(chalk.dim('  Tip: /key create|show|copy manages Opta inference API keys.\\n'));\n  return 'handled';\n};\n\n// --- Helpers ---\n\nfunction getNestedValue(obj: Record<string, unknown>, path: string): unknown {\n  const keys = path.split('.');\n  let current: unknown = obj;\n  for (const k of keys) {\n    if (current === null || current === undefined || typeof current !== 'object') return undefined;\n    current = (current as Record<string, unknown>)[k];\n  }\n  return current;\n}\n\nfunction buildNestedObject(path: string, value: string): Record<string, unknown> {\n  const keys = path.split('.');\n  const result: Record<string, unknown> = {};\n  let current = result;\n\n  for (let i = 0; i < keys.length - 1; i++) {\n    const next: Record<string, unknown> = {};\n    current[keys[i]!] = next;\n    current = next;\n  }\n\n  // Auto-convert types\n  const lastKey = keys[keys.length - 1]!;\n  if (value === 'true') current[lastKey] = true;\n  else if (value === 'false') current[lastKey] = false;\n  else if (/^\\d+$/.test(value)) current[lastKey] = parseInt(value, 10);\n  else current[lastKey] = value;\n\n  return result;\n}\n\nfunction flattenConfig(obj: Record<string, unknown>, prefix = ''): [string, unknown][] {\n  const result: [string, unknown][] = [];\n  for (const [key, value] of Object.entries(obj)) {\n    const path = prefix ? `${prefix}.${key}` : key;\n    if (value !== null && typeof value === 'object' && !Array.isArray(value)) {\n      result.push(...flattenConfig(value as Record<string, unknown>, path));\n    } else {\n      result.push([path, value]);\n    }\n  }\n  return result;\n}\n\nexport const manageCommands: SlashCommandDef[] = [\n  {\n    command: 'config',\n    description: 'View/change settings',\n    handler: configHandler,\n    category: 'tools',\n    usage: '/config [list|get|set|reset|search|menu] [key] [value]',\n    examples: ['/config', '/config menu', '/config get connection.host', '/config set connection.port 1234', '/config reset', '/config search git'],\n  },\n  {\n    command: 'doctor',\n    description: 'Environment health check',\n    handler: doctorHandler,\n    category: 'info',\n    usage: '/doctor',\n    examples: ['/doctor'],\n  },\n  {\n    command: 'mcp',\n    aliases: ['mcps'],\n    description: 'Manage MCP servers (list/add/remove/test)',\n    handler: mcpHandler,\n    category: 'tools',\n    usage: '/mcp [list|add|add-playwright|remove|test] ...',\n    examples: ['/mcp', '/mcp add docs \"npx @modelcontextprotocol/server-filesystem .\"', '/mcp test docs'],\n  },\n  {\n    command: 'update',\n    description: 'Update Opta components (cli/lmx/plus/web)',\n    handler: updateHandler,\n    category: 'tools',\n    usage: '/update [--components ...] [--target ...] [--dry-run] [--no-build] [--no-pull]',\n    examples: ['/update --dry-run', '/update --components web --target local'],\n  },\n  {\n    command: 'server',\n    description: 'Manage chat-safe server lifecycle (daemon wrapper)',\n    handler: serverHandler,\n    category: 'server',\n    usage: '/server [start|stop|status|logs] [--host <host>] [--port <port>] [--json]',\n    examples: ['/server status', '/server start --host 127.0.0.1 --port 3456'],\n  },\n  {\n    command: 'daemon',\n    description: 'Manage daemon runtime (start/stop/status/logs/run)',\n    handler: daemonHandler,\n    category: 'server',\n    usage: '/daemon [start|stop|status|logs|run] [--host <host>] [--port <port>] [--json]',\n    examples: ['/daemon status', '/daemon start', '/daemon logs'],\n  },\n  {\n    command: 'completions',\n    description: 'Generate shell completions (bash/zsh/fish)',\n    handler: completionsHandler,\n    category: 'tools',\n    usage: '/completions <bash|zsh|fish>',\n    examples: ['/completions zsh'],\n  },\n  {\n    command: 'skills',\n    description: 'List available tool skills and slash commands',\n    handler: skillsHandler,\n    category: 'info',\n    usage: '/skills',\n    examples: ['/skills'],\n  },\n  {\n    command: 'key',\n    aliases: ['apikey'],\n    description: 'Manage Opta inference API key (create/show/copy)',\n    handler: keyHandler,\n    category: 'tools',\n    usage: '/key [create|show|copy] [options]',\n    examples: ['/key', '/key show --reveal', '/key create --no-remote', '/key copy'],\n  },\n  {\n    command: 'keys',\n    description: 'Show configured API key status (masked)',\n    handler: keysHandler,\n    category: 'info',\n    usage: '/keys',\n    examples: ['/keys'],\n  },\n  {\n    command: 'quickfix',\n    aliases: ['fix', 'repair'],\n    description: 'Auto-repair config issues',\n    handler: quickfixHandler,\n    category: 'tools',\n    usage: '/quickfix',\n    examples: ['/quickfix', '/fix'],\n  },\n  {\n    command: 'permissions',\n    aliases: ['perms', 'perm'],\n    description: 'View/set tool permissions',\n    handler: permissionsHandler,\n    category: 'tools',\n    usage: '/permissions [tool] [allow|ask|deny]',\n    examples: ['/permissions', '/permissions edit_file allow', '/permissions run_command deny'],\n  },\n];\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/commands/slash/model.ts","messages":[{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":1,"message":"Invalid type \"unknown\" of template literal expression.","line":195,"column":71,"nodeType":"Identifier","messageId":"invalidType","endLine":195,"endColumn":74},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":218,"column":43,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":218,"endColumn":45,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[8372,8374],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":218,"column":54,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":218,"endColumn":56,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[8383,8385],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/return-await","severity":1,"message":"Returning an awaited promise is required in this context.","line":224,"column":18,"nodeType":"CallExpression","messageId":"requiredPromiseAwait","endLine":224,"endColumn":32,"suggestions":[{"messageId":"requiredPromiseAwaitSuggestion","fix":{"range":[8723,8723],"text":"await "},"desc":"Add `await` before the expression. Use caution as this may impact control flow."}]},{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":1,"message":"Invalid type \"unknown\" of template literal expression.","line":367,"column":41,"nodeType":"Identifier","messageId":"invalidType","endLine":367,"endColumn":44}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Model and agent profile slash commands: /model, /agent\n */\n\nimport chalk from 'chalk';\nimport type { SlashCommandDef, SlashContext, SlashResult } from './types.js';\nimport { runMenuPrompt } from '../../ui/prompt-nav.js';\n\nconst STABLE_MODEL_LOAD_TIMEOUT_MS = 300_000;\n\nimport type { ModelGroup } from '../../lmx/model-catalog.js';\n\ntype ModelConfigExtended = { favourites?: string[]; groups?: ModelGroup[] };\n\n/** Toggle a model ID in the favourites list and persist to config. */\nasync function toggleFavourite(modelId: string, current: string[]): Promise<string[]> {\n  const { saveConfig } = await import('../../core/config.js');\n  const normalised = modelId.trim();\n  const exists = current.some(f => f === normalised);\n  const updated = exists\n    ? current.filter(f => f !== normalised)\n    : [...current, normalised];\n  await saveConfig({ 'model.favourites': updated });\n  return updated;\n}\n\n/** Persist an updated groups array to config. */\nasync function saveGroups(groups: ModelGroup[]): Promise<void> {\n  const { saveConfig } = await import('../../core/config.js');\n  await saveConfig({ 'model.groups': groups });\n}\n\nconst groupHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const { DEFAULT_GROUPS } = await import('../../lmx/model-catalog.js');\n  const modelCfg = ctx.config.model as ModelConfigExtended;\n  const currentGroups: ModelGroup[] = modelCfg.groups ?? DEFAULT_GROUPS;\n\n  const parts = args.trim().split(/\\s+/);\n  const sub = parts[0] ?? '';\n\n  if (!sub) {\n    // List groups\n    console.log(chalk.bold('Model groups') + chalk.dim(modelCfg.groups ? '' : '  (built-in defaults)'));\n    for (const g of currentGroups) {\n      const pats = g.patterns.length ? chalk.dim(`  [${g.patterns.join(', ')}]`) : chalk.dim('  [catch-all]');\n      const color = g.color ?? '#94a3b8';\n      console.log(`  ${chalk.hex(color)(g.label.padEnd(20))} ${chalk.dim(g.name)}${pats}`);\n    }\n    console.log(chalk.dim('\\n  /model group add <name> <label>'));\n    console.log(chalk.dim('  /model group rm <name>'));\n    console.log(chalk.dim('  /model group pattern <name> <pattern>'));\n    console.log(chalk.dim('  /model group reset   restore built-in defaults'));\n    return 'handled';\n  }\n\n  if (sub === 'reset') {\n    await saveGroups([]);\n    const { saveConfig } = await import('../../core/config.js');\n    // Remove override entirely so defaults kick in\n    await saveConfig({ 'model.groups': undefined });\n    console.log(chalk.green('') + ' Model groups reset to built-in defaults');\n    return 'handled';\n  }\n\n  if (sub === 'add') {\n    const name = parts[1];\n    const label = parts.slice(2).join(' ');\n    if (!name || !label) {\n      console.log(chalk.yellow('Usage: /model group add <name> <label>'));\n      return 'handled';\n    }\n    if (currentGroups.some(g => g.name === name)) {\n      console.log(chalk.yellow(`  Group \"${name}\" already exists`));\n      return 'handled';\n    }\n    const updated = [...currentGroups, { name, label, patterns: [] }];\n    await saveGroups(updated);\n    console.log(chalk.green('') + ` Added group \"${name}\"  use /model group pattern ${name} <pattern> to add patterns`);\n    return 'handled';\n  }\n\n  if (sub === 'rm') {\n    const name = parts[1];\n    if (!name) { console.log(chalk.yellow('Usage: /model group rm <name>')); return 'handled'; }\n    const updated = currentGroups.filter(g => g.name !== name);\n    if (updated.length === currentGroups.length) {\n      console.log(chalk.yellow(`  Group \"${name}\" not found`));\n      return 'handled';\n    }\n    await saveGroups(updated);\n    console.log(chalk.green('') + ` Removed group \"${name}\"`);\n    return 'handled';\n  }\n\n  if (sub === 'pattern') {\n    const name = parts[1];\n    const pattern = parts.slice(2).join(' ');\n    if (!name || !pattern) {\n      console.log(chalk.yellow('Usage: /model group pattern <name> <pattern>'));\n      return 'handled';\n    }\n    const updated = currentGroups.map(g =>\n      g.name === name ? { ...g, patterns: [...g.patterns, pattern] } : g\n    );\n    if (!updated.some(g => g.name === name)) {\n      console.log(chalk.yellow(`  Group \"${name}\" not found`));\n      return 'handled';\n    }\n    await saveGroups(updated);\n    console.log(chalk.green('') + ` Added pattern \"${pattern}\" to group \"${name}\"`);\n    return 'handled';\n  }\n\n  console.log(chalk.yellow(`  Unknown group sub-command: ${sub}`));\n  return 'handled';\n};\n\nconst modelHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const trimmedArgs = args.trim();\n\n  // /model group ...  manage groups\n  if (trimmedArgs.startsWith('group')) {\n    return groupHandler(trimmedArgs.slice(5).trim(), ctx);\n  }\n\n  // /model fav [name]  toggle or list favourites\n  if (trimmedArgs.startsWith('fav')) {\n    const favTarget = trimmedArgs.slice(3).trim();\n    const currentFavs: string[] = (ctx.config.model as { favourites?: string[] }).favourites ?? [];\n\n    if (!favTarget) {\n      if (currentFavs.length === 0) {\n        console.log(chalk.dim('  No favourites yet  use /model fav <model-id> to pin a model'));\n      } else {\n        console.log(chalk.yellow('') + ' Favourites:');\n        for (const f of currentFavs) {\n          const isCurrent = f === ctx.config.model.default;\n          console.log(`  ${isCurrent ? chalk.green('') : ' '} ${f}`);\n        }\n        console.log(chalk.dim('\\n  /model fav <name> to toggle'));\n      }\n      return 'handled';\n    }\n\n    const updated = await toggleFavourite(favTarget, currentFavs);\n    const added = updated.includes(favTarget);\n    const icon = added ? chalk.yellow('') : chalk.dim('');\n    const verb = added ? 'Added to' : 'Removed from';\n    console.log(`${icon} ${verb} favourites: ${favTarget}`);\n    return 'handled';\n  }\n\n  if (trimmedArgs) {\n    // Direct switch: /model <name>\n    try {\n      let selectedModel = trimmedArgs;\n      const { LmxClient, lookupContextLimit } = await import('../../lmx/client.js');\n      const { ensureModelLoaded, findMatchingModelId } = await import('../../lmx/model-lifecycle.js');\n\n      const lmx = new LmxClient({\n        host: ctx.config.connection.host,\n        fallbackHosts: ctx.config.connection.fallbackHosts,\n        port: ctx.config.connection.port,\n        adminKey: ctx.config.connection.adminKey,\n      });\n\n      const [loadedRes, available] = await Promise.all([\n        lmx.models().catch(() => ({ models: [] })),\n        lmx.available().catch(() => []),\n      ]);\n      const loadedIds = loadedRes.models.map((m) => m.model_id);\n      const loadedMatch = findMatchingModelId(selectedModel, loadedIds);\n      if (loadedMatch) {\n        selectedModel = loadedMatch;\n      } else {\n        const onDiskMatch = findMatchingModelId(selectedModel, available.map((m) => m.repo_id));\n        if (onDiskMatch) {\n          const loadedId = await ensureModelLoaded(lmx, onDiskMatch, { timeoutMs: STABLE_MODEL_LOAD_TIMEOUT_MS });\n          selectedModel = loadedId;\n          console.log(chalk.green('\\u2713') + ` Loaded ${loadedId}`);\n        }\n      }\n\n      const { saveConfig } = await import('../../core/config.js');\n      await saveConfig({\n        model: {\n          default: selectedModel,\n          contextLimit: lookupContextLimit(selectedModel),\n        },\n      });\n      ctx.session.model = selectedModel;\n      console.log(chalk.green('\\u2713') + ` Switched to ${selectedModel}`);\n      return 'model-switched';\n    } catch (err) {\n      console.error(chalk.red('\\u2717') + ` Failed to switch model: ${err}`);\n      return 'handled';\n    }\n  }\n\n  // Interactive model picker: category-based with Favourites at top\n  try {\n    const { LmxClient, lookupContextLimit } = await import('../../lmx/client.js');\n    const { select, Separator } = await import('@inquirer/prompts');\n    const { classifyModel, DEFAULT_GROUPS } = await import('../../lmx/model-catalog.js');\n    const activeGroups = (ctx.config.model as ModelConfigExtended).groups ?? DEFAULT_GROUPS;\n\n    const lmx = new LmxClient({\n      host: ctx.config.connection.host,\n      fallbackHosts: ctx.config.connection.fallbackHosts,\n      port: ctx.config.connection.port,\n      adminKey: ctx.config.connection.adminKey,\n    });\n\n    const [loadedRes, availRes, cloudModels] = await Promise.all([\n      lmx.models().catch(() => null),\n      lmx.available().catch(() => null),\n      (async () => {\n        const hasKey = ctx.config.provider?.anthropic?.apiKey || process.env['ANTHROPIC_API_KEY'];\n        if (!hasKey) return [];\n        try {\n          const { getProvider } = await import('../../providers/manager.js');\n          const cfg = { ...ctx.config, provider: { ...ctx.config.provider, active: 'anthropic' as const } };\n          const p = await getProvider(cfg);\n          return p.listModels();\n        } catch { return []; }\n      })(),\n    ]);\n\n    const loadedModels = loadedRes?.models ?? [];\n    const toKey = (v: string) => v.toLowerCase().replace(/[^a-z0-9]+/g, '');\n    const loadedKeys = new Set(loadedModels.map((m) => toKey(m.model_id)));\n    const onDisk = (availRes ?? []).filter((a) => !loadedKeys.has(toKey(a.repo_id)));\n    const favourites: string[] = (ctx.config.model as { favourites?: string[] }).favourites ?? [];\n    const favSet = new Set(favourites);\n\n    if (loadedModels.length === 0 && onDisk.length === 0 && cloudModels.length === 0) {\n      console.log(chalk.dim('  No models found (LMX unreachable, no Anthropic key)'));\n      return 'handled';\n    }\n\n    type Choice = { name: string; value: string } | typeof Separator.prototype;\n    const choices: Choice[] = [];\n    const sep = (label: string) => new Separator(chalk.dim(` ${label} `));\n\n    // Helper: build a display line for a local model\n    const localLine = (\n      id: string,\n      ctxK: number,\n      status: 'loaded' | 'on-disk',\n      extras: string[],\n    ): string => {\n      const isCurrent = id === ctx.config.model.default;\n      const isFav = favSet.has(id);\n      const dot = isCurrent ? chalk.green('') : ' ';\n      const star = isFav ? chalk.yellow('') : ' ';\n      const statusTag = status === 'loaded' ? chalk.green('loaded') : chalk.dim('on disk');\n      const meta = chalk.dim([`${ctxK}K`, ...extras, statusTag].filter(Boolean).join('  '));\n      return `${dot}${star} ${id}  ${meta}`;\n    };\n\n    //  Favourites \n    if (favourites.length > 0) {\n      choices.push(sep('Favourites '));\n      for (const favId of favourites) {\n        const loaded = loadedModels.find(m => m.model_id === favId || toKey(m.model_id) === toKey(favId));\n        const disk = onDisk.find(a => a.repo_id === favId || toKey(a.repo_id) === toKey(favId));\n        const cloud = cloudModels.find(m => m.id === favId);\n\n        if (loaded) {\n          const ctxK = Math.round((loaded.context_length ?? lookupContextLimit(loaded.model_id)) / 1000);\n          const memStr = loaded.memory_bytes ? `${(loaded.memory_bytes / 1e9).toFixed(0)}GB` : '';\n          choices.push({ name: localLine(loaded.model_id, ctxK, 'loaded', [memStr].filter(Boolean)), value: loaded.model_id });\n        } else if (disk) {\n          const ctxK = Math.round(lookupContextLimit(disk.repo_id) / 1000);\n          const sizeStr = disk.size_bytes > 0 ? `${(disk.size_bytes / 1e9).toFixed(1)}GB` : '';\n          choices.push({ name: localLine(disk.repo_id, ctxK, 'on-disk', [sizeStr].filter(Boolean)), value: disk.repo_id });\n        } else if (cloud) {\n          const ctxStr = cloud.contextLength ? `${Math.round(cloud.contextLength / 1000)}K` : '';\n          const meta = chalk.dim([cloud.name ?? '', ctxStr, chalk.blue('cloud')].filter(Boolean).join('  '));\n          const isCurrent = cloud.id === ctx.config.model.default;\n          choices.push({ name: `${isCurrent ? chalk.green('') : ' '}${chalk.yellow('')} ${chalk.blue('')} ${cloud.id}  ${meta}`, value: cloud.id });\n        } else {\n          // Favourite no longer available  show greyed out\n          choices.push({ name: `  ${chalk.yellow('')} ${chalk.dim(favId)}  ${chalk.dim('unavailable')}`, value: favId });\n        }\n      }\n    }\n\n    // Build per-group buckets for non-favourite LMX models\n    const groupBuckets = new Map<string, Choice[]>();\n\n    for (const m of loadedModels) {\n      if (favSet.has(m.model_id)) continue;\n      const group = classifyModel(m.model_id, activeGroups);\n      const key = group?.name ?? activeGroups[activeGroups.length - 1]?.name ?? 'other';\n      const ctxK = Math.round((m.context_length ?? lookupContextLimit(m.model_id)) / 1000);\n      const memStr = m.memory_bytes ? `${(m.memory_bytes / 1e9).toFixed(0)}GB` : '';\n      const reqStr = m.request_count ? `${m.request_count} reqs` : '';\n      const bucket = groupBuckets.get(key) ?? [];\n      bucket.push({ name: localLine(m.model_id, ctxK, 'loaded', [memStr, reqStr].filter(Boolean)), value: m.model_id });\n      groupBuckets.set(key, bucket);\n    }\n\n    for (const a of onDisk) {\n      if (favSet.has(a.repo_id)) continue;\n      const group = classifyModel(a.repo_id, activeGroups);\n      const key = group?.name ?? activeGroups[activeGroups.length - 1]?.name ?? 'other';\n      const ctxK = Math.round(lookupContextLimit(a.repo_id) / 1000);\n      const sizeStr = a.size_bytes > 0 ? `${(a.size_bytes / 1e9).toFixed(1)}GB` : '';\n      const bucket = groupBuckets.get(key) ?? [];\n      bucket.push({ name: localLine(a.repo_id, ctxK, 'on-disk', [sizeStr].filter(Boolean)), value: a.repo_id });\n      groupBuckets.set(key, bucket);\n    }\n\n    // Emit group sections in user-defined order\n    for (const group of activeGroups) {\n      const bucket = groupBuckets.get(group.name);\n      if (!bucket || bucket.length === 0) continue;\n      const color = group.color ?? '#94a3b8';\n      choices.push(sep(chalk.hex(color)(group.label)));\n      choices.push(...bucket);\n    }\n\n    // Anthropic cloud models (not in favourites)\n    const nonFavCloud = cloudModels.filter(m => !favSet.has(m.id));\n    if (nonFavCloud.length > 0) {\n      choices.push(sep(chalk.blue('  Anthropic')));\n      for (const m of nonFavCloud) {\n        const isCurrent = m.id === ctx.config.model.default;\n        const ctxStr = m.contextLength ? `${Math.round(m.contextLength / 1000)}K` : '';\n        const meta = chalk.dim([m.name ?? '', ctxStr].filter(Boolean).join('  '));\n        choices.push({ name: `${isCurrent ? chalk.green('') : ' '}  ${chalk.blue('\\u2601')} ${m.id}  ${meta}`, value: m.id });\n      }\n    }\n\n    if (choices.filter(c => !('separator' in c)).length === 0) {\n      console.log(chalk.dim('  No models available'));\n      return 'handled';\n    }\n\n    let selectedModel: string;\n    try {\n      const hint = chalk.dim('  /model fav <name> to pin    /model <name> to switch directly');\n      console.log(hint);\n      const picked = await runMenuPrompt((context) =>\n        select({ message: chalk.dim('Select model'), choices }, context), 'select');\n      if (!picked) return 'handled';\n      selectedModel = picked;\n    } catch {\n      return 'handled';\n    }\n\n    if (selectedModel === ctx.config.model.default) {\n      console.log(chalk.dim(`  Already using ${selectedModel}`));\n      return 'handled';\n    }\n\n    // Load if on disk\n    if (onDisk.some(a => a.repo_id === selectedModel)) {\n      const { default: ora } = await import('ora');\n      const { ensureModelLoaded } = await import('../../lmx/model-lifecycle.js');\n      const spinner = ora({ text: `Loading ${selectedModel}...`, color: 'magenta' }).start();\n      try {\n        selectedModel = await ensureModelLoaded(lmx, selectedModel, { timeoutMs: STABLE_MODEL_LOAD_TIMEOUT_MS });\n        spinner.succeed(`Loaded ${selectedModel}`);\n      } catch (err) {\n        spinner.fail(`Failed to load: ${err}`);\n        return 'handled';\n      }\n    }\n\n    // Switch provider if cloud model selected\n    if (cloudModels.some(m => m.id === selectedModel)) {\n      const { saveConfig } = await import('../../core/config.js');\n      await saveConfig({\n        provider: { ...ctx.config.provider, active: 'anthropic' },\n        model: { default: selectedModel, contextLimit: 200000 },\n      });\n      ctx.session.model = selectedModel;\n      console.log(chalk.green('\\u2713') + ` Switched to ${selectedModel} ${chalk.dim('(Anthropic)')}`);\n      return 'model-switched';\n    }\n\n    const { saveConfig } = await import('../../core/config.js');\n    const ctxLimit = lookupContextLimit(selectedModel);\n    await saveConfig({ model: { default: selectedModel, contextLimit: ctxLimit } });\n    ctx.session.model = selectedModel;\n    console.log(chalk.green('\\u2713') + ` Switched to ${selectedModel}`);\n    return 'model-switched';\n  } catch {\n    console.log(chalk.dim(`  Current model: ${ctx.config.model.default}`));\n    console.log(chalk.dim(`  LMX unreachable \\u2014 use /model <name> to switch manually`));\n    return 'handled';\n  }\n};\n\nconst agentHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const { getAgentProfile, listAgentProfiles } = await import('../../core/agent-profiles.js');\n\n  if (args) {\n    // Direct switch: /agent <name>\n    const profile = getAgentProfile(args);\n    if (!profile) {\n      console.log(chalk.yellow(`  Unknown agent profile: ${args}`) + chalk.dim(' (try /agent to see options)'));\n      return 'handled';\n    }\n    ctx.chatState.agentProfile = profile.name;\n    const betaTag = profile.beta ? chalk.yellow(' [beta]') : '';\n    console.log(chalk.green('\\u2713') + ` Agent: ${chalk.bold(profile.name)}${betaTag} \\u2014 ${chalk.dim(profile.description)}`);\n    console.log(chalk.dim(`  Tools: ${profile.tools.length} enabled`));\n    if (profile.suggestedModel) {\n      console.log(chalk.dim(`  Suggested model: ${profile.suggestedModel}  switch with /model ${profile.suggestedModel}`));\n    }\n    return 'handled';\n  }\n\n  // Interactive picker\n  const { select } = await import('@inquirer/prompts');\n  const profiles = listAgentProfiles();\n  const currentProfile = ctx.chatState.agentProfile;\n\n  const choices = profiles.map(p => {\n    const isCurrent = p.name === currentProfile;\n    const dot = isCurrent ? chalk.green('\\u25cf ') : '  ';\n    const betaTag = p.beta ? chalk.yellow(' [beta]') : '';\n    return {\n      name: `${dot}${chalk.bold(p.name.padEnd(14))}${betaTag} ${chalk.dim(p.description)}  ${chalk.dim(`(${p.tools.length} tools)`)}`,\n      value: p.name,\n    };\n  });\n\n  let selected: string;\n  try {\n    const picked = await runMenuPrompt((context) =>\n      select({\n        message: chalk.dim('Select agent profile'),\n        choices,\n      }, context), 'select');\n    if (!picked) return 'handled';\n    selected = picked;\n  } catch {\n    return 'handled'; // Ctrl+C\n  }\n\n  const profile = getAgentProfile(selected);\n  if (profile) {\n    ctx.chatState.agentProfile = profile.name;\n    const betaTag = profile.beta ? chalk.yellow(' [beta]') : '';\n    console.log(chalk.green('\\u2713') + ` Agent: ${chalk.bold(profile.name)}${betaTag} \\u2014 ${chalk.dim(profile.description)}`);\n    console.log(chalk.dim(`  Tools: ${profile.tools.length} enabled`));\n    if (profile.suggestedModel) {\n      console.log(chalk.dim(`  Suggested model: ${profile.suggestedModel}  switch with /model ${profile.suggestedModel}`));\n    }\n  }\n  return 'handled';\n};\n\nexport const modelCommands: SlashCommandDef[] = [\n  {\n    command: 'model',\n    description: 'Switch model  category picker with favourites and use-case grouping',\n    handler: modelHandler,\n    category: 'session',\n    usage: '/model [name|fav [name]|group [sub-command]]',\n    examples: ['/model llama3', '/model fav dolphin-mixtral', '/model group', '/model group add work \" Work\"', '/model'],\n  },\n  {\n    command: 'agent',\n    aliases: ['profile'],\n    description: 'Switch agent profile',\n    handler: agentHandler,\n    category: 'session',\n    usage: '/agent [profile-name]',\n    examples: ['/agent coder', '/agent researcher', '/agent'],\n  },\n];\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/commands/slash/research.ts","messages":[{"ruleId":"@typescript-eslint/require-await","severity":1,"message":"Async arrow function 'researchHandler' has no 'await' expression.","line":36,"column":87,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":36,"endColumn":89,"suggestions":[{"messageId":"removeAsync","fix":{"range":[1154,1215],"text":"(args: string, ctx: SlashContext): SlashResult"},"desc":"Remove 'async'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Research mode slash command: /research\n *\n * Toggles a research mode that allows reading and running commands\n * but denies file modifications. Tracks research activity in the session\n * so /plan can detect when research has been done.\n */\n\nimport chalk from 'chalk';\nimport type { SlashCommandDef, SlashContext, SlashResult } from './types.js';\n\nfunction captureResearchActivation(args: string, ctx: SlashContext): void {\n  void import('../../learning/hooks.js')\n    .then(({ captureLearningEvent }) =>\n      captureLearningEvent(\n        ctx.config,\n        {\n          kind: 'research',\n          topic: args ? `Research mode: ${args}` : 'Research mode activated',\n          content: args\n            ? `Research mode entered with topic: ${args}`\n            : 'Research mode entered for exploratory investigation.',\n          tags: ['research', 'mode'],\n          evidence: [{ label: 'session', uri: `session://${ctx.session.id}` }],\n          metadata: {\n            sessionId: ctx.session.id,\n            command: '/research',\n          },\n          verified: true,\n        },\n      ),\n    )\n    .catch(() => {});\n}\n\nconst researchHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  // Toggle off if already in research mode and no args\n  if (!args && ctx.chatState.currentMode === 'research') {\n    ctx.chatState.currentMode = 'normal';\n    console.log(chalk.green('\\u2713') + ' Exited research mode');\n    return 'handled';\n  }\n\n  // Enter research mode\n  ctx.chatState.currentMode = 'research';\n  console.log(chalk.blue('\\u2713') + ' Entered research mode \\u2014 explore and investigate');\n  console.log(chalk.dim('  Allowed: read, search, run commands, web search/fetch'));\n  console.log(chalk.dim('  Blocked: file edits, writes, deletes'));\n\n  // Mark that research has been done in this session\n  ctx.session.messages.push({\n    role: 'user',\n    content: args\n      ? `[System: Research mode activated. Research topic: ${args}]`\n      : '[System: Research mode activated. Explore the codebase, search the web, run diagnostic commands, and take notes.]',\n  });\n  captureResearchActivation(args, ctx);\n\n  console.log(chalk.dim('  Type /research to exit'));\n  return 'handled';\n};\n\nexport const researchCommands: SlashCommandDef[] = [\n  {\n    command: 'research',\n    aliases: ['explore'],\n    description: 'Toggle research mode',\n    handler: researchHandler,\n    category: 'session',\n  },\n];\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/commands/slash/review.ts","messages":[{"ruleId":"@typescript-eslint/require-await","severity":1,"message":"Async arrow function 'reviewHandler' has no 'await' expression.","line":11,"column":85,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":11,"endColumn":87,"suggestions":[{"messageId":"removeAsync","fix":{"range":[303,364],"text":"(args: string, ctx: SlashContext): SlashResult"},"desc":"Remove 'async'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Code review slash command: /review\n *\n * Toggles a read-only review mode that denies all write/execute tools,\n * or optionally targets a specific file for review.\n */\n\nimport chalk from 'chalk';\nimport type { SlashCommandDef, SlashContext, SlashResult } from './types.js';\n\nconst reviewHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  // Toggle off if already in review mode and no args\n  if (!args && ctx.chatState.currentMode === 'review') {\n    ctx.chatState.currentMode = 'normal';\n    console.log(chalk.green('\\u2713') + ' Exited review mode');\n    return 'handled';\n  }\n\n  // Enter review mode\n  ctx.chatState.currentMode = 'review';\n  console.log(chalk.magenta('\\u2713') + ' Entered review mode \\u2014 read-only analysis');\n  console.log(chalk.dim('  All write/execute tools are blocked'));\n\n  // If a file path was provided, inject it as context\n  if (args) {\n    const filePath = args.trim();\n    ctx.session.messages.push({\n      role: 'user',\n      content: `[System: Review mode activated. Please review the following file for bugs, security issues, performance problems, and code style: ${filePath}]`,\n    });\n    console.log(chalk.dim(`  Target: ${filePath}`));\n  }\n\n  console.log(chalk.dim('  Type /review to exit'));\n  return 'handled';\n};\n\nexport const reviewCommands: SlashCommandDef[] = [\n  {\n    command: 'review',\n    description: 'Toggle code review mode',\n    handler: reviewHandler,\n    category: 'tools',\n  },\n];\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/commands/slash/session.ts","messages":[{"ruleId":"@typescript-eslint/require-await","severity":1,"message":"Async arrow function 'exitHandler' has no 'await' expression.","line":35,"column":85,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":35,"endColumn":87,"suggestions":[{"messageId":"removeAsync","fix":{"range":[1430,1493],"text":"(_args: string, _ctx: SlashContext): SlashResult"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":1,"message":"Async arrow function 'clearHandler' has no 'await' expression.","line":39,"column":86,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":39,"endColumn":88,"suggestions":[{"messageId":"removeAsync","fix":{"range":[1541,1604],"text":"(_args: string, _ctx: SlashContext): SlashResult"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/unbound-method","severity":1,"message":"A method that is not declared with `this: void` may cause unintentional scoping of `this` when separated from its object.\nConsider using an arrow function or explicitly `.bind()`ing the method to avoid calling the method with an unintended `this` value. \nIf a function does not access `this`, it can be annotated with `this: void`.","line":46,"column":11,"nodeType":"Identifier","messageId":"unboundWithoutThisAnnotation","endLine":46,"endColumn":15},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, value is always truthy.","line":83,"column":10,"nodeType":"Literal","messageId":"alwaysTruthy","endLine":83,"endColumn":14},{"ruleId":"@typescript-eslint/unbound-method","severity":1,"message":"A method that is not declared with `this: void` may cause unintentional scoping of `this` when separated from its object.\nConsider using an arrow function or explicitly `.bind()`ing the method to avoid calling the method with an unintended `this` value. \nIf a function does not access `this`, it can be annotated with `this: void`.","line":143,"column":17,"nodeType":"Identifier","messageId":"unboundWithoutThisAnnotation","endLine":143,"endColumn":21},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":192,"column":19,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":192,"endColumn":29},{"ruleId":"@typescript-eslint/unbound-method","severity":1,"message":"A method that is not declared with `this: void` may cause unintentional scoping of `this` when separated from its object.\nConsider using an arrow function or explicitly `.bind()`ing the method to avoid calling the method with an unintended `this` value. \nIf a function does not access `this`, it can be annotated with `this: void`.","line":266,"column":11,"nodeType":"Identifier","messageId":"unboundWithoutThisAnnotation","endLine":266,"endColumn":15},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":308,"column":21,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":308,"endColumn":30},{"ruleId":"@typescript-eslint/unbound-method","severity":1,"message":"A method that is not declared with `this: void` may cause unintentional scoping of `this` when separated from its object.\nConsider using an arrow function or explicitly `.bind()`ing the method to avoid calling the method with an unintended `this` value. \nIf a function does not access `this`, it can be annotated with `this: void`.","line":313,"column":13,"nodeType":"Identifier","messageId":"unboundWithoutThisAnnotation","endLine":313,"endColumn":20},{"ruleId":"@typescript-eslint/unbound-method","severity":1,"message":"A method that is not declared with `this: void` may cause unintentional scoping of `this` when separated from its object.\nConsider using an arrow function or explicitly `.bind()`ing the method to avoid calling the method with an unintended `this` value. \nIf a function does not access `this`, it can be annotated with `this: void`.","line":313,"column":35,"nodeType":"Identifier","messageId":"unboundWithoutThisAnnotation","endLine":313,"endColumn":42},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":349,"column":18,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":349,"endColumn":34},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":365,"column":41,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":365,"endColumn":57},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":377,"column":25,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":377,"endColumn":41},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":385,"column":39,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":385,"endColumn":55},{"ruleId":"@typescript-eslint/require-await","severity":1,"message":"Async arrow function 'costHandler' has no 'await' expression.","line":402,"column":84,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":402,"endColumn":86,"suggestions":[{"messageId":"removeAsync","fix":{"range":[14107,14169],"text":"(_args: string, ctx: SlashContext): SlashResult"},"desc":"Remove 'async'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Session-related slash commands: /exit, /clear, /save, /share, /export, /sessions, /init, /editor, /image\n */\n\nimport chalk from 'chalk';\nimport { errorMessage } from '../../utils/errors.js';\nimport { agentLoop } from '../../core/agent.js';\nimport { generateTitle, saveSession } from '../../memory/store.js';\nimport { estimateTokens, formatTokens } from '../../utils/tokens.js';\nimport { runMenuPrompt } from '../../ui/prompt-nav.js';\nimport type { SlashCommandDef, SlashContext, SlashResult } from './types.js';\n\nfunction parseSlashArgs(raw: string): string[] {\n  const tokens: string[] = [];\n  const pattern = /\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\"|'([^'\\\\]*(?:\\\\.[^'\\\\]*)*)'|`([^`\\\\]*(?:\\\\.[^`\\\\]*)*)`|([^\\s]+)/g;\n  let match: RegExpExecArray | null;\n\n  while ((match = pattern.exec(raw)) !== null) {\n    const captured = match[1] ?? match[2] ?? match[3] ?? match[4] ?? '';\n    tokens.push(captured.replace(/\\\\([\"'`\\\\])/g, '$1'));\n  }\n\n  return tokens;\n}\n\nfunction printSessionsUsage(): void {\n  console.log(chalk.dim('  Usage: /sessions [list|resume|delete|export|search|menu] [id|query] [options]'));\n  console.log(chalk.dim('    /sessions'));\n  console.log(chalk.dim('    /sessions list --limit 20 --model minimax --since 7d --tag bugfix'));\n  console.log(chalk.dim('    /sessions search \"auth bug\"'));\n  console.log(chalk.dim('    /sessions resume <id>'));\n  console.log(chalk.dim('    /sessions menu'));\n}\n\nconst exitHandler = async (_args: string, _ctx: SlashContext): Promise<SlashResult> => {\n  return 'exit';\n};\n\nconst clearHandler = async (_args: string, _ctx: SlashContext): Promise<SlashResult> => {\n  console.clear();\n  return 'handled';\n};\n\nconst shareHandler = async (_args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const { writeFile } = await import('node:fs/promises');\n  const { join } = await import('node:path');\n  const { select } = await import('@inquirer/prompts');\n  const { formatSessionExport } = await import('../share.js');\n  type ExportFormat = import('../share.js').ExportFormat;\n\n  let format: ExportFormat = 'markdown';\n  try {\n    const picked = await runMenuPrompt((context) =>\n      select<ExportFormat>({\n        message: chalk.dim('Export format'),\n        choices: [\n          { name: 'Markdown (.md)', value: 'markdown' as ExportFormat },\n          { name: 'JSON (.json)', value: 'json' as ExportFormat },\n          { name: 'Plain text (.txt)', value: 'text' as ExportFormat },\n        ],\n      }, context), 'select');\n    if (!picked) return 'handled';\n    format = picked;\n  } catch {\n    return 'handled'; // Ctrl+C\n  }\n\n  const ext = format === 'json' ? 'json' : format === 'text' ? 'txt' : 'md';\n  const filename = `opta-session-${ctx.session.id.slice(0, 8)}-${Date.now()}.${ext}`;\n  const filepath = join(process.cwd(), filename);\n\n  const content = formatSessionExport(ctx.session, format);\n  await writeFile(filepath, content, 'utf-8');\n  console.log(chalk.green('\\u2713') + ` Exported to ${chalk.cyan(filename)}`);\n  return 'handled';\n};\n\nconst interactiveSessionsBrowser = async (ctx: SlashContext): Promise<SlashResult> => {\n  const { listSessions, deleteSession, loadSession: loadSess } = await import('../../memory/store.js');\n  const { formatSessionExport } = await import('../share.js');\n  const { select } = await import('@inquirer/prompts');\n\n  while (true) {\n    const allSessions = await listSessions();\n    if (allSessions.length === 0) {\n      console.log(chalk.dim('  No saved sessions'));\n      return 'handled';\n    }\n\n    const items = allSessions.slice(0, 15);\n    const choices = items.map((s) => {\n      const isCurrent = s.id === ctx.session.id;\n      const dot = isCurrent ? chalk.green('\\u25cf ') : '  ';\n      const title = (s.title || 'Untitled').slice(0, 30);\n      const meta = chalk.dim(`${s.messageCount} msgs \\u00b7 ${new Date(s.created).toLocaleDateString()}`);\n      return {\n        name: `${dot}${s.id.slice(0, 8)}  ${title}  ${meta}`,\n        value: s.id,\n      };\n    });\n\n    let selectedId: string;\n    try {\n      const picked = await runMenuPrompt((context) =>\n        select({\n          message: chalk.dim('Select session'),\n          choices,\n        }, context), 'select');\n      if (!picked) return 'handled';\n      selectedId = picked;\n    } catch {\n      return 'handled'; // Ctrl+C\n    }\n\n    const isCurrent = selectedId === ctx.session.id;\n    const actionChoices = [\n      ...(isCurrent ? [] : [{ name: 'Resume this session', value: 'resume' }]),\n      { name: 'Export session', value: 'export' },\n      { name: 'Delete session', value: 'delete' },\n      { name: 'Cancel', value: 'cancel' },\n    ];\n\n    let action: string;\n    try {\n      const picked = await runMenuPrompt((context) =>\n        select({\n          message: chalk.dim(`Action for ${selectedId.slice(0, 8)}`),\n          choices: actionChoices,\n        }, context), 'select');\n      // Back key from action prompt should return to the session list.\n      if (!picked) continue;\n      action = picked;\n    } catch {\n      return 'handled';\n    }\n\n    switch (action) {\n      case 'resume':\n        console.log(chalk.dim(`  To resume, run: opta chat -r ${selectedId.slice(0, 8)}`));\n        return 'handled';\n      case 'export': {\n        const { writeFile } = await import('node:fs/promises');\n        const { join } = await import('node:path');\n        const sess = await loadSess(selectedId);\n        const content = formatSessionExport(sess, 'markdown');\n        const filename = `opta-session-${selectedId.slice(0, 8)}-${Date.now()}.md`;\n        await writeFile(join(process.cwd(), filename), content, 'utf-8');\n        console.log(chalk.green('\\u2713') + ` Exported to ${chalk.cyan(filename)}`);\n        return 'handled';\n      }\n      case 'delete':\n        if (isCurrent) {\n          console.log(chalk.yellow('  Cannot delete current session'));\n        } else {\n          await deleteSession(selectedId);\n          console.log(chalk.green('\\u2713') + ` Deleted session ${selectedId.slice(0, 8)}`);\n        }\n        continue;\n      default:\n        continue;\n    }\n  }\n};\n\nconst sessionsHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const tokens = parseSlashArgs(args);\n  const menuActions = new Set(['menu', 'interactive', 'nav', 'browser']);\n  const first = tokens[0]?.toLowerCase();\n\n  if (tokens.length === 0 || (first && menuActions.has(first))) {\n    return interactiveSessionsBrowser(ctx);\n  }\n\n  let action = 'list';\n  let startIndex = 0;\n  if (first && !first.startsWith('-')) {\n    action = first;\n    startIndex = 1;\n  }\n\n  const opts: {\n    json?: boolean;\n    model?: string;\n    since?: string;\n    tag?: string;\n    limit?: string;\n  } = {};\n  const unknown: string[] = [];\n  const positional: string[] = [];\n\n  for (let i = startIndex; i < tokens.length; i += 1) {\n    const token = tokens[i]!;\n\n    if (token === '--json') {\n      opts.json = true;\n      continue;\n    }\n    if (token === '--model') {\n      opts.model = tokens[i + 1];\n      i += 1;\n      continue;\n    }\n    if (token.startsWith('--model=')) {\n      opts.model = token.slice('--model='.length);\n      continue;\n    }\n    if (token === '--since') {\n      opts.since = tokens[i + 1];\n      i += 1;\n      continue;\n    }\n    if (token.startsWith('--since=')) {\n      opts.since = token.slice('--since='.length);\n      continue;\n    }\n    if (token === '--tag') {\n      opts.tag = tokens[i + 1];\n      i += 1;\n      continue;\n    }\n    if (token.startsWith('--tag=')) {\n      opts.tag = token.slice('--tag='.length);\n      continue;\n    }\n    if (token === '--limit') {\n      opts.limit = tokens[i + 1];\n      i += 1;\n      continue;\n    }\n    if (token.startsWith('--limit=')) {\n      opts.limit = token.slice('--limit='.length);\n      continue;\n    }\n    if (token.startsWith('-')) {\n      unknown.push(token);\n      continue;\n    }\n    positional.push(token);\n  }\n\n  if (unknown.length > 0) {\n    console.log(chalk.yellow(`  Unknown options: ${unknown.join(', ')}`));\n    printSessionsUsage();\n    return 'handled';\n  }\n\n  const id = action === 'search' || action === 'find'\n    ? (positional.join(' ').trim() || undefined)\n    : positional[0];\n\n  try {\n    const { sessions } = await import('../sessions.js');\n    await sessions(action, id, opts);\n  } catch (err) {\n    const { ExitError } = await import('../../core/errors.js');\n    if (!(err instanceof ExitError)) {\n      console.error(chalk.red('\\u2717') + ` Sessions command failed: ${errorMessage(err)}`);\n    }\n  }\n\n  return 'handled';\n};\n\nconst initHandler = async (_args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const { access } = await import('node:fs/promises');\n  const { join } = await import('node:path');\n  const contextFile = join(process.cwd(), 'OPTA.md');\n\n  try {\n    await access(contextFile);\n    console.log(chalk.yellow('  OPTA.md already exists. Delete it first to regenerate.'));\n    return 'handled';\n  } catch { /* doesn't exist, good */ }\n\n  console.log(chalk.dim('  Analyzing project...'));\n  ctx.session.messages.push({\n    role: 'user',\n    content: 'Analyze this project and generate an OPTA.md project context file. Include: project name, tech stack, architecture overview, key files, coding conventions, and any important notes for an AI assistant working on this codebase. Write it as a markdown file.',\n  });\n  console.log(chalk.dim('  Ask me to generate the OPTA.md file and I\\'ll analyze the project.'));\n  return 'handled';\n};\n\nconst editorHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const { editText } = await import('../editor.js');\n  const text = await editText(args || '');\n  if (text) {\n    console.log(chalk.dim(`  Editor returned ${text.split('\\n').length} lines`));\n    // Inject editor text as user message for processing\n    ctx.session.messages.push({ role: 'user', content: text });\n  } else {\n    console.log(chalk.dim('  Editor cancelled (empty content)'));\n  }\n  return 'handled';\n};\n\nconst imageHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  if (!args) {\n    console.log(chalk.dim('  Usage: /image <path> [question]'));\n    console.log(chalk.dim('  Examples:'));\n    console.log(chalk.dim('    /image screenshot.png What is this?'));\n    console.log(chalk.dim('    /image ./designs/mockup.png Review this UI'));\n    console.log(chalk.dim('  Supports: png, jpg, jpeg, gif, webp'));\n    return 'handled';\n  }\n\n  const parts = args.split(/\\s+/);\n  const imagePath = parts[0]!;\n  const question = parts.slice(1).join(' ') || 'What is in this image?';\n\n  try {\n    const { readFile: readFs } = await import('node:fs/promises');\n    const { resolve: resolvePath, extname } = await import('node:path');\n    const fullPath = resolvePath(imagePath);\n    const data = await readFs(fullPath);\n    const base64 = data.toString('base64');\n    const ext = extname(fullPath).slice(1).toLowerCase();\n    const mime = ext === 'jpg' ? 'jpeg' : ext;\n\n    // Set title from first image\n    if (!ctx.session.title) {\n      ctx.session.title = generateTitle(question);\n    }\n\n    const result = await agentLoop(question, ctx.config, {\n      existingMessages: ctx.session.messages,\n      sessionId: ctx.session.id,\n      silent: false,\n      mode: ctx.chatState.currentMode === 'plan' ? 'plan' : undefined,\n      imageBase64: `data:image/${mime};base64,${base64}`,\n    });\n\n    ctx.session.messages = result.messages;\n    ctx.session.toolCallCount += result.toolCallCount;\n    await saveSession(ctx.session);\n  } catch (err) {\n    console.error(chalk.red('\\u2717') + ` Failed to read image: ${errorMessage(err)}`);\n  }\n  return 'handled';\n};\n\nconst tagHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const { tagSession, untagSession } = await import('../../memory/store.js');\n  const parts = args.trim().split(/\\s+/);\n  const subcommand = parts[0]?.toLowerCase();\n\n  // /tag (no args) or /tag list  show current tags\n  if (!subcommand || subcommand === 'list') {\n    const tags = ctx.session.tags ?? [];\n    if (tags.length === 0) {\n      console.log(chalk.dim('  No tags on this session. Use /tag add <tag> to add one.'));\n    } else {\n      console.log(chalk.dim('  Tags: ') + tags.map(t => chalk.cyan(t)).join(', '));\n    }\n    return 'handled';\n  }\n\n  if (subcommand === 'add') {\n    const tagsToAdd = parts.slice(1).filter(Boolean);\n    if (tagsToAdd.length === 0) {\n      console.log(chalk.dim('  Usage: /tag add <tag1> [tag2] ...'));\n      return 'handled';\n    }\n    await tagSession(ctx.session.id, tagsToAdd);\n    ctx.session.tags = [...new Set([...(ctx.session.tags ?? []), ...tagsToAdd])];\n    console.log(chalk.green('\\u2713') + ` Added tags: ${tagsToAdd.map(t => chalk.cyan(t)).join(', ')}`);\n    return 'handled';\n  }\n\n  if (subcommand === 'remove' || subcommand === 'rm') {\n    const tagsToRemove = parts.slice(1).filter(Boolean);\n    if (tagsToRemove.length === 0) {\n      console.log(chalk.dim('  Usage: /tag remove <tag1> [tag2] ...'));\n      return 'handled';\n    }\n    await untagSession(ctx.session.id, tagsToRemove);\n    ctx.session.tags = (ctx.session.tags ?? []).filter(t => !tagsToRemove.includes(t));\n    console.log(chalk.green('\\u2713') + ` Removed tags: ${tagsToRemove.map(t => chalk.cyan(t)).join(', ')}`);\n    return 'handled';\n  }\n\n  // If the subcommand isn't recognized, treat the entire args as tags to add\n  const tagsToAdd = parts.filter(Boolean);\n  await tagSession(ctx.session.id, tagsToAdd);\n  ctx.session.tags = [...new Set([...(ctx.session.tags ?? []), ...tagsToAdd])];\n  console.log(chalk.green('\\u2713') + ` Added tags: ${tagsToAdd.map(t => chalk.cyan(t)).join(', ')}`);\n  return 'handled';\n};\n\nconst renameHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  if (!args.trim()) {\n    console.log(chalk.dim('  Usage: /rename <new title>'));\n    return 'handled';\n  }\n  const { renameSession } = await import('../../memory/store.js');\n  await renameSession(ctx.session.id, args.trim());\n  ctx.session.title = args.trim();\n  console.log(chalk.green('\\u2713') + ` Session renamed: ${args.trim()}`);\n  return 'handled';\n};\n\nconst costHandler = async (_args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const messages = ctx.session.messages;\n  const isLocal = ctx.config.provider.active === 'lmx';\n\n  let inputTokens = 0;\n  let outputTokens = 0;\n\n  for (const msg of messages) {\n    // Extract text content from string or ContentPart[] format\n    let text = '';\n    if (typeof msg.content === 'string') {\n      text = msg.content;\n    } else if (Array.isArray(msg.content)) {\n      text = msg.content\n        .filter((p): p is { type: 'text'; text: string } => p.type === 'text')\n        .map(p => p.text)\n        .join('');\n    }\n\n    const tokens = estimateTokens(text);\n\n    // Tool call arguments also count as output tokens\n    const toolTokens = msg.tool_calls\n      ? msg.tool_calls.reduce((sum, tc) => sum + estimateTokens(tc.function.arguments), 0)\n      : 0;\n\n    if (msg.role === 'assistant') {\n      outputTokens += tokens + toolTokens;\n    } else {\n      inputTokens += tokens;\n    }\n  }\n\n  const totalTokens = inputTokens + outputTokens;\n\n  console.log();\n  console.log(chalk.dim('  Session Token Usage'));\n  console.log(chalk.dim('  ' + '\\u2500'.repeat(32)));\n  console.log(`  Input tokens:   ${chalk.cyan(formatTokens(inputTokens))}`);\n  console.log(`  Output tokens:  ${chalk.cyan(formatTokens(outputTokens))}`);\n  console.log(`  Total tokens:   ${chalk.cyan(formatTokens(totalTokens))}`);\n  console.log(`  Messages:       ${chalk.cyan(String(messages.length))}`);\n  console.log(`  Tool calls:     ${chalk.cyan(String(ctx.session.toolCallCount))}`);\n  console.log(chalk.dim('  ' + '\\u2500'.repeat(32)));\n\n  if (isLocal) {\n    console.log(`  Cost:           ${chalk.green('Free')} ${chalk.dim('(local inference via Opta-LMX)')}`);\n  } else {\n    // Rough cost estimate for Anthropic Claude models\n    // claude-sonnet-4-5: $3/M input, $15/M output\n    const inputCost = (inputTokens / 1_000_000) * 3;\n    const outputCost = (outputTokens / 1_000_000) * 15;\n    const totalCost = inputCost + outputCost;\n\n    const model = ctx.config.provider.anthropic.model || 'claude-sonnet';\n    console.log(`  Provider:       ${chalk.dim('Anthropic')} ${chalk.dim(`(${model})`)}`);\n    console.log(`  Est. cost:      ${chalk.yellow('~$' + totalCost.toFixed(4) + ' USD')}`);\n    console.log(chalk.dim('  Note: Estimates based on approximate token counts'));\n  }\n\n  console.log();\n  return 'handled';\n};\n\nexport const sessionCommands: SlashCommandDef[] = [\n  {\n    command: 'exit',\n    aliases: ['quit', 'q'],\n    description: 'Save and exit',\n    handler: exitHandler,\n    category: 'session',\n    usage: '/exit',\n    examples: ['/exit', '/quit', '/q'],\n  },\n  {\n    command: 'clear',\n    description: 'Clear screen',\n    handler: clearHandler,\n    category: 'session',\n    usage: '/clear',\n    examples: ['/clear'],\n  },\n  {\n    command: 'share',\n    description: 'Export conversation',\n    handler: shareHandler,\n    category: 'session',\n    usage: '/share',\n    examples: ['/share'],\n  },\n  {\n    command: 'sessions',\n    description: 'Browse or manage sessions (list/search/resume/delete/export)',\n    handler: sessionsHandler,\n    category: 'session',\n    usage: '/sessions [list|resume|delete|export|search|menu] [id|query] [--json|--model <name>|--since <date>|--tag <tag>|--limit <n>]',\n    examples: ['/sessions', '/sessions menu', '/sessions list --limit 10', '/sessions search auth', '/sessions resume abc123'],\n  },\n  {\n    command: 'init',\n    description: 'Generate project context',\n    handler: initHandler,\n    category: 'session',\n    usage: '/init',\n    examples: ['/init'],\n  },\n  {\n    command: 'editor',\n    aliases: ['e'],\n    description: 'Open $EDITOR for input',\n    handler: editorHandler,\n    category: 'session',\n    usage: '/editor [initial-text]',\n    examples: ['/editor', '/editor Fix the login bug'],\n  },\n  {\n    command: 'image',\n    description: 'Analyze an image',\n    handler: imageHandler,\n    category: 'session',\n    usage: '/image <path> [question]',\n    examples: ['/image screenshot.png What is this?', '/image ./designs/mockup.png Review this UI'],\n  },\n  {\n    command: 'tag',\n    aliases: ['t'],\n    description: 'Manage session tags',\n    handler: tagHandler,\n    category: 'session',\n    usage: '/tag [add|remove|list] [tags...]',\n    examples: ['/tag', '/tag add bugfix urgent', '/tag remove urgent', '/tag list'],\n  },\n  {\n    command: 'rename',\n    aliases: ['title'],\n    description: 'Rename current session',\n    handler: renameHandler,\n    category: 'session',\n    usage: '/rename <new title>',\n    examples: ['/rename Auth refactor session', '/title Fix login bug'],\n  },\n  {\n    command: 'cost',\n    aliases: ['tokens', 'usage'],\n    description: 'Show session token usage and cost estimate',\n    handler: costHandler,\n    category: 'session',\n    usage: '/cost',\n    examples: ['/cost', '/tokens', '/usage'],\n  },\n];\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/commands/slash/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/commands/slash/workflow.ts","messages":[{"ruleId":"@typescript-eslint/require-await","severity":1,"message":"Async arrow function 'planHandler' has no 'await' expression.","line":43,"column":83,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":43,"endColumn":85,"suggestions":[{"messageId":"removeAsync","fix":{"range":[1410,1471],"text":"(args: string, ctx: SlashContext): SlashResult"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":197,"column":20,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":197,"endColumn":35},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":263,"column":24,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":263,"endColumn":67},{"ruleId":"@typescript-eslint/require-await","severity":1,"message":"Async arrow function 'compactHandler' has no 'await' expression.","line":297,"column":88,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":297,"endColumn":90,"suggestions":[{"messageId":"removeAsync","fix":{"range":[11289,11352],"text":"(_args: string, _ctx: SlashContext): SlashResult"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-deprecated","severity":1,"message":"`fmtTokens` is deprecated. Use `formatTokens` from `../utils/tokens.js` directly.","line":322,"column":33,"nodeType":"Identifier","messageId":"deprecatedWithReason","endLine":322,"endColumn":42},{"ruleId":"@typescript-eslint/require-await","severity":1,"message":"Async arrow function 'autoHandler' has no 'await' expression.","line":348,"column":83,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":348,"endColumn":85,"suggestions":[{"messageId":"removeAsync","fix":{"range":[13636,13697],"text":"(args: string, ctx: SlashContext): SlashResult"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":411,"column":17,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":411,"endColumn":27,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[15984,15985],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Workflow slash commands: /plan, /diff, /undo, /compact, /status\n */\n\nimport chalk from 'chalk';\nimport { errorMessage } from '../../utils/errors.js';\nimport { box, kv, statusDot, fmtTokens, progressBar } from '../../ui/box.js';\nimport { runMenuPrompt } from '../../ui/prompt-nav.js';\nimport { estimateMessageTokens } from '../../utils/tokens.js';\nimport type { SlashCommandDef, SlashContext, SlashResult } from './types.js';\n\nfunction capturePlanActivation(\n  ctx: SlashContext,\n  args: string,\n  hasResearchContext: boolean,\n): void {\n  void import('../../learning/hooks.js')\n    .then(({ captureLearningEvent }) =>\n      captureLearningEvent(\n        ctx.config,\n        {\n          kind: 'plan',\n          topic: 'Plan mode activated',\n          content: hasResearchContext\n            ? 'Plan mode entered with prior research context in this session.'\n            : args === '--skip'\n              ? 'Plan mode entered with --skip (no prior research context).'\n              : 'Plan mode entered.',\n          tags: ['plan', 'mode', hasResearchContext ? 'researched' : 'unresearched'],\n          evidence: [{ label: 'session', uri: `session://${ctx.session.id}` }],\n          metadata: {\n            sessionId: ctx.session.id,\n            commandArgs: args,\n            hasResearchContext,\n          },\n          verified: true,\n        },\n      ),\n    )\n    .catch(() => {});\n}\n\nconst planHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  if (args === 'off' || (ctx.chatState.currentMode === 'plan' && !args)) {\n    ctx.chatState.currentMode = 'normal';\n    console.log(chalk.green('\\u2713') + ' Exited plan mode');\n    return 'handled';\n  }\n\n  // --skip flag skips research check\n  if (args === '--skip') {\n    ctx.chatState.currentMode = 'plan';\n    console.log(chalk.magenta('\\u2713') + ' Entered plan mode \\u2014 read-only exploration');\n    console.log(chalk.dim('  Tools: read, search, list, find, ask, web_search, web_fetch'));\n    console.log(chalk.dim('  Type /plan off to exit'));\n    capturePlanActivation(ctx, args, false);\n    return 'handled';\n  }\n\n  // Check if research has been done in this session\n  const hasResearch = ctx.session.messages.some(m =>\n    typeof m.content === 'string' && m.content.includes('[System: Research mode activated')\n  );\n\n  if (!hasResearch && !args) {\n    console.log(chalk.yellow('\\n  No research context found for this planning session.\\n'));\n    console.log(chalk.dim('  Options:'));\n    console.log(`  ${chalk.cyan('/research')}      Start deep research first`);\n    console.log(`  ${chalk.cyan('/plan --skip')}   Skip research, plan from existing context`);\n    console.log();\n    return 'handled';\n  }\n\n  ctx.chatState.currentMode = 'plan';\n  console.log(chalk.magenta('\\u2713') + ' Entered plan mode \\u2014 read-only exploration');\n  if (hasResearch) {\n    console.log(chalk.dim('  Research context detected \\u2014 building on prior exploration'));\n  }\n  console.log(chalk.dim('  Tools: read, search, list, find, ask, web_search, web_fetch'));\n  console.log(chalk.dim('  Type /plan off to exit'));\n  capturePlanActivation(ctx, args, hasResearch);\n  return 'handled';\n};\n\nconst diffHandler = async (args: string, _ctx: SlashContext): Promise<SlashResult> => {\n  try {\n    const { execFileSync } = await import('node:child_process');\n    const { formatUnifiedDiff } = await import('../../ui/diff.js');\n\n    const stat = execFileSync('git', ['diff', '--stat'], { encoding: 'utf-8', cwd: process.cwd() });\n    if (!stat.trim()) {\n      console.log(chalk.dim('  No uncommitted changes'));\n      return 'handled';\n    }\n\n    // Show stat summary in a box\n    const statLines = stat.trim().split('\\n');\n    const summary = statLines[statLines.length - 1] ?? '';\n    const fileLines = statLines.slice(0, -1).map(l => ' ' + l.trim());\n    console.log('\\n' + box('Changes', [...fileLines, '', chalk.dim(summary.trim())]));\n\n    // If user passed a file, show full diff for that file\n    if (args) {\n      const fullDiff = execFileSync('git', ['diff', '--', args], { encoding: 'utf-8', cwd: process.cwd() });\n      if (fullDiff.trim()) {\n        console.log('\\n' + formatUnifiedDiff(fullDiff));\n      }\n    } else {\n      console.log(chalk.dim('  Tip: /diff <file> for inline diff'));\n    }\n  } catch {\n    console.log(chalk.dim('  Not a git repository'));\n  }\n  return 'handled';\n};\n\nconst undoHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  try {\n    const { isGitRepo } = await import('../../git/utils.js');\n    if (!(await isGitRepo(process.cwd()))) {\n      console.log(chalk.dim('  Not in a git repository'));\n      return 'handled';\n    }\n\n    const { listCheckpoints, readPatchContent, patchStat, undoCheckpoint, undoAllCheckpoints } = await import('../../git/checkpoints.js');\n    const { formatTruncatedDiff, formatPatchStat } = await import('../../ui/diff.js');\n\n    // --- /undo list (or /checkpoint alias) ---\n    if (args === 'list') {\n      const checkpoints = await listCheckpoints(process.cwd(), ctx.session.id);\n      if (checkpoints.length === 0) {\n        console.log(chalk.dim('  No checkpoints in this session'));\n      } else {\n        const lines = await Promise.all(\n          checkpoints.map(async (cp) => {\n            const patch = await readPatchContent(process.cwd(), ctx.session.id, cp.n);\n            const stat = patchStat(patch);\n            const ts = new Date(cp.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });\n            return `  ${chalk.bold(`#${cp.n}`)}  ${chalk.cyan(cp.tool.padEnd(12))} ${cp.path}  ${formatPatchStat(stat.additions, stat.deletions)}  ${chalk.dim(ts)}`;\n          }),\n        );\n        console.log('\\n' + box('Checkpoints', lines));\n        console.log(chalk.dim('  Tip: /undo N to revert a specific checkpoint\\n'));\n      }\n      return 'handled';\n    }\n\n    // --- /undo all ---\n    if (args === 'all') {\n      const checkpoints = await listCheckpoints(process.cwd(), ctx.session.id);\n      if (checkpoints.length === 0) {\n        console.log(chalk.dim('  No checkpoints in this session'));\n        return 'handled';\n      }\n\n      const { confirm } = await import('@inquirer/prompts');\n      const ok = await confirm({\n        message: `Revert all ${checkpoints.length} checkpoint${checkpoints.length === 1 ? '' : 's'}?`,\n        default: false,\n      });\n      if (!ok) {\n        console.log(chalk.dim('  Cancelled'));\n        return 'handled';\n      }\n\n      const undone = await undoAllCheckpoints(process.cwd(), ctx.session.id);\n      console.log(chalk.green('\\u2713') + ` Undone: ${undone} checkpoint${undone === 1 ? '' : 's'}`);\n      ctx.session.messages.push({\n        role: 'user',\n        content: `[System: User reversed all ${undone} checkpoints \\u2014 all changes have been reverted. Adjust your approach accordingly.]`,\n      });\n      return 'handled';\n    }\n\n    // --- /undo N (specific checkpoint, no confirmation) ---\n    if (args && !isNaN(parseInt(args, 10))) {\n      const n = parseInt(args, 10);\n      await undoCheckpoint(process.cwd(), ctx.session.id, n);\n\n      console.log(chalk.green('\\u2713') + ` Undone: Checkpoint #${n}`);\n      ctx.session.messages.push({\n        role: 'user',\n        content: `[System: User reversed Checkpoint #${n} \\u2014 changes have been reverted. Adjust your approach accordingly.]`,\n      });\n      return 'handled';\n    }\n\n    // --- /undo (no args): interactive checkpoint picker ---\n    const checkpoints = await listCheckpoints(process.cwd(), ctx.session.id);\n    if (checkpoints.length === 0) {\n      console.log(chalk.dim('  No checkpoints in this session'));\n      return 'handled';\n    }\n\n    // Single checkpoint: show preview + confirm (original behavior)\n    if (checkpoints.length === 1) {\n      const last = checkpoints[0]!;\n      const patch = await readPatchContent(process.cwd(), ctx.session.id, last.n);\n      const stat = patchStat(patch);\n\n      console.log();\n      console.log(\n        chalk.bold(`  Checkpoint #${last.n}`) +\n        chalk.dim(` \\u2014 ${last.tool} \\u2014 `) +\n        formatPatchStat(stat.additions, stat.deletions)\n      );\n      console.log();\n      if (patch) {\n        console.log(formatTruncatedDiff(patch, last.path, 20));\n        console.log();\n      }\n\n      const { confirm } = await import('@inquirer/prompts');\n      const ok = await confirm({\n        message: 'Revert this checkpoint?',\n        default: true,\n      });\n      if (!ok) {\n        console.log(chalk.dim('  Cancelled'));\n        return 'handled';\n      }\n\n      await undoCheckpoint(process.cwd(), ctx.session.id);\n      console.log(chalk.green('\\u2713') + ' Undone: Last checkpoint');\n      ctx.session.messages.push({\n        role: 'user',\n        content: `[System: User reversed Checkpoint #${last.n} \\u2014 changes have been reverted. Adjust your approach accordingly.]`,\n      });\n      return 'handled';\n    }\n\n    // Multiple checkpoints: interactive picker\n    const { select } = await import('@inquirer/prompts');\n    const now = Date.now();\n\n    const choices = await Promise.all(\n      [...checkpoints].reverse().map(async (cp) => {\n        const cpPatch = await readPatchContent(process.cwd(), ctx.session.id, cp.n);\n        const cpStat = patchStat(cpPatch);\n        const ago = Math.floor((now - new Date(cp.timestamp).getTime()) / 60000);\n        const agoStr = ago < 1 ? 'just now' : `${ago}m ago`;\n        return {\n          name: `#${String(cp.n).padEnd(3)} ${cp.path.padEnd(35).slice(0, 35)}  ${formatPatchStat(cpStat.additions, cpStat.deletions)}  ${chalk.dim(`(${agoStr})`)}`,\n          value: cp.n,\n        };\n      })\n    );\n\n    choices.push({ name: chalk.dim('\\u2500\\u2500 Cancel \\u2500\\u2500'), value: -1 });\n\n    const selectedN = await runMenuPrompt((context) =>\n      select({\n        message: chalk.dim('Select checkpoint to undo:'),\n        choices,\n      }, context), 'select');\n\n    if (selectedN === null || selectedN === -1) {\n      console.log(chalk.dim('  Cancelled'));\n      return 'handled';\n    }\n\n    // Show diff preview for selected checkpoint\n    const selectedCp = checkpoints.find(cp => cp.n === selectedN)!;\n    const selectedPatch = await readPatchContent(process.cwd(), ctx.session.id, selectedN);\n    if (selectedPatch) {\n      console.log();\n      console.log(formatTruncatedDiff(selectedPatch, selectedCp.path, 15));\n      console.log();\n    }\n\n    const { confirm: confirmUndo } = await import('@inquirer/prompts');\n    const ok = await confirmUndo({\n      message: `Revert checkpoint #${selectedN}?`,\n      default: true,\n    });\n    if (!ok) {\n      console.log(chalk.dim('  Cancelled'));\n      return 'handled';\n    }\n\n    await undoCheckpoint(process.cwd(), ctx.session.id, selectedN);\n    console.log(chalk.green('\\u2713') + ` Undone: Checkpoint #${selectedN}`);\n    ctx.session.messages.push({\n      role: 'user',\n      content: `[System: User reversed Checkpoint #${selectedN} \\u2014 changes have been reverted. Adjust your approach accordingly.]`,\n    });\n  } catch (err) {\n    if (err instanceof Error && err.message.includes('ExitPromptError')) {\n      console.log(chalk.dim('  Cancelled'));\n      return 'handled';\n    }\n    console.error(chalk.red('\\u2717') + ` Undo failed: ${errorMessage(err)}`);\n  }\n  return 'handled';\n};\n\nconst compactHandler = async (_args: string, _ctx: SlashContext): Promise<SlashResult> => {\n  console.log(chalk.dim('  Context compaction will happen automatically on next turn'));\n  // Force compaction by setting messages to trigger threshold\n  // The agent loop handles this automatically\n  return 'handled';\n};\n\nconst statusHandler = async (_args: string, ctx: SlashContext): Promise<SlashResult> => {\n  try {\n    const res = await fetch(`http://${ctx.config.connection.host}:${ctx.config.connection.port}/admin/status`);\n    const data = await res.json() as Record<string, unknown>;\n    const model = (data.models as string[] | undefined)?.[0];\n    const memory = data.memory as { used_gb?: number; total_gb?: number; usage_percent?: number } | undefined;\n    const tokens = estimateMessageTokens(ctx.session.messages);\n    const uptimeSec = data.uptime_seconds as number | undefined;\n\n    const lines: string[] = [\n      kv('LMX', `${ctx.config.connection.host}:${ctx.config.connection.port} ${statusDot(true)}`),\n    ];\n    if (model) lines.push(kv('Model', model));\n    if (memory) {\n      const memBar = progressBar((memory.usage_percent ?? 0) / 100, 16);\n      lines.push(kv('Memory', `${memory.used_gb?.toFixed(0)}/${memory.total_gb?.toFixed(0)} GB ${memBar}`));\n    }\n    lines.push(kv('Session', `${ctx.session.id.slice(0, 8)} (${ctx.session.messages.length} messages)`));\n    lines.push(kv('Tokens', `~${fmtTokens(tokens)}`));\n    if (uptimeSec !== undefined) lines.push(kv('Uptime', `${Math.floor(uptimeSec / 60)}m`));\n\n    // Checkpoint count\n    try {\n      const { listCheckpoints } = await import('../../git/checkpoints.js');\n      const checkpoints = await listCheckpoints(process.cwd(), ctx.session.id);\n      if (checkpoints.length > 0) {\n        lines.push(kv('Checkpoints', `${checkpoints.length} (session ${ctx.session.id.slice(0, 8)})`));\n      }\n    } catch {\n      // Ignore  checkpoints are optional\n    }\n\n    console.log('\\n' + box('Status', lines));\n  } catch {\n    console.log(chalk.red('\\n  \\u25cf LMX unreachable') + chalk.dim(` \\u2014 ${ctx.config.connection.host}:${ctx.config.connection.port}`));\n  }\n  return 'handled';\n};\n\n/** Handler for /checkpoint  alias for /undo list */\nconst checkpointHandler = async (_args: string, ctx: SlashContext): Promise<SlashResult> => {\n  return undoHandler('list', ctx);\n};\n\nconst autoHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const state = ctx.chatState as unknown as Record<string, unknown>;\n  const current = (state.autoAccept as boolean) || false;\n\n  if (!args) {\n    const status = current ? chalk.green('ON') : chalk.dim('OFF');\n    console.log(`  Auto-accept: ${status}`);\n    console.log(chalk.dim('  Usage: /auto on|off'));\n    return 'handled';\n  }\n\n  if (args === 'on' || args === 'true') {\n    state.autoAccept = true;\n    console.log(chalk.green('\\u2713') + ' Auto-accept: ' + chalk.green('ON'));\n    console.log(chalk.yellow('  \\u26a0 All tool calls will be approved automatically'));\n    return 'handled';\n  }\n\n  if (args === 'off' || args === 'false') {\n    state.autoAccept = false;\n    console.log(chalk.green('\\u2713') + ' Auto-accept: ' + chalk.dim('OFF'));\n    return 'handled';\n  }\n\n  console.log(chalk.dim('  Usage: /auto on|off'));\n  return 'handled';\n};\n\nfunction printAutonomyUsage(): void {\n  console.log(chalk.dim('  Usage: /autonomy [status|up|down|<1-5>|set <1-5>|mode execution|mode ceo]'));\n  console.log(chalk.dim('  Examples: /autonomy 4, /autonomy up, /autonomy mode ceo'));\n}\n\nconst autonomyHandler = async (args: string, ctx: SlashContext): Promise<SlashResult> => {\n  const {\n    autonomyDurationMinutes,\n    buildAutonomyProfile,\n    computeAutonomyConfigUpdates,\n    formatAutonomySlider,\n    resolveAutonomyLevel,\n    resolveAutonomyMode,\n  } = await import('../../core/autonomy.js');\n  const { saveConfig, loadConfig } = await import('../../core/config.js');\n\n  const tokens = args.trim().split(/\\s+/).filter(Boolean);\n  const currentLevel = resolveAutonomyLevel(ctx.config.autonomy.level);\n  const currentMode = resolveAutonomyMode(ctx.config.autonomy.mode);\n\n  const printStatus = (): void => {\n    const profile = buildAutonomyProfile(currentLevel, currentMode);\n    const slider = formatAutonomySlider(currentLevel);\n    console.log(chalk.cyan(`  Autonomy ${slider} L${currentLevel}/5 (${currentMode})`));\n    console.log(chalk.dim(`  Runtime budget: ${autonomyDurationMinutes(profile)} min  hard stop ${profile.hardStopAt} tool calls`));\n  };\n\n  if (tokens.length === 0 || tokens[0] === 'status') {\n    printStatus();\n    printAutonomyUsage();\n    return 'handled';\n  }\n\n  let nextLevel = currentLevel;\n  let nextMode = currentMode;\n  const first = tokens[0]!.toLowerCase();\n\n  if (first === 'up' || first === '+') {\n    nextLevel = resolveAutonomyLevel(currentLevel + 1);\n  } else if (first === 'down' || first === '-') {\n    nextLevel = resolveAutonomyLevel(currentLevel - 1);\n  } else if (first === 'set') {\n    if (!tokens[1]) {\n      printAutonomyUsage();\n      return 'handled';\n    }\n    nextLevel = resolveAutonomyLevel(tokens[1]);\n  } else if (first === 'mode') {\n    if (!tokens[1]) {\n      printAutonomyUsage();\n      return 'handled';\n    }\n    nextMode = resolveAutonomyMode(tokens[1]);\n  } else if (first === 'ceo') {\n    nextMode = 'ceo';\n  } else if (first === 'execution') {\n    nextMode = 'execution';\n  } else if (/^[1-5]$/.test(first)) {\n    nextLevel = resolveAutonomyLevel(first);\n  } else {\n    printAutonomyUsage();\n    return 'handled';\n  }\n\n  const updates = computeAutonomyConfigUpdates(nextLevel, nextMode);\n  await saveConfig(updates);\n  Object.assign(ctx.config, await loadConfig());\n\n  const profile = buildAutonomyProfile(nextLevel, nextMode);\n  const slider = formatAutonomySlider(nextLevel);\n  console.log(chalk.green('\\u2713') + ` Autonomy set to ${slider} L${nextLevel}/5 (${nextMode})`);\n  console.log(chalk.dim(`  Runtime budget: ${autonomyDurationMinutes(profile)} min  hard stop ${profile.hardStopAt} tool calls`));\n  return 'handled';\n};\n\nexport const workflowCommands: SlashCommandDef[] = [\n  {\n    command: 'plan',\n    description: 'Toggle plan mode',\n    handler: planHandler,\n    category: 'session',\n    usage: '/plan [off|--skip]',\n    examples: ['/plan', '/plan off', '/plan --skip'],\n  },\n  {\n    command: 'diff',\n    description: 'Uncommitted changes',\n    handler: diffHandler,\n    category: 'tools',\n    usage: '/diff [file]',\n    examples: ['/diff', '/diff src/index.ts'],\n  },\n  {\n    command: 'undo',\n    description: 'Undo checkpoint (list|all|N)',\n    handler: undoHandler,\n    category: 'tools',\n    usage: '/undo [list|all|N]',\n    examples: ['/undo', '/undo list', '/undo all', '/undo 3'],\n  },\n  {\n    command: 'checkpoint',\n    aliases: ['cp'],\n    description: 'List checkpoints',\n    handler: checkpointHandler,\n    category: 'tools',\n    usage: '/checkpoint',\n    examples: ['/checkpoint', '/cp'],\n  },\n  {\n    command: 'compact',\n    description: 'Force context compaction',\n    handler: compactHandler,\n    category: 'tools',\n    usage: '/compact',\n    examples: ['/compact'],\n  },\n  {\n    command: 'status',\n    description: 'System & LMX status',\n    handler: statusHandler,\n    category: 'info',\n    usage: '/status',\n    examples: ['/status'],\n  },\n  {\n    command: 'auto',\n    aliases: ['autoaccept', 'dangerous'],\n    description: 'Toggle auto-accept mode',\n    handler: autoHandler,\n    category: 'tools',\n    usage: '/auto [on|off]',\n    examples: ['/auto', '/auto on', '/auto off'],\n  },\n  {\n    command: 'autonomy',\n    aliases: ['autonomous'],\n    description: 'Set autonomous execution profile (1-5 + CEO mode)',\n    handler: autonomyHandler,\n    category: 'session',\n    usage: '/autonomy [status|up|down|<1-5>|set <1-5>|mode execution|mode ceo]',\n    examples: ['/autonomy', '/autonomy 5', '/autonomy up', '/autonomy mode ceo'],\n  },\n];\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/commands/status.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/commands/update.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-boolean-literal-compare","severity":1,"message":"This expression unnecessarily compares a boolean value to a boolean instead of negating it.","line":1037,"column":7,"nodeType":"BinaryExpression","messageId":"negated","endLine":1037,"endColumn":33,"fix":{"range":[35727,35753],"text":"journal?.enabled"}},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":1037,"column":14,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":1037,"endColumn":16,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[35734,35736],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":1062,"column":25,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":1062,"endColumn":27,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[36590,36592],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":1063,"column":26,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":1063,"endColumn":28,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[36632,36634],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":1064,"column":24,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":1064,"endColumn":26,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[36667,36669],"text":"."},"desc":"Remove unnecessary optional chain"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { existsSync } from 'node:fs';\nimport { dirname, join, basename, resolve } from 'node:path';\nimport { fileURLToPath } from 'node:url';\nimport chalk from 'chalk';\nimport { execa } from 'execa';\nimport { loadConfig } from '../core/config.js';\nimport { ExitError, EXIT } from '../core/errors.js';\nimport { createSegmentedStepProgressTracker } from '../ui/progress.js';\nimport { colorizeOptaWord } from '../ui/brand.js';\nimport { writeUpdateLog } from '../journal/update-log.js';\n\nexport type UpdateComponent = 'cli' | 'lmx' | 'plus' | 'web';\nexport type UpdateTarget = 'local' | 'remote';\nexport type UpdateTargetMode = 'auto' | 'local' | 'remote' | 'both';\n\ntype StepStatus = 'ok' | 'skip' | 'fail';\n\nexport interface UpdateOptions {\n  components?: string;\n  target?: UpdateTargetMode;\n  remoteHost?: string;\n  remoteUser?: string;\n  identityFile?: string;\n  localRoot?: string;\n  remoteRoot?: string;\n  dryRun?: boolean;\n  build?: boolean;\n  pull?: boolean;\n  json?: boolean;\n}\n\nconst SSH_CONNECT_TIMEOUT_SECONDS = 25;\n\ninterface StepResult {\n  target: UpdateTarget;\n  component: UpdateComponent;\n  step: string;\n  status: StepStatus;\n  message: string;\n  host?: string;\n}\n\ninterface SshConfig {\n  host: string;\n  user: string;\n  identityFile?: string;\n}\n\nexport interface RemoteLanGuardProbe {\n  state: 'ok' | 'dual_ip' | 'unsupported';\n  ethernetIp: string;\n  wifiIp: string;\n  wifiPower: string;\n}\n\ninterface RemoteLanGuardResult {\n  status: StepStatus;\n  message: string;\n  canProceed: boolean;\n}\n\ninterface CommandResult {\n  exitCode: number;\n  stdout: string;\n  stderr: string;\n}\n\nexport interface RemoteHostProbe {\n  host: string;\n  exitCode: number;\n  detail: string;\n}\n\nexport interface RemoteHostSelection {\n  selectedHost: string | null;\n  probes: RemoteHostProbe[];\n}\n\nexport interface SelectReachableRemoteHostOptions {\n  parallel?: boolean;\n}\n\nexport const CLI_UPDATE_BUILD_SCRIPT =\n  'npm run -s typecheck && (npm run -s build || (npm install --no-fund --no-audit && npm run -s typecheck && npm run -s build))';\n\nconst REQUIRED_OPTA_COMMANDS = [\n  'chat',\n  'tui',\n  'do',\n  'benchmark',\n  'status',\n  'models',\n  'config',\n  'sessions',\n  'mcp',\n  'serve',\n  'server',\n  'daemon',\n  'update',\n  'doctor',\n  'completions',\n] as const;\n\nexport function missingOptaCommands(helpOutput: string): string[] {\n  const lines = helpOutput.toLowerCase();\n  return REQUIRED_OPTA_COMMANDS.filter((command) => {\n    const pattern = new RegExp(`(^|\\\\s)${command}(\\\\s|$)`, 'm');\n    return !pattern.test(lines);\n  });\n}\n\nfunction quoteSh(input: string): string {\n  return `'${input.replace(/'/g, `'\"'\"'`)}'`;\n}\n\nfunction expandHome(input: string): string {\n  if (!input.startsWith('~')) return input;\n  const home = process.env['HOME'] ?? '';\n  return input.replace(/^~(?=$|\\/)/, home);\n}\n\nfunction isLocalHost(host: string): boolean {\n  const lower = host.trim().toLowerCase();\n  return lower === 'localhost' || lower === '127.0.0.1';\n}\n\nexport function parseComponentList(raw?: string): UpdateComponent[] {\n  // Default update scope intentionally excludes web to keep the primary\n  // desktop/local runtime path fast (CLI + LMX + Plus).\n  if (!raw || raw.trim() === '') return ['cli', 'lmx', 'plus'];\n  const parts = raw\n    .split(',')\n    .map((p) => p.trim().toLowerCase())\n    .filter(Boolean);\n\n  const allowed: UpdateComponent[] = ['cli', 'lmx', 'plus', 'web'];\n  const invalid = parts.filter((p) => !allowed.includes(p as UpdateComponent));\n  if (invalid.length > 0) {\n    throw new Error(`Invalid components: ${invalid.join(', ')}. Use: cli,lmx,plus,web`);\n  }\n\n  return [...new Set(parts as UpdateComponent[])];\n}\n\nexport function resolveTargets(mode: UpdateTargetMode, remoteHost: string): UpdateTarget[] {\n  switch (mode) {\n    case 'local':\n      return ['local'];\n    case 'remote':\n      return ['remote'];\n    case 'both':\n      return ['local', 'remote'];\n    case 'auto':\n    default:\n      return isLocalHost(remoteHost) ? ['local'] : ['local', 'remote'];\n  }\n}\n\nexport function remoteConnectFailureStatus(mode: UpdateTargetMode): StepStatus {\n  return mode === 'auto' ? 'skip' : 'fail';\n}\n\nexport function resolveRemoteHostCandidates(primaryHost: string, fallbackHosts: readonly string[] = []): string[] {\n  const hosts = [primaryHost, ...fallbackHosts]\n    .map((host) => host.trim())\n    .filter((host) => host.length > 0);\n\n  const deduped: string[] = [];\n  const seen = new Set<string>();\n  for (const host of hosts) {\n    const key = host.toLowerCase();\n    if (seen.has(key)) continue;\n    seen.add(key);\n    deduped.push(host);\n  }\n\n  return deduped;\n}\n\nexport async function selectReachableRemoteHost(\n  hosts: readonly string[],\n  probeHost: (host: string) => Promise<CommandResult>,\n  options: SelectReachableRemoteHostOptions = {},\n): Promise<RemoteHostSelection> {\n  if (options.parallel) {\n    const settled = await Promise.all(\n      hosts.map(async (host) => {\n        const result = await probeHost(host);\n        const detail = result.stderr || result.stdout || 'ssh failed';\n        return {\n          host,\n          exitCode: result.exitCode,\n          detail,\n        } satisfies RemoteHostProbe;\n      }),\n    );\n\n    const selected = settled.find((entry) => entry.exitCode === 0);\n    return {\n      selectedHost: selected?.host ?? null,\n      probes: settled,\n    };\n  }\n\n  const probes: RemoteHostProbe[] = [];\n\n  for (const host of hosts) {\n    const result = await probeHost(host);\n    const detail = result.stderr || result.stdout || 'ssh failed';\n    probes.push({\n      host,\n      exitCode: result.exitCode,\n      detail,\n    });\n\n    if (result.exitCode === 0) {\n      return {\n        selectedHost: host,\n        probes,\n      };\n    }\n  }\n\n  return {\n    selectedHost: null,\n    probes,\n  };\n}\n\nfunction detectAppsRoot(startCwd: string): string | null {\n  const moduleProjectRoot = resolve(fileURLToPath(new URL('../..', import.meta.url)));\n  const candidates = new Set<string>([\n    startCwd,\n    dirname(startCwd),\n    resolve(startCwd, '..', '..'),\n    moduleProjectRoot,\n    dirname(moduleProjectRoot),\n    resolve(moduleProjectRoot, '..', '..'),\n  ]);\n\n  for (const candidate of candidates) {\n    const resolved = resolve(candidate);\n\n    if (basename(resolved) === '1-Apps') {\n      return resolved;\n    }\n\n    if (basename(resolved) === '1D-Opta-CLI-TS' && basename(dirname(resolved)) === '1-Apps') {\n      return dirname(resolved);\n    }\n\n    const asApps = join(resolved, '1-Apps');\n    if (existsSync(asApps) && existsSync(join(asApps, '1D-Opta-CLI-TS'))) {\n      return asApps;\n    }\n\n    if (\n      existsSync(join(resolved, '1D-Opta-CLI-TS')) &&\n      existsSync(join(resolved, '1M-Opta-LMX'))\n    ) {\n      return resolved;\n    }\n  }\n\n  return null;\n}\n\nfunction deriveRemoteAppsRootFromLmxPath(lmxPath: string): string | null {\n  const resolved = resolve(lmxPath);\n  if (basename(resolved) === '1M-Opta-LMX') return dirname(resolved);\n  const marker = '/1M-Opta-LMX';\n  const idx = resolved.indexOf(marker);\n  if (idx > 0) return resolved.slice(0, idx);\n  return null;\n}\n\nfunction componentRepoPath(component: UpdateComponent, appsRoot: string): string {\n  switch (component) {\n    case 'cli':\n      return join(appsRoot, '1D-Opta-CLI-TS');\n    case 'lmx':\n      return join(appsRoot, '1M-Opta-LMX');\n    case 'plus':\n      return join(appsRoot, '1I-OptaPlus');\n    case 'web':\n      return join(appsRoot, '1L-Opta-Local');\n  }\n}\n\nasync function runLocalCommand(command: string, cwd?: string, dryRun = false): Promise<CommandResult> {\n  if (dryRun) {\n    return { exitCode: 0, stdout: `[dry-run] ${command}`, stderr: '' };\n  }\n\n  const result = await execa('bash', ['-lc', command], {\n    cwd,\n    reject: false,\n  });\n\n  return {\n    exitCode: result.exitCode ?? 1,\n    stdout: result.stdout,\n    stderr: result.stderr,\n  };\n}\n\nasync function runRemoteCommand(ssh: SshConfig, command: string, dryRun = false): Promise<CommandResult> {\n  if (dryRun) {\n    return { exitCode: 0, stdout: `[dry-run][${ssh.host}] ${command}`, stderr: '' };\n  }\n\n  const commandWithPath = `export PATH=/opt/homebrew/bin:/usr/local/bin:$PATH; ${command}`;\n  const args: string[] = [\n    '-o', 'BatchMode=yes',\n    '-o', `ConnectTimeout=${SSH_CONNECT_TIMEOUT_SECONDS}`,\n    '-o', 'ServerAliveInterval=5',\n    '-o', 'ServerAliveCountMax=2',\n  ];\n  if (ssh.identityFile) {\n    args.push('-i', ssh.identityFile);\n  }\n  args.push(`${ssh.user}@${ssh.host}`, `bash -lc ${quoteSh(commandWithPath)}`);\n\n  const result = await execa('ssh', args, { reject: false });\n  return {\n    exitCode: result.exitCode ?? 1,\n    stdout: result.stdout,\n    stderr: result.stderr,\n  };\n}\n\nasync function verifyRemoteCliCommands(ssh: SshConfig, dryRun: boolean): Promise<{ status: StepStatus; message: string }> {\n  if (dryRun) {\n    return { status: 'ok', message: 'dry-run remote command verification' };\n  }\n\n  const commandList = REQUIRED_OPTA_COMMANDS.join(' ');\n  const script = [\n    'if ! command -v node >/dev/null 2>&1; then echo \"__ERR__:missing-node\"; exit 40; fi',\n    'if ! command -v opta >/dev/null 2>&1; then echo \"__ERR__:missing-opta\"; exit 41; fi',\n    'help=\"$(opta --help 2>/dev/null)\" || { echo \"__ERR__:help-failed\"; exit 42; }',\n    `missing=\"\"; for c in ${commandList}; do echo \"$help\" | grep -Eq \"(^|[[:space:]])$c([[:space:]]|$)\" || missing=\"$missing $c\"; done`,\n    'if [ -n \"$missing\" ]; then echo \"__MISSING__:$missing\"; exit 43; fi',\n    'version=\"$(opta --version 2>/dev/null || true)\"',\n    'echo \"__VERSION__:$version\"',\n  ].join('; ');\n\n  const result = await runRemoteCommand(ssh, script, false);\n  if (result.exitCode === 40) {\n    return { status: 'fail', message: 'node runtime missing on remote host (install Node.js so /opt/homebrew/bin/opta can run)' };\n  }\n  if (result.exitCode === 41) {\n    return { status: 'fail', message: 'opta command not found in PATH on remote host' };\n  }\n  if (result.exitCode === 42) {\n    return { status: 'fail', message: 'opta --help failed on remote host' };\n  }\n  if (result.exitCode === 43) {\n    const marker = result.stdout.split('\\n').find((line) => line.startsWith('__MISSING__:'));\n    const missing = marker?.replace('__MISSING__:', '').trim() ?? 'unknown';\n    return { status: 'fail', message: `missing command entries in remote opta --help: ${missing}` };\n  }\n  if (result.exitCode !== 0) {\n    return { status: 'fail', message: result.stderr || result.stdout || 'remote command verification failed' };\n  }\n\n  const versionMarker = result.stdout.split('\\n').find((line) => line.startsWith('__VERSION__:'));\n  const version = versionMarker?.replace('__VERSION__:', '').trim() || 'unknown';\n  return { status: 'ok', message: `opta command available (${version})` };\n}\n\nfunction summarizeOutput(raw: string): string {\n  const firstLine = raw\n    .split('\\n')\n    .map((line) => line.trim())\n    .find((line) => line.length > 0);\n  return firstLine ?? 'unknown error';\n}\n\nexport function parseRemoteLanGuardMarker(output: string): RemoteLanGuardProbe | null {\n  for (const rawLine of output.split('\\n')) {\n    const line = rawLine.trim();\n    const match = /^__LAN_GUARD__:(ok|dual_ip|unsupported):([^:]*):([^:]*):([^:]*)$/.exec(line);\n    if (!match) continue;\n\n    return {\n      state: match[1] as RemoteLanGuardProbe['state'],\n      ethernetIp: match[2] ?? '',\n      wifiIp: match[3] ?? '',\n      wifiPower: match[4] ?? '',\n    };\n  }\n\n  return null;\n}\n\nfunction formatRemoteLanGuardContext(probe: RemoteLanGuardProbe): string {\n  const ethernetIp = probe.ethernetIp || 'none';\n  const wifiIp = probe.wifiIp || 'none';\n  const wifiPower = probe.wifiPower || 'unknown';\n  return `en0=${ethernetIp}, en1=${wifiIp}, wifi=${wifiPower}`;\n}\n\nfunction delayMs(ms: number): Promise<void> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n}\n\nasync function runRemoteLanStabilityGuard(\n  ssh: SshConfig,\n  dryRun: boolean,\n  mode: UpdateTargetMode,\n): Promise<RemoteLanGuardResult> {\n  if (dryRun) {\n    return {\n      status: 'ok',\n      message: 'dry-run LAN guard skipped',\n      canProceed: true,\n    };\n  }\n\n  const probeScript = [\n    'if ! command -v ipconfig >/dev/null 2>&1 || ! command -v networksetup >/dev/null 2>&1; then',\n    'echo \"__LAN_GUARD__:unsupported:::\"; exit 0;',\n    'fi;',\n    'eth_ip=\"$(ipconfig getifaddr en0 2>/dev/null || true)\";',\n    'wifi_ip=\"$(ipconfig getifaddr en1 2>/dev/null || true)\";',\n    'wifi_power=\"$(networksetup -getairportpower en1 2>/dev/null | sed -E \"s/^.*: //\")\";',\n    'if [ -n \"$eth_ip\" ] && [ -n \"$wifi_ip\" ] && [ \"$eth_ip\" = \"$wifi_ip\" ] && [ \"$wifi_power\" = \"On\" ]; then',\n    'echo \"__LAN_GUARD__:dual_ip:$eth_ip:$wifi_ip:$wifi_power\";',\n    'else',\n    'echo \"__LAN_GUARD__:ok:$eth_ip:$wifi_ip:$wifi_power\";',\n    'fi',\n  ].join(' ');\n\n  const probe = await runRemoteCommand(ssh, probeScript, false);\n  const probePayload = `${probe.stdout}\\n${probe.stderr}`;\n  const parsed = parseRemoteLanGuardMarker(probePayload);\n\n  if (probe.exitCode !== 0 && !parsed) {\n    return {\n      status: 'skip',\n      message: `LAN guard probe unavailable: ${summarizeOutput(probe.stderr || probe.stdout)}`,\n      canProceed: true,\n    };\n  }\n\n  if (!parsed) {\n    return {\n      status: 'skip',\n      message: 'LAN guard marker missing; continuing without network remediation',\n      canProceed: true,\n    };\n  }\n\n  if (parsed.state === 'unsupported') {\n    return {\n      status: 'skip',\n      message: 'LAN guard unsupported on remote host (missing macOS network tools)',\n      canProceed: true,\n    };\n  }\n\n  const context = formatRemoteLanGuardContext(parsed);\n  if (parsed.state === 'ok') {\n    return {\n      status: 'ok',\n      message: `LAN guard ok (${context})`,\n      canProceed: true,\n    };\n  }\n\n  const fixScript = [\n    'networksetup -setairportpower en1 off;',\n    'networksetup -setdhcp \"Wi-Fi\";',\n    'echo \"__LAN_GUARD_FIX__:applied\"',\n  ].join(' ');\n\n  const fix = await runRemoteCommand(ssh, fixScript, false);\n  let verify: CommandResult = { exitCode: 1, stdout: '', stderr: '' };\n  for (let attempt = 0; attempt < 8; attempt += 1) {\n    if (attempt > 0) {\n      await delayMs(1500);\n    }\n    verify = await runRemoteCommand(ssh, 'echo \"__LAN_GUARD_VERIFY__:ok\"', false);\n    if (verify.exitCode === 0) break;\n  }\n\n  if (verify.exitCode === 0 && fix.exitCode === 0) {\n    return {\n      status: 'ok',\n      message: `detected dual-IP conflict (${context}); disabled Wi-Fi and reset Wi-Fi DHCP`,\n      canProceed: true,\n    };\n  }\n\n  if (verify.exitCode === 0 && fix.exitCode !== 0) {\n    return {\n      status: 'skip',\n      message: `detected dual-IP conflict (${context}); connectivity recovered but fix command reported an error: ${summarizeOutput(fix.stderr || fix.stdout)}`,\n      canProceed: true,\n    };\n  }\n\n  const failureStatus = remoteConnectFailureStatus(mode);\n  const fixDetail = summarizeOutput(fix.stderr || fix.stdout);\n  const verifyDetail = summarizeOutput(verify.stderr || verify.stdout);\n  const modeHint = mode === 'auto'\n    ? 'auto mode skipped Studio updates; use --target remote once SSH is stable'\n    : 'fix network path and rerun update';\n\n  return {\n    status: failureStatus,\n    message: `dual-IP conflict detected (${context}); attempted auto-fix but SSH verification failed (fix=${fixDetail}; verify=${verifyDetail}) (${modeHint})`,\n    canProceed: false,\n  };\n}\n\nfunction isRecoverableGitFailure(raw: string): boolean {\n  const value = raw.toLowerCase();\n  return (\n    value.includes('permission denied (publickey)') ||\n    value.includes('could not read from remote repository') ||\n    value.includes('bad object head') ||\n    value.includes('repository not found')\n  );\n}\n\nfunction handleGitPullFailure(result: CommandResult, prefix: string): { status: StepStatus; message: string } {\n  const detail = result.stderr || result.stdout;\n  if (isRecoverableGitFailure(detail)) {\n    return {\n      status: 'skip',\n      message: `${prefix} unavailable (skipped): ${summarizeOutput(detail)}`,\n    };\n  }\n\n  return {\n    status: 'fail',\n    message: `${prefix} failed: ${detail}`,\n  };\n}\n\nasync function updateGitLocal(repoPath: string, noPull: boolean, dryRun: boolean): Promise<{ status: StepStatus; message: string }> {\n  if (!existsSync(repoPath)) {\n    return { status: 'skip', message: `repo missing: ${repoPath}` };\n  }\n  if (!existsSync(join(repoPath, '.git'))) {\n    return { status: 'skip', message: 'not a git repository (skipped pull)' };\n  }\n\n  const hasHead = await runLocalCommand('git rev-parse --verify HEAD >/dev/null 2>&1', repoPath, dryRun);\n  if (hasHead.exitCode !== 0) {\n    return { status: 'skip', message: 'invalid git metadata (missing HEAD, skipped pull)' };\n  }\n\n  const dirty = await runLocalCommand('git status --porcelain', repoPath, dryRun);\n  if (dirty.exitCode !== 0) {\n    return { status: 'skip', message: `git status unavailable (skipped pull): ${summarizeOutput(dirty.stderr || dirty.stdout)}` };\n  }\n  if (!dryRun && dirty.stdout.trim().length > 0) {\n    return { status: 'skip', message: 'dirty working tree (skipped pull)' };\n  }\n\n  if (noPull) {\n    return { status: 'ok', message: 'git pull skipped (--no-pull)' };\n  }\n\n  const pull = await runLocalCommand('git fetch --all --prune && git pull --ff-only', repoPath, dryRun);\n  if (pull.exitCode !== 0) {\n    return handleGitPullFailure(pull, 'git pull');\n  }\n\n  return { status: 'ok', message: dryRun ? 'dry-run git sync' : 'git sync complete' };\n}\n\nasync function updateGitRemote(repoPath: string, noPull: boolean, ssh: SshConfig, dryRun: boolean): Promise<{ status: StepStatus; message: string }> {\n  const script = [\n    `if [ ! -d ${quoteSh(repoPath)} ]; then exit 24; fi`,\n    `if [ ! -d ${quoteSh(join(repoPath, '.git'))} ]; then exit 26; fi`,\n    `git -C ${quoteSh(repoPath)} rev-parse --verify HEAD >/dev/null 2>&1 || exit 27`,\n    `status_out=\"$(git -C ${quoteSh(repoPath)} status --porcelain 2>/dev/null)\" || exit 28`,\n    'if [ -n \"$status_out\" ]; then exit 25; fi',\n    noPull ? ':' : `git -C ${quoteSh(repoPath)} fetch --all --prune && git -C ${quoteSh(repoPath)} pull --ff-only`,\n  ].join('; ');\n\n  const result = await runRemoteCommand(ssh, script, dryRun);\n\n  if (result.exitCode === 24) return { status: 'skip', message: `repo missing: ${repoPath}` };\n  if (result.exitCode === 26) return { status: 'skip', message: 'not a git repository (skipped pull)' };\n  if (result.exitCode === 27) return { status: 'skip', message: 'invalid git metadata (missing HEAD, skipped pull)' };\n  if (result.exitCode === 28) return { status: 'skip', message: 'git status unavailable (skipped pull)' };\n  if (result.exitCode === 25) return { status: 'skip', message: 'dirty working tree (skipped pull)' };\n  if (result.exitCode !== 0) {\n    return handleGitPullFailure(result, 'git sync');\n  }\n\n  return { status: 'ok', message: noPull ? 'git pull skipped (--no-pull)' : (dryRun ? 'dry-run git sync' : 'git sync complete') };\n}\n\nasync function runComponentBuildLocal(component: UpdateComponent, repoPath: string, dryRun: boolean, lmxPort: number): Promise<{ status: StepStatus; message: string }> {\n  switch (component) {\n    case 'cli': {\n      const cmd = CLI_UPDATE_BUILD_SCRIPT;\n      const result = await runLocalCommand(cmd, repoPath, dryRun);\n      if (result.exitCode !== 0) return { status: 'fail', message: result.stderr || result.stdout };\n      return { status: 'ok', message: dryRun ? 'dry-run typecheck + build' : 'npm typecheck + build complete' };\n    }\n    case 'lmx': {\n      const installCmd = [\n        `if [ -x ${quoteSh(join(repoPath, '.venv/bin/python'))} ]; then PIPY=${quoteSh(join(repoPath, '.venv/bin/python'))};`,\n        `elif [ -x ${quoteSh('/Users/Shared/Opta-LMX/venv/bin/python')} ]; then PIPY=${quoteSh('/Users/Shared/Opta-LMX/venv/bin/python')};`,\n        'else PIPY=python3; fi;',\n        `\"$PIPY\" -m pip install -e ${quoteSh(repoPath)} --no-deps || \"$PIPY\" -m pip install ${quoteSh(repoPath)} --no-deps`,\n      ].join(' ');\n\n      const install = await runLocalCommand(installCmd, repoPath, dryRun);\n      if (install.exitCode !== 0) return { status: 'fail', message: install.stderr || install.stdout };\n\n      const restartCmd = [\n        'pkill -f \"python -m opta_lmx.main\" >/dev/null 2>&1 || true;',\n        'pkill -f \"python -m opta_lmx\" >/dev/null 2>&1 || true;',\n        `if [ -x ${quoteSh(join(repoPath, '.venv/bin/python'))} ]; then PY=${quoteSh(join(repoPath, '.venv/bin/python'))};`,\n        `elif [ -x ${quoteSh('/Users/Shared/Opta-LMX/venv/bin/python')} ]; then PY=${quoteSh('/Users/Shared/Opta-LMX/venv/bin/python')};`,\n        'else PY=python3; fi;',\n        `nohup env LMX_LOGGING__FILE=/tmp/opta-lmx.log \"$PY\" -m opta_lmx.main --host 0.0.0.0 --port ${lmxPort} >/tmp/opta-lmx.log 2>&1 &`,\n        'ok=0;',\n        `for i in $(seq 1 45); do code=$(curl -s -o /dev/null -w \"%{http_code}\" http://127.0.0.1:${lmxPort}/healthz || true);`,\n        'if [ \"$code\" = \"200\" ] || [ \"$code\" = \"401\" ] || [ \"$code\" = \"403\" ]; then ok=1; break; fi;',\n        'sleep 1;',\n        'done;',\n        'if [ \"$ok\" = \"1\" ]; then true; else pgrep -f \"python -m opta_lmx.main\" >/dev/null 2>&1 || pgrep -f \"python -m opta_lmx\" >/dev/null 2>&1; fi',\n      ].join(' ');\n\n      const restart = await runLocalCommand(restartCmd, repoPath, dryRun);\n      if (restart.exitCode !== 0) {\n        return { status: 'fail', message: `install ok, restart/health failed: ${restart.stderr || restart.stdout}` };\n      }\n\n      return { status: 'ok', message: dryRun ? 'dry-run install/restart' : 'install + restart + health check complete' };\n    }\n    case 'plus': {\n      const result = await runLocalCommand('swift build', repoPath, dryRun);\n      if (result.exitCode !== 0) return { status: 'fail', message: result.stderr || result.stdout };\n      return { status: 'ok', message: dryRun ? 'dry-run swift build' : 'swift build complete' };\n    }\n    case 'web': {\n      const result = await runLocalCommand(\n        'if command -v pnpm >/dev/null 2>&1; then pnpm -C web run build || (pnpm -C web install --no-frozen-lockfile && pnpm -C web run build); else npm --prefix web run build || (npm --prefix web install --no-fund --no-audit && npm --prefix web run build); fi',\n        repoPath,\n        dryRun,\n      );\n      if (result.exitCode !== 0) return { status: 'fail', message: result.stderr || result.stdout };\n      return { status: 'ok', message: dryRun ? 'dry-run build' : 'web build complete' };\n    }\n  }\n}\n\nasync function runComponentBuildRemote(component: UpdateComponent, repoPath: string, dryRun: boolean, ssh: SshConfig, lmxPort: number, lmxPythonPath: string): Promise<{ status: StepStatus; message: string }> {\n  let command: string;\n\n  switch (component) {\n    case 'cli':\n      command = `cd ${quoteSh(repoPath)} && (${CLI_UPDATE_BUILD_SCRIPT})`;\n      break;\n    case 'lmx':\n      command = [\n        `cd ${quoteSh(repoPath)}`,\n        '&& {',\n        `if [ -x ${quoteSh('/Users/Shared/Opta-LMX/venv/bin/python')} ]; then PIPY=${quoteSh('/Users/Shared/Opta-LMX/venv/bin/python')};`,\n        `elif [ -x ${quoteSh(join(repoPath, '.venv/bin/python'))} ]; then PIPY=${quoteSh(join(repoPath, '.venv/bin/python'))};`,\n        'else PIPY=python3; fi;',\n        `\"$PIPY\" -m pip install -e ${quoteSh(repoPath)} --no-deps || \"$PIPY\" -m pip install ${quoteSh(repoPath)} --no-deps;`,\n        `pkill -f \"python -m opta_lmx.main\" >/dev/null 2>&1 || true;`,\n        `pkill -f \"python -m opta_lmx\" >/dev/null 2>&1 || true;`,\n        `if [ -x ${quoteSh(lmxPythonPath)} ] && ${quoteSh(lmxPythonPath)} -c \"import opta_lmx\" >/dev/null 2>&1; then PY=${quoteSh(lmxPythonPath)};`,\n        'elif command -v \"$PIPY\" >/dev/null 2>&1; then PY=\"$PIPY\";',\n        'else PY=python3; fi;',\n        `nohup env LMX_LOGGING__FILE=/tmp/opta-lmx.log \"$PY\" -m opta_lmx.main --host 0.0.0.0 --port ${lmxPort} >/tmp/opta-lmx.log 2>&1 &`,\n        'ok=0;',\n        `for i in $(seq 1 45); do code=$(curl -s -o /dev/null -w \"%{http_code}\" http://127.0.0.1:${lmxPort}/healthz || true);`,\n        'if [ \"$code\" = \"200\" ] || [ \"$code\" = \"401\" ] || [ \"$code\" = \"403\" ]; then ok=1; break; fi;',\n        'sleep 1;',\n        'done;',\n        'if [ \"$ok\" = \"1\" ]; then true; else pgrep -f \"python -m opta_lmx.main\" >/dev/null 2>&1 || pgrep -f \"python -m opta_lmx\" >/dev/null 2>&1; fi;',\n        '}',\n      ].join(' ');\n      break;\n    case 'plus':\n      command = `cd ${quoteSh(repoPath)} && swift build`;\n      break;\n    case 'web':\n      command = [\n        `cd ${quoteSh(repoPath)}`,\n        '&& if command -v pnpm >/dev/null 2>&1;',\n        'then pnpm -C web run build || (pnpm -C web install --no-frozen-lockfile && pnpm -C web run build);',\n        'else npm --prefix web run build || (npm --prefix web install --no-fund --no-audit && npm --prefix web run build);',\n        'fi',\n      ].join(' ');\n      break;\n  }\n\n  const result = await runRemoteCommand(ssh, command, dryRun);\n  if (result.exitCode !== 0) {\n    return { status: 'fail', message: result.stderr || result.stdout || 'remote command failed' };\n  }\n\n  const okMessage = component === 'lmx'\n    ? (dryRun ? 'dry-run install/restart' : 'install + restart + health check complete')\n    : component === 'cli'\n      ? (dryRun ? 'dry-run typecheck + build' : 'typecheck + build complete')\n    : (dryRun ? 'dry-run build' : 'build complete');\n  return { status: 'ok', message: okMessage };\n}\n\nfunction printHumanSummary(results: StepResult[]): void {\n  console.log('');\n  console.log(chalk.bold(colorizeOptaWord('Opta Update Summary')));\n\n  for (const result of results) {\n    const prefix = result.status === 'ok'\n      ? chalk.green('')\n      : result.status === 'skip'\n        ? chalk.yellow('!')\n        : chalk.red('');\n\n    const targetLabel = result.target === 'remote' && result.host\n      ? `${result.target}@${result.host}`\n      : result.target;\n\n    console.log(`${prefix} [${targetLabel}] ${result.component}:${result.step}  ${result.message}`);\n  }\n\n  const failures = results.filter((r) => r.status === 'fail').length;\n  const skips = results.filter((r) => r.status === 'skip').length;\n  const ok = results.filter((r) => r.status === 'ok').length;\n\n  console.log('');\n  console.log(chalk.dim(`ok=${ok} skip=${skips} fail=${failures}`));\n}\n\nfunction componentStep(\n  target: UpdateTarget,\n  component: UpdateComponent,\n  step: string,\n  outcome: { status: StepStatus; message: string },\n  host?: string,\n): StepResult {\n  return {\n    target,\n    component,\n    step,\n    status: outcome.status,\n    message: outcome.message,\n    host,\n  };\n}\n\nfunction canProceedToBuild(gitResult: { status: StepStatus; message: string }): boolean {\n  if (gitResult.status === 'fail') return false;\n  if (gitResult.message.startsWith('repo missing:')) return false;\n  return true;\n}\n\nexport async function updateCommand(opts: UpdateOptions): Promise<void> {\n  const config = await loadConfig();\n  const components = parseComponentList(opts.components);\n  const mode = opts.target ?? 'auto';\n  const remoteHost = opts.remoteHost ?? config.connection.host;\n  const targets = resolveTargets(mode, remoteHost);\n  let remoteHostUsed: string | null = null;\n\n  const results: StepResult[] = [];\n  const dryRun = Boolean(opts.dryRun);\n  const noBuild = opts.build === false;\n  const noPull = opts.pull === false;\n\n  const localAppsRoot = opts.localRoot\n    ? expandHome(opts.localRoot)\n    : detectAppsRoot(process.cwd());\n\n  const remoteAppsRoot = opts.remoteRoot\n    ? expandHome(opts.remoteRoot)\n    : deriveRemoteAppsRootFromLmxPath(config.connection.ssh.lmxPath);\n\n  const verifyStepCount = targets.includes('remote') && components.includes('cli') && !isLocalHost(remoteHost)\n    ? 1\n    : 0;\n  const remoteGuardStepCount = targets.includes('remote') && !isLocalHost(remoteHost)\n    ? 1\n    : 0;\n  const localStepCount = targets.includes('local')\n    ? (localAppsRoot ? components.length * 2 : 1)\n    : 0;\n  const remoteStepCount = targets.includes('remote')\n    ? (\n        isLocalHost(remoteHost)\n          ? components.length\n          : (components.length * 2 + verifyStepCount + remoteGuardStepCount)\n      )\n    : 0;\n  const progress = createSegmentedStepProgressTracker(\n    [\n      ...(localStepCount > 0 ? [{ key: 'local', label: 'Local', totalSteps: localStepCount }] : []),\n      ...(remoteStepCount > 0 ? [{ key: 'remote', label: 'Studio', totalSteps: remoteStepCount }] : []),\n    ],\n    'Update progress',\n    !opts.json,\n  );\n  const pushResult = (result: StepResult): void => {\n    results.push(result);\n    const hostSuffix = result.target === 'remote' && result.host\n      ? `@${result.host}`\n      : '';\n    const scope = result.target === 'remote' ? 'studio' : 'local';\n    progress.tick(result.target, `[${scope}] ${result.component}:${result.step}${hostSuffix} ${result.status}`);\n  };\n\n  if (targets.includes('local')) {\n    if (!localAppsRoot) {\n      pushResult({\n        target: 'local',\n        component: 'cli',\n        step: 'discover-root',\n        status: 'fail',\n        message: 'could not determine local 1-Apps root; use --local-root',\n      });\n    } else {\n      for (const component of components) {\n        const repoPath = componentRepoPath(component, localAppsRoot);\n        const gitResult = await updateGitLocal(repoPath, noPull, dryRun);\n        pushResult(componentStep('local', component, 'git', gitResult));\n\n        if (!canProceedToBuild(gitResult) || noBuild) {\n          if (noBuild) {\n            pushResult({\n              target: 'local',\n              component,\n              step: 'build',\n              status: 'skip',\n              message: 'skipped (--no-build)',\n            });\n          }\n          continue;\n        }\n\n        const buildResult = await runComponentBuildLocal(component, repoPath, dryRun, config.connection.port);\n        pushResult(componentStep('local', component, 'build', buildResult));\n      }\n    }\n  }\n\n  if (targets.includes('remote')) {\n    if (isLocalHost(remoteHost)) {\n      remoteHostUsed = remoteHost;\n      for (const component of components) {\n        pushResult({\n          target: 'remote',\n          component,\n          step: 'connect',\n          status: 'skip',\n          message: `remote host ${remoteHost} resolves to local; skipped`,\n          host: remoteHost,\n        });\n      }\n    } else {\n      const baseSshConfig: SshConfig = {\n        host: remoteHost,\n        user: opts.remoteUser ?? config.connection.ssh.user,\n        identityFile: expandHome(opts.identityFile ?? config.connection.ssh.identityFile),\n      };\n\n      const remoteCandidates = resolveRemoteHostCandidates(remoteHost, config.connection.fallbackHosts);\n      const selection = await selectReachableRemoteHost(remoteCandidates, (candidateHost) => runRemoteCommand({\n        ...baseSshConfig,\n        host: candidateHost,\n      }, 'echo connected', dryRun), { parallel: true });\n\n      if (!selection.selectedHost) {\n        const connectStatus = remoteConnectFailureStatus(mode);\n        const attemptDetail = selection.probes.length > 0\n          ? selection.probes.map((probe) => `${probe.host}: ${summarizeOutput(probe.detail)}`).join('; ')\n          : 'ssh failed';\n        const attemptedHosts = remoteCandidates.length > 0 ? remoteCandidates.join(', ') : remoteHost;\n        const connectDetail = `ssh failed for hosts (${attemptedHosts})  ${attemptDetail}`;\n        const connectMessage = mode === 'auto'\n          ? `${connectDetail} (auto mode skipped Studio updates; use --target remote once SSH is reachable)`\n          : connectDetail;\n        for (const component of components) {\n          pushResult({\n            target: 'remote',\n            component,\n            step: 'connect',\n            status: connectStatus,\n            message: connectMessage,\n            host: remoteHost,\n          });\n        }\n      } else {\n        remoteHostUsed = selection.selectedHost;\n        const sshConfig: SshConfig = {\n          ...baseSshConfig,\n          host: selection.selectedHost,\n        };\n\n        const guardComponent = components[0] ?? 'cli';\n        const guard = await runRemoteLanStabilityGuard(sshConfig, dryRun, mode);\n        pushResult(componentStep('remote', guardComponent, 'network', {\n          status: guard.status,\n          message: guard.message,\n        }, sshConfig.host));\n\n        if (!guard.canProceed) {\n          const gatedMessage = 'skipped due LAN guard failure';\n          for (const component of components) {\n            pushResult({\n              target: 'remote',\n              component,\n              step: 'git',\n              status: 'skip',\n              message: gatedMessage,\n              host: sshConfig.host,\n            });\n\n            if (noBuild) {\n              pushResult({\n                target: 'remote',\n                component,\n                step: 'build',\n                status: 'skip',\n                message: 'skipped (--no-build)',\n                host: sshConfig.host,\n              });\n            } else {\n              pushResult({\n                target: 'remote',\n                component,\n                step: 'build',\n                status: 'skip',\n                message: gatedMessage,\n                host: sshConfig.host,\n              });\n            }\n\n            if (component === 'cli') {\n              pushResult({\n                target: 'remote',\n                component,\n                step: 'verify',\n                status: 'skip',\n                message: gatedMessage,\n                host: sshConfig.host,\n              });\n            }\n          }\n        } else {\n          for (const component of components) {\n            const repoPath = component === 'lmx'\n              ? config.connection.ssh.lmxPath\n              : remoteAppsRoot\n                ? componentRepoPath(component, remoteAppsRoot)\n                : '';\n\n            if (!repoPath) {\n              pushResult({\n                target: 'remote',\n                component,\n                step: 'discover-root',\n                status: 'skip',\n                message: 'remote path unavailable; set --remote-root for cli/plus/web',\n                host: sshConfig.host,\n              });\n              continue;\n            }\n\n            const gitResult = await updateGitRemote(repoPath, noPull, sshConfig, dryRun);\n            pushResult(componentStep('remote', component, 'git', gitResult, sshConfig.host));\n\n            if (!canProceedToBuild(gitResult)) {\n              continue;\n            }\n\n            if (noBuild) {\n              pushResult({\n                target: 'remote',\n                component,\n                step: 'build',\n                status: 'skip',\n                message: 'skipped (--no-build)',\n                host: sshConfig.host,\n              });\n            } else {\n              const buildResult = await runComponentBuildRemote(\n                component,\n                repoPath,\n                dryRun,\n                sshConfig,\n                config.connection.port,\n                config.connection.ssh.pythonPath,\n              );\n              pushResult(componentStep('remote', component, 'build', buildResult, sshConfig.host));\n            }\n\n            if (component === 'cli') {\n              const verify = await verifyRemoteCliCommands(sshConfig, dryRun);\n              pushResult(componentStep('remote', component, 'verify', verify, sshConfig.host));\n            }\n          }\n        }\n      }\n    }\n  }\n\n  progress.done('all update steps finished');\n\n  if (opts.json) {\n    console.log(JSON.stringify({\n      mode,\n      components,\n      targets,\n      dryRun,\n      noBuild,\n      noPull,\n      localAppsRoot,\n      remoteHost,\n      remoteHostUsed,\n      remoteAppsRoot,\n      results,\n    }, null, 2));\n  } else {\n    printHumanSummary(results);\n  }\n\n  let updateLogPath: string | null = null;\n  const journal = config.journal;\n  if (journal?.enabled !== false) {\n    try {\n      const written = await writeUpdateLog({\n        summary: `opta update (${mode})  ${components.join(', ')}`,\n        commandInputs: {\n          components,\n          mode,\n          targets,\n          dryRun,\n          noBuild,\n          noPull,\n          localAppsRoot: localAppsRoot ?? '(auto-detect failed)',\n          remoteHost,\n          remoteHostUsed: remoteHostUsed ?? '(none)',\n          remoteAppsRoot: remoteAppsRoot ?? '(auto)',\n          json: Boolean(opts.json),\n        },\n        steps: results.map((result) => ({\n          target: result.target,\n          component: result.component,\n          step: result.step,\n          status: result.status,\n          message: result.host ? `[${result.host}] ${result.message}` : result.message,\n        })),\n        cwd: process.cwd(),\n        logsDir: journal?.updateLogsDir,\n        timezone: journal?.timezone,\n        author: journal?.author,\n        rangeStart: 200,\n        rangeEnd: 299,\n        promoted: true,\n        category: 'sync',\n      });\n      updateLogPath = written.path;\n    } catch {\n      // Fail-open by design: update command must not fail due to logging errors.\n    }\n  }\n\n  if (!opts.json && updateLogPath) {\n    console.log(chalk.dim(`Update log: ${updateLogPath}`));\n  }\n\n  const hasFailure = results.some((r) => r.status === 'fail');\n  if (hasFailure) {\n    throw new ExitError(EXIT.ERROR);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/context/exports.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/context/opis.ts","messages":[{"ruleId":"@typescript-eslint/return-await","severity":1,"message":"Returning an awaited promise is not allowed in this context.","line":208,"column":12,"nodeType":"AwaitExpression","messageId":"disallowedPromiseAwait","endLine":208,"endColumn":51,"fix":{"range":[5321,5327],"text":""}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { readFile, access } from 'node:fs/promises';\nimport { join } from 'node:path';\n\n// --- Types ---\n\nexport interface OpisContext {\n  summary: string; // Compressed text for system prompt\n  hasOpis: boolean; // Whether OPIS scaffold was found\n  docsDir: string; // Path to docs directory\n  fallbackMemory?: string; // Legacy memory content if no OPIS\n}\n\n// --- Constants ---\n\n/** Whitelist of recognized OPIS documentation files. */\nconst OPIS_FILES = [\n  'APP.md',\n  'ARCHITECTURE.md',\n  'GUARDRAILS.md',\n  'DECISIONS.md',\n  'ECOSYSTEM.md',\n  'KNOWLEDGE.md',\n  'WORKFLOWS.md',\n  'ROADMAP.md',\n  'INDEX.md',\n];\n\n// --- YAML Frontmatter Parser ---\n\ninterface Frontmatter {\n  title?: string;\n  type?: string;\n  status?: string;\n  [key: string]: string | undefined;\n}\n\n/**\n * Parse YAML frontmatter from markdown content.\n * Returns the parsed key-value pairs and the body (content after frontmatter).\n */\nfunction parseFrontmatter(content: string): { meta: Frontmatter; body: string } {\n  const trimmed = content.trimStart();\n  if (!trimmed.startsWith('---')) {\n    return { meta: {}, body: content };\n  }\n\n  const endIndex = trimmed.indexOf('---', 3);\n  if (endIndex === -1) {\n    return { meta: {}, body: content };\n  }\n\n  const yamlBlock = trimmed.slice(3, endIndex).trim();\n  const meta: Frontmatter = {};\n\n  for (const line of yamlBlock.split('\\n')) {\n    const colonIndex = line.indexOf(':');\n    if (colonIndex === -1) continue;\n    const key = line.slice(0, colonIndex).trim();\n    const value = line.slice(colonIndex + 1).trim();\n    if (key && value) {\n      meta[key] = value;\n    }\n  }\n\n  const body = trimmed.slice(endIndex + 3).trimStart();\n  return { meta, body };\n}\n\n// --- Helpers ---\n\n/**\n * Check if a file exists at the given path.\n */\nasync function fileExists(path: string): Promise<boolean> {\n  try {\n    await access(path);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Safely read a file, returning null if it doesn't exist.\n */\nasync function safeReadFile(path: string): Promise<string | null> {\n  try {\n    return await readFile(path, 'utf-8');\n  } catch (err) {\n    const code = (err as NodeJS.ErrnoException | undefined)?.code;\n    // Missing OPIS docs are expected in fallback paths.\n    if (code === 'ENOENT' || code === 'ENOTDIR') {\n      return null;\n    }\n    console.error(`Failed to read project doc ${path}:`, err);\n    return null;\n  }\n}\n\n/**\n * Extract the first non-heading, non-empty sentence from markdown body.\n */\nfunction extractPurpose(body: string): string {\n  const lines = body.split('\\n');\n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (!trimmed) continue;\n    if (trimmed.startsWith('#')) continue;\n    if (trimmed.startsWith('---')) continue;\n    // Return the first real content line\n    return trimmed;\n  }\n  return '';\n}\n\n/**\n * Extract guardrail rules matching `- G-XX:` pattern from content.\n */\nfunction extractGuardrails(content: string): string[] {\n  const rules: string[] = [];\n  for (const line of content.split('\\n')) {\n    const match = line.match(/^-\\s+(G-\\d+:.*)$/);\n    if (match?.[1]) {\n      rules.push(match[1]);\n    }\n  }\n  return rules;\n}\n\n/**\n * Extract decision headers matching `## D-XX:` pattern from content.\n * Returns the last 5.\n */\nfunction extractRecentDecisions(content: string): string[] {\n  const decisions: string[] = [];\n  for (const line of content.split('\\n')) {\n    const match = line.match(/^##\\s+(D-\\d+:.*)$/);\n    if (match?.[1]) {\n      decisions.push(match[1]);\n    }\n  }\n  // Return last 5\n  return decisions.slice(-5);\n}\n\n/**\n * Discover which OPIS files exist in the project (root and docs/).\n */\nasync function discoverOpisFiles(cwd: string): Promise<string[]> {\n  const docsDir = join(cwd, 'docs');\n  const found: string[] = [];\n\n  for (const file of OPIS_FILES) {\n    // APP.md lives at root\n    if (file === 'APP.md') {\n      if (await fileExists(join(cwd, file))) {\n        found.push(file);\n      }\n    } else {\n      // Other OPIS files live in docs/\n      if (await fileExists(join(docsDir, file))) {\n        found.push(file);\n      }\n    }\n  }\n\n  return found;\n}\n\n// --- Public API ---\n\n/**\n * Read a specific OPIS project document.\n *\n * Search order: docs/{file} first, then ./{file} (root).\n * Returns file content or a helpful message if not found.\n */\nexport async function readProjectDoc(cwd: string, file: string): Promise<string> {\n  // Try docs/ first\n  const docsPath = join(cwd, 'docs', file);\n  const docsContent = await safeReadFile(docsPath);\n  if (docsContent !== null) return docsContent;\n\n  // Try root\n  const rootPath = join(cwd, file);\n  const rootContent = await safeReadFile(rootPath);\n  if (rootContent !== null) return rootContent;\n\n  // Not found\n  return `${file} not found. Run \\`opta init\\` to scaffold OPIS project docs.`;\n}\n\n/**\n * Load OPIS context from the project directory.\n *\n * Detection: looks for APP.md at project root.\n * Fallback chain: APP.md -> .opta/memory.md -> CLAUDE.md -> no context.\n */\nexport async function loadOpisContext(cwd: string): Promise<OpisContext> {\n  const docsDir = join(cwd, 'docs');\n\n  // Check for APP.md (OPIS indicator)\n  const appMdPath = join(cwd, 'APP.md');\n  const appMdContent = await safeReadFile(appMdPath);\n\n  if (appMdContent === null) {\n    // No OPIS scaffold -- try fallback chain\n    return await loadFallbackContext(cwd, docsDir);\n  }\n\n  // Parse APP.md\n  const { meta, body } = parseFrontmatter(appMdContent);\n  const purpose = extractPurpose(body);\n\n  // Build summary sections\n  const sections: string[] = [];\n\n  // Project identity\n  const identityParts: string[] = [];\n  if (meta.title) identityParts.push(meta.title);\n  if (meta.type) identityParts.push(`(${meta.type})`);\n  if (meta.status) identityParts.push(`[${meta.status}]`);\n  if (purpose) identityParts.push(`- ${purpose}`);\n\n  if (identityParts.length > 0) {\n    sections.push(`Project identity: ${identityParts.join(' ')}`);\n  } else {\n    // No frontmatter, use first line of body as identity\n    const firstLine = body.split('\\n').find((l) => l.trim().length > 0)?.trim() || 'Unknown project';\n    sections.push(`Project identity: ${firstLine}`);\n  }\n\n  // Guardrails\n  const guardrailsContent = await safeReadFile(join(docsDir, 'GUARDRAILS.md'));\n  if (guardrailsContent) {\n    const rules = extractGuardrails(guardrailsContent);\n    if (rules.length > 0) {\n      sections.push(`Guardrails: ${rules.join('; ')}`);\n    }\n  }\n\n  // Recent decisions\n  const decisionsContent = await safeReadFile(join(docsDir, 'DECISIONS.md'));\n  if (decisionsContent) {\n    const decisions = extractRecentDecisions(decisionsContent);\n    if (decisions.length > 0) {\n      sections.push(`Recent decisions: ${decisions.join('; ')}`);\n    }\n  }\n\n  // Available docs footer\n  const availableDocs = await discoverOpisFiles(cwd);\n  if (availableDocs.length > 0) {\n    sections.push(`Available docs: ${availableDocs.join(', ')}`);\n  }\n\n  return {\n    summary: sections.join('\\n'),\n    hasOpis: true,\n    docsDir,\n  };\n}\n\n/**\n * Load fallback context when no OPIS scaffold is found.\n * Chain: .opta/memory.md -> CLAUDE.md -> empty\n */\nasync function loadFallbackContext(cwd: string, docsDir: string): Promise<OpisContext> {\n  // Try .opta/memory.md\n  const memoryContent = await safeReadFile(join(cwd, '.opta', 'memory.md'));\n  if (memoryContent) {\n    return {\n      summary: '',\n      hasOpis: false,\n      docsDir,\n      fallbackMemory: memoryContent,\n    };\n  }\n\n  // Try CLAUDE.md\n  const claudeContent = await safeReadFile(join(cwd, 'CLAUDE.md'));\n  if (claudeContent) {\n    return {\n      summary: '',\n      hasOpis: false,\n      docsDir,\n      fallbackMemory: claudeContent,\n    };\n  }\n\n  // No context available\n  return {\n    summary: '',\n    hasOpis: false,\n    docsDir,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/core/agent-execution.ts","messages":[{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['command'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":71,"column":26,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":71,"endColumn":47},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'parsedArgs['command'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":205,"column":50,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":205,"endColumn":77},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'parsedArgs['path'] ?? 'unknown'' will use Object's default stringification format ('[object Object]') when stringified.","line":225,"column":117,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":225,"endColumn":148}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * agent-execution.ts  Parallel tool dispatch with semaphore.\n *\n * Extracted from agent.ts to isolate the bounded-concurrency tool execution,\n * result collection, and tool card display logic.\n */\n\nimport type { OptaConfig } from './config.js';\nimport { debug } from './debug.js';\nimport { errorMessage } from '../utils/errors.js';\nimport { safeParseJson } from '../utils/json.js';\nimport { formatToolCall, formatToolResult } from '../ui/toolcards.js';\nimport type { Spinner } from '../ui/spinner.js';\nimport type { OnStreamCallbacks } from './agent.js';\nimport type { AgentMessage } from './agent.js';\nimport type { ToolDecision } from './agent-permissions.js';\nimport type { SessionContext } from '../hooks/integration.js';\nimport { fireToolPost, type HookManager } from '../hooks/integration.js';\nimport type { InsightEngine } from './insights.js';\nimport type { SubAgentContext } from './subagent.js';\n\n// --- Types ---\n\nexport interface ExecutionContext {\n  config: OptaConfig;\n  spinner: Spinner;\n  silent: boolean;\n  isSubAgent: boolean;\n  sessionId: string;\n  streamCallbacks?: OnStreamCallbacks;\n  insightEngine?: InsightEngine | null;\n  hooks: HookManager;\n  sessionCtx: SessionContext;\n  /** The tool registry with execute() and close() methods. */\n  registry: {\n    execute: (\n      name: string,\n      args: string,\n      parentCtx?: SubAgentContext,\n      signal?: AbortSignal\n    ) => Promise<string>;\n    close: () => Promise<void>;\n  };\n  signal?: AbortSignal;\n}\n\nexport interface ExecutionResult {\n  /** Number of tools that were successfully executed. */\n  toolCallsDelta: number;\n  /** New checkpoint count after any checkpoint creation. */\n  checkpointCount: number;\n}\n\nfunction queueLearningCapture(\n  config: OptaConfig,\n  event: import('../learning/hooks.js').CaptureLearningEventInput,\n): void {\n  if (!config.learning.enabled) return;\n  void import('../learning/hooks.js')\n    .then(({ captureLearningEvent }) => captureLearningEvent(config, event))\n    .catch(() => {});\n}\n\nfunction isSuccessfulVerificationCommand(\n  toolName: string,\n  args: Record<string, unknown>,\n  result: string,\n): boolean {\n  if (toolName !== 'run_command') return false;\n  if (!result.includes('[exit code: 0]')) return false;\n  const command = String(args['command'] ?? '').toLowerCase();\n  return /(test|build|typecheck|lint|vitest|npm run)/.test(command);\n}\n\n/**\n * Execute approved tool calls in parallel (bounded concurrency), collect results\n * in original order, and push tool messages onto the conversation.\n */\nexport async function executeToolCalls(\n  decisions: ToolDecision[],\n  messages: AgentMessage[],\n  ctx: ExecutionContext,\n  prevToolCallCount: number,\n  prevCheckpointCount: number,\n): Promise<ExecutionResult> {\n  const ensureNotAborted = () => {\n    if (ctx.signal?.aborted) {\n      const err = new Error('Turn cancelled');\n      err.name = 'AbortError';\n      throw err;\n    }\n  };\n\n  ensureNotAborted();\n  const maxParallel = ctx.config.safety.maxParallelTools;\n  let toolCallCount = prevToolCallCount;\n  let checkpointCount = prevCheckpointCount;\n\n  const approvedCalls = decisions.filter(d => d.approved);\n\n  // Simple semaphore for bounded concurrency\n  let running = 0;\n  const queue: Array<() => void> = [];\n  const acquire = () => new Promise<void>(resolve => {\n    if (running < maxParallel) { running++; resolve(); }\n    else queue.push(() => { running++; resolve(); });\n  });\n  const release = () => { running--; const next = queue.shift(); if (next) next(); };\n\n  const executionResults = new Map<string, { result: string; error?: undefined } | { result?: undefined; error: string }>();\n\n  // Display tool cards for approved calls\n  for (const { call, executionArgsJson } of approvedCalls) {\n    const effectiveArgs = executionArgsJson ?? call.args;\n    if (!ctx.silent) {\n      const parsedArgs = safeParseJson<Record<string, unknown>>(effectiveArgs, { raw: effectiveArgs });\n      console.log(formatToolCall(call.name, parsedArgs));\n    }\n    ctx.streamCallbacks?.onToolStart?.(call.name, call.id, effectiveArgs);\n    ctx.insightEngine?.toolStart(call.name, effectiveArgs);\n  }\n\n  // Execute in parallel with semaphore\n  if (approvedCalls.length > 0) {\n    ctx.spinner.start(`Running ${approvedCalls.length} tool${approvedCalls.length > 1 ? 's' : ''}...`);\n    await Promise.all(\n      approvedCalls.map(async ({ call, executionArgsJson }) => {\n        ensureNotAborted();\n        await acquire();\n        try {\n          ensureNotAborted();\n          const effectiveArgs = executionArgsJson ?? call.args;\n          const result = await ctx.registry.execute(call.name, effectiveArgs, undefined, ctx.signal);\n          executionResults.set(call.id, { result });\n          ctx.streamCallbacks?.onToolEnd?.(call.name, call.id, result);\n          await fireToolPost(ctx.hooks, call.name, effectiveArgs, result, ctx.sessionCtx);\n        } catch (err) {\n          if (ctx.signal?.aborted || (err instanceof Error && err.name === 'AbortError')) {\n            throw err;\n          }\n          const errMsg = errorMessage(err);\n          executionResults.set(call.id, { error: `Error: ${errMsg}` });\n          ctx.streamCallbacks?.onToolEnd?.(call.name, call.id, `Error: ${errMsg}`);\n        } finally {\n          release();\n        }\n      })\n    );\n    ctx.spinner.succeed(`${approvedCalls.length} tool${approvedCalls.length > 1 ? 's' : ''} done`);\n  }\n\n  // Collect results in original order\n  // Lazy-load git modules only when needed\n  let gitUtilsMod: typeof import('../git/utils.js') | null = null;\n  let gitCheckpointsMod: typeof import('../git/checkpoints.js') | null = null;\n  if (!ctx.isSubAgent && ctx.config.git.checkpoints) {\n    gitUtilsMod = await import('../git/utils.js');\n    gitCheckpointsMod = await import('../git/checkpoints.js');\n  }\n\n  for (const decision of decisions) {\n    ensureNotAborted();\n    const { call } = decision;\n    const effectiveArgs = decision.executionArgsJson ?? call.args;\n\n    if (!decision.approved) {\n      messages.push({\n        role: 'tool',\n        content: decision.denialReason ?? 'Permission denied.',\n        tool_call_id: call.id,\n      });\n      continue;\n    }\n\n    const execResult = executionResults.get(call.id);\n    const result = execResult?.result ?? execResult?.error ?? 'Error: no result';\n\n    if (!ctx.silent && result) {\n      console.log(formatToolResult(call.name, result));\n    }\n\n    messages.push({\n      role: 'tool',\n      content: result,\n      tool_call_id: call.id,\n    });\n\n    const parsedArgs = safeParseJson<Record<string, unknown>>(effectiveArgs, {});\n    if (result.startsWith('Error:')) {\n      queueLearningCapture(ctx.config, {\n        kind: 'problem',\n        topic: `Tool failure: ${call.name}`,\n        content: result.slice(0, 1200),\n        tags: ['tool-failure', call.name],\n        evidence: [{ label: 'session', uri: `session://${ctx.sessionId}` }],\n        metadata: {\n          tool: call.name,\n          args: parsedArgs,\n        },\n        verified: false,\n      });\n    } else if (isSuccessfulVerificationCommand(call.name, parsedArgs, result)) {\n      queueLearningCapture(ctx.config, {\n        kind: 'solution',\n        topic: `Verification succeeded: ${String(parsedArgs['command'] ?? '').slice(0, 120)}`,\n        content: result.slice(0, 1200),\n        tags: ['verification', 'success', 'run_command'],\n        evidence: [{ label: 'session', uri: `session://${ctx.sessionId}` }],\n        metadata: {\n          tool: call.name,\n          args: parsedArgs,\n        },\n        verified: true,\n      });\n    }\n\n    toolCallCount++;\n    debug(`Tool call #${toolCallCount}: ${call.name} \\u2192 ${result.slice(0, 100)}`);\n\n    // Create checkpoint for file-modifying tools (skip for sub-agents)\n    if (!ctx.isSubAgent && ctx.config.git.checkpoints && (call.name === 'edit_file' || call.name === 'write_file')) {\n      try {\n        if (gitUtilsMod && gitCheckpointsMod && await gitUtilsMod.isGitRepo(process.cwd())) {\n          checkpointCount++;\n          await gitCheckpointsMod.createCheckpoint(process.cwd(), ctx.sessionId, checkpointCount, call.name, String(parsedArgs['path'] ?? 'unknown'));\n        }\n      } catch {\n        // Checkpoint creation failed  non-fatal\n      }\n    }\n  }\n\n  return { toolCallsDelta: toolCallCount - prevToolCallCount, checkpointCount };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/core/agent-permissions.ts","messages":[{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":1,"message":"Invalid type \"unknown\" of template literal expression.","line":102,"column":38,"nodeType":"MemberExpression","messageId":"invalidType","endLine":102,"endColumn":50},{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":1,"message":"Invalid type \"unknown\" of template literal expression.","line":106,"column":38,"nodeType":"MemberExpression","messageId":"invalidType","endLine":106,"endColumn":50},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['content'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":107,"column":28,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":107,"endColumn":49},{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":1,"message":"Invalid type \"unknown\" of template literal expression.","line":110,"column":34,"nodeType":"MemberExpression","messageId":"invalidType","endLine":110,"endColumn":49},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":226,"column":28,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":226,"endColumn":46},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":335,"column":19,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":335,"endColumn":38},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":374,"column":21,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":374,"endColumn":40},{"ruleId":"@typescript-eslint/no-unnecessary-type-conversion","severity":1,"message":"Passing a string to String() does not change the type or value of the string.","line":413,"column":73,"nodeType":"Identifier","messageId":"unnecessaryTypeConversion","endLine":413,"endColumn":79,"suggestions":[{"messageId":"suggestRemove","fix":{"range":[15105,15130],"text":"parsedArgs['url']"},"desc":"Remove the type conversion."},{"messageId":"suggestSatisfies","data":{"type":"string"},"fix":{"range":[15105,15130],"text":"(parsedArgs['url'] satisfies string)"},"desc":"Instead, assert that the value satisfies the string type."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * agent-permissions.ts  Tool approval flow.\n *\n * Extracted from agent.ts to isolate the permission checking logic,\n * the interactive approval prompt, and the \"always allow\" persistence.\n */\n\nimport chalk from 'chalk';\nimport type { OptaConfig } from './config.js';\nimport { resolveBrowserPolicyConfig } from './browser-policy-config.js';\nimport { resolvePermission } from './tools/index.js';\nimport { PolicyEngine } from '../policy/engine.js';\nimport type { PolicyConfig } from '../policy/types.js';\nimport {\n  evaluateBrowserPolicyAction,\n  isBrowserToolName,\n} from '../browser/policy-engine.js';\nimport {\n  appendBrowserApprovalEvent,\n  extractBrowserSessionId,\n} from '../browser/approval-log.js';\nimport { loadBrowserRunCorpusAdaptationHint } from '../browser/adaptation.js';\nimport { safeParseJson } from '../utils/json.js';\nimport { runMenuPrompt } from '../ui/prompt-nav.js';\nimport type { OnStreamCallbacks } from './agent.js';\nimport type { ToolCallAccum } from './agent-streaming.js';\nimport type { SessionContext } from '../hooks/integration.js';\nimport {\n  fireToolPre,\n  type HookManager,\n} from '../hooks/integration.js';\n\n// --- Types ---\n\nexport interface ToolDecision {\n  call: ToolCallAccum;\n  approved: boolean;\n  denialReason?: string;\n  executionArgsJson?: string;\n}\n\ntype PermissionResponse = 'once' | 'always' | 'deny';\n\ninterface BrowserSessionScanResult {\n  sessions: Array<{\n    sessionId: string;\n    currentUrl?: string;\n  }>;\n  sessionIds: string[];\n  error?: string;\n}\n\nfunction isShellBrowserAutomationCommand(value: unknown): boolean {\n  if (typeof value !== 'string') return false;\n  const command = value.toLowerCase();\n  if (!command.includes('osascript')) return false;\n  return (\n    command.includes('application \"safari\"')\n    || command.includes('application \"google chrome\"')\n    || command.includes('application \"chrome\"')\n    || command.includes('document.queryselector')\n    || command.includes('javascript')\n  );\n}\n\nfunction mapPolicyFailureMode(\n  failureMode: OptaConfig['policy']['failureMode'],\n): PolicyConfig['failureMode'] {\n  if (failureMode === 'open') return 'open';\n  // Engine accepts only open|closed; degraded-safe maps to fail-closed.\n  return 'closed';\n}\n\nfunction mapPolicyConfig(policy: OptaConfig['policy']): PolicyConfig {\n  return {\n    enabled: policy.enabled,\n    mode: policy.mode,\n    gateAllAutonomy: policy.gateAllAutonomy,\n    failureMode: mapPolicyFailureMode(policy.failureMode),\n    audit: {\n      enabled: policy.audit.enabled,\n    },\n  };\n}\n\n// --- Permission Prompt ---\n\nasync function promptToolApproval(\n  toolName: string,\n  args: Record<string, unknown>\n): Promise<PermissionResponse> {\n  // Non-interactive environments (CI, piped stdin) default to deny\n  if (!process.stdin.isTTY || process.env['CI'] === 'true') {\n    return 'deny';\n  }\n\n  console.log();\n  console.log(chalk.yellow(`  Tool: ${toolName}`));\n\n  // Show relevant details based on tool type\n  if (toolName === 'edit_file') {\n    console.log(chalk.dim(`  File: ${args['path']}`));\n    console.log(chalk.red(`  - ${String(args['old_text']).slice(0, 100)}`));\n    console.log(chalk.green(`  + ${String(args['new_text']).slice(0, 100)}`));\n  } else if (toolName === 'write_file') {\n    console.log(chalk.dim(`  File: ${args['path']}`));\n    const content = String(args['content'] ?? '');\n    console.log(chalk.dim(`  ${content.length} bytes`));\n  } else if (toolName === 'run_command') {\n    console.log(chalk.dim(`  $ ${args['command']}`));\n  } else {\n    console.log(chalk.dim(`  ${JSON.stringify(args)}`));\n  }\n\n  const { select } = await import('@inquirer/prompts');\n  const choice = await runMenuPrompt((context) =>\n    select({\n      message: 'Allow?',\n      choices: [\n        { name: 'Yes, allow this once', value: 'once' as const },\n        { name: 'Always allow (persist)', value: 'always' as const },\n        { name: 'Deny', value: 'deny' as const },\n      ],\n      default: 'once',\n    }, context), 'select');\n\n  // Back key behaves like cancel/deny for safety.\n  return choice ?? 'deny';\n}\n\nasync function persistToolPermissionAllow(\n  toolName: string,\n  config: OptaConfig,\n  saveConfig: (partial: Record<string, unknown>) => Promise<void>,\n  silent: boolean,\n): Promise<void> {\n  try {\n    await saveConfig({ permissions: { ...config.permissions, [toolName]: 'allow' } });\n    config.permissions[toolName] = 'allow';\n    if (!silent) console.log(chalk.dim(`  Permission for ${toolName} set to \"allow\" permanently.`));\n  } catch (error) {\n    if (process.env.OPTA_DEBUG) console.error('Failed to persist permission:', error);\n  }\n}\n\nasync function getBrowserRuntimeDaemon(\n  config: OptaConfig,\n  cwd: string,\n) {\n  const { getSharedBrowserRuntimeDaemon } = await import('../browser/runtime-daemon.js');\n  return getSharedBrowserRuntimeDaemon({\n    cwd,\n    maxSessions: config.browser.runtime.maxSessions,\n    persistSessions: config.browser.runtime.persistSessions,\n    persistProfileContinuity: config.browser.runtime.persistProfileContinuity,\n    profileRetentionPolicy: {\n      retentionDays: config.browser.runtime.profileRetentionDays,\n      maxPersistedProfiles: config.browser.runtime.maxPersistedProfiles,\n    },\n    profilePruneIntervalMs: config.browser.runtime.profilePruneIntervalHours * 60 * 60 * 1_000,\n    artifactPrune: {\n      enabled: config.browser.artifacts.retention.enabled,\n      policy: {\n        retentionDays: config.browser.artifacts.retention.retentionDays,\n        maxPersistedSessions: config.browser.artifacts.retention.maxPersistedSessions,\n      },\n      intervalMs: config.browser.artifacts.retention.pruneIntervalHours * 60 * 60 * 1_000,\n    },\n    runCorpusRefresh: {\n      enabled: config.browser.runtime.runCorpus.enabled,\n      windowHours: config.browser.runtime.runCorpus.windowHours,\n    },\n  });\n}\n\nasync function scanActiveBrowserSessions(\n  config: OptaConfig,\n  cwd: string,\n): Promise<BrowserSessionScanResult> {\n  try {\n    const daemon = await getBrowserRuntimeDaemon(config, cwd);\n    // Ensure persisted sessions are recovered before scanning health.\n    await daemon.start();\n    const sessions = daemon.health().sessions\n      .filter((session) => session.status === 'open')\n      .map((session) => ({\n        sessionId: session.sessionId.trim(),\n        currentUrl: session.currentUrl?.trim() || undefined,\n      }))\n      .filter((session) => session.sessionId.length > 0);\n    return {\n      sessions,\n      sessionIds: sessions.map((session) => session.sessionId),\n    };\n  } catch (error) {\n    return {\n      sessions: [],\n      sessionIds: [],\n      error: error instanceof Error ? error.message : String(error),\n    };\n  }\n}\n\n// --- Resolve Tool Decisions ---\n\nexport interface ResolvePermissionsOptions {\n  isSubAgent: boolean;\n  silent: boolean;\n  saveConfig: (partial: Record<string, unknown>) => Promise<void>;\n  streamCallbacks?: OnStreamCallbacks;\n  hooks: HookManager;\n  sessionCtx: SessionContext;\n}\n\n/**\n * Resolves permissions for each tool call sequentially (prompts must be one-at-a-time).\n * Returns a ToolDecision[] indicating which calls are approved or denied.\n */\nexport async function resolveToolDecisions(\n  toolCalls: ToolCallAccum[],\n  config: OptaConfig,\n  options: ResolvePermissionsOptions,\n): Promise<ToolDecision[]> {\n  const { isSubAgent, silent, saveConfig, streamCallbacks, hooks, sessionCtx } = options;\n  const decisions: ToolDecision[] = [];\n  const isDangerousMode = (config.defaultMode ?? '').toLowerCase() === 'dangerous';\n  let browserAdaptationHint: Awaited<ReturnType<typeof loadBrowserRunCorpusAdaptationHint>> | null = null;\n  if (config.browser.adaptation.enabled) {\n    try {\n      browserAdaptationHint = await loadBrowserRunCorpusAdaptationHint(\n        sessionCtx.cwd,\n        config.browser.adaptation,\n      );\n    } catch (error) {\n      if (process.env.OPTA_DEBUG) {\n        console.error('Failed to load browser adaptation hint:', error);\n      }\n    }\n  }\n\n  const policyEngine = new PolicyEngine(mapPolicyConfig(config.policy), {\n    cwd: sessionCtx.cwd,\n  });\n\n  // Cache the browser session scan result for the entire turn so we call the daemon\n  // at most once regardless of how many browser tool calls are in this batch.\n  let _cachedBrowserSessionScan: BrowserSessionScanResult | null = null;\n  async function getActiveBrowserSessionsOnce(): Promise<BrowserSessionScanResult> {\n    if (_cachedBrowserSessionScan === null) {\n      _cachedBrowserSessionScan = await scanActiveBrowserSessions(config, sessionCtx.cwd);\n    }\n    return _cachedBrowserSessionScan;\n  }\n\n  for (const call of toolCalls) {\n    const parsedArgs = safeParseJson<Record<string, unknown>>(call.args, { raw: call.args });\n    let parsedArgsMutated = false;\n    let requiresBrowserApproval = false;\n    let browserSessionId: string | undefined;\n    let browserPolicyDecision: ReturnType<typeof evaluateBrowserPolicyAction> | null = null;\n\n    const logBrowserApprovalDecision = async (decision: 'approved' | 'denied'): Promise<void> => {\n      if (!requiresBrowserApproval) return;\n      try {\n        await appendBrowserApprovalEvent({\n          cwd: sessionCtx.cwd,\n          tool: call.name,\n          sessionId: browserSessionId,\n          decision,\n          risk: browserPolicyDecision?.risk,\n          actionKey: browserPolicyDecision?.actionKey,\n          targetHost: browserPolicyDecision?.targetHost,\n          targetOrigin: browserPolicyDecision?.targetOrigin,\n          policyReason: browserPolicyDecision?.reason,\n          riskEvidence: browserPolicyDecision?.riskEvidence,\n        });\n      } catch (error) {\n        if (process.env.OPTA_DEBUG) {\n          console.error('Failed to append browser approval event:', error);\n        }\n      }\n    };\n\n    if (config.browser.enabled && call.name === 'run_command') {\n      const command = parsedArgs['command'];\n      if (isShellBrowserAutomationCommand(command)) {\n        decisions.push({\n          call,\n          approved: false,\n          denialReason: 'Denied shell browser automation command; use browser_* tools instead.',\n        });\n        if (!silent) console.log(chalk.dim(`   ${call.name}  use browser_* tools instead of shell browser automation`));\n        continue;\n      }\n    }\n\n    if (isBrowserToolName(call.name)) {\n      browserSessionId = extractBrowserSessionId(parsedArgs);\n      let activeBrowserSessions: BrowserSessionScanResult['sessions'] = [];\n      if (config.browser.enabled && call.name !== 'browser_open') {\n        const scanResult = await getActiveBrowserSessionsOnce();\n        if (scanResult.error) {\n          decisions.push({\n            call,\n            approved: false,\n            denialReason: `Browser runtime session scan failed: ${scanResult.error}`,\n          });\n          if (!silent) console.log(chalk.dim(`   ${call.name}  browser session scan failed`));\n          continue;\n        }\n        activeBrowserSessions = scanResult.sessions;\n\n        if (scanResult.sessionIds.length === 0 && !browserSessionId) {\n          if (isSubAgent) {\n            decisions.push({\n              call,\n              approved: false,\n              denialReason: 'Permission denied (sub-agent cannot prompt browser spawn).',\n            });\n            continue;\n          }\n\n          const browserOpenPermission = resolvePermission('browser_open', config);\n          if (browserOpenPermission === 'deny') {\n            decisions.push({\n              call,\n              approved: false,\n              denialReason: 'Cannot spawn Opta Browser (browser_open permission is denied by config).',\n            });\n            if (!silent) console.log(chalk.dim(`   ${call.name}  browser_open denied by configuration`));\n            continue;\n          }\n\n          const spawnPromptArgs: Record<string, unknown> = {\n            mode: config.browser.mode ?? 'isolated',\n            __opta_spawn_prompt: true,\n            __opta_spawn_reason: 'No active Opta Browser sessions were found in the runtime scan.',\n            __opta_spawn_trigger_tool: call.name,\n            __opta_session_scan_count: 0,\n          };\n\n          if (streamCallbacks?.onPermissionRequest) {\n            const spawnDecision = await streamCallbacks.onPermissionRequest('browser_open', spawnPromptArgs);\n            if (spawnDecision === 'deny') {\n              decisions.push({\n                call,\n                approved: false,\n                denialReason: 'User declined spawning an Opta Browser session.',\n              });\n              continue;\n            }\n            if (spawnDecision === 'always' && browserOpenPermission === 'ask') {\n              await persistToolPermissionAllow('browser_open', config, saveConfig, silent);\n            }\n          } else {\n            const spawnResponse = await promptToolApproval('browser_open', spawnPromptArgs);\n            if (spawnResponse === 'deny') {\n              decisions.push({\n                call,\n                approved: false,\n                denialReason: 'User declined spawning an Opta Browser session.',\n              });\n              continue;\n            }\n            if (spawnResponse === 'always' && browserOpenPermission === 'ask') {\n              await persistToolPermissionAllow('browser_open', config, saveConfig, silent);\n            }\n          }\n\n          try {\n            const daemon = await getBrowserRuntimeDaemon(config, sessionCtx.cwd);\n            const openResult = await daemon.openSession({\n              sessionId: browserSessionId,\n              mode: config.browser.mode ?? 'isolated',\n            });\n            if (!openResult.ok || !openResult.data) {\n              const reason = openResult.error?.message ?? 'Browser runtime could not open a new session.';\n              decisions.push({\n                call,\n                approved: false,\n                denialReason: `Failed to spawn Opta Browser session: ${reason}`,\n              });\n              if (!silent) console.log(chalk.dim(`   ${call.name}  failed to spawn browser session`));\n              continue;\n            }\n\n            browserSessionId = openResult.data.id;\n            parsedArgs['session_id'] = browserSessionId;\n            parsedArgsMutated = true;\n            if (!silent) console.log(chalk.dim(`  Spawned Opta Browser session: ${browserSessionId}`));\n          } catch (error) {\n            decisions.push({\n              call,\n              approved: false,\n              denialReason: `Failed to spawn Opta Browser session: ${error instanceof Error ? error.message : String(error)}`,\n            });\n            if (!silent) console.log(chalk.dim(`   ${call.name}  browser spawn failed`));\n            continue;\n          }\n        } else if (!browserSessionId) {\n          browserSessionId = scanResult.sessionIds[0];\n          if (browserSessionId) {\n            parsedArgs['session_id'] = browserSessionId;\n            parsedArgsMutated = true;\n          }\n        }\n      }\n\n      if (\n        browserSessionId &&\n        (call.name === 'browser_click' || call.name === 'browser_type')\n      ) {\n        const hasExplicitUrl = typeof parsedArgs['url'] === 'string' && String(parsedArgs['url']).trim().length > 0;\n        if (!hasExplicitUrl) {\n          const activeSession = activeBrowserSessions.find((session) => session.sessionId === browserSessionId);\n          if (activeSession?.currentUrl) {\n            parsedArgs['url'] = activeSession.currentUrl;\n            parsedArgsMutated = true;\n          }\n        }\n      }\n\n      browserPolicyDecision = evaluateBrowserPolicyAction(resolveBrowserPolicyConfig(config), {\n        toolName: call.name,\n        args: parsedArgs,\n        adaptationHint: browserAdaptationHint?.policy,\n      });\n\n      if (browserPolicyDecision.decision === 'deny') {\n        try {\n          await appendBrowserApprovalEvent({\n            cwd: sessionCtx.cwd,\n            tool: call.name,\n            sessionId: browserSessionId,\n            decision: 'denied',\n            risk: browserPolicyDecision.risk,\n            actionKey: browserPolicyDecision.actionKey,\n            targetHost: browserPolicyDecision.targetHost,\n            targetOrigin: browserPolicyDecision.targetOrigin,\n            policyReason: browserPolicyDecision.reason,\n            riskEvidence: browserPolicyDecision.riskEvidence,\n          });\n        } catch (error) {\n          if (process.env.OPTA_DEBUG) {\n            console.error('Failed to append browser deny event:', error);\n          }\n        }\n        decisions.push({\n          call,\n          approved: false,\n          denialReason: `Denied by browser policy: ${browserPolicyDecision.reason}`,\n        });\n        if (!silent) console.log(chalk.dim(`  \\u2717 ${call.name} \\u2014 denied by browser policy`));\n        continue;\n      }\n\n      requiresBrowserApproval = browserPolicyDecision.decision === 'gate';\n    }\n\n    const policyDecision = await policyEngine.decide({\n      action: call.name,\n      // Dangerous mode explicitly bypasses approval prompts.\n      // Mark tool calls as non-autonomous so gate-all policy does not block unattended runs.\n      autonomous: !isDangerousMode,\n      actor: isSubAgent ? 'sub-agent' : 'agent',\n      metadata: {\n        toolCallId: call.id,\n      },\n    });\n\n    if (policyDecision.decision === 'deny') {\n      decisions.push({ call, approved: false, denialReason: `Denied by policy: ${policyDecision.reason}` });\n      if (!silent) console.log(chalk.dim(`  \\u2717 ${call.name} \\u2014 denied by policy`));\n      continue;\n    }\n\n    const requiresApproval = policyDecision.decision === 'gate' || requiresBrowserApproval;\n    const permission = resolvePermission(call.name, config);\n    let executionArgsJson = parsedArgsMutated ? JSON.stringify(parsedArgs) : call.args;\n\n    if (permission === 'deny') {\n      decisions.push({ call, approved: false, denialReason: 'Permission denied by configuration.' });\n      if (!silent) console.log(chalk.dim(`  \\u2717 ${call.name} \\u2014 denied`));\n      continue;\n    }\n\n    if (permission === 'ask' || requiresApproval) {\n      if (isSubAgent) {\n        await logBrowserApprovalDecision('denied');\n        decisions.push({\n          call,\n          approved: false,\n          denialReason: 'Permission denied (sub-agent cannot prompt user).',\n        });\n        continue;\n      }\n\n      if (streamCallbacks?.onPermissionRequest) {\n        const decision = await streamCallbacks.onPermissionRequest(call.name, parsedArgs);\n        if (decision === 'always' && permission === 'ask') {\n          await persistToolPermissionAllow(call.name, config, saveConfig, silent);\n        } else if (decision === 'deny') {\n          await logBrowserApprovalDecision('denied');\n          decisions.push({ call, approved: false, denialReason: 'User declined this action.' });\n          continue;\n        }\n        await logBrowserApprovalDecision('approved');\n      } else {\n        const response = await promptToolApproval(call.name, parsedArgs);\n        if (response === 'always' && permission === 'ask') {\n          await persistToolPermissionAllow(call.name, config, saveConfig, silent);\n        } else if (response === 'deny') {\n          await logBrowserApprovalDecision('denied');\n          decisions.push({ call, approved: false, denialReason: 'User declined this action.' });\n          continue;\n        }\n        await logBrowserApprovalDecision('approved');\n      }\n\n      if (requiresBrowserApproval) {\n        executionArgsJson = JSON.stringify({ ...parsedArgs, __browser_approved: true });\n      }\n    }\n\n    // Fire pre-tool hook (can cancel execution)\n    const preResult = await fireToolPre(hooks, call.name, executionArgsJson, sessionCtx);\n    if (preResult.cancelled) {\n      decisions.push({ call, approved: false, denialReason: `Tool blocked by hook: ${preResult.reason ?? 'no reason given'}` });\n      if (!silent) console.log(chalk.dim(`  \\u2717 ${call.name} \\u2014 blocked by hook`));\n      continue;\n    }\n\n    decisions.push({ call, approved: true, executionArgsJson });\n  }\n\n  return decisions;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/core/agent-profiles.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/core/agent-setup.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":234,"column":24,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":234,"endColumn":36},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'m.content' may use Object's default stringification format ('[object Object]') when stringified.","line":247,"column":32,"nodeType":"MemberExpression","messageId":"baseToString","endLine":247,"endColumn":41},{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":1,"message":"Invalid type \"string | ContentPart[] | null\" of template literal expression.","line":247,"column":32,"nodeType":"MemberExpression","messageId":"invalidType","endLine":247,"endColumn":41},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":263,"column":49,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":263,"endColumn":51,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[10022,10024],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":1,"message":"Invalid type \"unknown\" of template literal expression.","line":275,"column":33,"nodeType":"Identifier","messageId":"invalidType","endLine":275,"endColumn":36}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * agent-setup.ts  Client creation, system prompt, config.\n *\n * Extracted from agent.ts to isolate the OpenAI client lifecycle,\n * system prompt construction, and context compaction.\n */\n\nimport type OpenAI from 'openai';\nimport type { OptaConfig } from './config.js';\nimport { debug } from './debug.js';\nimport { COMPACTION_PROMPT } from './context.js';\nimport { buildAutonomyPromptBlock } from './autonomy.js';\nimport type { AgentMessage } from './agent.js';\n\ninterface ToolSchemaLike {\n  function: {\n    name: string;\n  };\n}\n\nexport interface CapabilityManifestRuntimeContext {\n  activeToolSchemas?: ToolSchemaLike[];\n  profile?: string;\n  mode?: string;\n}\n\nconst CAPABILITY_MARKER = '\\n\\nActive capabilities:\\n';\n\nfunction onOff(enabled: boolean): string {\n  return enabled ? 'on' : 'off';\n}\n\nexport function buildCapabilityManifest(\n  config: OptaConfig,\n  runtime: CapabilityManifestRuntimeContext = {},\n): string {\n  const toolNames = new Set((runtime.activeToolSchemas ?? []).map((schema) => schema.function.name));\n  const mode = runtime.mode ?? config.defaultMode;\n  const profile = runtime.profile ?? 'default';\n\n  const hasWebTools = toolNames.has('web_search') || toolNames.has('web_fetch');\n  const hasResearchTool = hasWebTools || Array.from(toolNames).some((name) => name.startsWith('research_'));\n  const hasBrowserTool = Array.from(toolNames).some((name) => name.startsWith('browser_') || name.includes('playwright'));\n  const hasLearningTool = [\n    'save_memory',\n    'learning_log',\n    'learning_summary',\n    'learning_retrieve',\n  ].some((name) => toolNames.has(name));\n  const toolCount = runtime.activeToolSchemas?.length ?? 0;\n\n  return [\n    `- session: mode=${mode}, profile=${profile}, tools=${toolCount}`,\n    `- research: ${onOff(config.research.enabled)} provider=${config.research.defaultProvider} tools=${hasResearchTool ? 'yes' : 'no'}`,\n    `- browser: ${onOff(config.browser.enabled)} mode=${config.browser.mode} automation=${hasBrowserTool ? 'yes' : 'no'}`,\n    `- learning: ${onOff(config.learning.enabled)} capture=${config.learning.captureLevel} tool=${hasLearningTool ? 'yes' : 'no'}`,\n    `- policy: ${onOff(config.policy.enabled)} mode=${config.policy.mode} gate-all=${onOff(config.policy.gateAllAutonomy)} failure=${config.policy.failureMode}`,\n  ].join('\\n');\n}\n\nexport function injectCapabilityManifest(prompt: string, manifest: string): string {\n  const markerIndex = prompt.indexOf(CAPABILITY_MARKER);\n  const basePrompt = markerIndex >= 0\n    ? prompt.slice(0, markerIndex).trimEnd()\n    : prompt.trimEnd();\n\n  return `${basePrompt}${CAPABILITY_MARKER}${manifest}`;\n}\n\n// --- Provider-Based Client ---\n\nexport async function getOrCreateClient(config: OptaConfig): Promise<OpenAI> {\n  const { getProvider } = await import('../providers/manager.js');\n  const provider = await getProvider(config);\n  debug(`Using provider: ${provider.name}`);\n  const client = await provider.getClient() as OpenAI & { __optaProviderName?: string };\n  client.__optaProviderName = provider.name;\n  return client;\n}\n\n/** Reset the cached client (useful for testing). */\nexport async function resetClientCache(): Promise<void> {\n  const { resetProviderCache } = await import('../providers/manager.js');\n  resetProviderCache();\n}\n\n// --- System Prompt ---\n\nexport async function buildSystemPrompt(\n  config: OptaConfig,\n  cwd?: string,\n  mode?: string,\n  runtime?: CapabilityManifestRuntimeContext,\n): Promise<string> {\n  const workingDir = cwd ?? process.cwd();\n\n  let prompt = `You are Opta, an AI coding assistant running locally on the user's machine. You help with coding tasks by using tools to read, edit, and search files, and run commands.\n\nRules:\n- Read files before editing them\n- Use edit_file for precise, targeted changes (not write_file to rewrite entire files)\n- Use search_files and find_files to understand the codebase before making changes\n- web_fetch: Fetch and read web pages (documentation, APIs, references)\n- Use native tool calls only; never emit pseudo tool tags like <execute_command>...</execute_command> in assistant text\n- If browser tools are available, prefer browser_* tools over shell GUI automation (e.g., osascript/xdotool)\n- Explain your reasoning before each action\n- When the task is complete, respond with a final summary (no tool calls)\n\nWorking directory: ${workingDir}`;\n\n  if (config.autonomy.level > 1 || config.autonomy.mode === 'ceo') {\n    prompt += `\\n\\n${buildAutonomyPromptBlock(config)}`;\n  }\n\n  // Load OPIS context\n  try {\n    const { loadOpisContext } = await import('../context/opis.js');\n    const opisCtx = await loadOpisContext(workingDir);\n\n    if (opisCtx.hasOpis && opisCtx.summary) {\n      prompt += `\\n\\n${opisCtx.summary}`;\n    } else if (opisCtx.fallbackMemory) {\n      prompt += `\\n\\nProject knowledge:\\n${opisCtx.fallbackMemory}`;\n    } else {\n      prompt += `\\n\\nTip: Run \\`opta init\\` to set up project documentation for better context.`;\n    }\n  } catch {\n    // OPIS loading failed  continue without context\n  }\n\n  // Load export map (gated by config.context.exportMap)\n  if (config.context.exportMap) {\n    try {\n      const { scanExports, formatExportMap } = await import('../context/exports.js');\n      const exportMap = await scanExports(workingDir);\n\n      if (exportMap.entries.length > 0) {\n        prompt += `\\n\\nCodebase exports:\\n${formatExportMap(exportMap)}`;\n      }\n    } catch {\n      // Export scanning failed  continue without map\n    }\n  }\n\n  // Warn about dirty working tree\n  try {\n    const { isGitRepo, isDirty } = await import('../git/utils.js');\n    if (await isGitRepo(workingDir) && await isDirty(workingDir)) {\n      prompt += '\\n\\nNote: Working tree has uncommitted changes from outside this session.';\n    }\n  } catch {\n    // Git utils unavailable  skip\n  }\n\n  if (mode === 'plan') {\n    prompt += `\\n\\nYou are in PLAN MODE. You are a software architect helping design an implementation approach.\n\nCRITICAL CONSTRAINTS:\n- You are READ-ONLY. You MUST NOT call edit_file, write_file, multi_edit, delete_file, or run_command.\n- You CAN use: read_file, list_dir, search_files, find_files, ask_user, web_search, web_fetch\n- Your goal is to explore the codebase and produce a clear implementation plan.\n\nPLANNING PROCESS:\n1. Understand the request  ask ONE clarifying question at a time if needed\n2. Explore the codebase  read relevant files, search for patterns\n3. Propose 2-3 approaches with trade-offs, lead with your recommendation\n4. Present the plan in sections, checking after each\n5. Conclude with: critical files to modify, estimated scope, risks\n\nWhen your plan is complete, say: \"Plan complete. Ready to implement?\"`;\n  }\n\n  if (mode === 'review') {\n    prompt += `\\n\\nYou are in CODE REVIEW MODE. You are a senior engineer performing a thorough code review.\n\nCRITICAL CONSTRAINTS:\n- You are READ-ONLY. You MUST NOT call edit_file, write_file, multi_edit, delete_file, or run_command.\n- You CAN use: read_file, list_dir, search_files, find_files, ask_user, web_search, web_fetch\n- Do NOT suggest fixes as tool calls  only describe what should change.\n\nREVIEW CHECKLIST:\n1. **Bugs**  Logic errors, edge cases, off-by-one, null handling\n2. **Security**  Injection, auth bypass, data exposure, unsafe operations\n3. **Performance**  N+1 queries, unnecessary allocations, blocking operations\n4. **Style**  Naming, consistency, dead code, complexity\n5. **Architecture**  Coupling, abstraction level, separation of concerns\n\nFormat findings as: [SEVERITY] Category  Description  Location`;\n  }\n\n  if (mode === 'research') {\n    prompt += `\\n\\nYou are in RESEARCH MODE. You are exploring ideas, searching for information, and taking notes.\n\nCONSTRAINTS:\n- You MUST NOT call edit_file, write_file, multi_edit, or delete_file.\n- You CAN use: read_file, list_dir, search_files, find_files, run_command, ask_user, web_search, web_fetch\n- Focus on gathering information, exploring approaches, and documenting findings.\n- Summarize your research findings clearly for later reference.`;\n  }\n\n  if (runtime) {\n    prompt = injectCapabilityManifest(\n      prompt,\n      buildCapabilityManifest(config, { ...runtime, mode: mode ?? runtime.mode }),\n    );\n  }\n\n  return prompt;\n}\n\n// --- Compaction Constants ---\n\n/** Minimum number of recent messages to preserve during compaction. */\nconst MIN_COMPACTION_WINDOW = 6;\n/** Maximum recent messages to keep (scales with context limit). */\nconst MAX_COMPACTION_WINDOW = 20;\n/** Divisor for scaling compaction window to context limit. */\nconst COMPACTION_WINDOW_SCALE = 4000;\n/** Minimum tokens allocated for conversation summary during compaction. */\nconst MIN_SUMMARY_BUDGET = 500;\n/** Maximum tokens allocated for conversation summary. */\nconst MAX_SUMMARY_BUDGET = 2000;\n/** Fraction of context limit allocated to summary budget. */\nconst SUMMARY_BUDGET_RATIO = 0.05;\n\n// --- Context Compaction ---\n\nexport async function compactHistory(\n  messages: AgentMessage[],\n  client: OpenAI,\n  model: string,\n  contextLimit: number\n): Promise<AgentMessage[]> {\n  const systemPrompt = messages[0]!;\n  const recentCount = Math.max(MIN_COMPACTION_WINDOW, Math.min(Math.floor(contextLimit / COMPACTION_WINDOW_SCALE), MAX_COMPACTION_WINDOW));\n  const recent = messages.slice(-recentCount);\n  const middle = messages.slice(1, -recentCount);\n\n  if (middle.length === 0) return messages;\n\n  debug(`Compacting ${middle.length} messages (keeping last ${recentCount})`);\n\n  const summaryBudget = Math.max(MIN_SUMMARY_BUDGET, Math.min(Math.floor(contextLimit * SUMMARY_BUDGET_RATIO), MAX_SUMMARY_BUDGET));\n\n  const middleText = middle\n    .filter((m) => m.content)\n    .map((m) => `[${m.role}] ${m.content}`)\n    .join('\\n');\n\n  try {\n    const response = await client.chat.completions.create({\n      model,\n      messages: [\n        {\n          role: 'system',\n          content: COMPACTION_PROMPT,\n        },\n        { role: 'user', content: middleText },\n      ],\n      max_tokens: summaryBudget,\n    });\n\n    const summary = response.choices[0]?.message?.content ?? '';\n    debug(`Compacted to ${summary.length} chars (budget: ${summaryBudget} tokens)`);\n\n    return [\n      systemPrompt,\n      {\n        role: 'user' as const,\n        content: `[Previous conversation summary]\\n${summary}`,\n      },\n      ...recent,\n    ];\n  } catch (err) {\n    debug(`Compaction failed: ${err}`);\n    return messages; // Keep original if compaction fails\n  }\n}\n\n// --- Observation Masking (re-export for agent.ts convenience) ---\n\nexport { maskOldObservations } from './context.js';\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/core/agent-streaming.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, value is always truthy.","line":101,"column":12,"nodeType":"Literal","messageId":"alwaysTruthy","endLine":101,"endColumn":16},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":132,"column":15,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":132,"endColumn":30},{"ruleId":"@typescript-eslint/no-deprecated","severity":1,"message":"`max_tokens` is deprecated. The maximum number of [tokens](/tokenizer) that can be generated in\nthe chat completion. This value can be used to control\n[costs](https://openai.com/api/pricing/) for text generated via API.\n\nThis value is now deprecated in favor of `max_completion_tokens`, and is not\ncompatible with\n[o-series models](https://platform.openai.com/docs/guides/reasoning).","line":134,"column":24,"nodeType":"Identifier","messageId":"deprecatedWithReason","endLine":134,"endColumn":34},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":220,"column":21,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":220,"endColumn":35},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, value is always truthy.","line":300,"column":12,"nodeType":"Literal","messageId":"alwaysTruthy","endLine":300,"endColumn":16},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":314,"column":27,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":314,"endColumn":41},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":508,"column":21,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":508,"endColumn":29}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * agent-streaming.ts  Stream collection + retry logic.\n *\n * Extracted from agent.ts to isolate the streaming response collection,\n * retry-with-backoff for transient errors, and tool call accumulation.\n */\n\nimport type OpenAI from 'openai';\nimport { debug } from './debug.js';\nimport { estimateTokens } from '../utils/tokens.js';\nimport { sanitizeTerminalText } from '../utils/text.js';\nimport { ThinkingRenderer, stripThinkTags } from '../ui/thinking.js';\nimport { sleep } from '../utils/common.js';\nimport type { StatusBar } from '../ui/statusbar.js';\nimport type { OnStreamCallbacks } from './agent.js';\nimport type { OptaConfig } from './config.js';\nimport { isAbortError, streamLmxChatWebSocket } from '../lmx/connection.js';\nimport { resolveLmxEndpoint } from '../lmx/endpoints.js';\n\n// --- Types ---\n\nexport interface ToolCallAccum {\n  id: string;\n  name: string;\n  args: string;\n}\n\n/** Token usage reported by the API in the final streaming chunk. */\nexport interface StreamUsage {\n  promptTokens: number;\n  completionTokens: number;\n}\n\n// --- Streaming Retry ---\n\n/** Retryable errors: network failures, timeouts, 5xx server errors. */\nfunction isRetryableError(err: unknown): boolean {\n  if (isAbortError(err)) return false;\n  if (err instanceof Error) {\n    const msg = err.message.toLowerCase();\n    if (msg.includes('lmx websocket stream closed unexpectedly') ||\n        msg.includes('lmx websocket handshake timed out') ||\n        msg.includes('lmx websocket idle timeout')) {\n      return true;\n    }\n    if (msg.includes('econnrefused') || msg.includes('econnreset') || msg.includes('etimedout') ||\n        msg.includes('fetch failed') || msg.includes('network') || msg.includes('socket hang up')) {\n      return true;\n    }\n  }\n  // OpenAI SDK wraps HTTP errors with a status property\n  const status = (err as { status?: number }).status;\n  if (status && status >= 500) return true;\n  return false;\n}\n\ninterface StreamTransportOptions {\n  config?: OptaConfig;\n  /** Runtime provider identifier (e.g. lmx, anthropic, lmx+fallback). */\n  providerName?: string;\n  signal?: AbortSignal;\n  /** Resolved LMX host cached across retries within a turn. */\n  resolvedLmxHost?: string;\n}\n\ntype RetryConfig = { maxRetries: number; backoffMs: number; backoffMultiplier: number };\n\nfunction describeError(err: unknown): string {\n  return err instanceof Error ? err.message : String(err);\n}\n\nasync function createSdkStream(\n  client: OpenAI,\n  params: Parameters<OpenAI['chat']['completions']['create']>[0],\n  signal?: AbortSignal,\n): Promise<AsyncIterable<OpenAI.Chat.Completions.ChatCompletionChunk>> {\n  const payload = {\n    ...params,\n    stream: true,\n    stream_options: { include_usage: true },\n  };\n\n  // OpenAI SDK supports passing AbortSignal via request options.\n  // Call the bound method directly to preserve `this` context across providers.\n  return client.chat.completions.create(\n    payload,\n    signal ? { signal } : undefined,\n  ) as Promise<AsyncIterable<OpenAI.Chat.Completions.ChatCompletionChunk>>;\n}\n\nasync function primeStream(\n  stream: AsyncIterable<OpenAI.Chat.Completions.ChatCompletionChunk>,\n): Promise<AsyncIterable<OpenAI.Chat.Completions.ChatCompletionChunk>> {\n  const iterator = stream[Symbol.asyncIterator]();\n  const first = await iterator.next();\n  if (first.done) {\n    return (async function* (): AsyncGenerator<OpenAI.Chat.Completions.ChatCompletionChunk> {})();\n  }\n  return (async function* (): AsyncGenerator<OpenAI.Chat.Completions.ChatCompletionChunk> {\n    yield first.value;\n    while (true) {\n      const next = await iterator.next();\n      if (next.done) return;\n      yield next.value;\n    }\n  })();\n}\n\nasync function maybeCreateLmxWsStream(\n  transport: StreamTransportOptions | undefined,\n  params: Parameters<OpenAI['chat']['completions']['create']>[0],\n): Promise<AsyncIterable<OpenAI.Chat.Completions.ChatCompletionChunk> | null> {\n  if (!transport?.config) return null;\n  const providerName = transport.providerName ?? transport.config.provider.active;\n  if (providerName !== 'lmx') return null;\n  let endpointHost = transport.resolvedLmxHost;\n  if (!endpointHost) {\n    const endpoint = await resolveLmxEndpoint({\n      host: transport.config.connection.host,\n      fallbackHosts: transport.config.connection.fallbackHosts,\n      port: transport.config.connection.port,\n      adminKey: transport.config.connection.adminKey,\n    }, {\n      timeoutMs: 1_500,\n    });\n    endpointHost = endpoint.host;\n    transport.resolvedLmxHost = endpointHost;\n  }\n  const { port, adminKey } = transport.config.connection;\n  return streamLmxChatWebSocket(endpointHost, port, {\n    model: params.model,\n    messages: params.messages ?? [],\n    temperature: params.temperature,\n    max_tokens: params.max_tokens,\n    top_p: params.top_p,\n    stop: params.stop,\n    tools: params.tools,\n    tool_choice: params.tool_choice,\n    response_format: params.response_format,\n    frequency_penalty: params.frequency_penalty,\n    presence_penalty: params.presence_penalty,\n  }, {\n    adminKey,\n    signal: transport.signal,\n  });\n}\n\ninterface RecoveryReplayState {\n  remainingContentPrefix: string;\n  remainingToolCallArgPrefixes: Map<number, string>;\n}\n\nfunction trimRecoveredContentPrefix(content: string, state: RecoveryReplayState): string {\n  if (!content || !state.remainingContentPrefix) return content;\n  if (state.remainingContentPrefix.startsWith(content)) {\n    state.remainingContentPrefix = state.remainingContentPrefix.slice(content.length);\n    return '';\n  }\n  if (content.startsWith(state.remainingContentPrefix)) {\n    const trimmed = content.slice(state.remainingContentPrefix.length);\n    state.remainingContentPrefix = '';\n    return trimmed;\n  }\n  // Diverged output: stop prefix trimming and continue with recovered stream as-is.\n  state.remainingContentPrefix = '';\n  return content;\n}\n\nfunction trimRecoveredToolCallArgsPrefix(index: number, args: string, state: RecoveryReplayState): string {\n  if (!args) return args;\n  const remainingPrefix = state.remainingToolCallArgPrefixes.get(index);\n  if (!remainingPrefix) return args;\n\n  if (remainingPrefix.startsWith(args)) {\n    const nextRemainingPrefix = remainingPrefix.slice(args.length);\n    if (nextRemainingPrefix.length > 0) {\n      state.remainingToolCallArgPrefixes.set(index, nextRemainingPrefix);\n    } else {\n      state.remainingToolCallArgPrefixes.delete(index);\n    }\n    return '';\n  }\n  if (args.startsWith(remainingPrefix)) {\n    state.remainingToolCallArgPrefixes.delete(index);\n    return args.slice(remainingPrefix.length);\n  }\n  // Diverged output for this tool call index: stop prefix trimming and continue as-is.\n  state.remainingToolCallArgPrefixes.delete(index);\n  return args;\n}\n\nfunction dedupeRecoveredChunk(\n  chunk: OpenAI.Chat.Completions.ChatCompletionChunk,\n  state: RecoveryReplayState,\n): OpenAI.Chat.Completions.ChatCompletionChunk | null {\n  if (!state.remainingContentPrefix && state.remainingToolCallArgPrefixes.size === 0) return chunk;\n  const choice = chunk.choices[0];\n  const delta = choice?.delta;\n  if (!delta) return chunk;\n\n  let contentChanged = false;\n  let nextContent = delta.content;\n  if (typeof delta.content === 'string' && state.remainingContentPrefix) {\n    const trimmed = trimRecoveredContentPrefix(delta.content, state);\n    if (trimmed !== delta.content) {\n      nextContent = trimmed;\n      contentChanged = true;\n    }\n  }\n\n  let toolCallsChanged = false;\n  let nextToolCalls = delta.tool_calls;\n  if (Array.isArray(delta.tool_calls) && delta.tool_calls.length > 0 && state.remainingToolCallArgPrefixes.size > 0) {\n    const trimmedToolCalls: typeof delta.tool_calls = [];\n    for (const toolCall of delta.tool_calls) {\n      const argsFragment = toolCall.function?.arguments;\n      let nextToolCall = toolCall;\n\n      if (typeof argsFragment === 'string' && argsFragment.length > 0) {\n        const idx = toolCall.index ?? 0;\n        const trimmedArgsFragment = trimRecoveredToolCallArgsPrefix(idx, argsFragment, state);\n        if (trimmedArgsFragment !== argsFragment) {\n          toolCallsChanged = true;\n          nextToolCall = {\n            ...toolCall,\n            function: {\n              ...toolCall.function,\n              arguments: trimmedArgsFragment,\n            },\n          };\n        }\n      }\n\n      const isNoopToolCall = !nextToolCall.id &&\n        !nextToolCall.type &&\n        !nextToolCall.function?.name &&\n        !nextToolCall.function?.arguments;\n      if (isNoopToolCall) {\n        toolCallsChanged = true;\n        continue;\n      }\n      trimmedToolCalls.push(nextToolCall);\n    }\n\n    if (toolCallsChanged || trimmedToolCalls.length !== delta.tool_calls.length) {\n      nextToolCalls = trimmedToolCalls;\n      toolCallsChanged = true;\n    }\n  }\n\n  if (!contentChanged && !toolCallsChanged) return chunk;\n\n  const hasOtherDeltaFields = Object.entries(delta).some(([key, value]) =>\n    key !== 'content' &&\n    key !== 'tool_calls' &&\n    value !== undefined &&\n    value !== null &&\n    (!Array.isArray(value) || value.length > 0),\n  );\n  const hasContent = typeof nextContent === 'string' && nextContent.length > 0;\n  const hasToolCalls = Array.isArray(nextToolCalls) && nextToolCalls.length > 0;\n  if (!hasContent && !hasToolCalls && !hasOtherDeltaFields && choice.finish_reason === null && !chunk.usage) {\n    return null;\n  }\n\n  const choices = [...chunk.choices];\n  choices[0] = {\n    ...choice,\n    delta: {\n      ...delta,\n      ...(contentChanged ? { content: nextContent } : {}),\n      ...(toolCallsChanged ? { tool_calls: nextToolCalls } : {}),\n    },\n  };\n  return {\n    ...chunk,\n    choices,\n  };\n}\n\nfunction withLmxMidStreamRecovery(\n  initialStream: AsyncIterable<OpenAI.Chat.Completions.ChatCompletionChunk>,\n  client: OpenAI,\n  params: Parameters<OpenAI['chat']['completions']['create']>[0],\n  retryConfig: RetryConfig,\n  onStatus: ((status: 'checking' | 'connected' | 'disconnected' | 'reconnecting', attempt?: number) => void) | undefined,\n  transport: StreamTransportOptions | undefined,\n): AsyncIterable<OpenAI.Chat.Completions.ChatCompletionChunk> {\n  return (async function* recoverableStream(): AsyncGenerator<OpenAI.Chat.Completions.ChatCompletionChunk> {\n    let currentStream = initialStream;\n    let emittedText = '';\n    const emittedToolCallArgsByIndex = new Map<number, string>();\n    const replayState: RecoveryReplayState = {\n      remainingContentPrefix: '',\n      remainingToolCallArgPrefixes: new Map<number, string>(),\n    };\n    let recoveryCycles = 0;\n    const maxRecoveryCycles = Math.max(1, retryConfig.maxRetries + 1);\n\n    while (true) {\n      try {\n        for await (const rawChunk of currentStream) {\n          const chunk = dedupeRecoveredChunk(rawChunk, replayState);\n          if (!chunk) continue;\n\n          const delta = chunk.choices[0]?.delta;\n          if (typeof delta?.content === 'string' && delta.content.length > 0) {\n            emittedText += delta.content;\n          }\n          if (Array.isArray(delta?.tool_calls) && delta.tool_calls.length > 0) {\n            for (const toolCall of delta.tool_calls) {\n              const argsFragment = toolCall.function?.arguments;\n              if (typeof argsFragment !== 'string' || argsFragment.length === 0) continue;\n              const idx = toolCall.index ?? 0;\n              emittedToolCallArgsByIndex.set(idx, (emittedToolCallArgsByIndex.get(idx) ?? '') + argsFragment);\n            }\n          }\n          yield chunk;\n        }\n        return;\n      } catch (err) {\n        if (isAbortError(err)) throw err;\n        if (!isRetryableError(err)) throw err;\n        if (recoveryCycles >= maxRecoveryCycles) {\n          onStatus?.('disconnected');\n          throw err;\n        }\n\n        recoveryCycles += 1;\n        let recoveredStream: AsyncIterable<OpenAI.Chat.Completions.ChatCompletionChunk> | null = null;\n        let reconnectError: unknown = err;\n        const wsRecoveryAttempts = Math.max(0, retryConfig.maxRetries);\n\n        for (let attempt = 1; attempt <= wsRecoveryAttempts; attempt += 1) {\n          onStatus?.('reconnecting', attempt);\n          const delay = retryConfig.backoffMs * Math.pow(retryConfig.backoffMultiplier, attempt - 1);\n          debug(`LMX mid-stream recovery attempt ${attempt}/${wsRecoveryAttempts} after ${delay}ms`);\n          await sleep(delay);\n\n          if (transport) {\n            transport.resolvedLmxHost = undefined;\n          }\n\n          try {\n            const wsStream = await maybeCreateLmxWsStream(transport, params);\n            if (!wsStream) break;\n            recoveredStream = await primeStream(wsStream);\n            onStatus?.('connected');\n            break;\n          } catch (reconnectErr) {\n            if (isAbortError(reconnectErr)) throw reconnectErr;\n            reconnectError = reconnectErr;\n            if (!isRetryableError(reconnectErr)) break;\n          }\n        }\n\n        if (!recoveredStream) {\n          if (wsRecoveryAttempts === 0) {\n            onStatus?.('reconnecting', 1);\n          }\n          debug(`LMX websocket mid-stream recovery falling back to SSE: ${describeError(reconnectError)}`);\n          if (transport) {\n            transport.resolvedLmxHost = undefined;\n          }\n          try {\n            recoveredStream = await createSdkStream(client, params, transport?.signal);\n          } catch (fallbackErr) {\n            onStatus?.('disconnected');\n            throw fallbackErr;\n          }\n          onStatus?.('connected');\n        }\n\n        replayState.remainingContentPrefix = emittedText;\n        replayState.remainingToolCallArgPrefixes = new Map<number, string>(emittedToolCallArgsByIndex);\n        currentStream = recoveredStream;\n      }\n    }\n  })();\n}\n\nexport async function createStreamWithRetry(\n  client: OpenAI,\n  params: Parameters<OpenAI['chat']['completions']['create']>[0],\n  retryConfig: RetryConfig,\n  onStatus?: (status: 'checking' | 'connected' | 'disconnected' | 'reconnecting', attempt?: number) => void,\n  transport?: StreamTransportOptions,\n): Promise<AsyncIterable<OpenAI.Chat.Completions.ChatCompletionChunk>> {\n  let lastError: unknown;\n  const shouldTryLmxWs = Boolean(\n    transport?.config &&\n    (transport.providerName ?? transport.config.provider.active) === 'lmx',\n  );\n\n  for (let attempt = 0; attempt <= retryConfig.maxRetries; attempt++) {\n    try {\n      if (attempt > 0) {\n        onStatus?.('reconnecting', attempt);\n        const delay = retryConfig.backoffMs * Math.pow(retryConfig.backoffMultiplier, attempt - 1);\n        debug(`Retry attempt ${attempt}/${retryConfig.maxRetries} after ${delay}ms`);\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n\n      // Preferred path for Opta LMX: bidirectional WebSocket stream with cancel.\n      // If WS is unavailable, we transparently fall back to SDK/SSE.\n      let stream: AsyncIterable<OpenAI.Chat.Completions.ChatCompletionChunk> | null = null;\n      let streamSource: 'ws' | 'sdk' = 'sdk';\n      try {\n        stream = await maybeCreateLmxWsStream(transport, params);\n        if (stream) {\n          stream = await primeStream(stream);\n          streamSource = 'ws';\n        }\n      } catch (err) {\n        if (isAbortError(err)) throw err;\n        if (shouldTryLmxWs && transport) {\n          transport.resolvedLmxHost = undefined;\n        }\n        if (isRetryableError(err) && attempt < retryConfig.maxRetries) {\n          throw err;\n        }\n        debug(`LMX websocket stream unavailable, falling back to SSE: ${describeError(err)}`);\n        stream = null;\n      }\n      if (!stream) {\n        stream = await createSdkStream(client, params, transport?.signal);\n        streamSource = 'sdk';\n      }\n\n      if (attempt > 0) {\n        onStatus?.('connected');\n      }\n\n      if (streamSource === 'ws' && shouldTryLmxWs) {\n        return withLmxMidStreamRecovery(stream, client, params, retryConfig, onStatus, transport);\n      }\n      return stream;\n    } catch (err) {\n      if (isAbortError(err)) throw err;\n      lastError = err;\n      if (!isRetryableError(err) || attempt === retryConfig.maxRetries) {\n        if (attempt > 0) onStatus?.('disconnected');\n        throw err;\n      }\n    }\n  }\n\n  throw lastError;\n}\n\n// --- Stream Collector ---\n\nexport async function collectStream(\n  stream: AsyncIterable<OpenAI.Chat.Completions.ChatCompletionChunk>,\n  onVisibleText: (chunk: string) => void,\n  statusBar?: StatusBar | null,\n  onStream?: OnStreamCallbacks\n): Promise<{ text: string; toolCalls: ToolCallAccum[]; thinkingRenderer: ThinkingRenderer; usage: StreamUsage | null; finishReason: string | null }> {\n  let text = '';\n  const toolCallMap = new Map<number, ToolCallAccum>();\n  const thinking = new ThinkingRenderer();\n  let usage: StreamUsage | null = null;\n  let finishReason: string | null = null;\n\n  for await (const chunk of stream) {\n    // Capture usage from the final chunk (sent when stream_options.include_usage is true)\n    if (chunk.usage) {\n      usage = {\n        promptTokens: chunk.usage.prompt_tokens,\n        completionTokens: chunk.usage.completion_tokens,\n      };\n    }\n\n    // Capture finish_reason from the final chunk (truncation detection)\n    const choiceFinishReason = chunk.choices[0]?.finish_reason;\n    if (choiceFinishReason) {\n      finishReason = choiceFinishReason;\n    }\n\n    const delta = chunk.choices[0]?.delta;\n    if (!delta) continue;\n\n    if (delta.content) {\n      const safeDelta = sanitizeTerminalText(delta.content);\n      text += safeDelta;\n      statusBar?.markStart();\n\n      // ThinkingRenderer handles <think> display and returns non-thinking content\n      const visible = thinking.process(safeDelta);\n      if (visible) {\n        onVisibleText(visible);\n        // Emit token event for TUI streaming\n        onStream?.onToken?.(visible);\n      }\n\n      // Emit thinking content if we're still in thinking mode\n      if (!visible && thinking.isThinking) {\n        onStream?.onThinking?.(safeDelta);\n      }\n\n      // Update status bar with token estimate\n      const tokenDelta = estimateTokens(safeDelta);\n      statusBar?.update(tokenDelta);\n    }\n\n    if (delta.tool_calls) {\n      for (const tc of delta.tool_calls) {\n        const idx = tc.index ?? 0;\n        const existing = toolCallMap.get(idx);\n        if (!existing) {\n          toolCallMap.set(idx, {\n            id: tc.id ?? '',\n            name: tc.function?.name ?? '',\n            args: tc.function?.arguments ?? '',\n          });\n        } else {\n          if (tc.id) existing.id = tc.id;\n          if (tc.function?.name) existing.name = tc.function.name;\n          if (tc.function?.arguments) existing.args += tc.function.arguments;\n        }\n      }\n    }\n  }\n\n  // Flush any remaining buffered text from thinking renderer\n  const remaining = thinking.flush();\n  if (remaining) {\n    onVisibleText(remaining);\n    onStream?.onToken?.(remaining);\n  }\n\n  // Strip <think> tags from the full collected text (for message history)\n  text = stripThinkTags(text);\n\n  return {\n    text,\n    toolCalls: [...toolCallMap.values()],\n    thinkingRenderer: thinking,\n    usage,\n    finishReason,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/core/agent.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":191,"column":64,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":191,"endColumn":66,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[6740,6742],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":191,"column":79,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":191,"endColumn":81,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[6755,6757],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":230,"column":24,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":230,"endColumn":26,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[8160,8162],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":231,"column":33,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":231,"endColumn":35,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[8239,8241],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":428,"column":24,"nodeType":"ChainExpression","messageId":"neverNullish","endLine":428,"endColumn":56},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":428,"column":48,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":428,"endColumn":50,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[16265,16267],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, value is always truthy.","line":454,"column":12,"nodeType":"Literal","messageId":"alwaysTruthy","endLine":454,"endColumn":16},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, value is always falsy.","line":585,"column":30,"nodeType":"UnaryExpression","messageId":"alwaysFalsy","endLine":585,"endColumn":40}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * agent.ts  Main agent loop orchestrator.\n *\n * Delegates to focused modules:\n *   agent-setup.ts       Client creation, system prompt, compaction\n *   agent-streaming.ts   Stream collection + retry logic\n *   agent-permissions.ts  Tool approval flow\n *   agent-execution.ts   Parallel tool dispatch with semaphore\n */\n\nimport chalk from 'chalk';\nimport type { OptaConfig } from './config.js';\nimport { ensureModel } from './errors.js';\nimport { debug } from './debug.js';\nimport { errorMessage } from '../utils/errors.js';\nimport { estimateMessageTokens } from '../utils/tokens.js';\nimport { createSpinner, type Spinner } from '../ui/spinner.js';\nimport { ThinkingRenderer } from '../ui/thinking.js';\nimport { StatusBar } from '../ui/statusbar.js';\nimport type { SubAgentContext } from './subagent.js';\nimport {\n  createHookManager,\n  fireSessionStart,\n  fireSessionEnd,\n  fireCompact,\n  fireError,\n  type SessionContext,\n} from '../hooks/integration.js';\n\n// --- Re-export sub-module types for consumers ---\nexport { resetClientCache, buildSystemPrompt } from './agent-setup.js';\nexport type { ToolCallAccum } from './agent-streaming.js';\nexport type { ToolDecision } from './agent-permissions.js';\n\n// --- Types (public API  unchanged) ---\n\nexport type ContentPart =\n  | { type: 'text'; text: string }\n  | { type: 'image_url'; image_url: { url: string } };\n\nexport interface AgentMessage {\n  role: 'system' | 'user' | 'assistant' | 'tool';\n  content: string | ContentPart[] | null;\n  tool_calls?: Array<{\n    id: string;\n    type: 'function';\n    function: { name: string; arguments: string };\n  }>;\n  tool_call_id?: string;\n}\n\nexport interface OnStreamCallbacks {\n  onToken?: (text: string) => void;\n  onToolStart?: (name: string, id: string, args: string) => void;\n  onToolEnd?: (name: string, id: string, result: string) => void;\n  onThinking?: (text: string) => void;\n  /**\n   * Called when a tool requires 'ask' permission.\n   * The callback must return a Promise that resolves to true (allow) or false (deny).\n   * If 'always' is chosen, the caller should persist the permission and return true.\n   */\n  onPermissionRequest?: (toolName: string, args: Record<string, unknown>) => Promise<'allow' | 'deny' | 'always'>;\n  /** Called when connection status changes during streaming (reconnection attempts). */\n  onConnectionStatus?: (status: 'checking' | 'connected' | 'disconnected' | 'reconnecting', attempt?: number) => void;\n  /** Called with inference observability insights (performance, context, tool selection). */\n  onInsight?: (insight: import('./insights.js').Insight) => void;\n  /** Called when the API returns token usage data (from final streaming chunk). */\n  onUsage?: (usage: { promptTokens: number; completionTokens: number }) => void;\n}\n\nexport interface AgentLoopOptions {\n  existingMessages?: AgentMessage[];\n  sessionId?: string;\n  silent?: boolean;\n  mode?: string;\n  imageBase64?: string;\n  /** Multiple images for multimodal vision support. */\n  images?: Array<{ base64: string; mimeType: string; name?: string }>;\n  subAgentContext?: SubAgentContext;\n  profile?: string;\n  onStream?: OnStreamCallbacks;\n  signal?: AbortSignal;\n  /**\n   * Optional override for standard local tool execution (used by daemon worker offload).\n   * MCP/custom/sub-agent tool routing still occurs inside the registry.\n   */\n  toolExecutor?: (name: string, argsJson: string, signal?: AbortSignal) => Promise<string>;\n  /** Called when a sub-agent is spawned (both spawn_agent and delegate_task subtasks). */\n  onSubAgentSpawn?: (id: string, label: string, dependsOn?: number) => void;\n  /** Called as a sub-agent progresses through phases. */\n  onSubAgentProgress?: (event: import('./subagent-events.js').SubAgentProgressEvent) => void;\n  /** Called when a sub-agent completes with its final result text. */\n  onSubAgentDone?: (agentId: string, result: string) => void;\n}\n\nexport interface AgentLoopResult {\n  messages: AgentMessage[];\n  toolCallCount: number;\n  lastThinkingRenderer?: ThinkingRenderer;\n}\n\ntype AutonomyRunCompletionStatus = import('./autonomy.js').AutonomyRunCompletionStatus;\n\nexport interface FinalReassessmentDecisionInput {\n  autonomyLevel: number;\n  objectiveReassessmentEnabled: boolean;\n  alreadyForcedFinalPass: boolean;\n}\n\nexport function shouldForceFinalReassessmentPass(\n  input: FinalReassessmentDecisionInput,\n): boolean {\n  return (\n    input.autonomyLevel >= 3\n    && input.objectiveReassessmentEnabled\n    && !input.alreadyForcedFinalPass\n  );\n}\n\nfunction makeAbortError(message = 'Turn cancelled'): Error {\n  const err = new Error(message);\n  err.name = 'AbortError';\n  return err;\n}\n\nfunction queueLearningCapture(\n  config: OptaConfig,\n  event: import('../learning/hooks.js').CaptureLearningEventInput,\n): void {\n  if (!config.learning.enabled) return;\n  void import('../learning/hooks.js')\n    .then(({ captureLearningEvent }) => captureLearningEvent(config, event))\n    .catch(() => {});\n}\n\nasync function buildLearningRetrievalBlock(\n  task: string,\n  config: OptaConfig,\n): Promise<string | null> {\n  if (!config.learning.enabled) return null;\n\n  try {\n    const { readLedgerEntries } = await import('../learning/ledger.js');\n    const { buildRetrievalPromptBlock } = await import('../learning/retrieval.js');\n    const entries = await readLedgerEntries();\n    if (entries.length === 0) return null;\n\n    const block = buildRetrievalPromptBlock(task, entries, 4);\n    if (block.includes('No matching prior learning found.')) {\n      return null;\n    }\n    return block;\n  } catch {\n    return null;\n  }\n}\n\n// --- Main Agent Loop ---\n\nexport async function agentLoop(\n  task: string,\n  config: OptaConfig,\n  options?: AgentLoopOptions\n): Promise<AgentLoopResult> {\n  // --- Imports from sub-modules ---\n  const {\n    getOrCreateClient,\n    buildSystemPrompt,\n    compactHistory,\n    maskOldObservations,\n    buildCapabilityManifest,\n    injectCapabilityManifest,\n  } = await import('./agent-setup.js');\n  const { createStreamWithRetry, collectStream } = await import('./agent-streaming.js');\n  const { resolveToolDecisions } = await import('./agent-permissions.js');\n  const { executeToolCalls } = await import('./agent-execution.js');\n  const {\n    applyAutonomyRuntimeProfile,\n    buildAutonomyCycleCheckpoint,\n    buildAutonomyStageCheckpointGuidance,\n    buildCeoAutonomyReport,\n  } = await import('./autonomy.js');\n\n  const isSubAgent = !!options?.subAgentContext;\n  const profiledConfig = applyAutonomyRuntimeProfile(config);\n\n  // When running as a sub-agent, apply derived config overrides\n  let effectiveConfig: OptaConfig;\n  if (isSubAgent) {\n    const { deriveChildConfig } = await import('./subagent.js');\n    effectiveConfig = deriveChildConfig(profiledConfig, options?.mode, options?.subAgentContext?.budget);\n  } else {\n    effectiveConfig = profiledConfig;\n  }\n\n  const client = await getOrCreateClient(effectiveConfig);\n  const transportProviderName = (client as import('openai').default & { __optaProviderName?: string }).__optaProviderName\n    ?? effectiveConfig.provider.active;\n\n  const model = effectiveConfig.model.default;\n  ensureModel(model);\n\n  // Use existing messages (multi-turn) or start fresh (single-shot)\n  // Build multimodal content if images are provided (single or multiple)\n  const allImages: Array<{ base64: string; mimeType: string; name?: string }> = [];\n  if (options?.imageBase64) {\n    allImages.push({ base64: options.imageBase64, mimeType: 'image/png' });\n  }\n  if (options?.images) {\n    allImages.push(...options.images);\n  }\n\n  const userMessage: AgentMessage = allImages.length > 0\n    ? {\n        role: 'user',\n        content: [\n          { type: 'text', text: task },\n          ...allImages.map(img => ({\n            type: 'image_url' as const,\n            image_url: { url: img.base64.startsWith('data:') ? img.base64 : `data:${img.mimeType};base64,${img.base64}` },\n          })),\n        ],\n      }\n    : { role: 'user', content: task };\n\n  let systemPrompt: string;\n  if (isSubAgent) {\n    // Sub-agents get a lightweight prompt without OPIS/export map\n    const { buildSubAgentPrompt } = await import('./subagent.js');\n    const cwd = options?.subAgentContext?.parentCwd ?? process.cwd();\n    const maxToolCalls = options?.subAgentContext?.budget.maxToolCalls ?? 15;\n    systemPrompt = buildSubAgentPrompt(task, cwd, maxToolCalls);\n  } else {\n    systemPrompt = await buildSystemPrompt(effectiveConfig, undefined, options?.mode);\n  }\n\n  // If an agent profile is active, append its system prompt suffix\n  if (options?.profile) {\n    const { getAgentProfile } = await import('./agent-profiles.js');\n    const activeProfile = getAgentProfile(options.profile);\n    if (activeProfile?.systemPromptSuffix) {\n      systemPrompt += '\\n\\n' + activeProfile.systemPromptSuffix;\n    }\n  }\n\n  const messages: AgentMessage[] = options?.existingMessages\n    ? [...options.existingMessages, userMessage]\n    : [\n        { role: 'system', content: systemPrompt },\n        userMessage,\n      ];\n\n  let toolCallCount = 0;\n  let toolCallTurns = 0;\n  const enforceAutonomyStages = effectiveConfig.autonomy.level >= 3;\n  const objectiveReassessmentEnabled = effectiveConfig.autonomy.objectiveReassessment;\n  let forcedFinalReassessmentTriggered = false;\n  let pendingFinalReassessmentPass = false;\n  let autonomyTurnCount = 0;\n  let lastAutonomyCheckpoint = buildAutonomyCycleCheckpoint(0);\n  let completionStatus: AutonomyRunCompletionStatus = 'stopped';\n  // Sub-agents are always silent\n  const silent = isSubAgent || (options?.silent ?? false);\n  const noopSpinner: Spinner = { start: () => {}, stop: () => {}, succeed: () => {}, fail: () => {} };\n  const spinner = silent ? noopSpinner : await createSpinner();\n  const sessionId = options?.sessionId ?? 'unknown';\n\n  // Status bar for real-time stats\n  const statusBar = silent ? null : new StatusBar({\n    model,\n    sessionId,\n    provider: effectiveConfig.provider.active,\n  });\n  let checkpointCount = 0;\n  let pseudoToolProtocolRetryCount = 0;\n  let lastThinkingRenderer: ThinkingRenderer | undefined;\n  const streamCallbacks = options?.onStream;\n\n  // Insight engine for REPL mode (non-TUI, non-silent)\n  // TUI mode uses its own InsightEngine wired through the adapter.\n  let insightEngine: import('./insights.js').InsightEngine | null = null;\n  if (!silent && !streamCallbacks?.onInsight && effectiveConfig.insights.enabled) {\n    const { InsightEngine } = await import('./insights.js');\n    const { formatInsight } = await import('../ui/insights.js');\n    insightEngine = new InsightEngine((insight) => {\n      console.log(formatInsight(insight));\n    });\n    insightEngine.setModel(model);\n    insightEngine.setContextLimit(effectiveConfig.model.contextLimit);\n  }\n\n  // Initialize background process manager (skip for sub-agents to avoid replacing parent's)\n  const { initProcessManager, shutdownProcessManager } = await import('./tools/index.js');\n  if (!isSubAgent) {\n    initProcessManager(effectiveConfig);\n  }\n\n  const { buildToolRegistry } = await import('../mcp/registry.js');\n  const registry = await buildToolRegistry(effectiveConfig, options?.mode, {\n    executeLocalTool: options?.toolExecutor,\n    onSubAgentSpawn: options?.onSubAgentSpawn,\n    onSubAgentProgress: options?.onSubAgentProgress,\n    onSubAgentDone: options?.onSubAgentDone,\n  });\n\n  const { getAgentProfile, filterToolsForMode } = await import('./agent-profiles.js');\n\n  // Filter tool schemas by agent profile (if active)\n  let activeSchemas = registry.schemas;\n  if (options?.profile) {\n    const activeProfile = getAgentProfile(options.profile);\n    if (activeProfile?.tools && activeProfile.tools.length > 0) {\n      const allowedTools = new Set(activeProfile.tools);\n      activeSchemas = activeSchemas.filter(\n        (s: { function: { name: string } }) => allowedTools.has(s.function.name)\n      );\n      debug(`Profile \"${options.profile}\" filtered tools: ${activeSchemas.length}/${registry.schemas.length}`);\n    }\n  }\n\n  const activeMode = options?.mode ?? effectiveConfig.defaultMode;\n  const preModeCount = activeSchemas.length;\n  activeSchemas = filterToolsForMode(activeSchemas, activeMode);\n  if (activeSchemas.length !== preModeCount) {\n    debug(`Mode \"${activeMode}\" filtered tools: ${activeSchemas.length}/${preModeCount}`);\n  }\n\n  // Inject a concise runtime capability manifest after tool filtering.\n  if (!isSubAgent) {\n    const manifest = buildCapabilityManifest(effectiveConfig, {\n      activeToolSchemas: activeSchemas,\n      mode: activeMode,\n      profile: options?.profile,\n    });\n\n    let systemMessage = messages.find((message) => message.role === 'system' && typeof message.content === 'string');\n    if (systemMessage && typeof systemMessage.content === 'string') {\n      systemMessage.content = injectCapabilityManifest(systemMessage.content, manifest);\n    } else if (!options?.existingMessages) {\n      messages.unshift({\n        role: 'system',\n        content: injectCapabilityManifest(systemPrompt, manifest),\n      });\n      systemMessage = messages[0];\n    }\n\n    const learningBlock = await buildLearningRetrievalBlock(task, effectiveConfig);\n    if (\n      learningBlock &&\n      systemMessage &&\n      typeof systemMessage.content === 'string' &&\n      !systemMessage.content.includes('### Relevant learning context')\n    ) {\n      systemMessage.content = `${systemMessage.content}\\n\\n${learningBlock}`;\n    }\n\n    const {\n      readToolCompatibilityEntry,\n      buildToolCompatibilityInstruction,\n    } = await import('./tool-compatibility.js');\n    const compatibilityEntry = await readToolCompatibilityEntry(process.cwd(), {\n      model,\n      provider: transportProviderName,\n    }).catch(() => null);\n    const compatibilityInstruction = buildToolCompatibilityInstruction(compatibilityEntry);\n    if (\n      compatibilityInstruction &&\n      systemMessage &&\n      typeof systemMessage.content === 'string' &&\n      !systemMessage.content.includes('### Tool-Call Compatibility')\n    ) {\n      systemMessage.content = `${systemMessage.content}\\n\\n${compatibilityInstruction}`;\n    }\n\n    if (effectiveConfig.browser.enabled && effectiveConfig.browser.autoInvoke) {\n      const [\n        { routeBrowserIntent, buildBrowserRoutingInstruction },\n        { loadBrowserRunCorpusAdaptationHint },\n      ] = await Promise.all([\n        import('../browser/intent-router.js'),\n        import('../browser/adaptation.js'),\n      ]);\n      const adaptationHint = effectiveConfig.browser.adaptation.enabled\n        ? await loadBrowserRunCorpusAdaptationHint(process.cwd(), effectiveConfig.browser.adaptation)\n            .catch(() => null)\n        : null;\n      const routingDecision = routeBrowserIntent(task, {\n        adaptationHint: adaptationHint?.intent,\n      });\n\n      if (routingDecision.shouldRoute) {\n        const routingInstruction = buildBrowserRoutingInstruction(routingDecision);\n        if (\n          routingInstruction &&\n          systemMessage &&\n          typeof systemMessage.content === 'string' &&\n          !systemMessage.content.includes('### Browser Auto-Routing')\n        ) {\n          systemMessage.content = `${systemMessage.content}\\n\\n${routingInstruction}`;\n        }\n      }\n    }\n  }\n\n  // Initialize hook manager (no-op when no hooks configured)\n  const hooks = createHookManager(effectiveConfig);\n  const sessionCtx: SessionContext = {\n    sessionId,\n    cwd: process.cwd(),\n    model,\n  };\n  if (!isSubAgent) {\n    await fireSessionStart(hooks, sessionCtx);\n  }\n\n  // Hoist dynamic imports used inside the loop to avoid per-iteration await overhead\n  const { saveConfig: saveConfigFn } = await import('./config.js');\n  const gitUtilsMod = await import('../git/utils.js');\n  const gitCheckpointsMod = await import('../git/checkpoints.js');\n  const gitCommitMod = await import('../git/commit.js');\n  const { detectPseudoToolMarkup, buildPseudoToolCorrectionMessage } = await import('./tool-protocol.js');\n  const { recordToolCompatibilityEvent } = await import('./tool-compatibility.js');\n  const loopStartedAtMs = Date.now();\n\n  // --- LMX Watchdog: continuous health monitor ---\n  // Only active for top-level (non-sub-agent) sessions running against LMX.\n  let watchdog: { stop(): void } | undefined;\n  const isLmxActive = (effectiveConfig.provider?.active ?? 'lmx') === 'lmx';\n  if (isLmxActive && !isSubAgent) {\n    const { LmxWatchdog } = await import('../lmx/watchdog.js');\n    const { LmxClient } = await import('../lmx/client.js');\n    const tempClient = new LmxClient({\n      host: effectiveConfig.connection.host,\n      fallbackHosts: effectiveConfig.connection.fallbackHosts,\n      port: effectiveConfig.connection.port,\n      adminKey: effectiveConfig.connection.adminKey,\n      timeoutMs: 4_000,\n      maxRetries: 0,\n    });\n    const wd = new LmxWatchdog(tempClient, () => {\n      if (!silent) {\n        console.log(\n          chalk.yellow(\n            '\\n  Warning: LMX unreachable  provider may degrade. Run `opta doctor` if this persists.',\n          ),\n        );\n      }\n    });\n    wd.start(15_000);\n    watchdog = wd;\n  }\n\n  try {\n    while (true) {\n      if (options?.signal?.aborted) {\n        throw makeAbortError();\n      }\n\n      const maxDurationMs = effectiveConfig.safety.circuitBreaker.maxDuration;\n      if (maxDurationMs > 0) {\n        const elapsedMs = Date.now() - loopStartedAtMs;\n        if (elapsedMs >= maxDurationMs) {\n          const elapsedMinutes = (elapsedMs / 60_000).toFixed(1);\n          const budgetMinutes = (maxDurationMs / 60_000).toFixed(1);\n          if (!silent) {\n            console.log(chalk.yellow(`\\n  Autonomous runtime budget reached (${elapsedMinutes}/${budgetMinutes} min). Stopping turn.`));\n          }\n          completionStatus = 'runtime_budget_reached';\n          messages.push({\n            role: 'assistant',\n            content: `Autonomy runtime budget reached (${elapsedMinutes}/${budgetMinutes} min). Returning the best complete state so far.`,\n          });\n          statusBar?.clear();\n          break;\n        }\n      }\n\n      // 0. Observation masking (free context savings)\n      const maskedMessages = maskOldObservations(messages, 4);\n      messages.splice(0, messages.length, ...maskedMessages);\n\n      // 1. Context compaction\n      const tokenEstimate = estimateMessageTokens(messages);\n      insightEngine?.contextUpdate(tokenEstimate);\n      const threshold = effectiveConfig.model.contextLimit * effectiveConfig.safety.compactAt;\n      if (tokenEstimate > threshold) {\n        debug(`Token estimate ${tokenEstimate} exceeds threshold ${threshold}`);\n        spinner.start('Compacting conversation history...');\n        const preCompactCount = messages.length;\n        const compacted = await compactHistory(messages, client, model, effectiveConfig.model.contextLimit);\n        const recoveredTokens = tokenEstimate - estimateMessageTokens(compacted);\n        messages.splice(0, messages.length, ...compacted);\n        spinner.succeed('Context compacted');\n        insightEngine?.compaction(preCompactCount, recoveredTokens);\n        await fireCompact(hooks, sessionCtx);\n      }\n\n      const stageCheckpoint = buildAutonomyCycleCheckpoint(autonomyTurnCount);\n      lastAutonomyCheckpoint = stageCheckpoint;\n      if (enforceAutonomyStages) {\n        messages.push({\n          role: 'system',\n          content: buildAutonomyStageCheckpointGuidance(stageCheckpoint, {\n            finalReassessment: pendingFinalReassessmentPass,\n          }),\n        });\n      }\n      pendingFinalReassessmentPass = false;\n      autonomyTurnCount += 1;\n\n      // 2. Call Opta LMX\n      insightEngine?.turnStart();\n      debug(`Sending ${messages.length} messages to ${model}`);\n      spinner.start('Thinking...');\n\n      // Reconnection status handler: use TUI callback if available, otherwise log to console\n      const reconnectHandler = streamCallbacks?.onConnectionStatus ?? (\n        silent ? undefined : (status: 'checking' | 'connected' | 'disconnected' | 'reconnecting', attempt?: number) => {\n          if (status === 'reconnecting') {\n            spinner.stop();\n            console.log(chalk.dim(`  Connection interrupted, reconnecting... (attempt ${attempt ?? '?'}/${effectiveConfig.connection.retry.maxRetries})`));\n            spinner.start('Reconnecting...');\n          } else if (status === 'connected') {\n            spinner.stop();\n            console.log(chalk.green('  \\u2713') + chalk.dim(' Reconnected'));\n            spinner.start('Thinking...');\n          } else if (status === 'disconnected') {\n            spinner.stop();\n          }\n        }\n      );\n\n      const stream = await createStreamWithRetry(\n        client,\n        {\n          model,\n          messages: messages as Parameters<typeof client.chat.completions.create>[0]['messages'],\n          tools: activeSchemas as Parameters<typeof client.chat.completions.create>[0]['tools'],\n          tool_choice: 'auto',\n        },\n        effectiveConfig.connection.retry,\n        reconnectHandler,\n        {\n          config: effectiveConfig,\n          providerName: transportProviderName,\n          signal: options?.signal,\n        },\n      );\n\n      spinner.stop();\n\n      // 3. Stream tokens to terminal, collect tool calls\n      statusBar?.newTurn();\n      let firstText = true;\n      const streamStartTime = Date.now();\n      const { text, toolCalls, thinkingRenderer: lastThinking, usage, finishReason } = await collectStream(stream, (chunk) => {\n        if (silent) return;\n        if (firstText) {\n          console.log(); // blank line before response\n          firstText = false;\n          // Fire first-token insight for REPL mode\n          insightEngine?.firstToken(Date.now() - streamStartTime);\n        }\n        process.stdout.write(chunk);\n      }, statusBar, streamCallbacks);\n\n      // Track last thinking renderer for expand/collapse toggle\n      lastThinkingRenderer = lastThinking;\n\n      // Set prompt tokens from API usage data (if available)\n      if (usage) {\n        statusBar?.setPromptTokens(usage.promptTokens);\n        streamCallbacks?.onUsage?.(usage);\n      }\n\n      // Truncation detection: warn if response was cut off by max_tokens\n      if (finishReason === 'length') {\n        const truncationWarning = chalk.yellow('   Response truncated (hit max_tokens limit)');\n        if (!silent) {\n          process.stdout.write('\\n' + truncationWarning + '\\n');\n        }\n        debug('Response truncated: finish_reason=length');\n      }\n\n      if (!silent && text && !firstText) {\n        process.stdout.write('\\n'); // newline after streamed text\n      }\n\n      // Print turn summary (tokens, speed, tool calls)\n      statusBar?.finalizeTurn();\n      if (!silent) statusBar?.printSummary();\n\n      if (toolCalls.length === 0 && text) {\n        const detection = detectPseudoToolMarkup(text);\n        if (detection.detected) {\n          if (!isSubAgent) {\n            await recordToolCompatibilityEvent(process.cwd(), {\n              model,\n              provider: transportProviderName,\n              status: 'pseudo_failure',\n              pseudoTags: detection.toolTags,\n            }).catch(() => {});\n          }\n\n          messages.push({\n            role: 'assistant',\n            content: text,\n          });\n\n          if (pseudoToolProtocolRetryCount < 1) {\n            pseudoToolProtocolRetryCount += 1;\n            const correction = buildPseudoToolCorrectionMessage(\n              detection,\n              effectiveConfig.browser.enabled,\n            );\n            if (!silent) {\n              console.log(chalk.yellow('   Invalid pseudo tool markup detected; retrying with protocol correction.'));\n            }\n            messages.push({\n              role: 'system',\n              content: correction,\n            });\n            continue;\n          }\n\n          const guidance = [\n            'Tool-call protocol error: model returned pseudo tool tags instead of executable tool calls.',\n            'Switch to a tool-calling compatible model/provider and retry.',\n            'Browser note: use browser_* tool calls; do not use shell GUI automation.',\n          ].join(' ');\n          if (!silent) {\n            console.log(chalk.red(`\\n  ${guidance}\\n`));\n          }\n          messages.push({\n            role: 'assistant',\n            content: guidance,\n          });\n          completionStatus = 'stopped';\n          statusBar?.clear();\n          break;\n        }\n      }\n\n      // 4. No tool calls = task complete\n      if (toolCalls.length === 0) {\n        // Persist the final assistant response so callers (e.g. opta do --format json)\n        // can reliably read it from message history.\n        messages.push({\n          role: 'assistant',\n          content: text || null,\n        });\n\n        // Fire turn-end insight for REPL mode\n        const turnElapsed = (Date.now() - streamStartTime) / 1000;\n        const turnTokens = estimateMessageTokens([{ role: 'assistant', content: text }]);\n        const turnSpeed = turnElapsed > 0.1 ? turnTokens / turnElapsed : 0;\n        insightEngine?.turnEnd({\n          tokens: turnTokens,\n          toolCalls: 0,\n          elapsed: turnElapsed,\n          speed: turnSpeed,\n          firstTokenLatencyMs: null,\n        });\n\n        if (shouldForceFinalReassessmentPass({\n          autonomyLevel: effectiveConfig.autonomy.level,\n          objectiveReassessmentEnabled,\n          alreadyForcedFinalPass: forcedFinalReassessmentTriggered,\n        })) {\n          forcedFinalReassessmentTriggered = true;\n          pendingFinalReassessmentPass = true;\n          if (!silent) {\n            console.log(chalk.dim('  Autonomy checkpoint: forcing final review/reassessment pass before completion.'));\n          }\n          statusBar?.clear();\n          continue;\n        }\n\n        completionStatus = 'completed';\n        if (text && text.trim() && toolCallCount > 0) {\n          queueLearningCapture(effectiveConfig, {\n            kind: 'solution',\n            topic: 'Tool-assisted turn completed',\n            content: text.slice(0, 1600),\n            tags: ['completion', 'tool-assisted', activeMode],\n            evidence: [{ label: 'session', uri: `session://${sessionId}` }],\n            metadata: {\n              mode: activeMode,\n              profile: options?.profile ?? 'default',\n              toolCallCount,\n            },\n            verified: true,\n          });\n        }\n\n        statusBar?.clear();\n        break;\n      }\n\n      toolCallTurns += 1;\n\n      // 5. Append assistant message with tool calls\n      if (!isSubAgent) {\n        await recordToolCompatibilityEvent(process.cwd(), {\n          model,\n          provider: transportProviderName,\n          status: 'success',\n        }).catch(() => {});\n      }\n\n      messages.push({\n        role: 'assistant',\n        content: text || null,\n        tool_calls: toolCalls.map((tc) => ({\n          id: tc.id,\n          type: 'function' as const,\n          function: { name: tc.name, arguments: tc.args },\n        })),\n      });\n      pseudoToolProtocolRetryCount = 0;\n\n      // 6. Resolve permissions then execute tools\n      const decisions = await resolveToolDecisions(toolCalls, effectiveConfig, {\n        isSubAgent,\n        silent,\n        saveConfig: saveConfigFn,\n        streamCallbacks,\n        hooks,\n        sessionCtx,\n      });\n\n      const execResult = await executeToolCalls(decisions, messages, {\n        config: effectiveConfig,\n        spinner,\n        silent,\n        isSubAgent,\n        sessionId,\n        streamCallbacks,\n        insightEngine,\n        hooks,\n        sessionCtx,\n        registry,\n        signal: options?.signal,\n      }, toolCallCount, checkpointCount);\n\n      toolCallCount += execResult.toolCallsDelta;\n      checkpointCount = execResult.checkpointCount;\n\n      // 7. Progressive circuit breaker\n      const cb = effectiveConfig.safety.circuitBreaker;\n\n      if (cb.hardStopAt > 0 && toolCallCount >= cb.hardStopAt) {\n        if (!silent) console.log(chalk.red(`\\n  Hard stop: ${cb.hardStopAt} tool calls reached.`));\n        completionStatus = 'hard_stop';\n        break;\n      }\n\n      if (cb.pauseAt > 0 && toolCallCount >= cb.pauseAt && toolCallCount % cb.pauseAt === 0) {\n        const isNonInteractive = !process.stdout.isTTY || process.env['CI'] === 'true';\n        const canContinueHeadless =\n          isNonInteractive &&\n          effectiveConfig.autonomy.headlessContinue &&\n          effectiveConfig.autonomy.level >= 4;\n\n        if (canContinueHeadless) {\n          // Headless continue: log a checkpoint and keep running without user prompt\n          if (!silent) {\n            console.log(\n              chalk.dim(`\\n   Headless checkpoint at ${toolCallCount} tool calls  continuing autonomously`),\n            );\n          }\n          queueLearningCapture(effectiveConfig, {\n            kind: 'plan',\n            topic: 'Headless circuit breaker checkpoint',\n            content: `Session auto-continued at ${toolCallCount} tool calls (headlessContinue=true, level=${effectiveConfig.autonomy.level})`,\n            tags: ['agent-loop', 'headless', 'circuit-breaker'],\n            verified: true,\n          });\n        } else if (silent || isNonInteractive) {\n          completionStatus = 'paused';\n          break;\n        } else {\n          console.log(chalk.yellow(`\\n  Reached ${toolCallCount} tool calls. Pausing.`));\n          const { confirm } = await import('@inquirer/prompts');\n          const shouldContinue = await confirm({ message: 'Continue?' });\n          if (!shouldContinue) {\n            completionStatus = 'paused';\n            break;\n          }\n        }\n      }\n\n      if (cb.warnAt > 0 && toolCallCount === cb.warnAt && !silent) {\n        console.log(chalk.dim(`\\n  Note: ${cb.warnAt} tool calls used (pauses at ${cb.pauseAt})`));\n      }\n\n      // R3: Periodic recovery checkpoint every 10 tool calls\n      if (sessionId && sessionId !== 'unknown' && toolCallCount > 0 && toolCallCount % 10 === 0) {\n        const { writeRecoveryCheckpoint } = await import('../memory/recovery.js');\n        void writeRecoveryCheckpoint(sessionId, messages, toolCallCount).catch(() => {});\n      }\n    }\n  } catch (err) {\n    // Fire the error hook so lifecycle hooks can observe failures\n    completionStatus = err instanceof Error && err.name === 'AbortError' ? 'aborted' : 'error';\n    const errMsg = errorMessage(err);\n    queueLearningCapture(effectiveConfig, {\n      kind: 'problem',\n      topic: 'Agent loop error',\n      content: errMsg,\n      tags: ['agent-loop', 'error', activeMode],\n      evidence: [{ label: 'session', uri: `session://${sessionId}` }],\n      metadata: {\n        mode: activeMode,\n        profile: options?.profile ?? 'default',\n      },\n      verified: false,\n    });\n    await fireError(hooks, errMsg, sessionCtx).catch(() => {});\n    throw err; // Re-throw so callers (chat.ts, do.ts, server.ts) handle it\n  } finally {\n    // Cleanup runs whether the loop completes normally or throws\n\n    if (!isSubAgent && effectiveConfig.autonomy.mode === 'ceo') {\n      try {\n        const reportCheckpoint = autonomyTurnCount > 0\n          ? buildAutonomyCycleCheckpoint(autonomyTurnCount - 1)\n          : lastAutonomyCheckpoint;\n        const reportStage = forcedFinalReassessmentTriggered\n          ? 'reassessment'\n          : reportCheckpoint.stage;\n        const report = buildCeoAutonomyReport({\n          objective: task,\n          completionStatus,\n          turnCount: autonomyTurnCount,\n          cycle: reportCheckpoint.cycle,\n          phase: reportCheckpoint.phase,\n          stage: reportStage,\n          toolCallCount,\n          toolCallTurns,\n          objectiveReassessmentEnabled,\n          forcedFinalReassessment: forcedFinalReassessmentTriggered,\n        });\n        const { writeUpdateLog } = await import('../journal/update-log.js');\n        await writeUpdateLog({\n          summary: report.summary,\n          slug: report.slug,\n          commandInputs: report.commandInputs,\n          steps: report.steps,\n          cwd: process.cwd(),\n          logsDir: effectiveConfig.journal.updateLogsDir,\n          timezone: effectiveConfig.journal.timezone,\n          author: effectiveConfig.journal.author,\n          promoted: false,\n          category: 'autonomy',\n        });\n      } catch {\n        // Fail-open by design: logging must never break agent loop completion.\n      }\n    }\n\n    // Auto-commit if enabled and tools were used (skip for sub-agents)\n    if (!isSubAgent && effectiveConfig.git.autoCommit && toolCallCount > 0 && options?.sessionId) {\n      try {\n        if (await gitUtilsMod.isGitRepo(process.cwd())) {\n          const modifiedFiles = await gitUtilsMod.getModifiedFiles(process.cwd());\n          if (modifiedFiles.length > 0) {\n            const commitMsg = await gitCommitMod.generateCommitMessage(messages, client, model);\n            const committed = await gitCommitMod.commitSessionChanges(process.cwd(), modifiedFiles, commitMsg);\n            if (committed && !silent) {\n              console.log(chalk.green('\\u2713') + chalk.dim(` Committed: ${commitMsg}`));\n            }\n            await gitCheckpointsMod.cleanupCheckpoints(process.cwd(), options.sessionId);\n          }\n        }\n      } catch (err) {\n        // Auto-commit failed  non-fatal\n        if (process.env.OPTA_DEBUG) console.error('Auto-commit failed:', err);\n      }\n    }\n\n    // Token usage shown by statusBar.printSummary() per turn\n\n    // Stop health watchdog (no-op if not started)\n    watchdog?.stop();\n\n    // R3: Delete recovery checkpoint on non-crash exit\n    if (sessionId && sessionId !== 'unknown' && completionStatus !== 'error') {\n      const { deleteRecoveryCheckpoint } = await import('../memory/recovery.js');\n      void deleteRecoveryCheckpoint(sessionId).catch(() => {});\n    }\n\n    await registry.close();\n\n    // Shutdown background processes (skip for sub-agents to avoid killing parent's)\n    if (!isSubAgent) {\n      await shutdownProcessManager();\n    }\n\n    // Fire session end hook\n    if (!isSubAgent) {\n      await fireSessionEnd(hooks, sessionCtx);\n    }\n  }\n\n  return { messages, toolCallCount, lastThinkingRenderer };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/core/autonomy.ts","messages":[{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'value ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":345,"column":30,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":345,"endColumn":41},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'value ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":352,"column":29,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":352,"endColumn":40}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { OptaConfig } from './config.js';\n\nexport type AutonomyLevel = 1 | 2 | 3 | 4 | 5;\nexport type AutonomyMode = 'execution' | 'ceo';\nexport const AUTONOMY_CYCLE_STAGES = [\n  'research',\n  'analysis',\n  'planning',\n  'sub-planning',\n  'execution',\n  'review',\n  'reassessment',\n] as const;\nexport type AutonomyCycleStage = (typeof AUTONOMY_CYCLE_STAGES)[number];\nexport type AutonomyRunCompletionStatus =\n  | 'completed'\n  | 'runtime_budget_reached'\n  | 'hard_stop'\n  | 'paused'\n  | 'aborted'\n  | 'error'\n  | 'stopped';\n\nexport interface AutonomyCycleCheckpoint {\n  turnIndex: number;\n  cycle: number;\n  phase: number;\n  stage: AutonomyCycleStage;\n  nextStage: AutonomyCycleStage;\n  stageCount: number;\n}\n\ninterface AutonomyCheckpointOptions {\n  finalReassessment?: boolean;\n}\n\ninterface CeoAutonomyReportStep {\n  target: string;\n  component: string;\n  step: string;\n  status: 'ok' | 'skip' | 'fail';\n  message: string;\n}\n\nexport interface CeoAutonomyReportInput {\n  objective: string;\n  completionStatus: AutonomyRunCompletionStatus;\n  turnCount: number;\n  cycle: number;\n  phase: number;\n  stage: AutonomyCycleStage;\n  toolCallCount: number;\n  toolCallTurns: number;\n  objectiveReassessmentEnabled: boolean;\n  forcedFinalReassessment: boolean;\n}\n\nexport interface CeoAutonomyReportPayload {\n  summary: string;\n  slug: string;\n  commandInputs: Record<string, unknown>;\n  steps: CeoAutonomyReportStep[];\n}\n\ninterface BaseAutonomyProfile {\n  level: AutonomyLevel;\n  defaultMode: OptaConfig['defaultMode'];\n  maxDurationMs: number;\n  warnAt: number;\n  pauseAt: number;\n  hardStopAt: number;\n  maxParallelTools: number;\n  compactAt: number;\n  subAgentMaxDepth: number;\n  subAgentMaxConcurrent: number;\n  subAgentBudgetToolCalls: number;\n  subAgentBudgetTokens: number;\n  subAgentBudgetTimeoutMs: number;\n  allowRunCommand: boolean;\n  allowDelegation: boolean;\n}\n\nexport interface ResolvedAutonomyProfile extends BaseAutonomyProfile {\n  mode: AutonomyMode;\n  label: string;\n  requireLiveData: boolean;\n}\n\nconst BASE_LEVELS: Record<AutonomyLevel, BaseAutonomyProfile> = {\n  1: {\n    level: 1,\n    defaultMode: 'safe',\n    maxDurationMs: 10 * 60_000,\n    warnAt: 25,\n    pauseAt: 50,\n    hardStopAt: 80,\n    maxParallelTools: 3,\n    compactAt: 0.65,\n    subAgentMaxDepth: 2,\n    subAgentMaxConcurrent: 2,\n    subAgentBudgetToolCalls: 20,\n    subAgentBudgetTokens: 12_288,\n    subAgentBudgetTimeoutMs: 90_000,\n    allowRunCommand: false,\n    allowDelegation: false,\n  },\n  2: {\n    level: 2,\n    defaultMode: 'auto',\n    maxDurationMs: 15 * 60_000,\n    warnAt: 40,\n    pauseAt: 80,\n    hardStopAt: 120,\n    maxParallelTools: 4,\n    compactAt: 0.68,\n    subAgentMaxDepth: 2,\n    subAgentMaxConcurrent: 3,\n    subAgentBudgetToolCalls: 30,\n    subAgentBudgetTokens: 16_384,\n    subAgentBudgetTimeoutMs: 120_000,\n    allowRunCommand: false,\n    allowDelegation: false,\n  },\n  3: {\n    level: 3,\n    defaultMode: 'auto',\n    maxDurationMs: 25 * 60_000,\n    warnAt: 60,\n    pauseAt: 0,\n    hardStopAt: 180,\n    maxParallelTools: 5,\n    compactAt: 0.72,\n    subAgentMaxDepth: 3,\n    subAgentMaxConcurrent: 4,\n    subAgentBudgetToolCalls: 45,\n    subAgentBudgetTokens: 24_576,\n    subAgentBudgetTimeoutMs: 180_000,\n    allowRunCommand: true,\n    allowDelegation: true,\n  },\n  4: {\n    level: 4,\n    defaultMode: 'auto',\n    maxDurationMs: 35 * 60_000,\n    warnAt: 90,\n    pauseAt: 0,\n    hardStopAt: 260,\n    maxParallelTools: 6,\n    compactAt: 0.74,\n    subAgentMaxDepth: 4,\n    subAgentMaxConcurrent: 5,\n    subAgentBudgetToolCalls: 70,\n    subAgentBudgetTokens: 32_768,\n    subAgentBudgetTimeoutMs: 240_000,\n    allowRunCommand: true,\n    allowDelegation: true,\n  },\n  5: {\n    level: 5,\n    defaultMode: 'auto',\n    maxDurationMs: 60 * 60_000,\n    warnAt: 140,\n    pauseAt: 0,\n    hardStopAt: 420,\n    maxParallelTools: 8,\n    compactAt: 0.78,\n    subAgentMaxDepth: 5,\n    subAgentMaxConcurrent: 6,\n    subAgentBudgetToolCalls: 110,\n    subAgentBudgetTokens: 65_536,\n    subAgentBudgetTimeoutMs: 420_000,\n    allowRunCommand: true,\n    allowDelegation: true,\n  },\n};\n\nconst AUTONOMY_STAGE_GUIDANCE: Record<AutonomyCycleStage, string> = {\n  'research': 'Gather current facts, constraints, and missing context before acting.',\n  'analysis': 'Analyze evidence, tradeoffs, and root causes with explicit assumptions.',\n  'planning': 'Define a concrete implementation plan with clear checkpoints.',\n  'sub-planning': 'Break the active plan into the next actionable sub-steps.',\n  'execution': 'Execute changes, run tools/tests, and capture concrete outputs.',\n  'review': 'Review results for correctness, regressions, and requirement coverage.',\n  'reassessment': 'Reassess objective completion, risks, and whether another cycle is required.',\n};\n\nfunction completionStatusLabel(status: AutonomyRunCompletionStatus): string {\n  const labels: Record<AutonomyRunCompletionStatus, string> = {\n    completed: 'completed',\n    runtime_budget_reached: 'runtime budget reached',\n    hard_stop: 'hard stop',\n    paused: 'paused',\n    aborted: 'aborted',\n    error: 'error',\n    stopped: 'stopped',\n  };\n\n  return labels[status];\n}\n\nfunction completionStatusToStepStatus(status: AutonomyRunCompletionStatus): 'ok' | 'skip' | 'fail' {\n  switch (status) {\n    case 'completed':\n      return 'ok';\n    case 'paused':\n    case 'runtime_budget_reached':\n    case 'stopped':\n      return 'skip';\n    case 'aborted':\n    case 'error':\n    case 'hard_stop':\n      return 'fail';\n    default: {\n      const unreachable: never = status;\n      return unreachable;\n    }\n  }\n}\n\nfunction normalizeTurnIndex(turnIndex: number): number {\n  if (!Number.isFinite(turnIndex)) return 0;\n  return Math.max(0, Math.floor(turnIndex));\n}\n\nexport function isAutonomyCycleStage(value: unknown): value is AutonomyCycleStage {\n  return AUTONOMY_CYCLE_STAGES.includes(value as AutonomyCycleStage);\n}\n\nexport function nextAutonomyCycleStage(stage: AutonomyCycleStage): AutonomyCycleStage {\n  const currentIndex = AUTONOMY_CYCLE_STAGES.indexOf(stage);\n  const normalizedIndex = currentIndex >= 0 ? currentIndex : 0;\n  const nextIndex = (normalizedIndex + 1) % AUTONOMY_CYCLE_STAGES.length;\n  return AUTONOMY_CYCLE_STAGES[nextIndex] ?? AUTONOMY_CYCLE_STAGES[0];\n}\n\nexport function buildAutonomyCycleCheckpoint(turnIndex: number): AutonomyCycleCheckpoint {\n  const normalizedTurn = normalizeTurnIndex(turnIndex);\n  const stageCount = AUTONOMY_CYCLE_STAGES.length;\n  const stageIndex = normalizedTurn % stageCount;\n  const stage = AUTONOMY_CYCLE_STAGES[stageIndex] ?? AUTONOMY_CYCLE_STAGES[0];\n\n  return {\n    turnIndex: normalizedTurn,\n    cycle: Math.floor(normalizedTurn / stageCount) + 1,\n    phase: stageIndex + 1,\n    stage,\n    nextStage: nextAutonomyCycleStage(stage),\n    stageCount,\n  };\n}\n\nexport function buildAutonomyStageCheckpointGuidance(\n  checkpoint: AutonomyCycleCheckpoint,\n  options?: AutonomyCheckpointOptions,\n): string {\n  const finalReassessment = options?.finalReassessment === true;\n  const enforcedStage: AutonomyCycleStage = finalReassessment ? 'reassessment' : checkpoint.stage;\n  const enforcedNextStage = nextAutonomyCycleStage(enforcedStage);\n  const lines = [\n    '### Autonomy Stage Checkpoint',\n    `- cycle: ${checkpoint.cycle} phase ${checkpoint.phase}/${checkpoint.stageCount}`,\n    `- stage: ${enforcedStage}`,\n    `- requirement: ${AUTONOMY_STAGE_GUIDANCE[enforcedStage]}`,\n  ];\n\n  if (finalReassessment) {\n    lines.push(\n      '- final pass: run a final review/reassessment now before ending this task.',\n      '- confirm objective status, unresolved risks, and recommended next action.',\n    );\n  } else {\n    lines.push(`- next stage: ${enforcedNextStage}`);\n  }\n\n  return lines.join('\\n');\n}\n\nexport function buildCeoAutonomyReport(input: CeoAutonomyReportInput): CeoAutonomyReportPayload {\n  const objectiveCompact = (input.objective || '')\n    .replace(/\\s+/g, ' ')\n    .trim()\n    .slice(0, 140) || '(no objective provided)';\n  const completionLabel = completionStatusLabel(input.completionStatus);\n  const summary = [\n    `CEO autonomy run ${completionLabel}.`,\n    `cycle=${input.cycle} phase=${input.phase} stage=${input.stage}.`,\n    `tool_calls=${input.toolCallCount} across ${input.toolCallTurns} tool turns.`,\n    `objective: ${objectiveCompact}`,\n  ].join(' ');\n\n  return {\n    summary,\n    slug: `ceo-autonomy-${input.completionStatus}`,\n    commandInputs: {\n      turnCount: input.turnCount,\n      cycle: input.cycle,\n      phase: input.phase,\n      stage: input.stage,\n      toolCallCount: input.toolCallCount,\n      toolCallTurns: input.toolCallTurns,\n      completionStatus: input.completionStatus,\n      objectiveReassessmentEnabled: input.objectiveReassessmentEnabled,\n      forcedFinalReassessment: input.forcedFinalReassessment,\n    },\n    steps: [\n      {\n        target: 'autonomy',\n        component: 'cycle',\n        step: 'phase',\n        status: 'ok',\n        message: `cycle=${input.cycle}, phase=${input.phase}/${AUTONOMY_CYCLE_STAGES.length}, stage=${input.stage}, turns=${input.turnCount}`,\n      },\n      {\n        target: 'autonomy',\n        component: 'tools',\n        step: 'usage',\n        status: 'ok',\n        message: `tool calls=${input.toolCallCount}, tool turns=${input.toolCallTurns}`,\n      },\n      {\n        target: 'autonomy',\n        component: 'review',\n        step: 'objective-reassessment',\n        status: input.objectiveReassessmentEnabled ? 'ok' : 'skip',\n        message: input.objectiveReassessmentEnabled\n          ? (input.forcedFinalReassessment\n              ? 'Final reassessment pass enforced before completion.'\n              : 'Objective reassessment enabled; standard completion path used.')\n          : 'Objective reassessment disabled.',\n      },\n      {\n        target: 'autonomy',\n        component: 'completion',\n        step: 'status',\n        status: completionStatusToStepStatus(input.completionStatus),\n        message: `run status: ${completionLabel}`,\n      },\n    ],\n  };\n}\n\nexport function resolveAutonomyLevel(value: unknown): AutonomyLevel {\n  const numeric = typeof value === 'number'\n    ? value\n    : Number.parseInt(String(value ?? ''), 10);\n  if (!Number.isFinite(numeric)) return 2;\n  const clamped = Math.min(5, Math.max(1, Math.floor(numeric)));\n  return clamped as AutonomyLevel;\n}\n\nexport function resolveAutonomyMode(value: unknown): AutonomyMode {\n  const normalized = String(value ?? '').trim().toLowerCase();\n  return normalized === 'ceo' ? 'ceo' : 'execution';\n}\n\nexport function formatAutonomySlider(levelInput: unknown): string {\n  const level = resolveAutonomyLevel(levelInput);\n  const filled = ''.repeat(level);\n  const empty = ''.repeat(5 - level);\n  return `[${filled}${empty}]`;\n}\n\nexport function buildAutonomyProfile(\n  levelInput: unknown,\n  modeInput: unknown,\n): ResolvedAutonomyProfile {\n  const level = resolveAutonomyLevel(levelInput);\n  const mode = resolveAutonomyMode(modeInput);\n  const base = BASE_LEVELS[level];\n\n  if (mode === 'execution') {\n    return {\n      ...base,\n      mode,\n      label: `L${base.level} Autonomous`,\n      requireLiveData: false,\n    };\n  }\n\n  return {\n    ...base,\n    mode: 'ceo',\n    label: `L${base.level} CEO`,\n    // CEO mode favors deliberation and review over aggressive parallelism.\n    maxParallelTools: Math.max(2, base.maxParallelTools - 1),\n    warnAt: Math.max(base.warnAt, Math.round(base.hardStopAt * 0.4)),\n    requireLiveData: true,\n  };\n}\n\nexport function autonomyDurationMinutes(profile: ResolvedAutonomyProfile): number {\n  return Math.round(profile.maxDurationMs / 60_000);\n}\n\nexport function computeAutonomyConfigUpdates(\n  levelInput: unknown,\n  modeInput: unknown,\n): Record<string, unknown> {\n  const profile = buildAutonomyProfile(levelInput, modeInput);\n  const ceoMode = profile.mode === 'ceo';\n  const raw: Record<string, unknown> = {\n    'autonomy.level': profile.level,\n    'autonomy.mode': profile.mode,\n    'autonomy.requireLiveData': ceoMode,\n    'autonomy.reportStyle': ceoMode ? 'executive' : 'standard',\n    defaultMode: profile.defaultMode,\n    'safety.maxParallelTools': profile.maxParallelTools,\n    'safety.compactAt': profile.compactAt,\n    'safety.circuitBreaker.warnAt': profile.warnAt,\n    'safety.circuitBreaker.pauseAt': profile.pauseAt,\n    'safety.circuitBreaker.hardStopAt': profile.hardStopAt,\n    'safety.circuitBreaker.maxDuration': profile.maxDurationMs,\n    'subAgent.maxDepth': profile.subAgentMaxDepth,\n    'subAgent.maxConcurrent': profile.subAgentMaxConcurrent,\n    'subAgent.defaultBudget.maxToolCalls': profile.subAgentBudgetToolCalls,\n    'subAgent.defaultBudget.maxTokens': profile.subAgentBudgetTokens,\n    'subAgent.defaultBudget.timeoutMs': profile.subAgentBudgetTimeoutMs,\n    'permissions.run_command': profile.allowRunCommand ? 'allow' : 'ask',\n    'permissions.spawn_agent': profile.allowDelegation ? 'allow' : 'ask',\n    'permissions.delegate_task': profile.allowDelegation ? 'allow' : 'ask',\n    'permissions.web_search': 'allow',\n    'permissions.web_fetch': 'allow',\n    'policy.gateAllAutonomy': profile.level <= 2,\n    'research.enabled': true,\n    'research.alwaysIncludeDocumentation': ceoMode ? true : undefined,\n    'policy.audit.enabled': ceoMode ? true : undefined,\n  };\n\n  const updates: Record<string, unknown> = {};\n  for (const [key, value] of Object.entries(raw)) {\n    if (value !== undefined) updates[key] = value;\n  }\n  return updates;\n}\n\nfunction withOptionalOverrides(\n  source: Record<string, unknown>,\n  target: Record<string, unknown>,\n): void {\n  for (const [key, value] of Object.entries(source)) {\n    if (value !== undefined) target[key] = value;\n  }\n}\n\nexport function applyAutonomyRuntimeProfile(config: OptaConfig): OptaConfig {\n  if (!config.autonomy.enforceProfile) return config;\n\n  const profile = buildAutonomyProfile(config.autonomy.level, config.autonomy.mode);\n  const ceoMode = profile.mode === 'ceo';\n\n  const permissions = { ...config.permissions };\n  permissions['run_command'] = profile.allowRunCommand ? 'allow' : (permissions['run_command'] ?? 'ask');\n  permissions['spawn_agent'] = profile.allowDelegation ? 'allow' : (permissions['spawn_agent'] ?? 'ask');\n  permissions['delegate_task'] = profile.allowDelegation ? 'allow' : (permissions['delegate_task'] ?? 'ask');\n  permissions['web_search'] = 'allow';\n  permissions['web_fetch'] = 'allow';\n\n  const updatedAutonomy = { ...config.autonomy };\n  const optionalAutonomy: Record<string, unknown> = {\n    requireLiveData: ceoMode ? true : updatedAutonomy.requireLiveData,\n    reportStyle: ceoMode ? 'executive' : updatedAutonomy.reportStyle,\n  };\n  withOptionalOverrides(optionalAutonomy, updatedAutonomy as unknown as Record<string, unknown>);\n\n  return {\n    ...config,\n    autonomy: updatedAutonomy,\n    defaultMode: profile.defaultMode,\n    permissions,\n    research: {\n      ...config.research,\n      enabled: true,\n      alwaysIncludeDocumentation: ceoMode ? true : config.research.alwaysIncludeDocumentation,\n    },\n    policy: {\n      ...config.policy,\n      gateAllAutonomy: profile.level <= 2,\n      audit: {\n        ...config.policy.audit,\n        enabled: ceoMode ? true : config.policy.audit.enabled,\n      },\n    },\n    safety: {\n      ...config.safety,\n      maxParallelTools: profile.maxParallelTools,\n      compactAt: profile.compactAt,\n      circuitBreaker: {\n        ...config.safety.circuitBreaker,\n        warnAt: profile.warnAt,\n        pauseAt: profile.pauseAt,\n        hardStopAt: profile.hardStopAt,\n        maxDuration: profile.maxDurationMs,\n      },\n    },\n    subAgent: {\n      ...config.subAgent,\n      maxDepth: profile.subAgentMaxDepth,\n      maxConcurrent: profile.subAgentMaxConcurrent,\n      defaultBudget: {\n        ...config.subAgent.defaultBudget,\n        maxToolCalls: profile.subAgentBudgetToolCalls,\n        maxTokens: profile.subAgentBudgetTokens,\n        timeoutMs: profile.subAgentBudgetTimeoutMs,\n      },\n    },\n  };\n}\n\nexport function buildAutonomyPromptBlock(config: OptaConfig): string {\n  const profile = buildAutonomyProfile(config.autonomy.level, config.autonomy.mode);\n  const minutes = autonomyDurationMinutes(profile);\n  const slider = formatAutonomySlider(profile.level);\n  const stageChain = AUTONOMY_CYCLE_STAGES.join(' -> ');\n\n  const lines = [\n    '### Autonomous Execution Profile',\n    `- profile: ${profile.label} ${slider}`,\n    `- max autonomous runtime per task: ${minutes} minutes`,\n    `- tool-call envelope: warn=${profile.warnAt}, hard-stop=${profile.hardStopAt}`,\n    `- enforced cycle stages: ${stageChain}`,\n    '- execution loop:',\n    '  1) Research current facts and constraints.',\n    '  2) Analyze root causes and design options.',\n    '  3) Create a concrete plan.',\n    '  4) Break the plan into sub-plans for immediate execution.',\n    '  5) Execute changes and run verification.',\n    '  6) Review outputs for quality and regressions.',\n    '  7) Reassess objective completion, then start the next cycle if needed.',\n    '- be proactive, precise, and explicit about assumptions.',\n  ];\n\n  if (profile.level >= 5) {\n    lines.push(\n      '- level 5 directive: sustain autonomous cycles for 30-60+ minutes when needed, using staged checkpoints and self-review before final output.',\n    );\n  }\n\n  if (profile.mode === 'ceo') {\n    lines.push(\n      '- CEO mode directives:',\n      '  - ask clarifying questions at key decision gates instead of guessing business intent.',\n      '  - verify time-sensitive claims with live data using web_search/web_fetch.',\n      '  - keep a work log of changes, decisions, and results.',\n      '  - propose long-term, permanent solutions and organization improvements.',\n      '  - finish with an executive summary + implementation report.',\n    );\n  }\n\n  return lines.join('\\n');\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/core/background.ts","messages":[{"ruleId":"@typescript-eslint/require-await","severity":1,"message":"Async method 'start' has no 'await' expression.","line":125,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":125,"endColumn":14,"suggestions":[{"messageId":"removeAsync","fix":{"range":[2957,3066],"text":"start(\n    command: string,\n    opts?: { timeout?: number; label?: string }\n  ): ProcessHandle"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":162,"column":5,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":162,"endColumn":18,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[4052,4053],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":1,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":162,"column":5,"nodeType":"TSNonNullExpression","messageId":"unnecessaryAssertion","endLine":162,"endColumn":18,"fix":{"range":[4052,4053],"text":""}},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":163,"column":5,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":163,"endColumn":18,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[4139,4140],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":1,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":163,"column":5,"nodeType":"TSNonNullExpression","messageId":"unnecessaryAssertion","endLine":163,"endColumn":18,"fix":{"range":[4139,4140],"text":""}},{"ruleId":"@typescript-eslint/require-await","severity":1,"message":"Async method 'kill' has no 'await' expression.","line":259,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":259,"endColumn":13,"suggestions":[{"messageId":"removeAsync","fix":{"range":[6992,7068],"text":"kill(id: string, signal: NodeJS.Signals = 'SIGTERM'): boolean"},"desc":"Remove 'async'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { spawn, type ChildProcess } from 'node:child_process';\nimport { nanoid } from 'nanoid';\nimport { debug } from './debug.js';\n\n// --- CircularBuffer ---\n\nexport class CircularBuffer {\n  private buffer: string = '';\n  private maxSize: number;\n  private _totalBytesWritten = 0;\n  private _lineCount = 0;\n\n  constructor(maxSize: number) {\n    this.maxSize = maxSize;\n  }\n\n  get totalBytesWritten(): number {\n    return this._totalBytesWritten;\n  }\n\n  get currentOffset(): number {\n    return this._lineCount;\n  }\n\n  append(data: string): void {\n    this.buffer += data;\n    this._totalBytesWritten += data.length;\n\n    // Count new newlines\n    for (let i = this.buffer.length - data.length; i < this.buffer.length; i++) {\n      if (this.buffer[i] === '\\n') this._lineCount++;\n    }\n\n    // Evict from front if over budget\n    if (this.buffer.length > this.maxSize) {\n      const excess = this.buffer.length - this.maxSize;\n      const cutAt = this.buffer.indexOf('\\n', excess);\n      if (cutAt !== -1) {\n        this.buffer = this.buffer.slice(cutAt + 1);\n      } else {\n        // No newline found beyond excess  clear everything\n        this.buffer = '';\n      }\n    }\n  }\n\n  getLines(count: number): string[] {\n    const lines = this.buffer.split('\\n').filter((l) => l.length > 0);\n    return lines.slice(-count);\n  }\n\n  getLinesSince(offset: number): string[] {\n    const lines = this.buffer.split('\\n').filter((l) => l.length > 0);\n    const total = lines.length;\n    const newCount = this._lineCount - offset;\n    if (newCount <= 0) return [];\n    return lines.slice(Math.max(0, total - newCount));\n  }\n}\n\n// --- Types ---\n\nexport interface ProcessHandle {\n  id: string;\n  pid: number;\n  command: string;\n}\n\nexport type ProcessState = 'running' | 'completed' | 'failed' | 'killed' | 'timeout';\n\nexport interface ProcessStatus {\n  id: string;\n  pid: number;\n  command: string;\n  label?: string;\n  state: ProcessState;\n  exitCode: number | null;\n  startedAt: number;\n  endedAt: number | null;\n  runtimeMs: number;\n}\n\nexport interface OutputSlice {\n  stdout: string;\n  stderr: string;\n  truncated: boolean;\n}\n\ninterface ManagedProcess {\n  id: string;\n  pid: number;\n  command: string;\n  label?: string;\n  state: ProcessState;\n  exitCode: number | null;\n  startedAt: number;\n  endedAt: number | null;\n  stdout: CircularBuffer;\n  stderr: CircularBuffer;\n  lastReadOffset: { stdout: number; stderr: number };\n  child: ChildProcess;\n  timeoutHandle?: ReturnType<typeof setTimeout>;\n}\n\nexport interface ProcessManagerOptions {\n  maxConcurrent: number;\n  defaultTimeout: number;\n  maxBufferSize: number;\n}\n\n// --- ProcessManager ---\n\nexport class ProcessManager {\n  private processes = new Map<string, ManagedProcess>();\n  private opts: ProcessManagerOptions;\n\n  constructor(opts: ProcessManagerOptions) {\n    this.opts = opts;\n  }\n\n  get activeCount(): number {\n    return [...this.processes.values()].filter((p) => p.state === 'running').length;\n  }\n\n  async start(\n    command: string,\n    opts?: { timeout?: number; label?: string }\n  ): Promise<ProcessHandle> {\n    if (this.activeCount >= this.opts.maxConcurrent) {\n      throw new Error(\n        `Max concurrent processes (${this.opts.maxConcurrent}) reached. Kill a process first.`\n      );\n    }\n\n    const id = nanoid(8);\n    const timeout = opts?.timeout ?? this.opts.defaultTimeout;\n    const child = spawn('sh', ['-c', command], {\n      cwd: process.cwd(),\n      stdio: ['ignore', 'pipe', 'pipe'],\n      detached: false,\n    });\n\n    if (!child.pid) {\n      throw new Error(`Background process: Failed to spawn \"${command}\". Verify the command exists and is executable.`);\n    }\n\n    const proc: ManagedProcess = {\n      id,\n      pid: child.pid,\n      command,\n      label: opts?.label,\n      state: 'running',\n      exitCode: null,\n      startedAt: Date.now(),\n      endedAt: null,\n      stdout: new CircularBuffer(this.opts.maxBufferSize),\n      stderr: new CircularBuffer(this.opts.maxBufferSize),\n      lastReadOffset: { stdout: 0, stderr: 0 },\n      child,\n    };\n\n    child.stdout!.on('data', (chunk: Buffer) => proc.stdout.append(chunk.toString()));\n    child.stderr!.on('data', (chunk: Buffer) => proc.stderr.append(chunk.toString()));\n\n    child.on('error', (err) => {\n      if (proc.state === 'running') {\n        proc.state = 'failed';\n      }\n      proc.endedAt = Date.now();\n      if (proc.timeoutHandle) clearTimeout(proc.timeoutHandle);\n      debug(`bg[${id}] spawn error: ${err.message}`);\n    });\n\n    child.on('close', (code, signal) => {\n      if (proc.state === 'running') {\n        proc.state = signal ? 'killed' : code === 0 ? 'completed' : 'failed';\n      }\n      proc.exitCode = code;\n      proc.endedAt = Date.now();\n      if (proc.timeoutHandle) clearTimeout(proc.timeoutHandle);\n      debug(`bg[${id}] exited: ${proc.state} (code=${code}, signal=${signal})`);\n    });\n\n    if (timeout > 0) {\n      proc.timeoutHandle = setTimeout(() => {\n        if (proc.state === 'running') {\n          proc.state = 'timeout';\n          child.kill('SIGTERM');\n          setTimeout(() => {\n            if (!child.killed) child.kill('SIGKILL');\n          }, 3000);\n        }\n      }, timeout);\n    }\n\n    this.processes.set(id, proc);\n    debug(`bg[${id}] started: pid=${child.pid} cmd=\"${command}\"`);\n    return { id, pid: child.pid, command };\n  }\n\n  status(id?: string): ProcessStatus | ProcessStatus[] {\n    if (!id) {\n      return [...this.processes.values()].map((p) => this.toStatus(p));\n    }\n    const proc = this.processes.get(id);\n    if (!proc) throw new Error(`Process \"${id}\" not found`);\n    return this.toStatus(proc);\n  }\n\n  private toStatus(p: ManagedProcess): ProcessStatus {\n    return {\n      id: p.id,\n      pid: p.pid,\n      command: p.command,\n      label: p.label,\n      state: p.state,\n      exitCode: p.exitCode,\n      startedAt: p.startedAt,\n      endedAt: p.endedAt,\n      runtimeMs: (p.endedAt ?? Date.now()) - p.startedAt,\n    };\n  }\n\n  output(\n    id: string,\n    opts?: {\n      lines?: number;\n      stream?: 'stdout' | 'stderr' | 'both';\n      sinceLastRead?: boolean;\n    }\n  ): OutputSlice {\n    const proc = this.processes.get(id);\n    if (!proc) throw new Error(`Process \"${id}\" not found`);\n\n    const lines = opts?.lines ?? 50;\n    const stream = opts?.stream ?? 'both';\n    const sinceLastRead = opts?.sinceLastRead ?? true;\n\n    let stdout = '';\n    let stderr = '';\n\n    if (stream === 'stdout' || stream === 'both') {\n      stdout = sinceLastRead\n        ? proc.stdout.getLinesSince(proc.lastReadOffset.stdout).join('\\n')\n        : proc.stdout.getLines(lines).join('\\n');\n      proc.lastReadOffset.stdout = proc.stdout.currentOffset;\n    }\n\n    if (stream === 'stderr' || stream === 'both') {\n      stderr = sinceLastRead\n        ? proc.stderr.getLinesSince(proc.lastReadOffset.stderr).join('\\n')\n        : proc.stderr.getLines(lines).join('\\n');\n      proc.lastReadOffset.stderr = proc.stderr.currentOffset;\n    }\n\n    return { stdout, stderr, truncated: false };\n  }\n\n  async kill(id: string, signal: NodeJS.Signals = 'SIGTERM'): Promise<boolean> {\n    const proc = this.processes.get(id);\n    if (!proc) throw new Error(`Process \"${id}\" not found`);\n    if (proc.state !== 'running') return false;\n\n    proc.child.kill(signal);\n    proc.state = 'killed';\n\n    // Force-kill after 5s if still alive\n    if (signal !== 'SIGKILL') {\n      setTimeout(() => {\n        if (!proc.child.killed) {\n          proc.child.kill('SIGKILL');\n        }\n      }, 5000);\n    }\n\n    return true;\n  }\n\n  async killAll(): Promise<void> {\n    const running = [...this.processes.values()].filter((p) => p.state === 'running');\n    await Promise.all(running.map((p) => this.kill(p.id)));\n  }\n\n  async cleanup(): Promise<void> {\n    await this.killAll();\n    this.processes.clear();\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/core/browser-policy-config.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":29,"column":62,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":29,"endColumn":64,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[903,905],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":31,"column":64,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":31,"endColumn":66,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1059,1061],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":47,"column":47,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":47,"endColumn":49,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1581,1583],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":50,"column":37,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":50,"endColumn":39,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1793,1795],"text":"."},"desc":"Remove unnecessary optional chain"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { OptaConfig } from './config.js';\n\nexport interface ResolvedBrowserPolicyConfig {\n  requireApprovalForHighRisk?: boolean;\n  allowedHosts?: string[];\n  blockedOrigins?: string[];\n  sensitiveActions?: string[];\n}\n\nfunction normalizeHostList(values: string[] | undefined): string[] {\n  if (!values || values.length === 0) return [];\n  const normalized: string[] = [];\n  for (const value of values) {\n    const candidate = value.trim().toLowerCase();\n    if (!candidate) continue;\n    normalized.push(candidate);\n  }\n  return normalized;\n}\n\nfunction isWildcardOnlyAllowlist(values: string[]): boolean {\n  return values.length === 1 && values[0] === '*';\n}\n\nexport function resolveBrowserPolicyConfig(config: OptaConfig | null | undefined): ResolvedBrowserPolicyConfig {\n  const browser = config?.browser;\n  if (!browser) return {};\n\n  const policyAllowedHosts = normalizeHostList(browser.policy?.allowedHosts);\n  const globalAllowedHosts = normalizeHostList(browser.globalAllowedHosts);\n  const policyBlockedOrigins = normalizeHostList(browser.policy?.blockedOrigins);\n  const globalBlockedOrigins = normalizeHostList(browser.blockedOrigins);\n\n  const useGlobalAllowedHosts = (\n    globalAllowedHosts.length > 0\n    && (policyAllowedHosts.length === 0 || isWildcardOnlyAllowlist(policyAllowedHosts))\n  );\n\n  const allowedHosts = useGlobalAllowedHosts\n    ? globalAllowedHosts\n    : policyAllowedHosts;\n  const blockedOrigins = policyBlockedOrigins.length > 0\n    ? policyBlockedOrigins\n    : globalBlockedOrigins;\n\n  return {\n    requireApprovalForHighRisk: browser.policy?.requireApprovalForHighRisk,\n    allowedHosts: allowedHosts.length > 0 ? allowedHosts : undefined,\n    blockedOrigins: blockedOrigins.length > 0 ? blockedOrigins : undefined,\n    sensitiveActions: browser.policy?.sensitiveActions,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/core/config.ts","messages":[{"ruleId":"@typescript-eslint/no-dynamic-delete","severity":1,"message":"Do not delete dynamically computed property keys.","line":607,"column":16,"nodeType":"TSAsExpression","messageId":"dynamicDelete","endLine":607,"endColumn":33},{"ruleId":"@typescript-eslint/no-dynamic-delete","severity":1,"message":"Do not delete dynamically computed property keys.","line":617,"column":16,"nodeType":"TSAsExpression","messageId":"dynamicDelete","endLine":617,"endColumn":30},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":1,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":662,"column":6,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":662,"endColumn":36,"fix":{"range":[22405,22432],"text":""}},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":1,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":669,"column":6,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":669,"endColumn":36,"fix":{"range":[22670,22697],"text":""}},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":1,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":812,"column":22,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":812,"endColumn":38,"fix":{"range":[27055,27065],"text":""}},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":1,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":848,"column":11,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":848,"endColumn":43,"fix":{"range":[28043,28053],"text":""}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":4,"source":"import { z } from 'zod';\nimport { normalizeConfiguredModelId } from '../lmx/model-lifecycle.js';\nimport { DEFAULT_BROWSER_ADAPTATION_CONFIG } from '../browser/adaptation.js';\n\nconst ToolPermission = z.enum(['allow', 'ask', 'deny']);\n\nconst McpStdioServerSchema = z.object({\n  transport: z.literal('stdio'),\n  command: z.string(),\n  args: z.array(z.string()).default([]),\n  env: z.record(z.string(), z.string()).default({}),\n});\n\nconst McpHttpServerSchema = z.object({\n  transport: z.literal('http'),\n  url: z.string().url(),\n});\n\nconst McpServerConfigSchema = z.discriminatedUnion('transport', [\n  McpStdioServerSchema,\n  McpHttpServerSchema,\n]);\n\nexport { McpServerConfigSchema };\n\nconst ResearchProviderNameSchema = z.enum(['auto', 'tavily', 'gemini', 'exa', 'brave', 'groq']);\nconst AutonomyModeSchema = z.enum(['execution', 'ceo']);\nconst WorkflowModeSchema = z.enum(['normal', 'plan', 'research', 'review']);\nconst ResponseIntentToneSchema = z.enum(['concise', 'technical', 'product']);\n\nconst DEFAULT_TUI_TRIGGER_MODES: Array<{\n  word: string;\n  modeHint?: 'normal' | 'plan' | 'research' | 'review';\n  priority: number;\n  capabilities: string[];\n  skills: string[];\n}> = [\n  {\n    word: 'review',\n    modeHint: 'review',\n    priority: 400,\n    capabilities: ['review'],\n    skills: ['ai26-3b-code-quality-code-reviewer', 'ai26-3b-code-quality-requesting-code-review'],\n  },\n  {\n    word: 'plan',\n    modeHint: 'plan',\n    priority: 300,\n    capabilities: ['planning'],\n    skills: ['ai26-3c-productivity-writing-plans'],\n  },\n  {\n    word: 'research',\n    modeHint: 'research',\n    priority: 200,\n    capabilities: ['research'],\n    skills: ['ai26-3i-ai-research-perp'],\n  },\n  {\n    word: 'browser',\n    priority: 100,\n    capabilities: ['browser'],\n    skills: ['playwright'],\n  },\n];\n\nconst TuiTriggerModeSchema = z.object({\n  word: z.string().min(1),\n  modeHint: WorkflowModeSchema.optional(),\n  priority: z.number().int().min(0).max(1000).default(0),\n  capabilities: z.array(z.string()).default([]),\n  skills: z.array(z.string()).default([]),\n});\n\nconst TuiSkillRuntimeSchema = z.object({\n  dynamicLoading: z.boolean().default(true),\n  unloadInactive: z.boolean().default(true),\n  ttlMinutes: z.number().min(1).max(1440).default(30),\n  maxActiveSkills: z.number().int().min(1).max(500).default(24),\n});\n\nconst ResearchProviderConfigSchema = z.object({\n  enabled: z.boolean().default(false),\n  apiKey: z.string().default(''),\n  timeoutMs: z.number().min(1000).max(120_000).default(20_000),\n});\n\nexport const OptaConfigSchema = z.object({\n  connection: z\n    .object({\n      host: z.string().default('localhost'),\n      fallbackHosts: z.array(z.string()).default([]),\n      port: z.number().default(1234),\n      protocol: z.literal('http').default('http'),\n      adminKey: z.string().optional(),\n      apiKey: z.string().optional(),\n      ssh: z\n        .object({\n          user: z.string().default('opta'),\n          identityFile: z.string().default('~/.ssh/id_ed25519'),\n          connectTimeoutSec: z.number().min(3).max(120).default(20),\n          lmxPath: z.string().default('/Users/Shared/312/Opta/1-Apps/1M-Opta-LMX'),\n          pythonPath: z.string().default('/Users/opta/.mlx-env/bin/python'),\n        })\n        .default({}),\n      inferenceTimeout: z.number().min(5000).max(600_000).default(120_000),\n      retry: z\n        .object({\n          maxRetries: z.number().min(0).max(10).default(3),\n          backoffMs: z.number().min(100).default(1000),\n          backoffMultiplier: z.number().min(1).default(2),\n        })\n        .default({}),\n    })\n    .default({}),\n  model: z\n    .object({\n      default: z.string().default(''),\n      contextLimit: z.number().default(32768),\n      favourites: z.array(z.string()).default([]),\n      /** User-defined groups. When absent, DEFAULT_GROUPS from model-catalog are used. */\n      groups: z\n        .array(\n          z.object({\n            name: z.string().min(1),\n            label: z.string().min(1),\n            color: z.string().optional(),\n            patterns: z.array(z.string()).default([]),\n          }),\n        )\n        .optional(),\n    })\n    .default({}),\n  defaultMode: z.enum(['safe', 'auto', 'plan', 'review', 'research', 'dangerous', 'ci']).default('safe'),\n  autonomy: z\n    .object({\n      level: z.number().int().min(1).max(5).default(2),\n      mode: AutonomyModeSchema.default('execution'),\n      enforceProfile: z.boolean().default(true),\n      objectiveReassessment: z.boolean().default(true),\n      requireLiveData: z.boolean().default(false),\n      reportStyle: z.enum(['standard', 'executive']).default('standard'),\n      headlessContinue: z.boolean().default(false),\n    })\n    .default({}),\n  permissions: z\n    .record(z.string(), ToolPermission)\n    .default({\n      // File operations\n      read_file: 'allow',\n      list_dir: 'allow',\n      search_files: 'allow',\n      find_files: 'allow',\n      edit_file: 'ask',\n      write_file: 'ask',\n      multi_edit: 'ask',\n      delete_file: 'ask',\n      // Shell\n      run_command: 'ask',\n      // User interaction\n      ask_user: 'allow',\n      // Project docs\n      read_project_docs: 'allow',\n      // Web\n      web_search: 'allow',\n      web_fetch: 'allow',\n      // Research\n      research_query: 'allow',\n      research_health: 'allow',\n      // Browser automation\n      browser_open: 'ask',\n      browser_navigate: 'ask',\n      browser_click: 'ask',\n      browser_type: 'ask',\n      browser_snapshot: 'ask',\n      browser_screenshot: 'ask',\n      browser_close: 'ask',\n      // Learning\n      learning_log: 'allow',\n      learning_summary: 'allow',\n      learning_retrieve: 'allow',\n      // Memory\n      save_memory: 'allow',\n      // Background processes\n      bg_start: 'ask',\n      bg_status: 'allow',\n      bg_output: 'allow',\n      bg_kill: 'ask',\n      // LSP\n      lsp_definition: 'allow',\n      lsp_references: 'allow',\n      lsp_hover: 'allow',\n      lsp_symbols: 'allow',\n      lsp_document_symbols: 'allow',\n      lsp_rename: 'ask',\n      // Sub-agents\n      spawn_agent: 'ask',\n      delegate_task: 'ask',\n      // Git\n      git_status: 'allow',\n      git_diff: 'allow',\n      git_log: 'allow',\n      git_commit: 'ask',\n    }),\n  safety: z\n    .object({\n      maxToolCalls: z.number().default(30), // backward compat\n      maxParallelTools: z.number().min(1).max(10).default(5),\n      compactAt: z.number().default(0.7),\n      circuitBreaker: z\n        .object({\n          warnAt: z.number().default(20),\n          pauseAt: z.number().default(40),\n          hardStopAt: z.number().default(100),\n          perToolLimit: z.number().default(0),\n          maxDuration: z.number().default(0),\n          silentBehavior: z.enum(['stop', 'warn-and-continue', 'error']).default('stop'),\n        })\n        .default({}),\n    })\n    .default({}),\n  git: z\n    .object({\n      autoCommit: z.boolean().default(true),\n      checkpoints: z.boolean().default(true),\n    })\n    .default({}),\n  journal: z\n    .object({\n      enabled: z.boolean().default(true),\n      sessionLogsDir: z.string().default('12-Session-Logs'),\n      updateLogsDir: z.string().default('updates'),\n      author: z.string().default(process.env['USER'] ?? process.env['USERNAME'] ?? 'unknown'),\n      timezone: z.string().default('local'),\n    })\n    .default({}),\n  mcp: z\n    .object({\n      servers: z.record(z.string(), McpServerConfigSchema).default({}),\n    })\n    .default({}),\n  search: z\n    .object({\n      searxngUrl: z.string().default('http://localhost:8081'),\n    })\n    .default({}),\n  research: z\n    .object({\n      enabled: z.boolean().default(true),\n      defaultProvider: ResearchProviderNameSchema.default('auto'),\n      alwaysIncludeDocumentation: z.boolean().default(true),\n      maxResults: z.number().min(1).max(20).default(8),\n      providers: z\n        .object({\n          tavily: ResearchProviderConfigSchema.default({}),\n          gemini: ResearchProviderConfigSchema.default({}),\n          exa: ResearchProviderConfigSchema.default({}),\n          brave: ResearchProviderConfigSchema.default({}),\n          groq: ResearchProviderConfigSchema.default({}),\n        })\n        .default({}),\n    })\n    .default({}),\n  browser: z\n    .object({\n      enabled: z.boolean().default(false),\n      mode: z.enum(['isolated', 'attach']).default('isolated'),\n      autoInvoke: z.boolean().default(false),\n      screenshotPolicy: z.enum(['on-demand', 'always', 'disabled']).default('on-demand'),\n      globalAllowedHosts: z.array(z.string()).default([]),\n      blockedOrigins: z.array(z.string()).default([]),\n      runtime: z\n        .object({\n          enabled: z.boolean().default(true),\n          persistSessions: z.boolean().default(true),\n          persistProfileContinuity: z.boolean().default(false),\n          maxSessions: z.number().min(1).max(20).default(3),\n          profileRetentionDays: z.number().min(1).max(3650).default(30),\n          maxPersistedProfiles: z.number().min(1).max(5000).default(200),\n          profilePruneIntervalHours: z.number().min(1).max(720).default(24),\n          runCorpus: z\n            .object({\n              enabled: z.boolean().default(true),\n              windowHours: z.number().min(1).max(720).default(168),\n            })\n            .default({}),\n        })\n        .default({}),\n      policy: z\n        .object({\n          requireApprovalForHighRisk: z.boolean().default(true),\n          allowedHosts: z.array(z.string()).default(['*']),\n          blockedOrigins: z.array(z.string()).default([]),\n          sensitiveActions: z\n            .array(z.string())\n            .default(['auth_submit', 'post', 'checkout', 'delete']),\n        })\n        .default({}),\n      adaptation: z\n        .object({\n          enabled: z.boolean().default(DEFAULT_BROWSER_ADAPTATION_CONFIG.enabled),\n          minAssessedSessions: z.number().min(1).max(5000).default(DEFAULT_BROWSER_ADAPTATION_CONFIG.minAssessedSessions),\n          regressionPressureThreshold: z.number().min(0).max(1).default(DEFAULT_BROWSER_ADAPTATION_CONFIG.regressionPressureThreshold),\n          meanRegressionScoreThreshold: z.number().min(0).max(1).default(DEFAULT_BROWSER_ADAPTATION_CONFIG.meanRegressionScoreThreshold),\n          failureRateThreshold: z.number().min(0).max(1).default(DEFAULT_BROWSER_ADAPTATION_CONFIG.failureRateThreshold),\n          investigateWeight: z.number().min(0).max(1).default(DEFAULT_BROWSER_ADAPTATION_CONFIG.investigateWeight),\n          intentRoutePenalty: z.number().min(0).max(20).default(DEFAULT_BROWSER_ADAPTATION_CONFIG.intentRoutePenalty),\n        })\n        .default({}),\n      artifacts: z\n        .object({\n          enabled: z.boolean().default(true),\n          screenshots: z.enum(['on_step', 'manual', 'off']).default('on_step'),\n          trace: z.boolean().default(true),\n          retention: z\n            .object({\n              enabled: z.boolean().default(false),\n              retentionDays: z.number().min(1).max(3650).default(30),\n              maxPersistedSessions: z.number().min(1).max(5000).default(200),\n              pruneIntervalHours: z.number().min(1).max(720).default(24),\n            })\n            .default({}),\n        })\n        .default({}),\n      mcp: z\n        .object({\n          enabled: z.boolean().default(true),\n          command: z.string().default('npx'),\n          package: z.string().default('@playwright/mcp@latest'),\n        })\n        .default({}),\n      attach: z\n        .object({\n          enabled: z.boolean().default(false),\n          wsEndpoint: z.string().default(''),\n          requireApproval: z.boolean().default(true),\n        })\n        .default({}),\n    })\n    .default({}),\n  background: z\n    .object({\n      maxConcurrent: z.number().min(1).max(20).default(5),\n      defaultTimeout: z.number().min(0).default(300_000), // 5 min\n      maxBufferSize: z.number().min(1024).default(1_048_576), // 1MB per stream\n      killOnSessionEnd: z.boolean().default(true),\n    })\n    .default({}),\n  hooks: z\n    .array(\n      z.object({\n        event: z.enum([\n          'session.start',\n          'session.end',\n          'tool.pre',\n          'tool.post',\n          'compact',\n          'error',\n        ]),\n        command: z.string(),\n        matcher: z.string().optional(),\n        timeout: z.number().min(100).max(60000).optional(),\n        background: z.boolean().optional(),\n      }),\n    )\n    .default([]),\n  lsp: z\n    .object({\n      enabled: z.boolean().default(true),\n      servers: z\n        .record(\n          z.string(),\n          z.object({\n            command: z.string(),\n            args: z.array(z.string()).default([]),\n            initializationOptions: z.record(z.string(), z.unknown()).default({}),\n          })\n        )\n        .default({}),\n      timeout: z.number().default(10000),\n    })\n    .default({}),\n  subAgent: z\n    .object({\n      enabled: z.boolean().default(true),\n      maxDepth: z.number().default(2),\n      maxConcurrent: z.number().default(3),\n      defaultBudget: z\n        .object({\n          maxToolCalls: z.number().default(15),\n          maxTokens: z.number().default(8192),\n          timeoutMs: z.number().default(60_000),\n        })\n        .default({}),\n      inheritMode: z.boolean().default(true),\n    })\n    .default({}),\n  learning: z\n    .object({\n      enabled: z.boolean().default(true),\n      captureLevel: z.enum(['exhaustive', 'balanced', 'lean']).default('exhaustive'),\n      includeUnverified: z.boolean().default(true),\n      ledgerPath: z.string().default('.opta/learning/ledger.jsonl'),\n      summaryDir: z.string().default('.opta/learning/summaries'),\n      governor: z\n        .object({\n          // Keep legacy \"combined\" accepted for backward compatibility, but\n          // use \"hybrid\" as the canonical default mode.\n          mode: z.enum(['hybrid', 'combined']).default('hybrid'),\n          autoCalibrate: z.boolean().default(true),\n          allowAutoDownshift: z.boolean().default(true),\n          restoreHysteresisSec: z.number().min(5).max(3600).default(120),\n          thresholds: z\n            .object({\n              cpuHighPct: z.number().min(1).max(100).default(82),\n              memoryHighPct: z.number().min(1).max(100).default(85),\n              eventLoopLagMs: z.number().min(1).max(5000).default(220),\n              diskWriteKbPerSec: z.number().min(1).max(10_000_000).default(50_000),\n            })\n            .default({}),\n        })\n        .default({}),\n    })\n    .default({}),\n  policy: z\n    .object({\n      enabled: z.boolean().default(true),\n      mode: z.enum(['full']).default('full'),\n      gateAllAutonomy: z.boolean().default(true),\n      failureMode: z.enum(['closed', 'degraded-safe', 'open']).default('closed'),\n      requireApprovalForModeSwitch: z.boolean().default(true),\n      audit: z\n        .object({\n          enabled: z.boolean().default(true),\n          path: z.string().default('.opta/policy/audit.jsonl'),\n          redactSecrets: z.boolean().default(true),\n        })\n        .default({}),\n    })\n    .default({}),\n  context: z\n    .object({\n      exportMap: z.boolean().default(true),\n    })\n    .default({}),\n  provider: z\n    .object({\n      active: z.enum(['lmx', 'anthropic']).default('lmx'),\n      fallbackOnFailure: z.boolean().default(false),\n      anthropic: z\n        .object({\n          apiKey: z.string().default(''),\n          model: z.string().default('claude-sonnet-4-5-20250929'),\n        })\n        .default({}),\n    })\n    .default({}),\n  insights: z\n    .object({\n      enabled: z.boolean().default(true),\n    })\n    .default({}),\n  tui: z\n    .object({\n      default: z.boolean().default(false),\n      triggerModes: z.array(TuiTriggerModeSchema).default(DEFAULT_TUI_TRIGGER_MODES),\n      skillRuntime: TuiSkillRuntimeSchema.default({}),\n      responseIntentTone: ResponseIntentToneSchema.default('technical'),\n    })\n    .default({}),\n});\n\nexport type OptaConfig = z.infer<typeof OptaConfigSchema>;\n\nexport const DEFAULT_CONFIG: OptaConfig = OptaConfigSchema.parse({});\n\nconst LOAD_CONFIG_CACHE_TTL_MS = 1_000;\n\ninterface LoadConfigCacheEntry {\n  key: string;\n  expiresAt: number;\n  value: OptaConfig;\n}\n\nlet loadConfigCache: LoadConfigCacheEntry | null = null;\n\nfunction cloneConfig(config: OptaConfig): OptaConfig {\n  return typeof structuredClone === 'function'\n    ? structuredClone(config)\n    : JSON.parse(JSON.stringify(config)) as OptaConfig;\n}\n\nfunction stableStringify(value: unknown): string {\n  if (Array.isArray(value)) {\n    return `[${value.map((item) => stableStringify(item)).join(',')}]`;\n  }\n  if (value && typeof value === 'object') {\n    const entries = Object.entries(value as Record<string, unknown>)\n      .sort(([a], [b]) => a.localeCompare(b))\n      .map(([k, v]) => `${JSON.stringify(k)}:${stableStringify(v)}`);\n    return `{${entries.join(',')}}`;\n  }\n  return JSON.stringify(value);\n}\n\nfunction buildLoadConfigCacheKey(overrides?: Record<string, unknown>): string {\n  const envKey = [\n    process.env['OPTA_HOST'] ?? '',\n    process.env['OPTA_PORT'] ?? '',\n    process.env['OPTA_ADMIN_KEY'] ?? '',\n    process.env['OPTA_API_KEY'] ?? '',\n    process.env['OPTA_MODEL'] ?? '',\n  ].join('|');\n  const overrideKey = stableStringify(overrides ?? {});\n  return `${envKey}::${overrideKey}`;\n}\n\nexport function clearLoadConfigCache(): void {\n  loadConfigCache = null;\n}\n\n/** Canonical permission defaults derived from the Zod schema. Single source of truth. */\nexport const DEFAULT_PERMISSIONS: Record<string, string> = DEFAULT_CONFIG.permissions;\n\n// ---------------------------------------------------------------------------\n// Part D: Zod error formatting\n// ---------------------------------------------------------------------------\n\n/**\n * Convert Zod validation issues into human-readable one-liners with fix suggestions.\n *\n * Maps common Zod error codes to plain-language descriptions and appends a\n * `Try: opta config set <path> <example>` hint where possible.\n */\nexport function formatZodErrors(error: z.ZodError): string[] {\n  return error.issues.map((issue) => {\n    const path = issue.path.join('.');\n    let description: string;\n\n    switch (issue.code) {\n      case 'invalid_type':\n        description = `Expected ${issue.expected} but got ${issue.received}`;\n        break;\n      case 'too_small': {\n        const minIssue = issue as z.ZodTooSmallIssue;\n        description = `Must be at least ${minIssue.minimum}`;\n        break;\n      }\n      case 'too_big': {\n        const maxIssue = issue as z.ZodTooBigIssue;\n        description = `Must be at most ${maxIssue.maximum}`;\n        break;\n      }\n      case 'invalid_enum_value': {\n        const enumIssue = issue as z.ZodInvalidEnumValueIssue;\n        description = `Must be one of: ${enumIssue.options.join(', ')}`;\n        break;\n      }\n      default:\n        description = issue.message;\n    }\n\n    // Build a helpful suggestion with the config path\n    const suggestion = path\n      ? `Try: opta config set ${path} <valid-value>`\n      : 'Check your config file for syntax errors';\n\n    return `Config warning: ${path || '(root)'} ${description}. ${suggestion}`;\n  });\n}\n\n// ---------------------------------------------------------------------------\n// Internal: strip broken keys from a raw config object\n// ---------------------------------------------------------------------------\n\n/**\n * Given a raw config object and a list of Zod issues, delete the top-level\n * keys that contain broken values so the schema can fill them with defaults.\n * Returns a shallow clone  the original object is not mutated.\n */\nfunction stripBrokenKeys(\n  raw: Record<string, unknown>,\n  issues: z.ZodIssue[],\n): Record<string, unknown> {\n  const clone = { ...raw };\n  for (const issue of issues) {\n    const topKey = issue.path[0];\n    if (topKey !== undefined && typeof topKey === 'string') {\n      // For nested paths (e.g. connection.port), we delete the deepest\n      // leaf we can reach so the rest of the sub-tree is preserved.\n      deleteNestedKey(clone, issue.path as string[]);\n    } else {\n      // Root-level issue  nothing we can strip\n    }\n  }\n  return clone;\n}\n\n/**\n * Delete a deeply-nested key described by `path` from `obj`.\n * If intermediate containers become empty objects after deletion they are\n * left in place (Zod will fill defaults).\n */\nfunction deleteNestedKey(obj: Record<string, unknown>, path: (string | number)[]): void {\n  if (path.length === 0) return;\n  if (path.length === 1) {\n    delete obj[path[0] as string];\n    return;\n  }\n\n  const [head, ...rest] = path;\n  const child = obj[head as string];\n  if (child !== null && child !== undefined && typeof child === 'object' && !Array.isArray(child)) {\n    deleteNestedKey(child as Record<string, unknown>, rest);\n  } else {\n    // Cannot traverse further  delete the whole branch\n    delete obj[head as string];\n  }\n}\n\n// ---------------------------------------------------------------------------\n// Part A: loadConfig with safeParse + self-healing\n// ---------------------------------------------------------------------------\n\nexport async function loadConfig(\n  overrides?: Record<string, unknown>\n): Promise<OptaConfig> {\n  const cacheKey = buildLoadConfigCacheKey(overrides);\n  if (loadConfigCache && loadConfigCache.key === cacheKey && loadConfigCache.expiresAt > Date.now()) {\n    return cloneConfig(loadConfigCache.value);\n  }\n\n  const raw: Record<string, unknown> = {};\n\n  // 1. Load user config (~/.config/opta/config.json)\n  try {\n    const store = await getConfigStore();\n    Object.assign(raw, store.store);\n  } catch {\n    // conf not available or no saved config  use defaults\n  }\n\n  // 2. Load project config (.opta/config.json via cosmiconfig)\n  try {\n    const { cosmiconfig } = await import('cosmiconfig');\n    const explorer = cosmiconfig('opta');\n    const result = await explorer.search();\n    if (result?.config) {\n      Object.assign(raw, result.config);\n    }\n  } catch {\n    // No project config found\n  }\n\n  // 3. Environment variable overrides\n  const connectionPatch: Record<string, unknown> = {};\n  if (process.env['OPTA_HOST']) connectionPatch['host'] = process.env['OPTA_HOST'];\n  if (process.env['OPTA_PORT']) connectionPatch['port'] = parseInt(process.env['OPTA_PORT'], 10);\n  if (process.env['OPTA_ADMIN_KEY']) connectionPatch['adminKey'] = process.env['OPTA_ADMIN_KEY'];\n  if (process.env['OPTA_API_KEY']) connectionPatch['apiKey'] = process.env['OPTA_API_KEY'];\n  if (Object.keys(connectionPatch).length > 0) {\n    (raw as Record<string, unknown>)['connection'] = {\n      ...((raw as Record<string, Record<string, unknown>>)['connection'] ?? {}),\n      ...connectionPatch,\n    };\n  }\n  const envModel = normalizeConfiguredModelId(process.env['OPTA_MODEL']);\n  if (envModel) {\n    (raw as Record<string, unknown>).model = {\n      ...((raw as Record<string, Record<string, unknown>>).model ?? {}),\n      default: envModel,\n    };\n  }\n\n  // 4. CLI flag overrides\n  if (overrides) {\n    Object.assign(raw, overrides);\n  }\n\n  // 5. Validate with safeParse  self-heal on failure\n  const result = OptaConfigSchema.safeParse(raw);\n\n  if (result.success) {\n    const normalized = {\n      ...result.data,\n      model: {\n        ...result.data.model,\n        default: normalizeConfiguredModelId(result.data.model.default),\n      },\n    };\n    loadConfigCache = {\n      key: cacheKey,\n      expiresAt: Date.now() + LOAD_CONFIG_CACHE_TTL_MS,\n      value: normalized,\n    };\n    return cloneConfig(normalized);\n  }\n\n  // Validation failed  show human-readable warnings\n  const hints = formatZodErrors(result.error);\n  for (const hint of hints) {\n    console.error(hint);\n  }\n\n  // Attempt self-healing: strip broken keys and re-parse with defaults\n  const healed = stripBrokenKeys(raw, result.error.issues);\n  const retryResult = OptaConfigSchema.safeParse(healed);\n\n  if (retryResult.success) {\n    const issueCount = result.error.issues.length;\n    console.error(\n      `Auto-healed ${issueCount} config issue${issueCount === 1 ? '' : 's'}. Run /quickfix for details.`,\n    );\n    const normalized = {\n      ...retryResult.data,\n      model: {\n        ...retryResult.data.model,\n        default: normalizeConfiguredModelId(retryResult.data.model.default),\n      },\n    };\n    loadConfigCache = {\n      key: cacheKey,\n      expiresAt: Date.now() + LOAD_CONFIG_CACHE_TTL_MS,\n      value: normalized,\n    };\n    return cloneConfig(normalized);\n  }\n\n  // Still broken after stripping  fatal error\n  throw new Error(\n    'Config is unparseable even after removing broken fields. ' +\n    'Run \"opta config reset\" to restore defaults.\\n' +\n    formatZodErrors(retryResult.error).join('\\n'),\n  );\n}\n\n// ---------------------------------------------------------------------------\n// Part B: healConfig  self-healing for malformed JSON\n// ---------------------------------------------------------------------------\n\nexport interface ConfigIssue {\n  path: string;\n  message: string;\n  suggestion: string;\n  autoFixed: boolean;\n}\n\n/**\n * Inspect the persisted user config, validate it against the schema, and\n * auto-fix any fields that can be reset to their defaults.\n *\n * Returns a list of every issue found, each annotated with whether it was\n * automatically repaired.\n */\nexport async function healConfig(): Promise<ConfigIssue[]> {\n  clearLoadConfigCache();\n  const store = await getConfigStore();\n  const raw = { ...store.store } as Record<string, unknown>;\n\n  const result = OptaConfigSchema.safeParse(raw);\n\n  if (result.success) {\n    return []; // Config is healthy\n  }\n\n  const issues: ConfigIssue[] = [];\n\n  for (const zodIssue of result.error.issues) {\n    const path = zodIssue.path.join('.');\n    let message: string;\n\n    switch (zodIssue.code) {\n      case 'invalid_type':\n        message = `Expected ${zodIssue.expected} but got ${zodIssue.received}`;\n        break;\n      case 'too_small': {\n        const minIssue = zodIssue as z.ZodTooSmallIssue;\n        message = `Must be at least ${minIssue.minimum}`;\n        break;\n      }\n      case 'too_big': {\n        const maxIssue = zodIssue as z.ZodTooBigIssue;\n        message = `Must be at most ${maxIssue.maximum}`;\n        break;\n      }\n      case 'invalid_enum_value': {\n        const enumIssue = zodIssue as z.ZodInvalidEnumValueIssue;\n        message = `Must be one of: ${enumIssue.options.join(', ')}`;\n        break;\n      }\n      default:\n        message = zodIssue.message;\n    }\n\n    const suggestion = path\n      ? `opta config set ${path} <valid-value>`\n      : 'Run \"opta config reset\" to restore all defaults';\n\n    // Attempt auto-fix: delete the broken key and see if the schema passes\n    const testRaw = { ...raw };\n    deleteNestedKey(testRaw, zodIssue.path as string[]);\n    const testResult = OptaConfigSchema.safeParse(testRaw);\n\n    const canAutoFix = testResult.success ||\n      !testResult.error.issues.some(i => i.path.join('.') === path);\n\n    if (canAutoFix) {\n      // Apply the fix to the persisted store\n      const topKey = zodIssue.path[0];\n      if (topKey !== undefined && typeof topKey === 'string') {\n        // Delete the broken key from the conf store\n        store.delete(topKey as string);\n      }\n      // Mutate raw for subsequent iterations\n      deleteNestedKey(raw, zodIssue.path as string[]);\n    }\n\n    issues.push({\n      path: path || '(root)',\n      message,\n      suggestion,\n      autoFixed: canAutoFix,\n    });\n  }\n\n  return issues;\n}\n\nexport async function saveConfig(\n  updates: Record<string, unknown>\n): Promise<void> {\n  clearLoadConfigCache();\n  const store = await getConfigStore();\n\n  for (const [key, rawValue] of Object.entries(updates)) {\n    let value = rawValue;\n    if (key === 'model.default' && typeof rawValue === 'string') {\n      value = normalizeConfiguredModelId(rawValue);\n    } else if (\n      key === 'model' &&\n      rawValue &&\n      typeof rawValue === 'object' &&\n      !Array.isArray(rawValue)\n    ) {\n      const modelUpdate = { ...(rawValue as Record<string, unknown>) };\n      if (typeof modelUpdate['default'] === 'string') {\n        modelUpdate['default'] = normalizeConfiguredModelId(\n          modelUpdate['default'] as string,\n        );\n      }\n      value = modelUpdate;\n    }\n    store.set(key, value);\n  }\n}\n\nlet _configStore: import('conf').default | null = null;\n\nexport async function getConfigStore(): Promise<import('conf').default> {\n  if (!_configStore) {\n    const { default: Conf } = await import('conf');\n    _configStore = new Conf({ projectName: 'opta' });\n  }\n  return _configStore;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/core/context.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/core/debug.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/core/diagnostics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/core/errors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/core/fileref.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":22,"column":11,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":22,"endColumn":20},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":23,"column":25,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":23,"endColumn":34},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":24,"column":59,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":24,"endColumn":68},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":41,"column":23,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":41,"endColumn":32},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":48,"column":21,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":48,"endColumn":30},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":1,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":48,"column":21,"nodeType":"TSNonNullExpression","messageId":"unnecessaryAssertion","endLine":48,"endColumn":30,"fix":{"range":[1728,1729],"text":""}},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":122,"column":23,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":122,"endColumn":32},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":137,"column":23,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":137,"endColumn":32},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":1,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":137,"column":23,"nodeType":"TSNonNullExpression","messageId":"unnecessaryAssertion","endLine":137,"endColumn":32,"fix":{"range":[4421,4422],"text":""}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { readFile } from 'node:fs/promises';\nimport { resolve, relative } from 'node:path';\nimport chalk from 'chalk';\n\nexport interface FileRef {\n  original: string;  // @src/core/agent.ts\n  path: string;      // resolved absolute path\n  content: string;   // file contents\n  lines: number;     // line count\n}\n\nexport interface LineRange {\n  path: string;\n  startLine: number | null;\n  endLine: number | null;\n}\n\nexport function parseLineRange(ref: string): LineRange {\n  const match = ref.match(/^(.+?):(\\d+)(?:-(\\d+))?$/);\n  if (!match) return { path: ref, startLine: null, endLine: null };\n  return {\n    path: match[1]!,\n    startLine: parseInt(match[2]!, 10),\n    endLine: match[3] ? parseInt(match[3], 10) : parseInt(match[2]!, 10),\n  };\n}\n\nexport function extractFileRefParts(ref: string): { original: string; path: string; startLine: number | null; endLine: number | null } {\n  const withoutAt = ref.startsWith('@') ? ref.slice(1) : ref;\n  const range = parseLineRange(withoutAt);\n  return { original: ref, ...range };\n}\n\nexport async function resolveFileRefs(message: string): Promise<{ cleanMessage: string; refs: FileRef[] }> {\n  // Match @path patterns (not @mentions which start with uppercase or are emails)\n  const pattern = /@((?:\\.{1,2}\\/|[a-z_])[^\\s,;:!?'\")\\]}>]+)/g;\n  const matches = [...message.matchAll(pattern)];\n  const cleanMessage = message;\n  const resolvedRefs = await Promise.all(\n    matches.map(async (match): Promise<FileRef | null> => {\n      const refPath = match[1]!;\n      const fullPath = resolve(process.cwd(), refPath);\n\n      try {\n        const content = await readFile(fullPath, 'utf-8');\n        const lines = content.split('\\n').length;\n        return {\n          original: match[0]!,\n          path: fullPath,\n          content,\n          lines,\n        };\n      } catch {\n        // File doesn't exist  leave the @reference as-is\n        return null;\n      }\n    }),\n  );\n\n  const refs = resolvedRefs.filter((ref): ref is FileRef => ref !== null);\n  for (const ref of refs) {\n    console.log(chalk.dim(`  attached: ${relative(process.cwd(), ref.path)} (${ref.lines} lines)`));\n  }\n\n  return { cleanMessage, refs };\n}\n\nexport function buildContextWithRefs(message: string, refs: FileRef[]): string {\n  if (refs.length === 0) return message;\n\n  let context = '';\n  for (const ref of refs) {\n    context += `\\n\\n<file path=\"${ref.path}\">\\n${ref.content}\\n</file>\\n`;\n  }\n\n  return message + context;\n}\n\n// --- Image Reference Support ---\n\nconst IMAGE_EXTENSIONS = new Set(['png', 'jpg', 'jpeg', 'gif', 'webp']);\n\nexport interface ImageRef {\n  original: string;  // @screenshot.png\n  path: string;      // resolved absolute path\n  base64: string;    // base64-encoded content\n  mimeType: string;  // image/png, image/jpeg, etc.\n  name: string;      // filename\n}\n\nfunction getImageMimeType(ext: string): string {\n  const mimes: Record<string, string> = {\n    png: 'image/png',\n    jpg: 'image/jpeg',\n    jpeg: 'image/jpeg',\n    gif: 'image/gif',\n    webp: 'image/webp',\n  };\n  return mimes[ext.toLowerCase()] ?? 'application/octet-stream';\n}\n\n/**\n * Check if a path refers to an image file (by extension).\n */\nexport function isImagePath(path: string): boolean {\n  const ext = path.split('.').pop()?.toLowerCase() ?? '';\n  return IMAGE_EXTENSIONS.has(ext);\n}\n\n/**\n * Resolve @image references in a message  reads image files as base64.\n *\n * Returns the clean message (with @image refs removed) and an array of\n * ImageRef objects containing the base64 data.\n */\nexport async function resolveImageRefs(message: string): Promise<{ cleanMessage: string; images: ImageRef[] }> {\n  const pattern = /@((?:\\.{1,2}\\/|[a-z_])[^\\s,;:!?'\")\\]}>]+)/g;\n  const matches = [...message.matchAll(pattern)];\n  let cleanMessage = message;\n  const resolvedImages = await Promise.all(\n    matches.map(async (match, idx): Promise<{ index: number; image: ImageRef; bytes: number } | null> => {\n      const refPath = match[1]!;\n      if (!isImagePath(refPath)) return null;\n\n      const fullPath = resolve(process.cwd(), refPath);\n      const ext = refPath.split('.').pop()?.toLowerCase() ?? '';\n\n      try {\n        const data = await readFile(fullPath);\n        const base64 = data.toString('base64');\n        const mimeType = getImageMimeType(ext);\n        const name = refPath.split('/').pop() ?? refPath;\n\n        return {\n          index: idx,\n          image: {\n            original: match[0]!,\n            path: fullPath,\n            base64,\n            mimeType,\n            name,\n          },\n          bytes: data.length,\n        };\n      } catch {\n        // File doesn't exist  leave the @reference as-is\n        return null;\n      }\n    }),\n  );\n\n  const orderedImages = resolvedImages\n    .filter((entry): entry is { index: number; image: ImageRef; bytes: number } => entry !== null)\n    .sort((a, b) => a.index - b.index);\n  const images = orderedImages.map((entry) => entry.image);\n\n  for (const entry of orderedImages) {\n    cleanMessage = cleanMessage.replace(entry.image.original, '').trim();\n    console.log(\n      chalk.dim(\n        `  attached image: ${relative(process.cwd(), entry.image.path)} (${(entry.bytes / 1024).toFixed(1)} KB)`,\n      ),\n    );\n  }\n\n  return { cleanMessage, images };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/core/insights.ts","messages":[{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['path'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":209,"column":33,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":209,"endColumn":51},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['pattern'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":211,"column":27,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":211,"endColumn":48},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['pattern'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":213,"column":27,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":213,"endColumn":48},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['command'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":215,"column":28,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":215,"endColumn":49},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['path'] ?? '.'' will use Object's default stringification format ('[object Object]') when stringified.","line":217,"column":33,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":217,"endColumn":52},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['url'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":219,"column":23,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":219,"endColumn":40},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['query'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":221,"column":27,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":221,"endColumn":46}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * InsightEngine  Real-time observability into local model inference.\n *\n * Generates  Insight blocks from agent loop events: first-token latency,\n * generation speed, context utilization, tool selection, compaction, and\n * connection status. Zero extra model calls  pure event observation.\n */\n\nimport { estimateTokens } from '../utils/tokens.js';\n\nexport type InsightCategory = 'perf' | 'context' | 'tool' | 'connection' | 'summary';\n\nexport interface Insight {\n  category: InsightCategory;\n  text: string;\n  /** Unix timestamp when the insight was generated. */\n  ts: number;\n}\n\nexport type InsightCallback = (insight: Insight) => void;\n\ninterface TurnState {\n  startTime: number;\n  firstTokenMs: number | null;\n  tokens: number;\n  toolCalls: string[];\n  compacted: boolean;\n  peakSpeed: number;\n  lastSpeedInsightAt: number;\n  reconnectAttempts: number;\n}\n\n/** Minimum interval (ms) between speed insights to avoid spam. */\nconst SPEED_INSIGHT_INTERVAL = 5000;\n\n/** Token threshold before first speed insight (skip trivial responses). */\nconst SPEED_INSIGHT_MIN_TOKENS = 50;\n\nexport class InsightEngine {\n  private cb: InsightCallback;\n  private turn: TurnState | null = null;\n  private model = '';\n  private contextLimit = 32768;\n  private contextUsed = 0;\n\n  constructor(callback: InsightCallback) {\n    this.cb = callback;\n  }\n\n  setModel(model: string): void {\n    this.model = shortName(model);\n  }\n\n  setContextLimit(limit: number): void {\n    this.contextLimit = limit;\n  }\n\n  // --- Turn Lifecycle ---\n\n  turnStart(): void {\n    this.turn = {\n      startTime: Date.now(),\n      firstTokenMs: null,\n      tokens: 0,\n      toolCalls: [],\n      compacted: false,\n      peakSpeed: 0,\n      lastSpeedInsightAt: 0,\n      reconnectAttempts: 0,\n    };\n  }\n\n  firstToken(latencyMs: number): void {\n    if (!this.turn) return;\n    this.turn.firstTokenMs = latencyMs;\n\n    let qualifier: string;\n    if (latencyMs < 200) qualifier = 'instant';\n    else if (latencyMs < 500) qualifier = 'fast';\n    else if (latencyMs < 1500) qualifier = 'warm-up complete';\n    else qualifier = 'cold start';\n\n    this.emit('perf', `First token in ${latencyMs}ms  ${qualifier}`);\n  }\n\n  // --- Streaming Progress ---\n\n  progress(tokens: number, speed: number, _elapsed: number): void {\n    if (!this.turn) return;\n    this.turn.tokens = tokens;\n    if (speed > this.turn.peakSpeed) this.turn.peakSpeed = speed;\n\n    const now = Date.now();\n    const sinceLastSpeed = now - this.turn.lastSpeedInsightAt;\n\n    if (tokens >= SPEED_INSIGHT_MIN_TOKENS && sinceLastSpeed >= SPEED_INSIGHT_INTERVAL) {\n      this.turn.lastSpeedInsightAt = now;\n\n      let qualifier: string;\n      if (speed > 80) qualifier = 'blazing';\n      else if (speed > 40) qualifier = 'strong';\n      else if (speed > 15) qualifier = 'steady';\n      else qualifier = 'deliberate';\n\n      this.emit('perf', `${speed.toFixed(1)} tok/s ${this.model ? `on ${this.model}` : ''}  ${qualifier} generation`);\n    }\n  }\n\n  // --- Context ---\n\n  contextUpdate(usedTokens: number): void {\n    this.contextUsed = usedTokens;\n    const pct = Math.round((usedTokens / this.contextLimit) * 100);\n\n    if (pct >= 80) {\n      this.emit('context', `Context pressure: ${pct}% used (${fmtK(usedTokens)}/${fmtK(this.contextLimit)})  compaction imminent`);\n    } else if (pct >= 60) {\n      this.emit('context', `Context: ${pct}% used (${fmtK(usedTokens)}/${fmtK(this.contextLimit)})`);\n    }\n  }\n\n  compaction(oldMessages: number, recoveredTokens: number): void {\n    if (!this.turn) return;\n    this.turn.compacted = true;\n    this.emit('context', `Compacted ${oldMessages} messages  recovered ~${fmtK(recoveredTokens)} tokens`);\n  }\n\n  // --- Tool Selection ---\n\n  toolStart(name: string, args: string): void {\n    if (!this.turn) return;\n    this.turn.toolCalls.push(name);\n\n    const brief = toolBrief(name, args);\n    this.emit('tool', `${name}${brief ? `  ${brief}` : ''}`);\n  }\n\n  toolEnd(name: string, _id: string, result: string): void {\n    const resultLen = result.length;\n    if (resultLen > 5000) {\n      this.emit('tool', `${name} returned ${fmtK(estimateTokens(result))} tokens of context`);\n    }\n  }\n\n  // --- Connection ---\n\n  connectionStatus(status: string, attempt?: number): void {\n    if (!this.turn) return;\n    if (status === 'reconnecting') {\n      this.turn.reconnectAttempts = attempt ?? this.turn.reconnectAttempts + 1;\n      this.emit('connection', `Reconnecting to LMX (attempt ${this.turn.reconnectAttempts})`);\n    } else if (status === 'connected' && this.turn.reconnectAttempts > 0) {\n      this.emit('connection', `Reconnected after ${this.turn.reconnectAttempts} attempt${this.turn.reconnectAttempts > 1 ? 's' : ''}`);\n    } else if (status === 'disconnected') {\n      this.emit('connection', 'LMX connection lost');\n    }\n  }\n\n  // --- Turn Summary ---\n\n  turnEnd(stats: {\n    tokens: number;\n    toolCalls: number;\n    elapsed: number;\n    speed: number;\n    firstTokenLatencyMs: number | null;\n  }): void {\n    if (!this.turn) return;\n\n    const parts: string[] = [];\n    parts.push(`${stats.tokens} tokens`);\n    if (stats.toolCalls > 0) parts.push(`${stats.toolCalls} tool${stats.toolCalls > 1 ? 's' : ''}`);\n    parts.push(`${stats.elapsed.toFixed(1)}s`);\n    if (stats.speed > 0) parts.push(`${stats.speed.toFixed(0)} tok/s`);\n    if (this.turn.compacted) parts.push('compacted');\n\n    this.emit('summary', parts.join('  '));\n    this.turn = null;\n  }\n\n  // --- Internal ---\n\n  private emit(category: InsightCategory, text: string): void {\n    this.cb({ category, text, ts: Date.now() });\n  }\n}\n\n// --- Helpers ---\n\nfunction shortName(model: string): string {\n  return model\n    .replace(/^mlx-community\\//, '')\n    .replace(/^huggingface\\//, '');\n}\n\nfunction fmtK(n: number): string {\n  return n >= 1000 ? `${(n / 1000).toFixed(1)}k` : String(n);\n}\n\n/** Extract a brief description from tool args for insight display. */\nfunction toolBrief(name: string, argsJson: string): string {\n  try {\n    const args = JSON.parse(argsJson) as Record<string, unknown>;\n    switch (name) {\n      case 'read_file':\n      case 'write_file':\n      case 'edit_file':\n      case 'delete_file':\n        return shortPath(String(args['path'] ?? ''));\n      case 'search_files':\n        return `\"${String(args['pattern'] ?? '').slice(0, 30)}\"`;\n      case 'find_files':\n        return `\"${String(args['pattern'] ?? '').slice(0, 30)}\"`;\n      case 'run_command':\n        return `$ ${String(args['command'] ?? '').slice(0, 40)}`;\n      case 'list_dir':\n        return shortPath(String(args['path'] ?? '.'));\n      case 'web_fetch':\n        return String(args['url'] ?? '').slice(0, 50);\n      case 'web_search':\n        return `\"${String(args['query'] ?? '').slice(0, 40)}\"`;\n      default:\n        return '';\n    }\n  } catch {\n    return '';\n  }\n}\n\nfunction shortPath(p: string): string {\n  const parts = p.split('/');\n  if (parts.length <= 3) return p;\n  return `.../${parts.slice(-2).join('/')}`;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/core/model-display.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":43,"column":32,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":43,"endColumn":49},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":1,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":43,"column":32,"nodeType":"TSNonNullExpression","messageId":"unnecessaryAssertion","endLine":43,"endColumn":49,"fix":{"range":[1080,1081],"text":""}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":1,"source":"/**\n * Model display profiles  cosmetic metadata for CLI display.\n *\n * Converts raw repo IDs like \"inferencerlabs/MiniMax-M2.5-MLX-6.5bit\"\n * into human-friendly names like \"MiniMax M2.5 6.5b\" with format tags\n * and 3-letter org abbreviations.\n *\n * Separate from core/models.ts (which handles context limits / compaction).\n */\n\nexport type ModelFormat = 'MLX' | 'GGUF' | 'CLOUD' | 'UNKNOWN';\n\nexport interface ModelDisplayProfile {\n  repoId: string;\n  displayName: string;\n  orgAbbrev: string;\n  format: ModelFormat;\n}\n\n// --- Org abbreviation map ---\n\nconst ORG_ABBREVS: Record<string, string> = {\n  'mlx-community': 'MLX',\n  'inferencerlabs': 'IFL',\n  'inferencelabs': 'IFL',\n  'lmstudio-community': 'LMS',\n  'huggingface': 'HGF',\n  'unsloth': 'UNS',\n  'bartowski': 'BAR',\n  'microsoft': 'MSF',\n  'google': 'GGL',\n  'meta-llama': 'MET',\n  'anthropic': 'ANT',\n  'mistralai': 'MST',\n  'qwen': 'QWN',\n  'openai': 'OAI',\n  'cohere': 'COH',\n  '01-ai': 'ZAI',\n  'deepseek-ai': 'DSK',\n};\n\nfunction getOrgAbbrev(org: string): string {\n  if (ORG_ABBREVS[org]) return ORG_ABBREVS[org]!;\n  // Fallback: first 3 uppercase chars of org\n  return org.replace(/[^a-zA-Z]/g, '').slice(0, 3).toUpperCase() || 'UNK';\n}\n\n// --- Format detection ---\n\nfunction detectFormat(repoId: string, org: string): ModelFormat {\n  const lower = repoId.toLowerCase();\n  if (lower.includes('.gguf')) return 'GGUF';\n  if (org === 'anthropic' || lower.startsWith('claude')) return 'CLOUD';\n  if (org === 'mlx-community' || org === 'inferencerlabs' || org === 'inferencelabs') return 'MLX';\n  // Default local models to MLX\n  return 'MLX';\n}\n\n// --- Display name simplification ---\n\nfunction simplifyName(modelPart: string): string {\n  let name = modelPart;\n\n  // Normalize quant suffixes (order matters  longer patterns first)\n  name = name.replace(/6\\.5bit/gi, '6.5b');\n  name = name.replace(/(\\d+)bit/gi, '$1b');\n  name = name.replace(/Q2_K_XL/gi, 'Q2K');\n  name = name.replace(/Q3_K_[A-Z]+/gi, 'Q3K');\n  name = name.replace(/Q4_K_M/gi, 'Q4M');\n  name = name.replace(/Q4_K_S/gi, 'Q4S');\n  name = name.replace(/Q5_K_M/gi, 'Q5M');\n  name = name.replace(/Q6_K/gi, 'Q6K');\n  name = name.replace(/Q8_0/gi, 'Q8');\n\n  // Remove standalone \"MLX\" (it's redundant with the format tag)\n  name = name.replace(/[-_]MLX(?=[-_]|$)/gi, '');\n  name = name.replace(/^MLX[-_]/gi, '');\n\n  // Replace separators with spaces\n  name = name.replace(/[-_]/g, ' ');\n\n  // Collapse multiple spaces\n  name = name.replace(/\\s{2,}/g, ' ').trim();\n\n  return name;\n}\n\n// --- Main export ---\n\nexport function getDisplayProfile(repoId: string): ModelDisplayProfile {\n  const slashIdx = repoId.indexOf('/');\n\n  if (slashIdx === -1) {\n    // No org prefix  treat the whole thing as the name\n    return {\n      repoId,\n      displayName: simplifyName(repoId),\n      orgAbbrev: 'UNK',\n      format: repoId.toLowerCase().includes('.gguf') ? 'GGUF' : 'UNKNOWN',\n    };\n  }\n\n  const org = repoId.slice(0, slashIdx);\n  const modelPart = repoId.slice(slashIdx + 1);\n\n  const orgAbbrev = getOrgAbbrev(org);\n  const format = detectFormat(repoId, org);\n  const displayName = simplifyName(modelPart);\n\n  return { repoId, displayName, orgAbbrev, format };\n}\n\n/** Chalk color string for a format tag (caller must apply to chalk). */\nexport function formatTagLabel(format: ModelFormat): string {\n  switch (format) {\n    case 'MLX': return '[MLX]';\n    case 'GGUF': return '[GGUF]';\n    case 'CLOUD': return '[Cloud]';\n    default: return '[?]';\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/core/model-recommend.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/core/models.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/core/orchestrator.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":49,"column":19,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":49,"endColumn":31,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[1520,1521],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":86,"column":25,"nodeType":"ChainExpression","messageId":"neverNullish","endLine":86,"endColumn":55},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":86,"column":40,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":86,"endColumn":42,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[2524,2526],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of type `any[]` to a variable of type `(SubAgentResult | null)[]`.","line":87,"column":9,"nodeType":"VariableDeclarator","messageId":"unsafeAssignment","endLine":87,"endColumn":88},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, value is always falsy.","line":98,"column":9,"nodeType":"Identifier","messageId":"alwaysFalsy","endLine":98,"endColumn":16},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":102,"column":23,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":102,"endColumn":40},{"ruleId":"@typescript-eslint/no-unnecessary-template-expression","severity":1,"message":"Template literal expression is unnecessary and can be simplified.","line":122,"column":14,"nodeType":null,"messageId":"noUnnecessaryTemplateExpression","endLine":122,"endColumn":26,"fix":{"range":[4021,4035],"text":"nanoid(8)"}},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":126,"column":24,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":126,"endColumn":58,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[4199,4200],"text":"?."},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":150,"column":27,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":150,"endColumn":48}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { nanoid } from 'nanoid';\nimport type { OptaConfig } from './config.js';\nimport type { SubAgentTask, SubAgentResult, SubAgentContext } from './subagent.js';\nimport type { ToolRegistry } from '../mcp/registry.js';\nimport type { SubAgentProgressEvent } from './subagent-events.js';\n\ninterface DelegationPlan {\n  plan: string;\n  subtasks: Array<{\n    task: string;\n    scope?: string;\n    depends_on?: number;\n  }>;\n}\n\ninterface DelegationOptions {\n  onAgentProgress?: (event: SubAgentProgressEvent) => void;\n  onAgentSpawn?: (id: string, label: string, dependsOn?: number) => void;\n  onAgentDone?: (agentId: string, result: string) => void;\n}\n\ntype SpawnFn = (\n  task: SubAgentTask,\n  config: OptaConfig,\n  client: import('openai').default,\n  registry: ToolRegistry,\n  parentContext?: SubAgentContext\n) => Promise<SubAgentResult>;\n\nconst MAX_SUBTASKS = 5;\n\n/**\n * Build execution waves from subtask dependencies (topological sort).\n *\n * Each wave contains indices of subtasks whose dependencies are all in\n * earlier waves. Subtasks within a wave can execute in parallel.\n */\nfunction buildWaves(subtasks: DelegationPlan['subtasks']): number[][] {\n  const n = subtasks.length;\n  const assigned = new Set<number>();\n  const waves: number[][] = [];\n\n  // Safety: cap iterations at n to prevent infinite loops on bad input\n  for (let iter = 0; iter < n && assigned.size < n; iter++) {\n    const wave: number[] = [];\n    for (let i = 0; i < n; i++) {\n      if (assigned.has(i)) continue;\n\n      const dep = subtasks[i]!.depends_on;\n      // No dependency, or dependency already completed in a prior wave\n      if (dep === undefined || dep < 0 || dep >= n || assigned.has(dep)) {\n        wave.push(i);\n      }\n    }\n\n    if (wave.length === 0) {\n      // Remaining tasks have circular or unresolvable dependencies  force them\n      for (let i = 0; i < n; i++) {\n        if (!assigned.has(i)) wave.push(i);\n      }\n    }\n\n    for (const idx of wave) assigned.add(idx);\n    waves.push(wave);\n  }\n\n  return waves;\n}\n\nexport async function executeDelegation(\n  plan: DelegationPlan,\n  config: OptaConfig,\n  client: import('openai').default,\n  registry: ToolRegistry,\n  spawnFn: SpawnFn,\n  delegationOptions?: DelegationOptions,\n): Promise<string> {\n  if (plan.subtasks.length > MAX_SUBTASKS) {\n    throw new Error(`Maximum ${MAX_SUBTASKS} subtasks allowed per delegation.`);\n  }\n\n  if (plan.subtasks.length === 0) {\n    return `Delegation: ${plan.plan}\\n\\nNo subtasks to execute.`;\n  }\n\n  const maxConcurrent = config.subAgent?.maxConcurrent ?? 3;\n  const results: (SubAgentResult | null)[] = new Array(plan.subtasks.length).fill(null);\n  const lines: string[] = [];\n  lines.push(`Delegation: ${plan.plan}`);\n  lines.push(`Subtasks: ${plan.subtasks.length}`);\n  lines.push('');\n\n  // Build execution waves from dependency graph\n  const waves = buildWaves(plan.subtasks);\n  let aborted = false;\n\n  for (const wave of waves) {\n    if (aborted) break;\n\n    // Execute all subtasks in this wave concurrently (bounded by maxConcurrent)\n    const wavePromises = wave.map(async (i) => {\n      const subtask = plan.subtasks[i]!;\n\n      // Build description, injecting dependency results\n      let description = subtask.task;\n      if (subtask.depends_on !== undefined) {\n        if (subtask.depends_on < 0 || subtask.depends_on >= plan.subtasks.length) {\n          lines.push(`Warning: subtask ${i + 1} has invalid depends_on=${subtask.depends_on} (ignored).`);\n        } else {\n          const depResult = results[subtask.depends_on];\n          if (depResult) {\n            if (depResult.status === 'budget_exceeded' || depResult.status === 'timeout') {\n              description = `${subtask.task}\\n\\nContext from previous subtask (${depResult.status}  results may be incomplete):\\n${depResult.response}`;\n            } else {\n              description = `${subtask.task}\\n\\nContext from previous subtask:\\n${depResult.response}`;\n            }\n          }\n        }\n      }\n\n      const agentTask: SubAgentTask = {\n        id: `${nanoid(8)}`,\n        description,\n        scope: subtask.scope,\n        onProgress: delegationOptions?.onAgentProgress\n          ? (event) => delegationOptions.onAgentProgress!(event)\n          : undefined,\n      };\n\n      delegationOptions?.onAgentSpawn?.(\n        agentTask.id,\n        subtask.task.slice(0, 40),\n        subtask.depends_on,\n      );\n\n      const result = await spawnFn(agentTask, config, client, registry);\n      delegationOptions?.onAgentDone?.(agentTask.id, result.response);\n      results[i] = result;\n      return { index: i, result };\n    });\n\n    // Bounded concurrency: process wave in chunks of maxConcurrent\n    for (let start = 0; start < wavePromises.length; start += maxConcurrent) {\n      const chunk = wavePromises.slice(start, start + maxConcurrent);\n      const settled = await Promise.allSettled(chunk);\n\n      for (const outcome of settled) {\n        if (outcome.status === 'fulfilled') {\n          const { index, result } = outcome.value;\n          const subtask = plan.subtasks[index]!;\n          lines.push(`--- Subtask ${index + 1}: ${subtask.task} ---`);\n          lines.push(`Status: ${result.status}`);\n          lines.push(result.response);\n          lines.push('');\n\n          if (result.status === 'error') {\n            lines.push(`Delegation stopped: subtask ${index + 1} failed with error.`);\n            aborted = true;\n          }\n        } else {\n          lines.push(`--- Subtask failed: ${outcome.reason} ---`);\n          lines.push('');\n          aborted = true;\n        }\n      }\n\n      if (aborted) break;\n    }\n  }\n\n  const completed = results.filter(r => r?.status === 'completed');\n  const totalToolCalls = results.reduce((sum, r) => sum + (r?.toolCallCount ?? 0), 0);\n  const totalDuration = results.reduce((sum, r) => sum + (r?.durationMs ?? 0), 0);\n\n  lines.push('--- Delegation Summary ---');\n  lines.push(`Completed: ${completed.length}/${plan.subtasks.length}`);\n  lines.push(`Total tool calls: ${totalToolCalls}`);\n  lines.push(`Total duration: ${(totalDuration / 1000).toFixed(1)}s`);\n\n  return lines.join('\\n');\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/core/subagent-events.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/core/subagent.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":247,"column":36,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":247,"endColumn":47,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[7175,7176],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, value is always truthy.","line":266,"column":12,"nodeType":"Literal","messageId":"alwaysTruthy","endLine":266,"endColumn":16},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":365,"column":17,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":365,"endColumn":57},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .edits on an `any` value.","line":366,"column":63,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":366,"endColumn":68},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .edits on an `any` value.","line":367,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":367,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .path on an `any` value.","line":368,"column":39,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":368,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":369,"column":36,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":369,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .path on an `any` value.","line":369,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":369,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":373,"column":19,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":373,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .path on an `any` value.","line":373,"column":31,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":373,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .file on an `any` value.","line":373,"column":44,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":373,"endColumn":48}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { OptaConfig } from './config.js';\nimport { errorMessage } from '../utils/errors.js';\nimport { estimateMessageTokens } from '../utils/tokens.js';\nimport { detectPhaseFromTool, type SubAgentPhase, type SubAgentProgressEvent } from './subagent-events.js';\n\n// --- Type Definitions ---\n\nexport interface SubAgentBudget {\n  maxToolCalls: number;\n  maxTokens: number;\n  timeoutMs: number;\n}\n\nexport interface SubAgentTask {\n  id: string;\n  description: string;\n  scope?: string;\n  budget?: Partial<SubAgentBudget>;\n  tools?: string[];\n  mode?: string;\n  onProgress?: (event: SubAgentProgressEvent) => void;\n}\n\nexport interface SubAgentResult {\n  taskId: string;\n  status: 'completed' | 'budget_exceeded' | 'timeout' | 'cancelled' | 'error';\n  response: string;\n  toolCallCount: number;\n  tokenEstimate: number;\n  filesRead: string[];\n  filesModified: string[];\n  durationMs: number;\n}\n\nexport interface SubAgentContext {\n  parentSessionId: string;\n  depth: number;\n  budget: SubAgentBudget;\n  parentCwd: string;\n}\n\n// --- Task 1: Budget Validation & Defaults ---\n\nexport function resolveBudget(\n  overrides: Partial<SubAgentBudget>,\n  config: OptaConfig\n): SubAgentBudget {\n  const defaults = config.subAgent.defaultBudget;\n  const hardStopAt = config.safety.circuitBreaker.hardStopAt;\n\n  const maxToolCalls = Math.min(\n    overrides.maxToolCalls ?? defaults.maxToolCalls,\n    hardStopAt > 0 ? hardStopAt : Infinity\n  );\n\n  return {\n    maxToolCalls,\n    maxTokens: overrides.maxTokens ?? defaults.maxTokens,\n    timeoutMs: overrides.timeoutMs ?? defaults.timeoutMs,\n  };\n}\n\nexport function validateBudget(budget: SubAgentBudget): void {\n  if (budget.maxToolCalls <= 0) {\n    throw new Error('maxToolCalls must be positive');\n  }\n  if (budget.maxTokens <= 0) {\n    throw new Error('maxTokens must be positive');\n  }\n  if (budget.timeoutMs < 5000) {\n    throw new Error('timeoutMs must be at least 5000');\n  }\n}\n\n// --- Task 2: Context & Depth Tracking ---\n\nexport function createSubAgentContext(\n  sessionId: string,\n  parentContext: SubAgentContext | undefined,\n  config: OptaConfig\n): SubAgentContext {\n  const depth = parentContext ? parentContext.depth + 1 : 1;\n  const maxDepth = config.subAgent.maxDepth;\n\n  if (depth > maxDepth) {\n    throw new Error(`Maximum sub-agent depth (${maxDepth}) exceeded`);\n  }\n\n  return {\n    parentSessionId: sessionId,\n    depth,\n    budget: resolveBudget({}, config),\n    parentCwd: parentContext?.parentCwd ?? process.cwd(),\n  };\n}\n\n// --- Task 3: System Prompt Generation ---\n\nexport function buildSubAgentPrompt(\n  task: string,\n  cwd: string,\n  maxToolCalls: number\n): string {\n  return `You are a focused sub-agent assistant. You have been delegated a specific task to complete independently.\n\nYour task: ${task}\n\nWorking directory: ${cwd}\n\nConstraints:\n- You have a budget of ${maxToolCalls} tool calls. Use them efficiently.\n- Be concise in your responses. Your output will be consumed by a parent agent.\n- Do not ask the user questions  you are running silently.\n- Focus only on the task described above.\n- Do NOT spawn further sub-agents unless absolutely necessary.\n\nWhen finished, provide a structured summary:\n1. What you found or did (key findings, code patterns, data points).\n2. Files read  list every file path you examined.\n3. Files modified  list every file path you created, edited, or deleted, with a one-line description of the change.\nIf no files were modified, state \"No files modified.\"`;\n}\n\n// --- Task 4: Permission Derivation for Children ---\n\nexport function deriveChildConfig(\n  parentConfig: OptaConfig,\n  modeOverride?: string,\n  budget?: SubAgentBudget\n): OptaConfig {\n  const resolvedBudget = budget ?? {\n    maxToolCalls: parentConfig.subAgent.defaultBudget.maxToolCalls,\n    maxTokens: parentConfig.subAgent.defaultBudget.maxTokens,\n    timeoutMs: parentConfig.subAgent.defaultBudget.timeoutMs,\n  };\n\n  const mode = modeOverride ??\n    (parentConfig.subAgent.inheritMode ? parentConfig.defaultMode : 'safe');\n\n  // Derive permissions: always deny ask_user for silent children\n  const childPermissions = { ...parentConfig.permissions };\n  childPermissions['ask_user'] = 'deny';\n\n  return {\n    ...parentConfig,\n    defaultMode: mode as OptaConfig['defaultMode'],\n    permissions: childPermissions,\n    git: {\n      autoCommit: false,\n      checkpoints: false,\n    },\n    safety: {\n      ...parentConfig.safety,\n      circuitBreaker: {\n        ...parentConfig.safety.circuitBreaker,\n        hardStopAt: resolvedBudget.maxToolCalls,\n        pauseAt: 0, // No interactive pausing for silent agents\n        warnAt: 0,  // No warnings for silent agents\n      },\n    },\n  };\n}\n\n// --- Task 5: Core spawnSubAgent Function ---\n\nexport async function spawnSubAgent(\n  task: SubAgentTask,\n  config: OptaConfig,\n  client: import('openai').default,\n  registry: import('../mcp/registry.js').ToolRegistry,\n  parentContext?: SubAgentContext,\n  signal?: AbortSignal\n): Promise<SubAgentResult> {\n  const startTime = Date.now();\n  const budget = resolveBudget(task.budget ?? {}, config);\n\n  // Mutable state captured by the builder closure\n  let toolCallCount = 0;\n  const filesRead: string[] = [];\n  const filesModified: string[] = [];\n  const messages: Array<{\n    role: 'system' | 'user' | 'assistant' | 'tool';\n    content: string | null;\n    tool_calls?: Array<{\n      id: string;\n      type: 'function';\n      function: { name: string; arguments: string };\n    }>;\n    tool_call_id?: string;\n  }> = [];\n\n  /** Build a SubAgentResult from the current closure state. */\n  function buildResult(\n    status: SubAgentResult['status'],\n    response: string,\n  ): SubAgentResult {\n    return {\n      taskId: task.id,\n      status,\n      response,\n      toolCallCount,\n      tokenEstimate: estimateMessageTokens(messages),\n      filesRead: [...new Set(filesRead)],\n      filesModified: [...new Set(filesModified)],\n      durationMs: Date.now() - startTime,\n    };\n  }\n\n  /** Emit a sub-agent progress event. */\n  function emitPhase(phase: SubAgentPhase, toolName?: string): void {\n    task.onProgress?.({\n      agentId: task.id,\n      phase,\n      taskDescription: task.description,\n      toolName,\n      toolCallCount,\n      elapsedMs: Date.now() - startTime,\n    });\n  }\n\n  // Check if already cancelled before starting\n  if (signal?.aborted) {\n    emitPhase('cancelled');\n    return buildResult('cancelled', 'Sub-agent cancelled before starting.');\n  }\n\n  try {\n    validateBudget(budget);\n  } catch (err) {\n    emitPhase('error');\n    return buildResult('error', `Budget validation failed: ${errorMessage(err)}`);\n  }\n\n  const childConfig = deriveChildConfig(config, task.mode, budget);\n  const cwd = task.scope ?? parentContext?.parentCwd ?? process.cwd();\n  const systemPrompt = buildSubAgentPrompt(task.description, cwd, budget.maxToolCalls);\n  const model = config.model.default;\n\n  // Initialize messages array with system + user messages\n  messages.push(\n    { role: 'system', content: systemPrompt },\n    { role: 'user', content: task.description },\n  );\n\n  // Build the tool schemas to use (respect whitelist if provided)\n  const toolSchemas = task.tools\n    ? registry.schemas.filter(s => task.tools!.includes(s.function.name))\n    : registry.schemas;\n\n  // Import resolvePermission once outside the loop\n  const { resolvePermission } = await import('./tools/index.js');\n\n  // AbortController for cancelling inflight LLM requests on timeout or external cancellation\n  const abortController = new AbortController();\n\n  // Link external signal to internal abort\n  if (signal) {\n    const onAbort = () => abortController.abort();\n    signal.addEventListener('abort', onAbort, { once: true });\n    // Clean up listener when done (handled in finally block via clearTimeout pattern)\n  }\n\n  emitPhase('spawning');\n\n  const runLoop = async (): Promise<SubAgentResult> => {\n    while (true) {\n      // Check budget before each LLM call\n      if (toolCallCount >= budget.maxToolCalls) {\n        const lastAssistantMsg = [...messages].reverse().find(m => m.role === 'assistant');\n        emitPhase('error');\n        return buildResult(\n          'budget_exceeded',\n          typeof lastAssistantMsg?.content === 'string'\n            ? lastAssistantMsg.content\n            : `Budget exceeded after ${toolCallCount} tool calls.`,\n        );\n      }\n\n      emitPhase('thinking');\n\n      const response = await client.chat.completions.create({\n        model,\n        messages: messages as Parameters<typeof client.chat.completions.create>[0]['messages'],\n        tools: toolSchemas.length > 0\n          ? toolSchemas as Parameters<typeof client.chat.completions.create>[0]['tools']\n          : undefined,\n        tool_choice: toolSchemas.length > 0 ? 'auto' : undefined,\n      }, { signal: abortController.signal });\n\n      const choice = response.choices[0];\n      if (!choice) {\n        emitPhase('error');\n        return buildResult('error', 'No response from model.');\n      }\n\n      const assistantMsg = choice.message;\n      const text = assistantMsg.content ?? '';\n      const toolCalls = assistantMsg.tool_calls ?? [];\n\n      // No tool calls = task complete\n      if (toolCalls.length === 0) {\n        emitPhase('done');\n        return buildResult('completed', text);\n      }\n\n      // Add assistant message with tool calls\n      messages.push({\n        role: 'assistant',\n        content: text || null,\n        tool_calls: toolCalls.map(tc => ({\n          id: tc.id,\n          type: 'function' as const,\n          function: { name: tc.function.name, arguments: tc.function.arguments },\n        })),\n      });\n\n      // Execute each tool call\n      for (const tc of toolCalls) {\n        // Check if timeout has fired between tool calls\n        if (abortController.signal.aborted) {\n          throw new Error('TIMEOUT');\n        }\n\n        const toolName = tc.function.name;\n\n        // Check if tool is in whitelist (if whitelist exists)\n        if (task.tools && !task.tools.includes(toolName)) {\n          messages.push({\n            role: 'tool',\n            content: `Permission denied: tool \"${toolName}\" is not in the allowed tool list for this sub-agent.`,\n            tool_call_id: tc.id,\n          });\n          toolCallCount++;\n          continue;\n        }\n\n        // Check permission\n        const permission = resolvePermission(toolName, childConfig);\n        if (permission === 'deny' || permission === 'ask') {\n          // Silent agents cannot prompt: ask becomes deny\n          messages.push({\n            role: 'tool',\n            content: 'Permission denied by configuration.',\n            tool_call_id: tc.id,\n          });\n          toolCallCount++;\n          continue;\n        }\n\n        // Emit tool phase before execution\n        emitPhase(detectPhaseFromTool(toolName), toolName);\n\n        // Execute the tool (pass context explicitly for concurrency safety)\n        const result = await registry.execute(toolName, tc.function.arguments, parentContext);\n        messages.push({\n          role: 'tool',\n          content: result,\n          tool_call_id: tc.id,\n        });\n\n        toolCallCount++;\n\n        // Track files\n        try {\n          const args = JSON.parse(tc.function.arguments);\n          if (toolName === 'multi_edit' && Array.isArray(args.edits)) {\n            for (const edit of args.edits) {\n              if (edit && typeof edit.path === 'string') {\n                filesModified.push(edit.path);\n              }\n            }\n          } else {\n            const path = args.path ?? args.file;\n            if (path) {\n              if (['read_file', 'read_project_docs'].includes(toolName)) {\n                filesRead.push(String(path));\n              }\n              if (['edit_file', 'write_file', 'delete_file'].includes(toolName)) {\n                filesModified.push(String(path));\n              }\n            }\n          }\n        } catch {\n          // Ignore arg parse errors for tracking\n        }\n\n        // Check budget after each tool call\n        if (toolCallCount >= budget.maxToolCalls) {\n          break;\n        }\n      }\n    }\n  };\n\n  // Wrap with timeout, always restore registry context\n  let timeoutHandle: ReturnType<typeof setTimeout> | undefined;\n  try {\n    const result = await Promise.race([\n      runLoop(),\n      new Promise<SubAgentResult>((_, reject) => {\n        timeoutHandle = setTimeout(() => {\n          abortController.abort(); // Cancel inflight LLM request\n          reject(new Error('TIMEOUT'));\n        }, budget.timeoutMs);\n      }),\n    ]);\n    return result;\n  } catch (err) {\n    if (err instanceof Error && err.message === 'TIMEOUT') {\n      // Distinguish external cancellation from internal timeout\n      if (signal?.aborted) {\n        emitPhase('cancelled');\n        return buildResult('cancelled', 'Sub-agent cancelled by parent.');\n      }\n      emitPhase('timeout');\n      return buildResult('timeout', `Sub-agent timed out after ${budget.timeoutMs}ms.`);\n    }\n\n    // External cancellation may also surface as an AbortError\n    if (signal?.aborted) {\n      emitPhase('cancelled');\n      return buildResult('cancelled', 'Sub-agent cancelled by parent.');\n    }\n\n    emitPhase('error');\n    return buildResult('error', errorMessage(err));\n  } finally {\n    if (timeoutHandle !== undefined) clearTimeout(timeoutHandle);\n  }\n}\n\n// --- Task 6: Tool Result Formatting ---\n\nexport function formatSubAgentResult(result: SubAgentResult): string {\n  const statusPrefix = result.status === 'error'\n    ? '[ERROR] '\n    : result.status === 'budget_exceeded'\n    ? '[BUDGET EXCEEDED] '\n    : result.status === 'timeout'\n    ? '[TIMEOUT] '\n    : result.status === 'cancelled'\n    ? '[CANCELLED] '\n    : '';\n\n  const lines: string[] = [];\n  lines.push(`${statusPrefix}Sub-agent result (${result.toolCallCount} tool calls, ${(result.durationMs / 1000).toFixed(1)}s):`);\n  lines.push('');\n  lines.push(result.response);\n\n  if (result.filesRead.length > 0) {\n    lines.push('');\n    lines.push(`Files read: ${result.filesRead.join(', ')}`);\n  }\n  if (result.filesModified.length > 0) {\n    lines.push('');\n    lines.push(`Files modified: ${result.filesModified.join(', ')}`);\n  }\n\n  return lines.join('\\n');\n}\n\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/core/tool-compatibility.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-type-conversion","severity":1,"message":"Passing a string to String() does not change the type or value of the string.","line":76,"column":18,"nodeType":"Identifier","messageId":"unnecessaryTypeConversion","endLine":76,"endColumn":24,"suggestions":[{"messageId":"suggestRemove","fix":{"range":[2539,2558],"text":"entry.model"},"desc":"Remove the type conversion."},{"messageId":"suggestSatisfies","data":{"type":"string"},"fix":{"range":[2539,2558],"text":"entry.model satisfies string"},"desc":"Instead, assert that the value satisfies the string type."}]},{"ruleId":"@typescript-eslint/no-unnecessary-type-conversion","severity":1,"message":"Passing a string to String() does not change the type or value of the string.","line":77,"column":21,"nodeType":"Identifier","messageId":"unnecessaryTypeConversion","endLine":77,"endColumn":27,"suggestions":[{"messageId":"suggestRemove","fix":{"range":[2580,2602],"text":"entry.provider"},"desc":"Remove the type conversion."},{"messageId":"suggestSatisfies","data":{"type":"string"},"fix":{"range":[2580,2602],"text":"entry.provider satisfies string"},"desc":"Instead, assert that the value satisfies the string type."}]},{"ruleId":"@typescript-eslint/no-unnecessary-type-conversion","severity":1,"message":"Passing a string to String() does not change the type or value of the string.","line":78,"column":24,"nodeType":"Identifier","messageId":"unnecessaryTypeConversion","endLine":78,"endColumn":30,"suggestions":[{"messageId":"suggestRemove","fix":{"range":[2627,2652],"text":"entry.firstSeenAt"},"desc":"Remove the type conversion."},{"messageId":"suggestSatisfies","data":{"type":"string"},"fix":{"range":[2627,2652],"text":"entry.firstSeenAt satisfies string"},"desc":"Instead, assert that the value satisfies the string type."}]},{"ruleId":"@typescript-eslint/no-unnecessary-type-conversion","severity":1,"message":"Passing a string to String() does not change the type or value of the string.","line":79,"column":23,"nodeType":"Identifier","messageId":"unnecessaryTypeConversion","endLine":79,"endColumn":29,"suggestions":[{"messageId":"suggestRemove","fix":{"range":[2676,2700],"text":"entry.lastSeenAt"},"desc":"Remove the type conversion."},{"messageId":"suggestSatisfies","data":{"type":"string"},"fix":{"range":[2676,2700],"text":"entry.lastSeenAt satisfies string"},"desc":"Instead, assert that the value satisfies the string type."}]},{"ruleId":"@typescript-eslint/no-unnecessary-type-conversion","severity":1,"message":"Passing a number to Number() does not change the type or value of the number.","line":80,"column":48,"nodeType":"Identifier","messageId":"unnecessaryTypeConversion","endLine":80,"endColumn":54,"suggestions":[{"messageId":"suggestRemove","fix":{"range":[2749,2780],"text":"(entry.successCount ?? 0)"},"desc":"Remove the type conversion."},{"messageId":"suggestSatisfies","data":{"type":"number"},"fix":{"range":[2749,2780],"text":"(entry.successCount ?? 0) satisfies number"},"desc":"Instead, assert that the value satisfies the number type."}]},{"ruleId":"@typescript-eslint/no-unnecessary-type-conversion","severity":1,"message":"Passing a number to Number() does not change the type or value of the number.","line":81,"column":54,"nodeType":"Identifier","messageId":"unnecessaryTypeConversion","endLine":81,"endColumn":60,"suggestions":[{"messageId":"suggestRemove","fix":{"range":[2837,2874],"text":"(entry.pseudoFailureCount ?? 0)"},"desc":"Remove the type conversion."},{"messageId":"suggestSatisfies","data":{"type":"number"},"fix":{"range":[2837,2874],"text":"(entry.pseudoFailureCount ?? 0) satisfies number"},"desc":"Instead, assert that the value satisfies the number type."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { mkdir, readFile, writeFile } from 'node:fs/promises';\nimport { dirname, join } from 'node:path';\n\nexport const TOOL_COMPATIBILITY_RELATIVE_PATH = join(\n  '.opta',\n  'browser',\n  'tool-compatibility.json',\n);\n\nexport type ToolProtocolStatus = 'success' | 'pseudo_failure';\n\nexport interface ToolCompatibilityEntry {\n  model: string;\n  provider: string;\n  firstSeenAt: string;\n  lastSeenAt: string;\n  successCount: number;\n  pseudoFailureCount: number;\n  lastStatus: ToolProtocolStatus;\n  lastPseudoTags: string[];\n}\n\ninterface ToolCompatibilityStore {\n  schemaVersion: 1;\n  updatedAt: string;\n  entries: Record<string, ToolCompatibilityEntry>;\n}\n\nexport interface ToolCompatibilityEventInput {\n  model: string;\n  provider: string;\n  status: ToolProtocolStatus;\n  pseudoTags?: string[];\n  timestamp?: string;\n}\n\nfunction nowIso(): string {\n  return new Date().toISOString();\n}\n\nfunction normalizeIdPart(value: string): string {\n  return value.trim().toLowerCase();\n}\n\nfunction compatibilityKey(model: string, provider: string): string {\n  return `${normalizeIdPart(provider)}::${normalizeIdPart(model)}`;\n}\n\nfunction normalizeTags(tags: string[] | undefined): string[] {\n  if (!tags || tags.length === 0) return [];\n  return [...new Set(tags.map((tag) => tag.trim().toLowerCase()).filter(Boolean))]\n    .sort((left, right) => left.localeCompare(right));\n}\n\nexport function toolCompatibilityPath(cwd = process.cwd()): string {\n  return join(cwd, TOOL_COMPATIBILITY_RELATIVE_PATH);\n}\n\nasync function readStore(cwd = process.cwd()): Promise<ToolCompatibilityStore> {\n  const path = toolCompatibilityPath(cwd);\n  try {\n    const raw = await readFile(path, 'utf-8');\n    const parsed = JSON.parse(raw) as Partial<ToolCompatibilityStore> | null;\n    if (!parsed || typeof parsed !== 'object') {\n      throw new Error('Invalid compatibility telemetry payload');\n    }\n    const entriesInput = parsed.entries;\n    const entries: Record<string, ToolCompatibilityEntry> = {};\n    if (entriesInput && typeof entriesInput === 'object' && !Array.isArray(entriesInput)) {\n      for (const [key, value] of Object.entries(entriesInput as Record<string, unknown>)) {\n        if (!value || typeof value !== 'object' || Array.isArray(value)) continue;\n        const entry = value as Partial<ToolCompatibilityEntry>;\n        if (!entry.model || !entry.provider || !entry.firstSeenAt || !entry.lastSeenAt) continue;\n        if (entry.lastStatus !== 'success' && entry.lastStatus !== 'pseudo_failure') continue;\n        entries[key] = {\n          model: String(entry.model),\n          provider: String(entry.provider),\n          firstSeenAt: String(entry.firstSeenAt),\n          lastSeenAt: String(entry.lastSeenAt),\n          successCount: Math.max(0, Math.floor(Number(entry.successCount ?? 0))),\n          pseudoFailureCount: Math.max(0, Math.floor(Number(entry.pseudoFailureCount ?? 0))),\n          lastStatus: entry.lastStatus,\n          lastPseudoTags: normalizeTags(entry.lastPseudoTags),\n        };\n      }\n    }\n    return {\n      schemaVersion: 1,\n      updatedAt: typeof parsed.updatedAt === 'string' ? parsed.updatedAt : nowIso(),\n      entries,\n    };\n  } catch (error) {\n    const err = error as NodeJS.ErrnoException;\n    if (err.code === 'ENOENT') {\n      return {\n        schemaVersion: 1,\n        updatedAt: nowIso(),\n        entries: {},\n      };\n    }\n    // Corrupt telemetry is reset deterministically.\n    return {\n      schemaVersion: 1,\n      updatedAt: nowIso(),\n      entries: {},\n    };\n  }\n}\n\nasync function writeStore(store: ToolCompatibilityStore, cwd = process.cwd()): Promise<void> {\n  const path = toolCompatibilityPath(cwd);\n  await mkdir(dirname(path), { recursive: true });\n  await writeFile(path, `${JSON.stringify(store, null, 2)}\\n`, 'utf-8');\n}\n\nexport async function readToolCompatibilityEntry(\n  cwd: string,\n  input: { model: string; provider: string },\n): Promise<ToolCompatibilityEntry | null> {\n  const key = compatibilityKey(input.model, input.provider);\n  const store = await readStore(cwd);\n  return store.entries[key] ?? null;\n}\n\nexport async function recordToolCompatibilityEvent(\n  cwd: string,\n  event: ToolCompatibilityEventInput,\n): Promise<ToolCompatibilityEntry> {\n  const timestamp = event.timestamp ?? nowIso();\n  const store = await readStore(cwd);\n  const key = compatibilityKey(event.model, event.provider);\n  const existing = store.entries[key];\n  const next: ToolCompatibilityEntry = existing\n    ? { ...existing }\n    : {\n        model: event.model,\n        provider: event.provider,\n        firstSeenAt: timestamp,\n        lastSeenAt: timestamp,\n        successCount: 0,\n        pseudoFailureCount: 0,\n        lastStatus: event.status,\n        lastPseudoTags: [],\n      };\n\n  next.lastSeenAt = timestamp;\n  next.lastStatus = event.status;\n  if (event.status === 'success') {\n    next.successCount += 1;\n    next.lastPseudoTags = [];\n  } else {\n    next.pseudoFailureCount += 1;\n    next.lastPseudoTags = normalizeTags(event.pseudoTags);\n  }\n\n  store.entries[key] = next;\n  store.updatedAt = timestamp;\n  await writeStore(store, cwd);\n  return next;\n}\n\nexport function buildToolCompatibilityInstruction(\n  entry: ToolCompatibilityEntry | null,\n): string {\n  if (!entry || entry.pseudoFailureCount <= 0) return '';\n\n  const total = entry.successCount + entry.pseudoFailureCount;\n  const failureRate = total > 0 ? entry.pseudoFailureCount / total : 1;\n  const tags = entry.lastPseudoTags.length > 0\n    ? `Last pseudo tags: ${entry.lastPseudoTags.join(', ')}.`\n    : 'Last pseudo tags: unknown.';\n\n  const severity = entry.successCount === 0 || failureRate >= 0.5\n    ? 'high'\n    : failureRate >= 0.25\n      ? 'medium'\n      : 'low';\n\n  return [\n    '### Tool-Call Compatibility',\n    `Model telemetry (${entry.provider}/${entry.model}) indicates ${severity} protocol risk: ${entry.pseudoFailureCount}/${total} prior turns returned pseudo tool markup.`,\n    tags,\n    'Emit native JSON tool calls only (no XML/plain-text pseudo directives).',\n  ].join('\\n');\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/core/tool-protocol.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/core/tools/executors.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":44,"column":48,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":44,"endColumn":50,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1818,1820],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'value ?? 'general'' will use Object's default stringification format ('[object Object]') when stringified.","line":156,"column":22,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":156,"endColumn":40},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'value ?? 'reflection'' will use Object's default stringification format ('[object Object]') when stringified.","line":171,"column":22,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":171,"endColumn":43},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'value ?? fallback' will use Object's default stringification format ('[object Object]') when stringified.","line":177,"column":22,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":177,"endColumn":39},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'item['label'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":187,"column":26,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":187,"endColumn":45},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'item['uri'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":188,"column":24,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":188,"endColumn":41},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":213,"column":23,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":213,"endColumn":25,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[8325,8327],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":213,"column":35,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":213,"endColumn":37,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[8337,8339],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":229,"column":41,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":229,"endColumn":43,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[8873,8875],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":230,"column":45,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":230,"endColumn":47,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[8937,8939],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":231,"column":54,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":231,"endColumn":56,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[9017,9019],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":233,"column":45,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":233,"endColumn":47,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[9128,9130],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":234,"column":52,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":234,"endColumn":54,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[9209,9211],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":236,"column":53,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":236,"endColumn":55,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[9299,9301],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":238,"column":41,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":238,"endColumn":43,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[9414,9416],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":238,"column":52,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":238,"endColumn":54,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[9425,9427],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":240,"column":49,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":240,"endColumn":51,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[9509,9511],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":240,"column":60,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":240,"endColumn":62,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[9520,9522],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":241,"column":56,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":241,"endColumn":58,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[9598,9600],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":241,"column":67,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":241,"endColumn":69,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[9609,9611],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":243,"column":45,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":243,"endColumn":47,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[9693,9695],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":243,"column":56,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":243,"endColumn":58,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[9704,9706],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":246,"column":39,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":246,"endColumn":41,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[9820,9822],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":246,"column":50,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":246,"endColumn":52,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[9831,9833],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":247,"column":43,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":247,"endColumn":45,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[9892,9894],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":247,"column":54,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":247,"endColumn":56,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[9903,9905],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":258,"column":30,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":258,"endColumn":32,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[10113,10115],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":285,"column":5,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":285,"endColumn":32},{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":1,"message":"Invalid type \"unknown\" of template literal expression.","line":287,"column":60,"nodeType":"Identifier","messageId":"invalidType","endLine":287,"endColumn":63},{"ruleId":"@typescript-eslint/return-await","severity":1,"message":"Returning an awaited value that is not a promise is not allowed.","line":349,"column":16,"nodeType":"AwaitExpression","messageId":"nonPromiseAwait","endLine":349,"endColumn":40,"fix":{"range":[12910,12916],"text":""}},{"ruleId":"@typescript-eslint/await-thenable","severity":1,"message":"Unexpected `await` of a non-Promise (non-\"Thenable\") value.","line":349,"column":16,"nodeType":"AwaitExpression","messageId":"await","endLine":349,"endColumn":40,"suggestions":[{"messageId":"removeAwait","fix":{"range":[12910,12915],"text":""},"desc":"Remove unnecessary `await`."}]},{"ruleId":"@typescript-eslint/return-await","severity":1,"message":"Returning an awaited value that is not a promise is not allowed.","line":351,"column":16,"nodeType":"AwaitExpression","messageId":"nonPromiseAwait","endLine":351,"endColumn":40,"fix":{"range":[12975,12981],"text":""}},{"ruleId":"@typescript-eslint/await-thenable","severity":1,"message":"Unexpected `await` of a non-Promise (non-\"Thenable\") value.","line":351,"column":16,"nodeType":"AwaitExpression","messageId":"await","endLine":351,"endColumn":40,"suggestions":[{"messageId":"removeAwait","fix":{"range":[12975,12980],"text":""},"desc":"Remove unnecessary `await`."}]},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['path'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":385,"column":31,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":385,"endColumn":49},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['path'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":401,"column":31,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":401,"endColumn":49},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['content'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":403,"column":26,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":403,"endColumn":47},{"ruleId":"@typescript-eslint/unbound-method","severity":1,"message":"A method that is not declared with `this: void` may cause unintentional scoping of `this` when separated from its object.\nConsider using an arrow function or explicitly `.bind()`ing the method to avoid calling the method with an unintended `this` value. \nIf a function does not access `this`, it can be annotated with `this: void`.","line":406,"column":11,"nodeType":"Identifier","messageId":"unboundWithoutThisAnnotation","endLine":406,"endColumn":18},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['path'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":414,"column":31,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":414,"endColumn":49},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['old_text'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":416,"column":26,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":416,"endColumn":48},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['new_text'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":417,"column":26,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":417,"endColumn":48},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['path'] ?? '.'' will use Object's default stringification format ('[object Object]') when stringified.","line":436,"column":31,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":436,"endColumn":50},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['pattern'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":461,"column":26,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":461,"endColumn":47},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['path'] ?? '.'' will use Object's default stringification format ('[object Object]') when stringified.","line":462,"column":37,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":462,"endColumn":56},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['glob']' will use Object's default stringification format ('[object Object]') when stringified.","line":463,"column":38,"nodeType":"MemberExpression","messageId":"baseToString","endLine":463,"endColumn":50},{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":1,"message":"Invalid type \"unknown\" of template literal expression.","line":486,"column":67,"nodeType":"Identifier","messageId":"invalidType","endLine":486,"endColumn":70},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":506,"column":24,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":506,"endColumn":33},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['pattern'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":521,"column":26,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":521,"endColumn":47},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['path'] ?? '.'' will use Object's default stringification format ('[object Object]') when stringified.","line":522,"column":37,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":522,"endColumn":56},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['command'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":535,"column":26,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":535,"endColumn":47},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['question'] ?? 'What would you like to do?'' will use Object's default stringification format ('[object Object]') when stringified.","line":554,"column":27,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":554,"endColumn":75},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['file'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":563,"column":23,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":563,"endColumn":41},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['query'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":569,"column":24,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":569,"endColumn":43},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":576,"column":18,"nodeType":"ChainExpression","messageId":"neverNullish","endLine":576,"endColumn":43},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":576,"column":31,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":576,"endColumn":33,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[20340,20342],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":601,"column":52,"nodeType":"ChainExpression","messageId":"neverNullish","endLine":601,"endColumn":76},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":601,"column":61,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":601,"endColumn":63,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[21201,21203],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['url'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":610,"column":22,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":610,"endColumn":39},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":633,"column":14,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":633,"endColumn":27},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":635,"column":14,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":635,"endColumn":30},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":637,"column":14,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":637,"endColumn":27},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['query'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":661,"column":24,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":661,"endColumn":43},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'value ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":725,"column":22,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":725,"endColumn":33},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'value ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":733,"column":22,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":733,"endColumn":33},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['session_id']' will use Object's default stringification format ('[object Object]') when stringified.","line":794,"column":57,"nodeType":"MemberExpression","messageId":"baseToString","endLine":794,"endColumn":75},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['ws_endpoint']' will use Object's default stringification format ('[object Object]') when stringified.","line":807,"column":46,"nodeType":"MemberExpression","messageId":"baseToString","endLine":807,"endColumn":65},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['session_id'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":845,"column":28,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":845,"endColumn":52},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['url'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":846,"column":22,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":846,"endColumn":39},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['session_id'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":896,"column":28,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":896,"endColumn":52},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['selector'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":897,"column":27,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":897,"endColumn":49},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'policyArgs['url']' will use Object's default stringification format ('[object Object]') when stringified.","line":907,"column":35,"nodeType":"MemberExpression","messageId":"baseToString","endLine":907,"endColumn":52},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['session_id'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":953,"column":28,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":953,"endColumn":52},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['selector'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":954,"column":27,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":954,"endColumn":49},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['text'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":955,"column":23,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":955,"endColumn":41},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'policyArgs['url']' will use Object's default stringification format ('[object Object]') when stringified.","line":965,"column":35,"nodeType":"MemberExpression","messageId":"baseToString","endLine":965,"endColumn":52},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['session_id'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":1012,"column":28,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":1012,"endColumn":52},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['session_id'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":1054,"column":28,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":1054,"endColumn":52},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['session_id'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":1100,"column":28,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":1100,"endColumn":52},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['topic'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":1126,"column":24,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":1126,"endColumn":43},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['content'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":1127,"column":26,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":1127,"endColumn":47},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['id'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":1140,"column":21,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":1140,"endColumn":37},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['ts']' may use Object's default stringification format ('[object Object]') when stringified.","line":1143,"column":65,"nodeType":"MemberExpression","messageId":"baseToString","endLine":1143,"endColumn":75},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['from']' may use Object's default stringification format ('[object Object]') when stringified.","line":1178,"column":59,"nodeType":"MemberExpression","messageId":"baseToString","endLine":1178,"endColumn":71},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['to']' may use Object's default stringification format ('[object Object]') when stringified.","line":1179,"column":55,"nodeType":"MemberExpression","messageId":"baseToString","endLine":1179,"endColumn":65},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['query'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":1192,"column":24,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":1192,"endColumn":43},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['path'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":1215,"column":35,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":1215,"endColumn":53},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":1223,"column":17,"nodeType":"TSAsExpression","messageId":"neverNullish","endLine":1223,"endColumn":93},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":1231,"column":18,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":1231,"endColumn":27},{"ruleId":"@typescript-eslint/no-unnecessary-type-conversion","severity":1,"message":"Passing a string to String() does not change the type or value of the string.","line":1232,"column":30,"nodeType":"Identifier","messageId":"unnecessaryTypeConversion","endLine":1232,"endColumn":36,"suggestions":[{"messageId":"suggestRemove","fix":{"range":[40825,40848],"text":"(edit.path ?? '')"},"desc":"Remove the type conversion."},{"messageId":"suggestSatisfies","data":{"type":"string"},"fix":{"range":[40825,40848],"text":"(edit.path ?? '') satisfies string"},"desc":"Instead, assert that the value satisfies the string type."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":1232,"column":37,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":1232,"endColumn":46},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['content'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":1288,"column":26,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":1288,"endColumn":47},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['category'] ?? 'note'' will use Object's default stringification format ('[object Object]') when stringified.","line":1289,"column":27,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":1289,"endColumn":53},{"ruleId":"@typescript-eslint/unbound-method","severity":1,"message":"A method that is not declared with `this: void` may cause unintentional scoping of `this` when separated from its object.\nConsider using an arrow function or explicitly `.bind()`ing the method to avoid calling the method with an unintended `this` value. \nIf a function does not access `this`, it can be annotated with `this: void`.","line":1295,"column":11,"nodeType":"Identifier","messageId":"unboundWithoutThisAnnotation","endLine":1295,"endColumn":18},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['command'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":1350,"column":26,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":1350,"endColumn":47},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['label']' will use Object's default stringification format ('[object Object]') when stringified.","line":1352,"column":40,"nodeType":"MemberExpression","messageId":"baseToString","endLine":1352,"endColumn":53},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['id']' will use Object's default stringification format ('[object Object]') when stringified.","line":1360,"column":34,"nodeType":"MemberExpression","messageId":"baseToString","endLine":1360,"endColumn":44},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['id'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":1379,"column":21,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":1379,"endColumn":37},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['id'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":1397,"column":21,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":1397,"endColumn":37},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":1398,"column":19,"nodeType":"TSAsExpression","messageId":"neverNullish","endLine":1398,"endColumn":51}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":98,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { readFile, writeFile, readdir } from 'node:fs/promises';\nimport { randomUUID } from 'node:crypto';\nimport { resolve, relative } from 'node:path';\nimport { realpathSync } from 'node:fs';\nimport chalk from 'chalk';\nimport { debug } from '../debug.js';\nimport { errorMessage } from '../../utils/errors.js';\nimport type { OptaConfig } from '../config.js';\nimport { resolveBrowserPolicyConfig } from '../browser-policy-config.js';\nimport { ProcessManager, type ProcessStatus } from '../background.js';\nimport { DEFAULT_IGNORE_DIRS } from '../../utils/ignore.js';\nimport {\n  BrowserRuntimeDaemon,\n  getSharedBrowserRuntimeDaemon,\n  resetSharedBrowserRuntimeDaemonForTests,\n} from '../../browser/runtime-daemon.js';\nimport { evaluateBrowserPolicyAction } from '../../browser/policy-engine.js';\nimport { withRetryTaxonomy } from '../../browser/retry-taxonomy.js';\nimport {\n  appendLedgerEntry,\n  learningLedgerPath,\n  readLedgerEntries,\n} from '../../learning/ledger.js';\nimport { retrieveTopLedgerEntries } from '../../learning/retrieval.js';\nimport { summarizeLedgerByDate } from '../../learning/summarizer.js';\nimport type {\n  CaptureLevel,\n  LearningEntryKind,\n  LearningLedgerEntry,\n} from '../../learning/types.js';\nimport { checkResearchProviderHealth } from '../../research/health.js';\nimport { routeResearchQuery } from '../../research/router.js';\nimport type { ResearchProviderId, ResearchQueryIntent } from '../../research/types.js';\n\n// --- Error Recovery Hints ---\n\n/**\n * Map common error codes/messages to actionable recovery hints.\n * Returns a user-friendly message with a concrete next step.\n * Includes dim slash command suggestions for in-REPL recovery.\n */\nexport function enrichError(error: unknown): string {\n  const message = errorMessage(error);\n  const code = (error as NodeJS.ErrnoException)?.code;\n\n  // Network: connection refused\n  if (code === 'ECONNREFUSED' || message.includes('ECONNREFUSED') || message.includes('fetch failed')) {\n    return `${message}\\n  Hint: LMX unreachable \\u2014 check connection with /status or run opta doctor`\n      + chalk.dim('\\n  Try: /status or /serve status');\n  }\n\n  // Network: timeout\n  if (code === 'ETIMEDOUT' || message.includes('ETIMEDOUT') || message.includes('AbortError') || message.includes('timed out')) {\n    return `${message}\\n  Hint: Request timed out \\u2014 LMX may be overloaded. Try: opta status`\n      + chalk.dim('\\n  Try: /status');\n  }\n\n  // Network: DNS resolution failure\n  if (code === 'ENOTFOUND' || message.includes('ENOTFOUND')) {\n    return `${message}\\n  Hint: Host not found \\u2014 check connection.host in config: opta config list`\n      + chalk.dim('\\n  Try: /config search connection');\n  }\n\n  // File: permission denied\n  if (code === 'EACCES' || message.includes('EACCES') || message.includes('permission denied')) {\n    return `${message}\\n  Hint: Permission denied \\u2014 check file permissions or run with appropriate access`\n      + chalk.dim('\\n  Try: /permissions to review tool access levels');\n  }\n\n  // File: not found\n  if (code === 'ENOENT' || message.includes('ENOENT') || message.includes('no such file')) {\n    // Try to extract the path from the error message\n    const pathMatch = message.match(/'([^']+)'/);\n    const parentDir = pathMatch?.[1]?.split('/').slice(0, -1).join('/');\n    const hint = parentDir\n      ? `Hint: File not found \\u2014 verify the path exists: ls ${parentDir}`\n      : 'Hint: File not found \\u2014 verify the path exists';\n    return `${message}\\n  ${hint}`\n      + chalk.dim('\\n  Try: /diff to see recent changes');\n  }\n\n  // File: directory not empty\n  if (code === 'ENOTEMPTY' || message.includes('ENOTEMPTY')) {\n    return `${message}\\n  Hint: Directory not empty \\u2014 remove contents first or use recursive delete`;\n  }\n\n  // File: path is a directory\n  if (code === 'EISDIR' || message.includes('EISDIR')) {\n    return `${message}\\n  Hint: Path is a directory, not a file \\u2014 check the target path`;\n  }\n\n  // Process: command not found\n  if (message.includes('command not found') || message.includes('not found') && message.includes('sh:')) {\n    return `${message}\\n  Hint: Command not found \\u2014 check spelling or install the missing tool`\n      + chalk.dim('\\n  Try: /doctor for diagnostics');\n  }\n\n  // Path traversal\n  if (message.includes('Path traversal blocked')) {\n    return `${message}\\n  Hint: Tool can only access files within the working directory`;\n  }\n\n  // Unknown errors get a generic diagnostic suggestion\n  return message + chalk.dim('\\n  Try: /doctor for diagnostics');\n}\n\nconst RESEARCH_INTENTS: ResearchQueryIntent[] = ['general', 'news', 'academic', 'coding'];\nconst RESEARCH_INTENT_SET = new Set<ResearchQueryIntent>(RESEARCH_INTENTS);\nconst RESEARCH_PROVIDER_IDS: ResearchProviderId[] = ['tavily', 'gemini', 'exa', 'brave', 'groq'];\nconst RESEARCH_PROVIDER_SET = new Set<ResearchProviderId>(RESEARCH_PROVIDER_IDS);\n\nconst LEARNING_KINDS: LearningEntryKind[] = [\n  'plan',\n  'problem',\n  'solution',\n  'reflection',\n  'research',\n];\nconst LEARNING_KIND_SET = new Set<LearningEntryKind>(LEARNING_KINDS);\n\nconst CAPTURE_LEVELS: CaptureLevel[] = ['exhaustive', 'balanced', 'lean'];\nconst CAPTURE_LEVEL_SET = new Set<CaptureLevel>(CAPTURE_LEVELS);\n\nfunction toPositiveInt(value: unknown, fallback: number): number {\n  const parsed = Number(value);\n  if (!Number.isFinite(parsed) || parsed <= 0) return fallback;\n  return Math.floor(parsed);\n}\n\nfunction toOptionalTimeoutMs(value: unknown): number | undefined {\n  if (value === undefined) return undefined;\n  const parsed = Number(value);\n  if (!Number.isFinite(parsed) || parsed <= 0) return undefined;\n  return Math.floor(parsed);\n}\n\nfunction toOptionalNumber(value: unknown): number | undefined {\n  if (value === undefined) return undefined;\n  const parsed = Number(value);\n  if (!Number.isFinite(parsed)) return undefined;\n  return parsed;\n}\n\nfunction toStringArray(value: unknown): string[] {\n  if (!Array.isArray(value)) return [];\n  return value\n    .map((item) => String(item).trim())\n    .filter((item) => item.length > 0);\n}\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return value !== null && typeof value === 'object' && !Array.isArray(value);\n}\n\nfunction parseResearchIntent(value: unknown): ResearchQueryIntent {\n  const raw = String(value ?? 'general').trim().toLowerCase() as ResearchQueryIntent;\n  if (RESEARCH_INTENT_SET.has(raw)) return raw;\n  return 'general';\n}\n\nfunction parseProviderOrder(value: unknown): ResearchProviderId[] | undefined {\n  if (!Array.isArray(value)) return undefined;\n  const parsed = value\n    .map((item) => String(item).trim().toLowerCase() as ResearchProviderId)\n    .filter((item) => RESEARCH_PROVIDER_SET.has(item));\n  if (parsed.length === 0) return undefined;\n  return Array.from(new Set(parsed));\n}\n\nfunction parseLearningKind(value: unknown): LearningEntryKind {\n  const raw = String(value ?? 'reflection').trim().toLowerCase() as LearningEntryKind;\n  if (LEARNING_KIND_SET.has(raw)) return raw;\n  return 'reflection';\n}\n\nfunction parseCaptureLevel(value: unknown, fallback: CaptureLevel): CaptureLevel {\n  const raw = String(value ?? fallback).trim().toLowerCase() as CaptureLevel;\n  if (CAPTURE_LEVEL_SET.has(raw)) return raw;\n  return fallback;\n}\n\nfunction parseLearningEvidence(value: unknown): LearningLedgerEntry['evidence'] {\n  if (!Array.isArray(value)) return [];\n  const evidence: LearningLedgerEntry['evidence'] = [];\n  for (const item of value) {\n    if (!isRecord(item)) continue;\n    const label = String(item['label'] ?? '').trim();\n    const uri = String(item['uri'] ?? '').trim();\n    if (!label || !uri) continue;\n    evidence.push({ label, uri });\n  }\n  return evidence;\n}\n\nfunction compactText(value: string, maxChars: number): string {\n  const normalized = value.replace(/\\s+/g, ' ').trim();\n  if (normalized.length <= maxChars) return normalized;\n  return `${normalized.slice(0, maxChars)}...`;\n}\n\nasync function loadRuntimeConfigSafe(): Promise<OptaConfig | null> {\n  try {\n    const { loadConfig } = await import('../config.js');\n    return await loadConfig();\n  } catch {\n    return null;\n  }\n}\n\nasync function resolveBrowserPolicyAdaptationHint(\n  config: OptaConfig | null,\n): Promise<import('../../browser/adaptation.js').BrowserPolicyAdaptationHint | undefined> {\n  if (!config?.browser?.adaptation?.enabled) return undefined;\n  try {\n    const { loadBrowserRunCorpusAdaptationHint } = await import('../../browser/adaptation.js');\n    const hint = await loadBrowserRunCorpusAdaptationHint(\n      process.cwd(),\n      config.browser.adaptation,\n    );\n    return hint.policy;\n  } catch {\n    return undefined;\n  }\n}\n\nasync function getBrowserRuntimeDaemon(config: OptaConfig | null): Promise<BrowserRuntimeDaemon> {\n  const daemon = await getSharedBrowserRuntimeDaemon({\n    cwd: process.cwd(),\n    maxSessions: config?.browser.runtime?.maxSessions ?? 3,\n    persistSessions: config?.browser.runtime?.persistSessions ?? true,\n    persistProfileContinuity: config?.browser.runtime?.persistProfileContinuity ?? false,\n    profileRetentionPolicy: {\n      retentionDays: config?.browser.runtime?.profileRetentionDays ?? 30,\n      maxPersistedProfiles: config?.browser.runtime?.maxPersistedProfiles ?? 200,\n    },\n    profilePruneIntervalMs: (config?.browser.runtime?.profilePruneIntervalHours ?? 24) * 60 * 60 * 1_000,\n    artifactPrune: {\n      enabled: config?.browser.artifacts?.retention?.enabled ?? false,\n      policy: {\n        retentionDays: config?.browser.artifacts?.retention?.retentionDays ?? 30,\n        maxPersistedSessions: config?.browser.artifacts?.retention?.maxPersistedSessions ?? 200,\n      },\n      intervalMs: (config?.browser.artifacts?.retention?.pruneIntervalHours ?? 24) * 60 * 60 * 1_000,\n    },\n    runCorpusRefresh: {\n      enabled: config?.browser.runtime?.runCorpus?.enabled ?? true,\n      windowHours: config?.browser.runtime?.runCorpus?.windowHours ?? 168,\n    },\n  });\n  await daemon.start();\n  return daemon;\n}\n\nfunction browserRuntimeDisabled(\n  config: OptaConfig | null,\n  sessionId: string,\n): string | null {\n  if (config?.browser.runtime?.enabled === false) {\n    const disabledError = withRetryTaxonomy(\n      'BROWSER_RUNTIME_DISABLED',\n      'Browser runtime is disabled by config (browser.runtime.enabled=false).',\n    );\n    return browserErrorResult(\n      sessionId,\n      disabledError.code,\n      disabledError.message,\n      disabledError,\n    );\n  }\n  return null;\n}\n\nexport async function resetBrowserRuntimeForTests(): Promise<void> {\n  await resetSharedBrowserRuntimeDaemonForTests();\n}\n\n// --- Tool Executors ---\n\nexport async function executeTool(\n  name: string,\n  argsJson: string\n): Promise<string> {\n  let args: Record<string, unknown>;\n  try {\n    args = JSON.parse(argsJson);\n  } catch (err) {\n    return `Error: Invalid JSON arguments: ${argsJson} - ${err}`;\n  }\n\n  debug(`Executing tool: ${name}(${JSON.stringify(args)})`);\n\n  try {\n    switch (name) {\n      case 'read_file':\n        return await execReadFile(args);\n      case 'write_file':\n        return await execWriteFile(args);\n      case 'edit_file':\n        return await execEditFile(args);\n      case 'list_dir':\n        return await execListDir(args);\n      case 'search_files':\n        return await execSearchFiles(args);\n      case 'find_files':\n        return await execFindFiles(args);\n      case 'run_command':\n        return await execRunCommand(args);\n      case 'ask_user':\n        return await execAskUser(args);\n      case 'read_project_docs':\n        return await execReadProjectDocs(args);\n      case 'web_search':\n        return await execWebSearch(args);\n      case 'web_fetch':\n        return await execWebFetch(args);\n      case 'research_query':\n        return await execResearchQuery(args);\n      case 'research_health':\n        return await execResearchHealth();\n      case 'browser_open':\n        return await execBrowserOpen(args);\n      case 'browser_navigate':\n        return await execBrowserNavigate(args);\n      case 'browser_click':\n        return await execBrowserClick(args);\n      case 'browser_type':\n        return await execBrowserType(args);\n      case 'browser_snapshot':\n        return await execBrowserSnapshot(args);\n      case 'browser_screenshot':\n        return await execBrowserScreenshot(args);\n      case 'browser_close':\n        return await execBrowserClose(args);\n      case 'learning_log':\n        return await execLearningLog(args);\n      case 'learning_summary':\n        return await execLearningSummary(args);\n      case 'learning_retrieve':\n        return await execLearningRetrieve(args);\n      case 'delete_file':\n        return await execDeleteFile(args);\n      case 'multi_edit':\n        return await execMultiEdit(args);\n      case 'save_memory':\n        return await execSaveMemory(args);\n      case 'bg_start':\n        return await execBgStart(args);\n      case 'bg_status':\n        return await execBgStatus(args);\n      case 'bg_output':\n        return await execBgOutput(args);\n      case 'bg_kill':\n        return await execBgKill(args);\n      default:\n        return `Error: Unknown tool \"${name}\"`;\n    }\n  } catch (err) {\n    return `Error: ${enrichError(err)}`;\n  }\n}\n\n// --- Path Traversal Guard ---\n\nexport function assertWithinCwd(resolvedPath: string): void {\n  // Use realpathSync on cwd to resolve symlinks (e.g., macOS /var -> /private/var).\n  // For the target path, try realpathSync first; if it doesn't exist yet, walk up\n  // to the nearest existing ancestor and check from there.\n  const cwd = realpathSync(process.cwd());\n  let normalized: string;\n  try {\n    normalized = realpathSync(resolvedPath);\n  } catch {\n    // Path doesn't exist yet (e.g., write_file to new location).\n    // Resolve without symlink expansion but normalize cwd-relative.\n    normalized = resolve(cwd, resolvedPath);\n  }\n  if (!normalized.startsWith(cwd + '/') && normalized !== cwd) {\n    throw new Error(`Path traversal blocked: \"${normalized}\" is outside working directory \"${cwd}\"`);\n  }\n}\n\n// --- Individual Tool Implementations ---\n\nasync function execReadFile(args: Record<string, unknown>): Promise<string> {\n  const path = resolve(String(args['path'] ?? ''));\n  assertWithinCwd(path);\n  const offset = Number(args['offset'] ?? 1);\n  const limit = Number(args['limit'] ?? 0);\n\n  const content = await readFile(path, 'utf-8');\n  const lines = content.split('\\n');\n\n  const start = Math.max(0, offset - 1);\n  const end = limit > 0 ? start + limit : lines.length;\n  const slice = lines.slice(start, end);\n\n  return slice.map((line, i) => `${start + i + 1}\\t${line}`).join('\\n');\n}\n\nasync function execWriteFile(args: Record<string, unknown>): Promise<string> {\n  const path = resolve(String(args['path'] ?? ''));\n  assertWithinCwd(path);\n  const content = String(args['content'] ?? '');\n\n  const { mkdir } = await import('node:fs/promises');\n  const { dirname } = await import('node:path');\n  await mkdir(dirname(path), { recursive: true });\n  await writeFile(path, content, 'utf-8');\n\n  return `File written: ${relative(process.cwd(), path)} (${content.length} bytes)`;\n}\n\nasync function execEditFile(args: Record<string, unknown>): Promise<string> {\n  const path = resolve(String(args['path'] ?? ''));\n  assertWithinCwd(path);\n  const oldText = String(args['old_text'] ?? '');\n  const newText = String(args['new_text'] ?? '');\n\n  const content = await readFile(path, 'utf-8');\n\n  const occurrences = content.split(oldText).length - 1;\n  if (occurrences === 0) {\n    return `Error: old_text not found in ${relative(process.cwd(), path)}`;\n  }\n  if (occurrences > 1) {\n    return `Error: old_text appears ${occurrences} times in ${relative(process.cwd(), path)}  must be unique`;\n  }\n\n  const updated = content.replace(oldText, newText);\n  await writeFile(path, updated, 'utf-8');\n\n  return `File edited: ${relative(process.cwd(), path)}`;\n}\n\nasync function execListDir(args: Record<string, unknown>): Promise<string> {\n  const path = resolve(String(args['path'] ?? '.'));\n  assertWithinCwd(path);\n  const recursive = Boolean(args['recursive']);\n\n  if (recursive) {\n    const { default: fg } = await import('fast-glob');\n    const files = await fg('**/*', {\n      cwd: path,\n      dot: false,\n      onlyFiles: false,\n      ignore: [...DEFAULT_IGNORE_DIRS],\n    });\n    return files.sort().join('\\n') || '(empty directory)';\n  }\n\n  const entries = await readdir(path, { withFileTypes: true });\n  return (\n    entries\n      .map((e) => (e.isDirectory() ? `${e.name}/` : e.name))\n      .sort()\n      .join('\\n') || '(empty directory)'\n  );\n}\n\nasync function execSearchFiles(args: Record<string, unknown>): Promise<string> {\n  const pattern = String(args['pattern'] ?? '');\n  const searchPath = resolve(String(args['path'] ?? '.'));\n  const glob = args['glob'] ? String(args['glob']) : undefined;\n\n  // Try ripgrep first\n  try {\n    const { execa } = await import('execa');\n    const rgArgs = ['-n', '--max-count', '50', '--color', 'never'];\n    if (glob) rgArgs.push('--glob', glob);\n    rgArgs.push(pattern, searchPath);\n\n    const result = await execa('rg', rgArgs, { reject: false, timeout: 10000 });\n    if (result.stdout) {\n      // Make paths relative\n      return result.stdout\n        .split('\\n')\n        .map((line) => {\n          const rel = relative(process.cwd(), line.split(':')[0] ?? '');\n          const rest = line.substring((line.split(':')[0] ?? '').length);\n          return rel + rest;\n        })\n        .join('\\n');\n    }\n    if (result.exitCode === 1) return 'No matches found.';\n  } catch (err) {\n    debug(`ripgrep not available, falling back to basic search: ${err}`);\n  }\n\n  // Fallback: fast-glob + readFile\n  const { default: fg } = await import('fast-glob');\n  const files = await fg(glob ?? '**/*', {\n    cwd: searchPath,\n    dot: false,\n    ignore: [...DEFAULT_IGNORE_DIRS],\n  });\n\n  const results: string[] = [];\n  const regex = new RegExp(pattern);\n\n  for (const file of files.slice(0, 100)) {\n    try {\n      const fullPath = resolve(searchPath, file);\n      const content = await readFile(fullPath, 'utf-8');\n      const lines = content.split('\\n');\n      for (let i = 0; i < lines.length; i++) {\n        if (regex.test(lines[i]!)) {\n          results.push(`${file}:${i + 1}:${lines[i]}`);\n          if (results.length >= 50) break;\n        }\n      }\n    } catch {\n      // Skip unreadable files\n    }\n    if (results.length >= 50) break;\n  }\n\n  return results.length > 0 ? results.join('\\n') : 'No matches found.';\n}\n\nasync function execFindFiles(args: Record<string, unknown>): Promise<string> {\n  const pattern = String(args['pattern'] ?? '');\n  const searchPath = resolve(String(args['path'] ?? '.'));\n\n  const { default: fg } = await import('fast-glob');\n  const files = await fg(pattern, {\n    cwd: searchPath,\n    dot: false,\n    ignore: [...DEFAULT_IGNORE_DIRS],\n  });\n\n  return files.length > 0 ? files.sort().join('\\n') : 'No files found.';\n}\n\nasync function execRunCommand(args: Record<string, unknown>): Promise<string> {\n  const command = String(args['command'] ?? '');\n  const timeout = Number(args['timeout'] ?? 30000);\n\n  const { execa } = await import('execa');\n  const result = await execa('sh', ['-c', command], {\n    reject: false,\n    timeout,\n    cwd: process.cwd(),\n  });\n\n  let output = '';\n  if (result.stdout) output += result.stdout;\n  if (result.stderr) output += (output ? '\\n' : '') + `[stderr] ${result.stderr}`;\n  output += `\\n[exit code: ${result.exitCode}]`;\n\n  return output;\n}\n\nasync function execAskUser(args: Record<string, unknown>): Promise<string> {\n  const question = String(args['question'] ?? 'What would you like to do?');\n\n  const { input } = await import('@inquirer/prompts');\n  const answer = await input({ message: question });\n\n  return answer;\n}\n\nasync function execReadProjectDocs(args: Record<string, unknown>): Promise<string> {\n  const file = String(args['file'] ?? '');\n  const { readProjectDoc } = await import('../../context/opis.js');\n  return readProjectDoc(process.cwd(), file);\n}\n\nasync function execWebSearch(args: Record<string, unknown>): Promise<string> {\n  const query = String(args['query'] ?? '');\n  const maxResults = Number(args['max_results'] ?? 5);\n\n  let searxngUrl: string;\n  try {\n    const { loadConfig } = await import('../config.js');\n    const config = await loadConfig();\n    searxngUrl = config.search?.searxngUrl ?? '';\n  } catch {\n    return 'Error: Could not load config for search URL. Run: opta config set search.searxngUrl <url>';\n  }\n\n  if (!searxngUrl) {\n    return 'Error: No SearXNG URL configured. Run: opta config set search.searxngUrl <url>';\n  }\n\n  const url = `${searxngUrl}/search?q=${encodeURIComponent(query)}&format=json`;\n\n  try {\n    const response = await fetch(url, { signal: AbortSignal.timeout(10000) });\n    if (!response.ok) return `Error: Search returned ${response.status}`;\n\n    const data = (await response.json()) as {\n      results?: Array<{ title: string; url: string; content: string }>;\n    };\n    const results = (data.results ?? []).slice(0, maxResults);\n\n    if (results.length === 0) return 'No results found.';\n\n    return results\n      .map(\n        (r, i) =>\n          `${i + 1}. ${r.title}\\n   ${r.url}\\n   ${r.content?.slice(0, 200) ?? ''}`\n      )\n      .join('\\n\\n');\n  } catch (err) {\n    return `Error: Search failed  ${errorMessage(err)}`;\n  }\n}\n\nasync function execWebFetch(args: Record<string, unknown>): Promise<string> {\n  const url = String(args['url'] ?? '');\n  const maxChars = Number(args['max_chars'] ?? 10000);\n\n  // Security: only allow http:// and https:// URLs\n  if (!/^https?:\\/\\//i.test(url)) {\n    return `Error: Only http:// and https:// URLs are allowed (got \"${url}\")`;\n  }\n\n  try {\n    const response = await fetch(url, {\n      signal: AbortSignal.timeout(10000),\n      headers: { 'User-Agent': 'Opta-CLI/0.1 (web-fetch)' },\n    });\n    if (!response.ok) return `Error: Fetch returned ${response.status}`;\n\n    let html = await response.text();\n\n    // Extract content from <main>, <article>, or <body> if present\n    const mainMatch = html.match(/<main[^>]*>([\\s\\S]*?)<\\/main>/i);\n    const articleMatch = html.match(/<article[^>]*>([\\s\\S]*?)<\\/article>/i);\n    const bodyMatch = html.match(/<body[^>]*>([\\s\\S]*?)<\\/body>/i);\n\n    if (mainMatch) {\n      html = mainMatch[1]!;\n    } else if (articleMatch) {\n      html = articleMatch[1]!;\n    } else if (bodyMatch) {\n      html = bodyMatch[1]!;\n    }\n\n    // Simple HTML-to-text: strip tags, decode entities, collapse whitespace\n    const text = html\n      .replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, '')\n      .replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, '')\n      .replace(/<[^>]+>/g, ' ')\n      .replace(/&nbsp;/g, ' ')\n      .replace(/&amp;/g, '&')\n      .replace(/&lt;/g, '<')\n      .replace(/&gt;/g, '>')\n      .replace(/&quot;/g, '\"')\n      .replace(/&#39;/g, \"'\")\n      .replace(/\\s+/g, ' ')\n      .trim();\n\n    return text.slice(0, maxChars);\n  } catch (err) {\n    return `Error: Fetch failed  ${errorMessage(err)}`;\n  }\n}\n\nasync function execResearchQuery(args: Record<string, unknown>): Promise<string> {\n  const query = String(args['query'] ?? '').trim();\n  if (!query) return 'Error: query is required';\n\n  const intent = parseResearchIntent(args['intent']);\n  const maxResults = toPositiveInt(args['max_results'], 5);\n  const providerOrder = parseProviderOrder(args['provider_order']);\n\n  const { loadConfig } = await import('../config.js');\n  const config = await loadConfig();\n\n  const result = await routeResearchQuery(\n    { query, intent, maxResults },\n    { config, providerOrder },\n  );\n\n  if (!result.ok) {\n    return JSON.stringify({\n      ok: false,\n      code: result.error.code,\n      message: result.error.message,\n      attempts: result.attempts.map((attempt) => ({\n        provider: attempt.provider,\n        code: attempt.error.code,\n      })),\n    });\n  }\n\n  return JSON.stringify({\n    ok: true,\n    provider: result.provider,\n    answer: compactText(result.result.answer, 1200),\n    citations: result.result.citations.slice(0, maxResults).map((citation) => ({\n      url: citation.url,\n      title: citation.title ?? '',\n      source: citation.source ?? '',\n    })),\n    attempts: result.attempts.map((attempt) => ({\n      provider: attempt.provider,\n      code: attempt.error.code,\n    })),\n  });\n}\n\nasync function execResearchHealth(): Promise<string> {\n  const { loadConfig } = await import('../config.js');\n  const config = await loadConfig();\n  const summary = await checkResearchProviderHealth({ config });\n\n  const checks = [...summary.checks]\n    .sort((a, b) => a.provider.localeCompare(b.provider))\n    .map((check) => ({\n      provider: check.provider,\n      status: check.status,\n      latency_ms: check.latencyMs,\n      error_code: check.error?.code ?? null,\n    }));\n\n  return JSON.stringify({\n    ok: summary.ok,\n    checks,\n  });\n}\n\nfunction parseBrowserMode(value: unknown): 'isolated' | 'attach' | undefined {\n  const raw = String(value ?? '').trim().toLowerCase();\n  if (raw === 'isolated' || raw === 'attach') return raw;\n  return undefined;\n}\n\nfunction parseBrowserWaitUntil(\n  value: unknown,\n): 'load' | 'domcontentloaded' | 'networkidle' | 'commit' | undefined {\n  const raw = String(value ?? '').trim().toLowerCase();\n  if (\n    raw === 'load'\n    || raw === 'domcontentloaded'\n    || raw === 'networkidle'\n    || raw === 'commit'\n  ) {\n    return raw;\n  }\n  return undefined;\n}\n\nfunction browserErrorResult(\n  sessionId: string,\n  code: string,\n  message: string,\n  errorMeta?: {\n    retryable?: boolean;\n    retryCategory?: string;\n    retryHint?: string;\n  },\n): string {\n  const retryable = errorMeta?.retryable;\n  const retryCategory = errorMeta?.retryCategory;\n  const retryHint = errorMeta?.retryHint;\n  return JSON.stringify({\n    ok: false,\n    session_id: sessionId,\n    code,\n    message,\n    retryable: typeof retryable === 'boolean' ? retryable : null,\n    retry_category: typeof retryCategory === 'string' ? retryCategory : null,\n    retry_hint: typeof retryHint === 'string' ? retryHint : null,\n  });\n}\n\nfunction isBrowserPolicyApproved(args: Record<string, unknown>): boolean {\n  return Boolean(args['__browser_approved']);\n}\n\nfunction browserPolicyError(sessionId: string, code: string, reason: string): string {\n  const retry = withRetryTaxonomy(code, reason);\n  return browserErrorResult(sessionId, code, reason, retry);\n}\n\nasync function resolveBrowserSessionUrl(\n  config: OptaConfig | null,\n  sessionId: string,\n): Promise<string | undefined> {\n  try {\n    const daemon = await getBrowserRuntimeDaemon(config);\n    const session = daemon.health().sessions.find((item) => item.sessionId === sessionId);\n    const url = session?.currentUrl?.trim();\n    return url && url.length > 0 ? url : undefined;\n  } catch {\n    return undefined;\n  }\n}\n\nasync function execBrowserOpen(args: Record<string, unknown>): Promise<string> {\n  const config = await loadRuntimeConfigSafe();\n  const explicitSessionId = args['session_id'] ? String(args['session_id']) : undefined;\n  const disabled = browserRuntimeDisabled(config, explicitSessionId ?? 'browser-session');\n  if (disabled) return disabled;\n\n  let mode = parseBrowserMode(args['mode']);\n  if (!mode) {\n    mode = config?.browser.mode ?? 'isolated';\n  }\n\n  const daemon = await getBrowserRuntimeDaemon(config);\n  const result = await daemon.openSession({\n    sessionId: explicitSessionId,\n    mode,\n    wsEndpoint: args['ws_endpoint'] ? String(args['ws_endpoint']) : undefined,\n    headless: args['headless'] === undefined ? undefined : Boolean(args['headless']),\n  });\n\n  if (!result.ok) {\n    return browserErrorResult(\n      result.action.sessionId,\n      result.error?.code ?? 'OPEN_SESSION_FAILED',\n      result.error?.message ?? 'Failed to open browser session.',\n      result.error,\n    );\n  }\n\n  if (!result.data) {\n    const missingDataError = withRetryTaxonomy(\n      'OPEN_SESSION_FAILED',\n      'Missing session data from browser manager.',\n    );\n    return browserErrorResult(\n      result.action.sessionId,\n      missingDataError.code,\n      missingDataError.message,\n      missingDataError,\n    );\n  }\n\n  return JSON.stringify({\n    ok: true,\n    session_id: result.data.id,\n    mode: result.data.mode,\n    status: result.data.status,\n    runtime: result.data.runtime,\n    current_url: result.data.currentUrl ?? null,\n  });\n}\n\nasync function execBrowserNavigate(args: Record<string, unknown>): Promise<string> {\n  const config = await loadRuntimeConfigSafe();\n  const sessionId = String(args['session_id'] ?? '').trim();\n  const url = String(args['url'] ?? '').trim();\n  if (!sessionId) return 'Error: session_id is required';\n  if (!url) return 'Error: url is required';\n\n  const disabled = browserRuntimeDisabled(config, sessionId);\n  if (disabled) return disabled;\n  const adaptationHint = await resolveBrowserPolicyAdaptationHint(config);\n\n  const policyDecision = evaluateBrowserPolicyAction(resolveBrowserPolicyConfig(config), {\n    toolName: 'browser_navigate',\n    args: { ...args, url },\n    approved: isBrowserPolicyApproved(args),\n    adaptationHint,\n  });\n  if (policyDecision.decision === 'deny') {\n    return browserPolicyError(sessionId, 'BROWSER_POLICY_DENY', policyDecision.reason);\n  }\n  if (policyDecision.decision === 'gate') {\n    return browserPolicyError(\n      sessionId,\n      'BROWSER_POLICY_APPROVAL_REQUIRED',\n      policyDecision.reason,\n    );\n  }\n\n  const daemon = await getBrowserRuntimeDaemon(config);\n  const result = await daemon.navigate(sessionId, {\n    url,\n    timeoutMs: toOptionalTimeoutMs(args['timeout_ms']),\n    waitUntil: parseBrowserWaitUntil(args['wait_until']),\n  });\n\n  if (!result.ok) {\n    return browserErrorResult(\n      sessionId,\n      result.error?.code ?? 'NAVIGATE_FAILED',\n      result.error?.message ?? 'Failed to navigate browser session.',\n      result.error,\n    );\n  }\n\n  return JSON.stringify({\n    ok: true,\n    session_id: sessionId,\n    url: result.data?.url ?? null,\n  });\n}\n\nasync function execBrowserClick(args: Record<string, unknown>): Promise<string> {\n  const config = await loadRuntimeConfigSafe();\n  const sessionId = String(args['session_id'] ?? '').trim();\n  const selector = String(args['selector'] ?? '').trim();\n  if (!sessionId) return 'Error: session_id is required';\n  if (!selector) return 'Error: selector is required';\n\n  const disabled = browserRuntimeDisabled(config, sessionId);\n  if (disabled) return disabled;\n  const adaptationHint = await resolveBrowserPolicyAdaptationHint(config);\n  const sessionUrl = await resolveBrowserSessionUrl(config, sessionId);\n  const policyArgs: Record<string, unknown> = { ...args, selector };\n  if (\n    (!policyArgs['url'] || String(policyArgs['url']).trim().length === 0)\n    && sessionUrl\n  ) {\n    policyArgs['url'] = sessionUrl;\n  }\n\n  const policyDecision = evaluateBrowserPolicyAction(resolveBrowserPolicyConfig(config), {\n    toolName: 'browser_click',\n    args: policyArgs,\n    approved: isBrowserPolicyApproved(args),\n    adaptationHint,\n  });\n  if (policyDecision.decision === 'deny') {\n    return browserPolicyError(sessionId, 'BROWSER_POLICY_DENY', policyDecision.reason);\n  }\n  if (policyDecision.decision === 'gate') {\n    return browserPolicyError(\n      sessionId,\n      'BROWSER_POLICY_APPROVAL_REQUIRED',\n      policyDecision.reason,\n    );\n  }\n\n  const daemon = await getBrowserRuntimeDaemon(config);\n  const result = await daemon.click(sessionId, {\n    selector,\n    timeoutMs: toOptionalTimeoutMs(args['timeout_ms']),\n  });\n\n  if (!result.ok) {\n    return browserErrorResult(\n      sessionId,\n      result.error?.code ?? 'CLICK_FAILED',\n      result.error?.message ?? 'Failed to click selector.',\n      result.error,\n    );\n  }\n\n  return JSON.stringify({\n    ok: true,\n    session_id: sessionId,\n  });\n}\n\nasync function execBrowserType(args: Record<string, unknown>): Promise<string> {\n  const config = await loadRuntimeConfigSafe();\n  const sessionId = String(args['session_id'] ?? '').trim();\n  const selector = String(args['selector'] ?? '').trim();\n  const text = String(args['text'] ?? '');\n  if (!sessionId) return 'Error: session_id is required';\n  if (!selector) return 'Error: selector is required';\n\n  const disabled = browserRuntimeDisabled(config, sessionId);\n  if (disabled) return disabled;\n  const adaptationHint = await resolveBrowserPolicyAdaptationHint(config);\n  const sessionUrl = await resolveBrowserSessionUrl(config, sessionId);\n  const policyArgs: Record<string, unknown> = { ...args, selector, text };\n  if (\n    (!policyArgs['url'] || String(policyArgs['url']).trim().length === 0)\n    && sessionUrl\n  ) {\n    policyArgs['url'] = sessionUrl;\n  }\n\n  const policyDecision = evaluateBrowserPolicyAction(resolveBrowserPolicyConfig(config), {\n    toolName: 'browser_type',\n    args: policyArgs,\n    approved: isBrowserPolicyApproved(args),\n    adaptationHint,\n  });\n  if (policyDecision.decision === 'deny') {\n    return browserPolicyError(sessionId, 'BROWSER_POLICY_DENY', policyDecision.reason);\n  }\n  if (policyDecision.decision === 'gate') {\n    return browserPolicyError(\n      sessionId,\n      'BROWSER_POLICY_APPROVAL_REQUIRED',\n      policyDecision.reason,\n    );\n  }\n\n  const daemon = await getBrowserRuntimeDaemon(config);\n  const result = await daemon.type(sessionId, {\n    selector,\n    text,\n    timeoutMs: toOptionalTimeoutMs(args['timeout_ms']),\n  });\n\n  if (!result.ok) {\n    return browserErrorResult(\n      sessionId,\n      result.error?.code ?? 'TYPE_FAILED',\n      result.error?.message ?? 'Failed to type into selector.',\n      result.error,\n    );\n  }\n\n  return JSON.stringify({\n    ok: true,\n    session_id: sessionId,\n  });\n}\n\nasync function execBrowserSnapshot(args: Record<string, unknown>): Promise<string> {\n  const config = await loadRuntimeConfigSafe();\n  const sessionId = String(args['session_id'] ?? '').trim();\n  if (!sessionId) return 'Error: session_id is required';\n\n  const disabled = browserRuntimeDisabled(config, sessionId);\n  if (disabled) return disabled;\n\n  const daemon = await getBrowserRuntimeDaemon(config);\n  const result = await daemon.snapshot(sessionId);\n\n  if (!result.ok) {\n    return browserErrorResult(\n      sessionId,\n      result.error?.code ?? 'SNAPSHOT_FAILED',\n      result.error?.message ?? 'Failed to capture snapshot.',\n      result.error,\n    );\n  }\n\n  if (!result.data) {\n    const missingDataError = withRetryTaxonomy(\n      'SNAPSHOT_FAILED',\n      'Snapshot data missing from browser manager.',\n    );\n    return browserErrorResult(\n      sessionId,\n      missingDataError.code,\n      missingDataError.message,\n      missingDataError,\n    );\n  }\n\n  return JSON.stringify({\n    ok: true,\n    session_id: sessionId,\n    artifact_path: result.data.artifact.relativePath,\n    size_bytes: result.data.artifact.sizeBytes,\n    html_chars: result.data.html.length,\n  });\n}\n\nasync function execBrowserScreenshot(args: Record<string, unknown>): Promise<string> {\n  const config = await loadRuntimeConfigSafe();\n  const sessionId = String(args['session_id'] ?? '').trim();\n  if (!sessionId) return 'Error: session_id is required';\n\n  const disabled = browserRuntimeDisabled(config, sessionId);\n  if (disabled) return disabled;\n\n  const daemon = await getBrowserRuntimeDaemon(config);\n  const result = await daemon.screenshot(sessionId, {\n    fullPage: args['full_page'] === undefined ? undefined : Boolean(args['full_page']),\n    type: args['type'] === 'jpeg' ? 'jpeg' : args['type'] === 'png' ? 'png' : undefined,\n    quality: toOptionalNumber(args['quality']),\n  });\n\n  if (!result.ok) {\n    return browserErrorResult(\n      sessionId,\n      result.error?.code ?? 'SCREENSHOT_FAILED',\n      result.error?.message ?? 'Failed to capture screenshot.',\n      result.error,\n    );\n  }\n\n  if (!result.data) {\n    const missingDataError = withRetryTaxonomy(\n      'SCREENSHOT_FAILED',\n      'Screenshot data missing from browser manager.',\n    );\n    return browserErrorResult(\n      sessionId,\n      missingDataError.code,\n      missingDataError.message,\n      missingDataError,\n    );\n  }\n\n  return JSON.stringify({\n    ok: true,\n    session_id: sessionId,\n    artifact_path: result.data.artifact.relativePath,\n    size_bytes: result.data.artifact.sizeBytes,\n    mime_type: result.data.artifact.mimeType,\n  });\n}\n\nasync function execBrowserClose(args: Record<string, unknown>): Promise<string> {\n  const config = await loadRuntimeConfigSafe();\n  const sessionId = String(args['session_id'] ?? '').trim();\n  if (!sessionId) return 'Error: session_id is required';\n\n  const disabled = browserRuntimeDisabled(config, sessionId);\n  if (disabled) return disabled;\n\n  const daemon = await getBrowserRuntimeDaemon(config);\n  const result = await daemon.closeSession(sessionId);\n\n  if (!result.ok) {\n    return browserErrorResult(\n      sessionId,\n      result.error?.code ?? 'CLOSE_SESSION_FAILED',\n      result.error?.message ?? 'Failed to close browser session.',\n      result.error,\n    );\n  }\n\n  return JSON.stringify({\n    ok: true,\n    session_id: sessionId,\n    status: result.data?.status ?? 'closed',\n  });\n}\n\nasync function execLearningLog(args: Record<string, unknown>): Promise<string> {\n  const topic = String(args['topic'] ?? '').trim();\n  const content = String(args['content'] ?? '').trim();\n  if (!topic) return 'Error: topic is required';\n  if (!content) return 'Error: content is required';\n\n  let defaultCaptureLevel: CaptureLevel = 'balanced';\n  try {\n    const { loadConfig } = await import('../config.js');\n    const config = await loadConfig();\n    defaultCaptureLevel = config.learning.captureLevel;\n  } catch {\n    // Fallback to deterministic local default.\n  }\n\n  const id = String(args['id'] ?? '').trim()\n    || `learn-${Date.now()}-${randomUUID().slice(0, 8)}`;\n\n  const tsInput = args['ts'] === undefined ? undefined : String(args['ts']);\n  const tsDate = tsInput ? new Date(tsInput) : new Date();\n  if (Number.isNaN(tsDate.getTime())) {\n    return 'Error: ts must be a valid date/time';\n  }\n  const ts = tsDate.toISOString();\n\n  const entry: LearningLedgerEntry = {\n    id,\n    ts,\n    kind: parseLearningKind(args['kind']),\n    captureLevel: parseCaptureLevel(args['capture_level'], defaultCaptureLevel),\n    topic,\n    content,\n    tags: Array.from(new Set(toStringArray(args['tags']))),\n    evidence: parseLearningEvidence(args['evidence']),\n    metadata: isRecord(args['metadata']) ? args['metadata'] : {},\n  };\n\n  await appendLedgerEntry(entry);\n\n  return JSON.stringify({\n    ok: true,\n    id: entry.id,\n    ts: entry.ts,\n    kind: entry.kind,\n    capture_level: entry.captureLevel,\n    topic: entry.topic,\n    ledger_path: learningLedgerPath(process.cwd()),\n  });\n}\n\nasync function execLearningSummary(args: Record<string, unknown>): Promise<string> {\n  const entries = await readLedgerEntries();\n  const summary = summarizeLedgerByDate(entries, {\n    from: args['from'] === undefined ? undefined : String(args['from']),\n    to: args['to'] === undefined ? undefined : String(args['to']),\n  });\n\n  const maxChars = toPositiveInt(args['max_chars'], 4000);\n  if (summary.length <= maxChars) {\n    return summary;\n  }\n\n  const truncated = summary.slice(0, maxChars).trimEnd();\n  return `${truncated}\\n...[truncated]`;\n}\n\nasync function execLearningRetrieve(args: Record<string, unknown>): Promise<string> {\n  const query = String(args['query'] ?? '').trim();\n  if (!query) return 'Error: query is required';\n\n  const limit = toPositiveInt(args['limit'], 5);\n  const entries = await readLedgerEntries();\n  const ranked = retrieveTopLedgerEntries(query, entries, limit).filter((item) => item.score > 0);\n\n  return JSON.stringify({\n    ok: true,\n    query,\n    count: ranked.length,\n    results: ranked.map((item) => ({\n      id: item.entry.id,\n      ts: item.entry.ts,\n      kind: item.entry.kind,\n      topic: item.entry.topic,\n      score: Number(item.score.toFixed(4)),\n      content: compactText(item.entry.content, 240),\n    })),\n  });\n}\n\nasync function execDeleteFile(args: Record<string, unknown>): Promise<string> {\n  const filePath = resolve(String(args['path'] ?? ''));\n  assertWithinCwd(filePath);\n  const { unlink } = await import('node:fs/promises');\n  await unlink(filePath);\n  return `File deleted: ${relative(process.cwd(), filePath)}`;\n}\n\nasync function execMultiEdit(args: Record<string, unknown>): Promise<string> {\n  const edits = args['edits'] as Array<{ path: string; old_text: string; new_text: string }> ?? [];\n\n  if (edits.length === 0) return 'Error: No edits provided';\n  if (edits.length > 20) return `Error: Too many edits (${edits.length}). Maximum 20 per call.`;\n\n  // Group edits by file path, preserving original indices for error reporting\n  const fileGroups = new Map<string, Array<{ index: number; old_text: string; new_text: string }>>();\n  for (let i = 0; i < edits.length; i++) {\n    const edit = edits[i]!;\n    const filePath = resolve(String(edit.path ?? ''));\n    assertWithinCwd(filePath);\n    const group = fileGroups.get(filePath) ?? [];\n    group.push({ index: i, old_text: edit.old_text, new_text: edit.new_text });\n    fileGroups.set(filePath, group);\n  }\n\n  let appliedCount = 0;\n  const failures: string[] = [];\n  const fileSummaries: string[] = [];\n\n  for (const [filePath, group] of fileGroups) {\n    let content: string;\n    try {\n      content = await readFile(filePath, 'utf-8');\n    } catch (err) {\n      // All edits for this file fail\n      for (const edit of group) {\n        failures.push(`edit #${edit.index + 1} in ${relative(process.cwd(), filePath)}: ${errorMessage(err)}`);\n      }\n      continue;\n    }\n\n    let fileApplied = 0;\n    for (const edit of group) {\n      const occurrences = content.split(edit.old_text).length - 1;\n      if (occurrences === 0) {\n        failures.push(`edit #${edit.index + 1} in ${relative(process.cwd(), filePath)}: old_text not found`);\n        continue;\n      }\n      if (occurrences > 1) {\n        failures.push(`edit #${edit.index + 1} in ${relative(process.cwd(), filePath)}: old_text appears ${occurrences} times (must be unique)`);\n        continue;\n      }\n      content = content.replace(edit.old_text, edit.new_text);\n      fileApplied++;\n    }\n\n    if (fileApplied > 0) {\n      await writeFile(filePath, content, 'utf-8');\n      fileSummaries.push(`${relative(process.cwd(), filePath)} (${fileApplied} edit${fileApplied > 1 ? 's' : ''})`);\n      appliedCount += fileApplied;\n    }\n  }\n\n  const total = edits.length;\n  let result = `Applied ${appliedCount}/${total} edits across ${fileGroups.size} file${fileGroups.size > 1 ? 's' : ''}: ${fileSummaries.join(', ')}`;\n\n  if (failures.length > 0) {\n    result += `\\nFailed: ${failures.join('; ')}`;\n  }\n\n  return result;\n}\n\nasync function execSaveMemory(args: Record<string, unknown>): Promise<string> {\n  const content = String(args['content'] ?? '');\n  const category = String(args['category'] ?? 'note');\n  const timestamp = new Date().toISOString().split('T')[0];\n\n  const memoryPath = resolve(process.cwd(), '.opta', 'memory.md');\n\n  const { mkdir } = await import('node:fs/promises');\n  const { dirname } = await import('node:path');\n  await mkdir(dirname(memoryPath), { recursive: true });\n\n  let existing = '';\n  try {\n    existing = await readFile(memoryPath, 'utf-8');\n  } catch {\n    existing = '# Project Memory\\n\\n';\n  }\n\n  const entry = `\\n## [${category}] ${timestamp}\\n\\n${content}\\n`;\n  await writeFile(memoryPath, existing + entry, 'utf-8');\n\n  return `Memory saved to .opta/memory.md (${category})`;\n}\n\n// --- Background Process Management ---\n\nlet _processManager: ProcessManager | null = null;\n\nfunction getProcessManager(): ProcessManager {\n  if (!_processManager) {\n    // Use defaults; config-driven values set via initProcessManager()\n    _processManager = new ProcessManager({\n      maxConcurrent: 5,\n      defaultTimeout: 300_000,\n      maxBufferSize: 1_048_576,\n    });\n  }\n  return _processManager;\n}\n\nexport function initProcessManager(config: OptaConfig): void {\n  _processManager = new ProcessManager({\n    maxConcurrent: config.background.maxConcurrent,\n    defaultTimeout: config.background.defaultTimeout,\n    maxBufferSize: config.background.maxBufferSize,\n  });\n}\n\nexport async function shutdownProcessManager(): Promise<void> {\n  if (_processManager) {\n    await _processManager.cleanup();\n    _processManager = null;\n  }\n}\n\nexport function forceKillAllProcesses(): void {\n  if (_processManager) {\n    _processManager.killAll().catch(() => {});\n    _processManager = null;\n  }\n}\n\nasync function execBgStart(args: Record<string, unknown>): Promise<string> {\n  const command = String(args['command'] ?? '');\n  const timeout = args['timeout'] !== undefined ? Number(args['timeout']) : undefined;\n  const label = args['label'] ? String(args['label']) : undefined;\n\n  const pm = getProcessManager();\n  const handle = await pm.start(command, { timeout, label });\n  return `Process started: id=${handle.id} pid=${handle.pid} cmd=\"${command}\"`;\n}\n\nfunction execBgStatus(args: Record<string, unknown>): string {\n  const id = args['id'] ? String(args['id']) : undefined;\n  const pm = getProcessManager();\n\n  if (!id) {\n    const all = pm.status() as ProcessStatus[];\n    if (all.length === 0) return 'No background processes.';\n    return all\n      .map(\n        (s) =>\n          `id=${s.id} state=${s.state} pid=${s.pid} runtime=${(s.runtimeMs / 1000).toFixed(1)}s${s.label ? ` label=\"${s.label}\"` : ''} cmd=\"${s.command}\"`\n      )\n      .join('\\n');\n  }\n\n  const s = pm.status(id) as ProcessStatus;\n  return `id=${s.id} state=${s.state} pid=${s.pid} exit=${s.exitCode ?? 'n/a'} runtime=${(s.runtimeMs / 1000).toFixed(1)}s${s.label ? ` label=\"${s.label}\"` : ''} cmd=\"${s.command}\"`;\n}\n\nfunction execBgOutput(args: Record<string, unknown>): string {\n  const id = String(args['id'] ?? '');\n  const lines = args['lines'] !== undefined ? Number(args['lines']) : undefined;\n  const stream = args['stream'] as 'stdout' | 'stderr' | 'both' | undefined;\n  const sinceLastRead = args['since_last_read'] !== undefined ? Boolean(args['since_last_read']) : true;\n\n  const pm = getProcessManager();\n  const output = pm.output(id, { lines, stream, sinceLastRead });\n\n  let result = '';\n  if (output.stdout) result += `[stdout]\\n${output.stdout}\\n`;\n  if (output.stderr) result += `[stderr]\\n${output.stderr}\\n`;\n  if (!output.stdout && !output.stderr) result = '(no new output)';\n  if (output.truncated) result += '[truncated]\\n';\n\n  return result;\n}\n\nasync function execBgKill(args: Record<string, unknown>): Promise<string> {\n  const id = String(args['id'] ?? '');\n  const signal = (args['signal'] as NodeJS.Signals) ?? 'SIGTERM';\n\n  const pm = getProcessManager();\n  const s = pm.status(id) as ProcessStatus;\n  const killed = await pm.kill(id, signal);\n\n  if (!killed) {\n    return `Process ${id} is already ${s.state} (not running).`;\n  }\n\n  return `Process ${id} killed (was running for ${(s.runtimeMs / 1000).toFixed(1)}s)`;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/core/tools/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/core/tools/permissions.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":1,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":157,"column":12,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":157,"endColumn":50,"fix":{"range":[4149,4177],"text":""}},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":161,"column":16,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":161,"endColumn":34},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":1,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":171,"column":12,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":171,"endColumn":61,"fix":{"range":[4760,4788],"text":""}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { DEFAULT_PERMISSIONS, type OptaConfig } from '../config.js';\n\n// --- Permission Resolution ---\n\nexport const MODE_PERMISSIONS: Record<string, Record<string, 'allow' | 'ask' | 'deny'>> = {\n  safe: {\n    research_query: 'allow',\n    research_health: 'allow',\n    learning_log: 'allow',\n    learning_summary: 'allow',\n    learning_retrieve: 'allow',\n  },\n  auto: {\n    edit_file: 'allow',\n    write_file: 'allow',\n    delete_file: 'allow',\n    multi_edit: 'allow',\n    bg_start: 'allow',\n    bg_kill: 'allow',\n    spawn_agent: 'allow',\n    delegate_task: 'allow',\n    research_query: 'allow',\n    research_health: 'allow',\n    browser_open: 'allow',\n    browser_navigate: 'allow',\n    browser_click: 'allow',\n    browser_type: 'allow',\n    browser_snapshot: 'allow',\n    browser_screenshot: 'allow',\n    browser_close: 'allow',\n    learning_log: 'allow',\n    learning_summary: 'allow',\n    learning_retrieve: 'allow',\n  },\n  plan: {\n    edit_file: 'deny',\n    write_file: 'deny',\n    delete_file: 'deny',\n    multi_edit: 'deny',\n    run_command: 'deny',\n    bg_start: 'deny',\n    bg_kill: 'deny',\n    spawn_agent: 'deny',\n    delegate_task: 'deny',\n    browser_open: 'deny',\n    browser_navigate: 'deny',\n    browser_click: 'deny',\n    browser_type: 'deny',\n    browser_snapshot: 'deny',\n    browser_screenshot: 'deny',\n    browser_close: 'deny',\n    learning_log: 'deny',\n    research_query: 'allow',\n    research_health: 'allow',\n    learning_summary: 'allow',\n    learning_retrieve: 'allow',\n  },\n  review: {\n    edit_file: 'deny',\n    write_file: 'deny',\n    delete_file: 'deny',\n    multi_edit: 'deny',\n    run_command: 'deny',\n    bg_start: 'deny',\n    spawn_agent: 'deny',\n    delegate_task: 'deny',\n    browser_open: 'deny',\n    browser_navigate: 'deny',\n    browser_click: 'deny',\n    browser_type: 'deny',\n    browser_snapshot: 'deny',\n    browser_screenshot: 'deny',\n    browser_close: 'deny',\n    learning_log: 'deny',\n    research_query: 'allow',\n    research_health: 'allow',\n    learning_summary: 'allow',\n    learning_retrieve: 'allow',\n  },\n  research: {\n    edit_file: 'deny',\n    write_file: 'deny',\n    delete_file: 'deny',\n    multi_edit: 'deny',\n    spawn_agent: 'deny',\n    delegate_task: 'deny',\n    research_query: 'allow',\n    research_health: 'allow',\n    browser_open: 'allow',\n    browser_navigate: 'allow',\n    browser_snapshot: 'allow',\n    browser_screenshot: 'allow',\n    browser_close: 'allow',\n    learning_log: 'deny',\n    learning_summary: 'allow',\n    learning_retrieve: 'allow',\n  },\n  dangerous: {\n    edit_file: 'allow',\n    write_file: 'allow',\n    delete_file: 'allow',\n    multi_edit: 'allow',\n    run_command: 'allow',\n    bg_start: 'allow',\n    bg_kill: 'allow',\n    spawn_agent: 'allow',\n    delegate_task: 'allow',\n    research_query: 'allow',\n    research_health: 'allow',\n    browser_open: 'allow',\n    browser_navigate: 'allow',\n    browser_click: 'allow',\n    browser_type: 'allow',\n    browser_snapshot: 'allow',\n    browser_screenshot: 'allow',\n    browser_close: 'allow',\n    learning_log: 'allow',\n    learning_summary: 'allow',\n    learning_retrieve: 'allow',\n  },\n  ci: {\n    edit_file: 'deny',\n    write_file: 'deny',\n    delete_file: 'deny',\n    multi_edit: 'deny',\n    run_command: 'deny',\n    ask_user: 'deny',\n    bg_start: 'deny',\n    bg_kill: 'deny',\n    spawn_agent: 'deny',\n    delegate_task: 'deny',\n    browser_open: 'deny',\n    browser_navigate: 'deny',\n    browser_click: 'deny',\n    browser_type: 'deny',\n    browser_snapshot: 'deny',\n    browser_screenshot: 'deny',\n    browser_close: 'deny',\n    learning_log: 'deny',\n    research_query: 'allow',\n    research_health: 'allow',\n    learning_summary: 'allow',\n    learning_retrieve: 'allow',\n  },\n};\n\nexport function resolvePermission(\n  toolName: string,\n  config: OptaConfig\n): 'allow' | 'ask' | 'deny' {\n  // Per-tool config overrides take highest precedence\n  const configPerm = config.permissions[toolName];\n  const defaultPerm = DEFAULT_PERMISSIONS[toolName];\n\n  // If the user explicitly set a per-tool override different from defaults, use it\n  if (configPerm && configPerm !== defaultPerm) {\n    return configPerm as 'allow' | 'ask' | 'deny';\n  }\n\n  // Mode-level permissions (mode handles CI via the 'ci' mode)\n  const mode = config.defaultMode ?? 'safe';\n  const modePerm = MODE_PERMISSIONS[mode]?.[toolName];\n  if (modePerm) return modePerm;\n\n  // Custom tools (custom__*) execute shell commands, so they inherit\n  // run_command's mode-level permissions when no explicit override exists.\n  if (toolName.startsWith('custom__')) {\n    const customModePerm = MODE_PERMISSIONS[mode]?.['run_command'];\n    if (customModePerm) return customModePerm;\n    // Default: same as run_command ('ask')\n    return (configPerm ?? 'ask') as 'allow' | 'ask' | 'deny';\n  }\n\n  // Fall back to config permission or default\n  const permission = configPerm ?? defaultPerm ?? 'ask';\n  return permission as 'allow' | 'ask' | 'deny';\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/core/tools/schemas.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/core/version.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/daemon/background-manager.ts","messages":[{"ruleId":"@typescript-eslint/require-await","severity":1,"message":"Async method 'start' has no 'await' expression.","line":179,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":179,"endColumn":14,"suggestions":[{"messageId":"removeAsync","fix":{"range":[4898,4981],"text":"start(input: StartBackgroundProcessInput): BackgroundProcessSnapshot"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":220,"column":17,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":220,"endColumn":19,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[6149,6151],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":223,"column":17,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":223,"endColumn":19,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[6273,6275],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/require-await","severity":1,"message":"Async method 'kill' has no 'await' expression.","line":293,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":293,"endColumn":13,"suggestions":[{"messageId":"removeAsync","fix":{"range":[8347,8452],"text":"kill(processId: string, signal: BackgroundSignal = 'SIGTERM'): KillBackgroundResult | null"},"desc":"Remove 'async'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { spawn, type ChildProcess } from 'node:child_process';\nimport { resolve as resolvePath } from 'node:path';\nimport { nanoid } from 'nanoid';\nimport type {\n  BackgroundOutputChunk,\n  BackgroundOutputEventPayload,\n  BackgroundOutputSlice,\n  BackgroundProcessSnapshot,\n  BackgroundProcessState,\n  BackgroundSignal,\n  BackgroundStatusEventPayload,\n  BackgroundStream,\n} from '../protocol/v3/types.js';\n\nexport interface BackgroundManagerOptions {\n  maxConcurrent: number;\n  defaultTimeout: number;\n  maxBufferSize: number;\n}\n\nexport interface StartBackgroundProcessInput {\n  sessionId: string;\n  command: string;\n  label?: string;\n  cwd?: string;\n  timeoutMs?: number;\n}\n\nexport interface BackgroundOutputQuery {\n  afterSeq: number;\n  limit: number;\n  stream: 'stdout' | 'stderr' | 'both';\n}\n\nexport interface KillBackgroundResult {\n  killed: boolean;\n  process: BackgroundProcessSnapshot;\n}\n\nexport type BackgroundManagerEvent =\n  | {\n      type: 'output';\n      sessionId: string;\n      payload: BackgroundOutputEventPayload;\n    }\n  | {\n      type: 'status';\n      sessionId: string;\n      payload: BackgroundStatusEventPayload;\n    };\n\ntype BackgroundEventSubscriber = (event: BackgroundManagerEvent) => void;\n\ninterface ManagedBackgroundProcess {\n  processId: string;\n  sessionId: string;\n  pid: number;\n  command: string;\n  label?: string;\n  cwd: string;\n  state: BackgroundProcessState;\n  exitCode: number | null;\n  startedAtMs: number;\n  endedAtMs: number | null;\n  timeoutMs: number;\n  child: ChildProcess;\n  requestedSignal?: BackgroundSignal;\n  outputs: BackgroundOutputChunk[];\n  outputBytes: number;\n  nextOutputSeq: number;\n  timeoutHandle?: ReturnType<typeof setTimeout>;\n  killEscalationHandle?: ReturnType<typeof setTimeout>;\n}\n\nfunction parseShellCommand(cmd: string): [string, string[]] {\n  const tokens: string[] = [];\n  let current = '';\n  let inSingle = false;\n  let inDouble = false;\n  for (let i = 0; i < cmd.length; i++) {\n    const ch = cmd[i];\n    if (ch === \"'\" && !inDouble) { inSingle = !inSingle; continue; }\n    if (ch === '\"' && !inSingle) { inDouble = !inDouble; continue; }\n    if (ch === '\\\\' && !inSingle && i + 1 < cmd.length) { current += cmd[++i]; continue; }\n    if ((ch === ' ' || ch === '\\t') && !inSingle && !inDouble) {\n      if (current) { tokens.push(current); current = ''; }\n      continue;\n    }\n    current += ch;\n  }\n  if (current) tokens.push(current);\n  const [exe = '', ...args] = tokens;\n  return [exe, args];\n}\n\nfunction reasonFromState(\n  state: BackgroundProcessState\n): BackgroundStatusEventPayload['reason'] {\n  switch (state) {\n    case 'completed':\n      return 'completed';\n    case 'failed':\n      return 'failed';\n    case 'killed':\n      return 'killed';\n    case 'timeout':\n      return 'timeout';\n    case 'running':\n      return 'running';\n  }\n}\n\nexport class BackgroundManager {\n  private static readonly SIGTERM_GRACE_MS = 3_000;\n  private static readonly SIGKILL_GRACE_MS = 5_000;\n\n  private readonly processes = new Map<string, ManagedBackgroundProcess>();\n  private readonly subscribers = new Set<BackgroundEventSubscriber>();\n  private options: BackgroundManagerOptions;\n\n  constructor(options: BackgroundManagerOptions) {\n    this.options = { ...options };\n  }\n\n  updateOptions(next: BackgroundManagerOptions): void {\n    this.options = { ...next };\n  }\n\n  subscribe(cb: BackgroundEventSubscriber): () => void {\n    this.subscribers.add(cb);\n    return () => {\n      this.subscribers.delete(cb);\n    };\n  }\n\n  list(sessionId?: string): BackgroundProcessSnapshot[] {\n    const snapshots: BackgroundProcessSnapshot[] = [];\n    for (const proc of this.processes.values()) {\n      if (sessionId && proc.sessionId !== sessionId) continue;\n      snapshots.push(this.toSnapshot(proc));\n    }\n    snapshots.sort((a, b) => {\n      if (a.startedAt === b.startedAt) {\n        return a.processId.localeCompare(b.processId);\n      }\n      return a.startedAt.localeCompare(b.startedAt);\n    });\n    return snapshots;\n  }\n\n  status(processId: string): BackgroundProcessSnapshot | null {\n    const proc = this.processes.get(processId);\n    if (!proc) return null;\n    return this.toSnapshot(proc);\n  }\n\n  output(processId: string, query: BackgroundOutputQuery): BackgroundOutputSlice | null {\n    const proc = this.processes.get(processId);\n    if (!proc) return null;\n\n    const matching = proc.outputs.filter((chunk) => {\n      if (chunk.seq <= query.afterSeq) return false;\n      if (query.stream === 'both') return true;\n      return chunk.stream === query.stream;\n    });\n    const hasMore = matching.length > query.limit;\n    const chunks = matching.slice(0, query.limit);\n    const lastChunk = chunks.length > 0 ? chunks[chunks.length - 1] : undefined;\n    const nextSeq = lastChunk ? lastChunk.seq : query.afterSeq;\n\n    return {\n      process: this.toSnapshot(proc),\n      chunks,\n      nextSeq,\n      hasMore,\n    };\n  }\n\n  async start(input: StartBackgroundProcessInput): Promise<BackgroundProcessSnapshot> {\n    const running = [...this.processes.values()].filter((proc) => proc.state === 'running').length;\n    if (running >= this.options.maxConcurrent) {\n      throw new Error(`Max concurrent processes (${this.options.maxConcurrent}) reached`);\n    }\n\n    const processId = nanoid(8);\n    const cwd = resolvePath(input.cwd ?? process.cwd());\n    const timeoutMs = input.timeoutMs ?? this.options.defaultTimeout;\n\n    const [exe, args] = parseShellCommand(input.command);\n    const child = spawn(exe, args, {\n      cwd,\n      stdio: ['ignore', 'pipe', 'pipe'],\n      detached: false,\n    });\n\n    if (!child.pid) {\n      throw new Error(`Background process failed to start: ${input.command}`);\n    }\n\n    const nowMs = Date.now();\n    const proc: ManagedBackgroundProcess = {\n      processId,\n      sessionId: input.sessionId,\n      pid: child.pid,\n      command: input.command,\n      label: input.label,\n      cwd,\n      state: 'running',\n      exitCode: null,\n      startedAtMs: nowMs,\n      endedAtMs: null,\n      timeoutMs,\n      child,\n      outputs: [],\n      outputBytes: 0,\n      nextOutputSeq: 0,\n    };\n    this.processes.set(processId, proc);\n\n    child.stdout?.on('data', (chunk: Buffer) => {\n      this.appendOutput(proc, 'stdout', chunk.toString('utf-8'));\n    });\n    child.stderr?.on('data', (chunk: Buffer) => {\n      this.appendOutput(proc, 'stderr', chunk.toString('utf-8'));\n    });\n\n    child.on('error', () => {\n      const previous = proc.state;\n      proc.state = 'failed';\n      proc.endedAtMs = Date.now();\n      this.clearTimers(proc);\n      this.emitStatus(proc, {\n        reason: 'spawn-error',\n        previousState: previous,\n      });\n    });\n\n    child.on('close', (code, signal) => {\n      const previous = proc.state;\n      if (proc.state === 'running') {\n        if (proc.requestedSignal || signal) {\n          proc.state = 'killed';\n        } else if (code === 0) {\n          proc.state = 'completed';\n        } else {\n          proc.state = 'failed';\n        }\n      }\n\n      proc.exitCode = code;\n      proc.endedAtMs = Date.now();\n      this.clearTimers(proc);\n      this.emitStatus(proc, {\n        reason: reasonFromState(proc.state),\n        previousState: previous,\n        signal: proc.requestedSignal,\n      });\n\n      // Prune processes completed more than 5 minutes ago\n      const COMPLETED_RETENTION_MS = 5 * 60 * 1_000;\n      const cutoff = Date.now() - COMPLETED_RETENTION_MS;\n      for (const [id, p] of this.processes) {\n        if (p.state !== 'running' && (p.endedAtMs ?? p.startedAtMs) < cutoff) {\n          this.processes.delete(id);\n        }\n      }\n    });\n\n    if (timeoutMs > 0) {\n      proc.timeoutHandle = setTimeout(() => {\n        if (proc.state !== 'running') return;\n        const previous = proc.state;\n        proc.state = 'timeout';\n        this.emitStatus(proc, {\n          reason: 'timeout',\n          previousState: previous,\n        });\n        proc.child.kill('SIGTERM');\n        proc.killEscalationHandle = setTimeout(() => {\n          if (proc.state === 'running' || proc.state === 'timeout') {\n            proc.child.kill('SIGKILL');\n          }\n        }, BackgroundManager.SIGTERM_GRACE_MS);\n        proc.killEscalationHandle.unref();\n      }, timeoutMs);\n      proc.timeoutHandle.unref();\n    }\n\n    this.emitStatus(proc, { reason: 'started' });\n    return this.toSnapshot(proc);\n  }\n\n  async kill(processId: string, signal: BackgroundSignal = 'SIGTERM'): Promise<KillBackgroundResult | null> {\n    const proc = this.processes.get(processId);\n    if (!proc) return null;\n    if (proc.state !== 'running') {\n      return { killed: false, process: this.toSnapshot(proc) };\n    }\n\n    proc.requestedSignal = signal;\n    const killed = proc.child.kill(signal);\n\n    if (signal !== 'SIGKILL') {\n      proc.killEscalationHandle = setTimeout(() => {\n        if (proc.state === 'running') {\n          proc.requestedSignal = 'SIGKILL';\n          proc.child.kill('SIGKILL');\n        }\n      }, BackgroundManager.SIGKILL_GRACE_MS);\n      proc.killEscalationHandle.unref();\n    }\n\n    return { killed, process: this.toSnapshot(proc) };\n  }\n\n  async killSession(sessionId: string, signal: BackgroundSignal = 'SIGTERM'): Promise<number> {\n    let killed = 0;\n    for (const proc of this.processes.values()) {\n      if (proc.sessionId !== sessionId || proc.state !== 'running') continue;\n      const result = await this.kill(proc.processId, signal);\n      if (result?.killed) killed += 1;\n    }\n    return killed;\n  }\n\n  async close(signal: BackgroundSignal = 'SIGTERM'): Promise<void> {\n    const running = [...this.processes.values()].filter((proc) => proc.state === 'running');\n    await Promise.all(running.map(async (proc) => {\n      await this.kill(proc.processId, signal);\n    }));\n  }\n\n  private appendOutput(proc: ManagedBackgroundProcess, stream: BackgroundStream, text: string): void {\n    if (text.length === 0) return;\n    const chunk: BackgroundOutputChunk = {\n      seq: ++proc.nextOutputSeq,\n      ts: new Date().toISOString(),\n      stream,\n      text,\n    };\n\n    proc.outputs.push(chunk);\n    proc.outputBytes += Buffer.byteLength(text, 'utf-8');\n    while (proc.outputBytes > this.options.maxBufferSize && proc.outputs.length > 0) {\n      const evicted = proc.outputs.shift();\n      if (!evicted) break;\n      proc.outputBytes -= Buffer.byteLength(evicted.text, 'utf-8');\n    }\n\n    this.emit({\n      type: 'output',\n      sessionId: proc.sessionId,\n      payload: {\n        processId: proc.processId,\n        sessionId: proc.sessionId,\n        pid: proc.pid,\n        seq: chunk.seq,\n        ts: chunk.ts,\n        stream: chunk.stream,\n        text: chunk.text,\n      },\n    });\n  }\n\n  private emitStatus(\n    proc: ManagedBackgroundProcess,\n    input: {\n      reason: BackgroundStatusEventPayload['reason'];\n      previousState?: BackgroundProcessState;\n      signal?: BackgroundSignal;\n    }\n  ): void {\n    this.emit({\n      type: 'status',\n      sessionId: proc.sessionId,\n      payload: {\n        process: this.toSnapshot(proc),\n        reason: input.reason,\n        previousState: input.previousState,\n        signal: input.signal,\n      },\n    });\n  }\n\n  private emit(event: BackgroundManagerEvent): void {\n    for (const subscriber of this.subscribers) {\n      try {\n        subscriber(event);\n      } catch {\n        // Isolate subscriber failures.\n      }\n    }\n  }\n\n  private toSnapshot(proc: ManagedBackgroundProcess): BackgroundProcessSnapshot {\n    return {\n      processId: proc.processId,\n      sessionId: proc.sessionId,\n      pid: proc.pid,\n      command: proc.command,\n      label: proc.label,\n      cwd: proc.cwd,\n      state: proc.state,\n      exitCode: proc.exitCode,\n      startedAt: new Date(proc.startedAtMs).toISOString(),\n      endedAt: proc.endedAtMs ? new Date(proc.endedAtMs).toISOString() : null,\n      runtimeMs: (proc.endedAtMs ?? Date.now()) - proc.startedAtMs,\n      timeoutMs: proc.timeoutMs,\n    };\n  }\n\n  private clearTimers(proc: ManagedBackgroundProcess): void {\n    if (proc.timeoutHandle) {\n      clearTimeout(proc.timeoutHandle);\n      proc.timeoutHandle = undefined;\n    }\n    if (proc.killEscalationHandle) {\n      clearTimeout(proc.killEscalationHandle);\n      proc.killEscalationHandle = undefined;\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/daemon/client.ts","messages":[{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'data' may use Object's default stringification format ('[object Object]') when stringified.","line":133,"column":43,"nodeType":"Identifier","messageId":"baseToString","endLine":133,"endColumn":47},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, value is always falsy.","line":134,"column":44,"nodeType":"UnaryExpression","messageId":"alwaysFalsy","endLine":134,"endColumn":52}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import WebSocket, { type RawData } from 'ws';\nimport { ensureDaemonRunning } from './lifecycle.js';\nimport type { ClientSubmitTurn, CreateSessionRequest, PermissionDecision, SessionSnapshot, V3Envelope } from '../protocol/v3/types.js';\n\ninterface SessionDetail extends SessionSnapshot {\n  messages: unknown[];\n}\n\ninterface LegacyChatResponse {\n  session_id: string;\n  response: string;\n  stats?: unknown;\n  model?: string;\n}\n\nexport class DaemonClient {\n  constructor(\n    readonly host: string,\n    readonly port: number,\n    readonly token: string\n  ) {}\n\n  static async connect(opts?: { host?: string; port?: number }): Promise<DaemonClient> {\n    const state = await ensureDaemonRunning(opts);\n    return new DaemonClient(state.host, state.port, state.token);\n  }\n\n  private async request<T>(path: string, init?: RequestInit): Promise<T> {\n    const url = `http://${this.host}:${this.port}${path}`;\n    const headers = new Headers(init?.headers);\n    headers.set('Authorization', `Bearer ${this.token}`);\n    if (!headers.has('Content-Type') && init?.body) {\n      headers.set('Content-Type', 'application/json');\n    }\n\n    const res = await fetch(url, {\n      ...init,\n      headers,\n    });\n\n    if (!res.ok) {\n      const msg = await res.text().catch(() => '');\n      throw new Error(`Daemon request failed (${res.status}): ${msg || res.statusText}`);\n    }\n    return res.json() as Promise<T>;\n  }\n\n  async health(): Promise<{ status: string; version?: string }> {\n    return this.request('/v3/health');\n  }\n\n  async createSession(req: CreateSessionRequest): Promise<SessionSnapshot> {\n    return this.request('/v3/sessions', {\n      method: 'POST',\n      body: JSON.stringify(req),\n    });\n  }\n\n  async getSession(sessionId: string): Promise<SessionDetail> {\n    return this.request(`/v3/sessions/${encodeURIComponent(sessionId)}`);\n  }\n\n  async submitTurn(sessionId: string, payload: ClientSubmitTurn): Promise<{ turnId: string; queued: number }> {\n    return this.request(`/v3/sessions/${encodeURIComponent(sessionId)}/turns`, {\n      method: 'POST',\n      body: JSON.stringify(payload),\n    });\n  }\n\n  async cancel(sessionId: string, payload: { turnId?: string; writerId?: string }): Promise<{ cancelled: number }> {\n    return this.request(`/v3/sessions/${encodeURIComponent(sessionId)}/cancel`, {\n      method: 'POST',\n      body: JSON.stringify(payload),\n    });\n  }\n\n  async resolvePermission(sessionId: string, payload: PermissionDecision): Promise<{ ok: boolean; conflict: boolean; message?: string }> {\n    return this.request(`/v3/sessions/${encodeURIComponent(sessionId)}/permissions/${encodeURIComponent(payload.requestId)}`, {\n      method: 'POST',\n      body: JSON.stringify(payload),\n    });\n  }\n\n  async events(sessionId: string, afterSeq: number): Promise<{ events: V3Envelope[] }> {\n    return this.request(`/v3/sessions/${encodeURIComponent(sessionId)}/events?afterSeq=${afterSeq}`);\n  }\n\n  async legacyChat(message: string, sessionId?: string): Promise<LegacyChatResponse> {\n    const url = `http://${this.host}:${this.port}/v1/chat`;\n    const res = await fetch(url, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        message,\n        session_id: sessionId,\n      }),\n    });\n    if (!res.ok) {\n      const text = await res.text().catch(() => '');\n      throw new Error(`Daemon legacy chat failed (${res.status}): ${text || res.statusText}`);\n    }\n    return res.json() as Promise<LegacyChatResponse>;\n  }\n\n  connectWebSocket(\n    sessionId: string,\n    afterSeq: number,\n    handlers: {\n      onEvent: (event: V3Envelope) => void;\n      onError?: (err: Error) => void;\n      onOpen?: () => void;\n      onClose?: () => void;\n    }\n  ): { socket: WebSocket; close: () => void } {\n    const wsUrl = `ws://${this.host}:${this.port}/v3/ws?sessionId=${encodeURIComponent(sessionId)}&afterSeq=${afterSeq}`;\n    const socket = new WebSocket(wsUrl, {\n      headers: {\n        Authorization: `Bearer ${this.token}`,\n      },\n    });\n\n    socket.on('open', () => {\n      handlers.onOpen?.();\n    });\n    socket.on('close', () => {\n      handlers.onClose?.();\n    });\n    socket.on('error', (err: Error) => {\n      handlers.onError?.(err);\n    });\n    socket.on('message', (data: RawData) => {\n      try {\n        const decoded = JSON.parse(String(data)) as V3Envelope;\n        if (typeof decoded !== 'object' || !decoded || !('event' in decoded)) return;\n        handlers.onEvent(decoded);\n      } catch {\n        // Ignore malformed events.\n      }\n    });\n\n    return {\n      socket,\n      close: () => {\n        if (socket.readyState === socket.OPEN || socket.readyState === socket.CONNECTING) {\n          socket.close();\n        }\n      },\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/daemon/http-server.ts","messages":[{"ruleId":"@typescript-eslint/require-await","severity":1,"message":"Async function 'registerHttpRoutes' has no 'await' expression.","line":101,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingAwait","endLine":101,"endColumn":34,"suggestions":[{"messageId":"removeAsync","fix":{"range":[3307,3402],"text":"function registerHttpRoutes(app: FastifyInstance, opts: HttpServerOptions): void"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":102,"column":31,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":102,"endColumn":33,"suggestions":[{"messageId":"removeAsync","fix":{"range":[3426,3432],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":108,"column":34,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":108,"endColumn":36,"suggestions":[{"messageId":"removeAsync","fix":{"range":[3531,3537],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/return-await","severity":1,"message":"Returning an awaited promise is required in this context.","line":157,"column":14,"nodeType":"CallExpression","messageId":"requiredPromiseAwait","endLine":157,"endColumn":44,"suggestions":[{"messageId":"requiredPromiseAwaitSuggestion","fix":{"range":[5631,5631],"text":"await "},"desc":"Add `await` before the expression. Use caution as this may impact control flow."}]},{"ruleId":"@typescript-eslint/return-await","severity":1,"message":"Returning an awaited promise is required in this context.","line":226,"column":14,"nodeType":"CallExpression","messageId":"requiredPromiseAwait","endLine":226,"endColumn":49,"suggestions":[{"messageId":"requiredPromiseAwaitSuggestion","fix":{"range":[8854,8854],"text":"await "},"desc":"Add `await` before the expression. Use caution as this may impact control flow."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import Fastify, { type FastifyInstance, type FastifyReply, type FastifyRequest } from 'fastify';\nimport websocket from '@fastify/websocket';\nimport { VERSION } from '../core/version.js';\nimport {\n  BackgroundKillHttpSchema,\n  BackgroundListQuerySchema,\n  BackgroundOutputQuerySchema,\n  BackgroundProcessParamsSchema,\n  BackgroundStartHttpSchema,\n  BackgroundStatusQuerySchema,\n  CreateSessionHttpSchema,\n  EventsQuerySchema,\n  PermissionDecisionHttpSchema,\n  PermissionParamsSchema,\n  SessionParamsSchema,\n  SubmitTurnHttpSchema,\n} from '../protocol/v3/http.js';\nimport type { V3Envelope } from '../protocol/v3/types.js';\nimport type { SessionManager } from './session-manager.js';\nimport { registerWsServer } from './ws-server.js';\nimport { writeDaemonState, type DaemonState } from './lifecycle.js';\nimport { daemonLogsPath } from './telemetry.js';\n\nexport interface HttpServerOptions {\n  daemonId: string;\n  host: string;\n  port: number;\n  token: string;\n  sessionManager: SessionManager;\n}\n\nexport interface RunningHttpServer {\n  app: FastifyInstance;\n  host: string;\n  port: number;\n  close: () => Promise<void>;\n}\n\nfunction readBearer(req: FastifyRequest): string | null {\n  const auth = req.headers.authorization;\n  if (!auth) return null;\n  const trimmed = auth.trim();\n  if (!trimmed.toLowerCase().startsWith('bearer ')) return null;\n  return trimmed.slice(7).trim() || null;\n}\n\nfunction isAuthorized(req: FastifyRequest, expectedToken: string): boolean {\n  const fromHeader = readBearer(req);\n  if (fromHeader === expectedToken) return true;\n  const query = req.query as { token?: string } | undefined;\n  return query?.token === expectedToken;\n}\n\nfunction rejectUnauthorized(reply: FastifyReply): FastifyReply {\n  return reply.status(401).send({ error: 'Unauthorized' });\n}\n\nasync function waitForTurnDone(\n  sessionManager: SessionManager,\n  sessionId: string,\n  turnId: string,\n  timeoutMs = 600_000\n): Promise<{ stats: unknown; message: string }> {\n  return new Promise((resolve, reject) => {\n    let done = false;\n    const timeout = setTimeout(() => {\n      if (done) return;\n      done = true;\n      unsubscribe();\n      reject(new Error(`Timed out waiting for turn ${turnId}`));\n    }, timeoutMs);\n    timeout.unref();\n\n    const unsubscribe = sessionManager.subscribe(sessionId, (event) => {\n      if (done) return;\n      if (event.event === 'turn.done') {\n        const payload = event.payload as { turnId?: string; stats?: unknown };\n        if (payload.turnId !== turnId) return;\n        done = true;\n        clearTimeout(timeout);\n        unsubscribe();\n        void sessionManager.getSessionMessages(sessionId).then((messages) => {\n          const assistantMsgs = (messages ?? []).filter(m => m.role === 'assistant');\n          const last = assistantMsgs[assistantMsgs.length - 1];\n          const text = typeof last?.content === 'string' ? last.content : '';\n          resolve({ stats: payload.stats, message: text });\n        }).catch(reject);\n      }\n      if (event.event === 'turn.error') {\n        const payload = event.payload as { turnId?: string; message?: string };\n        if (payload.turnId !== turnId) return;\n        done = true;\n        clearTimeout(timeout);\n        unsubscribe();\n        reject(new Error(payload.message ?? 'Turn failed'));\n      }\n    });\n  });\n}\n\nasync function registerHttpRoutes(app: FastifyInstance, opts: HttpServerOptions): Promise<void> {\n  app.get('/health', async () => ({\n    status: 'ok',\n    version: VERSION,\n    daemon: true,\n  }));\n\n  app.get('/v3/health', async () => ({\n    status: 'ok',\n    version: VERSION,\n    daemonId: opts.daemonId,\n    runtime: opts.sessionManager.getRuntimeStats(),\n  }));\n\n  app.get('/v3/metrics', async (req, reply) => {\n    if (!isAuthorized(req, opts.token)) return rejectUnauthorized(reply);\n    const runtime = opts.sessionManager.getRuntimeStats();\n    return {\n      daemonId: opts.daemonId,\n      runtime,\n      ts: new Date().toISOString(),\n    };\n  });\n\n  app.post('/v3/sessions', async (req, reply) => {\n    if (!isAuthorized(req, opts.token)) return rejectUnauthorized(reply);\n    const parsed = CreateSessionHttpSchema.safeParse(req.body ?? {});\n    if (!parsed.success) {\n      return reply.status(400).send({ error: 'Invalid request body', details: parsed.error.issues });\n    }\n    const snapshot = await opts.sessionManager.createSession(parsed.data);\n    return reply.status(201).send(snapshot);\n  });\n\n  app.get('/v3/sessions/:sessionId', async (req, reply) => {\n    if (!isAuthorized(req, opts.token)) return rejectUnauthorized(reply);\n    const parsed = SessionParamsSchema.safeParse(req.params);\n    if (!parsed.success) return reply.status(400).send({ error: 'Invalid session id' });\n\n    const snapshot = await opts.sessionManager.getSession(parsed.data.sessionId);\n    if (!snapshot) return reply.status(404).send({ error: 'Session not found' });\n    const messages = await opts.sessionManager.getSessionMessages(parsed.data.sessionId);\n    return { ...snapshot, messages: messages ?? [] };\n  });\n\n  app.post('/v3/sessions/:sessionId/turns', async (req, reply) => {\n    if (!isAuthorized(req, opts.token)) return rejectUnauthorized(reply);\n    const params = SessionParamsSchema.safeParse(req.params);\n    if (!params.success) return reply.status(400).send({ error: 'Invalid session id' });\n    const body = SubmitTurnHttpSchema.safeParse(req.body ?? {});\n    if (!body.success) {\n      return reply.status(400).send({ error: 'Invalid request body', details: body.error.issues });\n    }\n\n    try {\n      const queued = await opts.sessionManager.submitTurn(params.data.sessionId, body.data);\n      return reply.status(202).send(queued);\n    } catch (err) {\n      return reply.status(404).send({ error: err instanceof Error ? err.message : String(err) });\n    }\n  });\n\n  app.post('/v3/sessions/:sessionId/cancel', async (req, reply) => {\n    if (!isAuthorized(req, opts.token)) return rejectUnauthorized(reply);\n    const params = SessionParamsSchema.safeParse(req.params);\n    if (!params.success) return reply.status(400).send({ error: 'Invalid session id' });\n    const body = req.body as { turnId?: string; writerId?: string } | undefined;\n    const cancelled = await opts.sessionManager.cancelSessionTurns(params.data.sessionId, {\n      turnId: body?.turnId,\n      writerId: body?.writerId,\n    });\n    return { cancelled };\n  });\n\n  app.post('/v3/sessions/:sessionId/permissions/:requestId', async (req, reply) => {\n    if (!isAuthorized(req, opts.token)) return rejectUnauthorized(reply);\n    const params = PermissionParamsSchema.safeParse(req.params);\n    if (!params.success) return reply.status(400).send({ error: 'Invalid params' });\n    const body = PermissionDecisionHttpSchema.safeParse(req.body ?? {});\n    if (!body.success) return reply.status(400).send({ error: 'Invalid body', details: body.error.issues });\n\n    const result = opts.sessionManager.resolvePermission(params.data.sessionId, body.data);\n    if (!result.ok && result.conflict) {\n      return reply.status(409).send(result);\n    }\n    if (!result.ok) {\n      return reply.status(404).send(result);\n    }\n    return result;\n  });\n\n  app.get('/v3/sessions/:sessionId/events', async (req, reply) => {\n    if (!isAuthorized(req, opts.token)) return rejectUnauthorized(reply);\n    const params = SessionParamsSchema.safeParse(req.params);\n    if (!params.success) return reply.status(400).send({ error: 'Invalid session id' });\n    const query = EventsQuerySchema.safeParse(req.query ?? {});\n    if (!query.success) return reply.status(400).send({ error: 'Invalid query' });\n    const events = await opts.sessionManager.getEventsAfter(params.data.sessionId, query.data.afterSeq);\n    return { events };\n  });\n\n  app.get('/v3/background', async (req, reply) => {\n    if (!isAuthorized(req, opts.token)) return rejectUnauthorized(reply);\n    const query = BackgroundListQuerySchema.safeParse(req.query ?? {});\n    if (!query.success) return reply.status(400).send({ error: 'Invalid query', details: query.error.issues });\n\n    try {\n      const processes = await opts.sessionManager.listBackgroundProcesses(query.data.sessionId);\n      return { processes };\n    } catch (err) {\n      const message = err instanceof Error ? err.message : String(err);\n      if (/Session not found/i.test(message)) {\n        return reply.status(404).send({ error: message });\n      }\n      return reply.status(500).send({ error: message });\n    }\n  });\n\n  app.post('/v3/background/start', async (req, reply) => {\n    if (!isAuthorized(req, opts.token)) return rejectUnauthorized(reply);\n    const body = BackgroundStartHttpSchema.safeParse(req.body ?? {});\n    if (!body.success) return reply.status(400).send({ error: 'Invalid body', details: body.error.issues });\n\n    try {\n      const process = await opts.sessionManager.startBackgroundProcess(body.data);\n      return reply.status(201).send({ process });\n    } catch (err) {\n      const message = err instanceof Error ? err.message : String(err);\n      if (/Session not found/i.test(message)) {\n        return reply.status(404).send({ error: message });\n      }\n      if (/Max concurrent processes/i.test(message)) {\n        return reply.status(409).send({ error: message });\n      }\n      return reply.status(500).send({ error: message });\n    }\n  });\n\n  app.get('/v3/background/:processId/status', async (req, reply) => {\n    if (!isAuthorized(req, opts.token)) return rejectUnauthorized(reply);\n    const params = BackgroundProcessParamsSchema.safeParse(req.params);\n    if (!params.success) return reply.status(400).send({ error: 'Invalid process id' });\n    const query = BackgroundStatusQuerySchema.safeParse(req.query ?? {});\n    if (!query.success) return reply.status(400).send({ error: 'Invalid query', details: query.error.issues });\n\n    const process = opts.sessionManager.getBackgroundStatus(params.data.processId);\n    if (!process) return reply.status(404).send({ error: 'Background process not found' });\n    if (query.data.sessionId && process.sessionId !== query.data.sessionId) {\n      return reply.status(404).send({ error: 'Background process not found' });\n    }\n    return { process };\n  });\n\n  app.get('/v3/background/:processId/output', async (req, reply) => {\n    if (!isAuthorized(req, opts.token)) return rejectUnauthorized(reply);\n    const params = BackgroundProcessParamsSchema.safeParse(req.params);\n    if (!params.success) return reply.status(400).send({ error: 'Invalid process id' });\n    const query = BackgroundOutputQuerySchema.safeParse(req.query ?? {});\n    if (!query.success) return reply.status(400).send({ error: 'Invalid query', details: query.error.issues });\n\n    const output = opts.sessionManager.getBackgroundOutput(params.data.processId, query.data);\n    if (!output) return reply.status(404).send({ error: 'Background process not found' });\n    return output;\n  });\n\n  app.post('/v3/background/:processId/kill', async (req, reply) => {\n    if (!isAuthorized(req, opts.token)) return rejectUnauthorized(reply);\n    const params = BackgroundProcessParamsSchema.safeParse(req.params);\n    if (!params.success) return reply.status(400).send({ error: 'Invalid process id' });\n    const body = BackgroundKillHttpSchema.safeParse(req.body ?? {});\n    if (!body.success) return reply.status(400).send({ error: 'Invalid body', details: body.error.issues });\n\n    const result = await opts.sessionManager.killBackgroundProcess(\n      params.data.processId,\n      body.data.signal\n    );\n    if (!result) return reply.status(404).send({ error: 'Background process not found' });\n    return result;\n  });\n\n  app.get('/v3/sse/events', async (req, reply) => {\n    if (!isAuthorized(req, opts.token)) return rejectUnauthorized(reply);\n    const query = req.query as { sessionId?: string; afterSeq?: string };\n    const sessionId = query.sessionId;\n    if (!sessionId) {\n      return reply.status(400).send({ error: 'Missing sessionId query param' });\n    }\n    const afterSeq = Number.parseInt(query.afterSeq ?? '0', 10);\n    const safeAfter = Number.isFinite(afterSeq) ? afterSeq : 0;\n\n    reply.raw.setHeader('Content-Type', 'text/event-stream');\n    reply.raw.setHeader('Cache-Control', 'no-cache, no-transform');\n    reply.raw.setHeader('Connection', 'keep-alive');\n    reply.raw.write(': connected\\n\\n');\n\n    let cursorSeq = safeAfter;\n    let replaying = true;\n    const bufferedLive: V3Envelope[] = [];\n\n    const writeEvent = (event: V3Envelope) => {\n      reply.raw.write(`data: ${JSON.stringify(event)}\\n\\n`);\n    };\n\n    const flushBufferedLive = () => {\n      if (bufferedLive.length === 0) return;\n      bufferedLive.sort((a, b) => a.seq - b.seq);\n      for (const event of bufferedLive) {\n        if (event.seq <= cursorSeq) continue;\n        cursorSeq = event.seq;\n        writeEvent(event);\n      }\n      bufferedLive.length = 0;\n    };\n\n    const unsubscribe = opts.sessionManager.subscribe(sessionId, (event) => {\n      if (event.seq <= cursorSeq) return;\n      if (replaying) {\n        bufferedLive.push(event);\n        return;\n      }\n      cursorSeq = event.seq;\n      writeEvent(event);\n    });\n\n    try {\n      const history = await opts.sessionManager.getEventsAfter(sessionId, safeAfter);\n      history.sort((a, b) => a.seq - b.seq);\n      for (const event of history) {\n        if (event.seq <= cursorSeq) continue;\n        cursorSeq = event.seq;\n        writeEvent(event);\n      }\n    } finally {\n      replaying = false;\n      flushBufferedLive();\n    }\n\n    const heartbeat = setInterval(() => {\n      if (!reply.raw.writable || reply.raw.destroyed) return;\n      reply.raw.write(': ping\\n\\n');\n    }, 15_000);\n    heartbeat.unref();\n\n    req.raw.on('close', () => {\n      clearInterval(heartbeat);\n      unsubscribe();\n      reply.raw.end();\n    });\n  });\n\n  // Legacy compatibility endpoint for existing scripts.\n  app.post('/v1/chat', async (req, reply) => {\n    const body = req.body as { message?: unknown; session_id?: unknown } | undefined;\n    if (!body || typeof body.message !== 'string' || !body.message.trim()) {\n      return reply.status(400).send({ error: 'Missing required field: message (string)' });\n    }\n\n    const requestedId = typeof body.session_id === 'string' ? body.session_id : undefined;\n    const session = await opts.sessionManager.createSession({\n      sessionId: requestedId,\n    });\n    const queued = await opts.sessionManager.submitTurn(session.sessionId, {\n      clientId: 'legacy-http',\n      writerId: 'legacy-http',\n      content: body.message,\n      mode: 'do',\n    });\n\n    try {\n      const done = await waitForTurnDone(opts.sessionManager, session.sessionId, queued.turnId);\n      return {\n        session_id: session.sessionId,\n        response: done.message,\n        stats: done.stats,\n        model: session.model,\n      };\n    } catch (err) {\n      return reply.status(500).send({\n        error: err instanceof Error ? err.message : String(err),\n      });\n    }\n  });\n}\n\nasync function listenWithPortFallback(app: FastifyInstance, host: string, preferredPort: number): Promise<number> {\n  const candidates = [preferredPort, ...Array.from({ length: 21 }, (_, idx) => 10_000 + idx)];\n  const occupied: number[] = [];\n  for (const candidate of candidates) {\n    try {\n      await app.listen({ host, port: candidate });\n      return candidate;\n    } catch (err) {\n      const msg = err instanceof Error ? err.message : String(err);\n      if (!/EADDRINUSE/i.test(msg)) throw err;\n      occupied.push(candidate);\n    }\n  }\n  throw new Error(`No available daemon port found (occupied: ${occupied.join(', ')})`);\n}\n\nexport async function startHttpServer(opts: HttpServerOptions): Promise<RunningHttpServer> {\n  const app = Fastify({\n    logger: false,\n    bodyLimit: 10 * 1024 * 1024,\n  });\n\n  await app.register(websocket);\n  await registerHttpRoutes(app, opts);\n  await registerWsServer(app, {\n    sessionManager: opts.sessionManager,\n    token: opts.token,\n  });\n\n  const boundPort = await listenWithPortFallback(app, opts.host, opts.port);\n  const state: DaemonState = {\n    pid: process.pid,\n    daemonId: opts.daemonId,\n    host: opts.host,\n    port: boundPort,\n    token: opts.token,\n    startedAt: new Date().toISOString(),\n    logsPath: daemonLogsPath(),\n  };\n  await writeDaemonState(state);\n\n  return {\n    app,\n    host: opts.host,\n    port: boundPort,\n    close: async () => {\n      await app.close();\n    },\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/daemon/lifecycle.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":143,"column":12,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":143,"endColumn":21},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":190,"column":46,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":190,"endColumn":54}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { existsSync } from 'node:fs';\nimport { readFile, writeFile, mkdir, rm } from 'node:fs/promises';\nimport { dirname, join } from 'node:path';\nimport { homedir } from 'node:os';\nimport { randomBytes } from 'node:crypto';\nimport { spawn } from 'node:child_process';\nimport { fileURLToPath } from 'node:url';\nimport { daemonLogsPath } from './telemetry.js';\n\nexport interface DaemonState {\n  pid: number;\n  daemonId: string;\n  host: string;\n  port: number;\n  token: string;\n  startedAt: string;\n  logsPath: string;\n}\n\nconst DEFAULT_HOST = '127.0.0.1';\nconst DEFAULT_PORT = 9999;\n\nfunction daemonDir(): string {\n  return join(homedir(), '.config', 'opta', 'daemon');\n}\n\nfunction statePath(): string {\n  return join(daemonDir(), 'state.json');\n}\n\nfunction tokenPath(): string {\n  return join(daemonDir(), 'token');\n}\n\nfunction pidPath(): string {\n  return join(daemonDir(), 'daemon.pid');\n}\n\nasync function ensureDaemonDir(): Promise<void> {\n  await mkdir(daemonDir(), { recursive: true });\n}\n\nexport async function readDaemonState(): Promise<DaemonState | null> {\n  try {\n    const raw = await readFile(statePath(), 'utf-8');\n    return JSON.parse(raw) as DaemonState;\n  } catch {\n    return null;\n  }\n}\n\nexport async function writeDaemonState(state: DaemonState): Promise<void> {\n  await ensureDaemonDir();\n  await writeFile(statePath(), JSON.stringify(state, null, 2), 'utf-8');\n  await writeFile(pidPath(), String(state.pid), 'utf-8');\n}\n\nexport async function clearDaemonState(): Promise<void> {\n  await Promise.all([\n    rm(statePath(), { force: true }),\n    rm(pidPath(), { force: true }),\n  ]);\n}\n\nexport async function readDaemonToken(): Promise<string | null> {\n  try {\n    return (await readFile(tokenPath(), 'utf-8')).trim();\n  } catch {\n    return null;\n  }\n}\n\nexport async function writeDaemonToken(token: string): Promise<void> {\n  await ensureDaemonDir();\n  await writeFile(tokenPath(), token, { encoding: 'utf-8', mode: 0o600 });\n}\n\nexport async function createDaemonToken(): Promise<string> {\n  const token = randomBytes(24).toString('hex');\n  await writeDaemonToken(token);\n  return token;\n}\n\nexport function defaultDaemonHost(): string {\n  return DEFAULT_HOST;\n}\n\nexport function defaultDaemonPort(): number {\n  return DEFAULT_PORT;\n}\n\nexport function isProcessRunning(pid: number): boolean {\n  try {\n    process.kill(pid, 0);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nasync function pingDaemon(host: string, port: number, timeoutMs = 500): Promise<boolean> {\n  const controller = new AbortController();\n  const timer = setTimeout(() => controller.abort(), timeoutMs);\n  timer.unref();\n  try {\n    const res = await fetch(`http://${host}:${port}/v3/health`, { signal: controller.signal });\n    return res.ok;\n  } catch {\n    return false;\n  } finally {\n    clearTimeout(timer);\n  }\n}\n\nexport async function isDaemonRunning(state?: DaemonState | null): Promise<boolean> {\n  const current = state ?? await readDaemonState();\n  if (!current) return false;\n  if (!isProcessRunning(current.pid)) return false;\n  return pingDaemon(current.host, current.port, 800);\n}\n\nfunction resolveCliEntrypoint(): string {\n  // In source mode this module lives at src/daemon/lifecycle.ts and the CLI entry\n  // is ../index.ts. In bundled mode this chunk lives in dist/ and the entry is\n  // dist/index.js (sibling, not parent).\n  const selfPath = fileURLToPath(import.meta.url);\n  const ext = selfPath.endsWith('.ts') ? '.ts' : '.js';\n  const baseDir = dirname(selfPath);\n\n  const sibling = join(baseDir, `index${ext}`);\n  if (existsSync(sibling)) return sibling;\n\n  const parent = join(baseDir, '..', `index${ext}`);\n  if (existsSync(parent)) return parent;\n\n  // Final fallback keeps previous behavior if the filesystem check is inconclusive.\n  return parent;\n}\n\nexport async function startDaemonDetached(opts?: { host?: string; port?: number }): Promise<DaemonState> {\n  const existing = await readDaemonState();\n  if (await isDaemonRunning(existing)) {\n    return existing!;\n  }\n\n  const host = opts?.host ?? DEFAULT_HOST;\n  const port = opts?.port ?? DEFAULT_PORT;\n  const token = await createDaemonToken();\n  const entry = resolveCliEntrypoint();\n  const nodeArgs: string[] = [];\n  if (entry.endsWith('.ts')) {\n    nodeArgs.push('--import', 'tsx');\n  }\n  nodeArgs.push(entry, 'daemon', 'run', '--host', host, '--port', String(port), '--token', token);\n\n  const child = spawn(process.execPath, nodeArgs, {\n    detached: true,\n    stdio: 'ignore',\n    env: {\n      ...process.env,\n      OPTA_DAEMON_PROCESS: '1',\n    },\n  });\n  child.unref();\n\n  const started = await waitForDaemonReady(10_000);\n  if (!started) {\n    throw new Error('Timed out waiting for daemon to start');\n  }\n\n  const running = await readDaemonState();\n  if (!running) {\n    throw new Error('Daemon did not publish state');\n  }\n  return running;\n}\n\nasync function waitForDaemonReady(timeoutMs: number): Promise<boolean> {\n  const start = Date.now();\n  while (Date.now() - start < timeoutMs) {\n    const current = await readDaemonState();\n    if (current && await isDaemonRunning(current)) return true;\n    await new Promise(resolve => setTimeout(resolve, 120));\n  }\n  return false;\n}\n\nexport async function ensureDaemonRunning(opts?: { host?: string; port?: number }): Promise<DaemonState> {\n  const current = await readDaemonState();\n  if (await isDaemonRunning(current)) return current!;\n  return startDaemonDetached(opts);\n}\n\nexport async function stopDaemon(): Promise<boolean> {\n  const state = await readDaemonState();\n  if (!state) return false;\n\n  if (!isProcessRunning(state.pid)) {\n    await clearDaemonState();\n    return true;\n  }\n\n  process.kill(state.pid, 'SIGTERM');\n  const start = Date.now();\n  while (Date.now() - start < 4000) {\n    if (!isProcessRunning(state.pid)) {\n      await clearDaemonState();\n      return true;\n    }\n    await new Promise(resolve => setTimeout(resolve, 100));\n  }\n\n  // Last resort\n  process.kill(state.pid, 'SIGKILL');\n  await clearDaemonState();\n  return true;\n}\n\nexport async function daemonStatus(): Promise<{\n  running: boolean;\n  state: DaemonState | null;\n  logsPath: string;\n}> {\n  const state = await readDaemonState();\n  const running = await isDaemonRunning(state);\n  if (!running && state) {\n    await clearDaemonState();\n  }\n  return {\n    running,\n    state: running ? state : null,\n    logsPath: daemonLogsPath(),\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/daemon/main.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/daemon/permission-coordinator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/daemon/session-manager.ts","messages":[{"ruleId":"@typescript-eslint/require-await","severity":1,"message":"Async method 'getSession' has no 'await' expression.","line":171,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":171,"endColumn":19,"suggestions":[{"messageId":"removeAsync","fix":{"range":[5236,5304],"text":"getSession(sessionId: string): SessionSnapshot | null"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":1,"message":"Async method 'getSessionMessages' has no 'await' expression.","line":177,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":177,"endColumn":27,"suggestions":[{"messageId":"removeAsync","fix":{"range":[5439,5514],"text":"getSessionMessages(sessionId: string): AgentMessage[] | null"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":1,"message":"Async method 'listBackgroundProcesses' has no 'await' expression.","line":299,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":299,"endColumn":32,"suggestions":[{"messageId":"removeAsync","fix":{"range":[9454,9541],"text":"listBackgroundProcesses(sessionId?: string): BackgroundProcessSnapshot[]"},"desc":"Remove 'async'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { nanoid } from 'nanoid';\nimport type { AgentMessage } from '../core/agent.js';\nimport { agentLoop } from '../core/agent.js';\nimport { loadConfig, type OptaConfig } from '../core/config.js';\nimport { LmxClient } from '../lmx/client.js';\nimport { findMatchingModelId, normalizeConfiguredModelId } from '../lmx/model-lifecycle.js';\nimport {\n  appendSessionEvent,\n  hasSessionStore,\n  listStoredSessions,\n  readSessionEventsAfter,\n  readSessionSnapshot,\n  writeSessionSnapshot,\n  type StoredSessionSnapshot,\n} from './session-store.js';\nimport { PermissionCoordinator } from './permission-coordinator.js';\nimport { TurnQueue, type QueuedTurn } from './turn-queue.js';\nimport { makeEnvelope } from '../protocol/v3/events.js';\nimport { ToolWorkerPool } from './worker-pool.js';\nimport type {\n  BackgroundOutputSlice,\n  BackgroundProcessSnapshot,\n  BackgroundSignal,\n  ClientSubmitTurn,\n  CreateSessionRequest,\n  PermissionDecision,\n  SessionSnapshot,\n  TurnDonePayload,\n  TurnErrorCode,\n  TurnErrorPayload,\n  V3Envelope,\n} from '../protocol/v3/types.js';\nimport { logDaemonEvent } from './telemetry.js';\nimport {\n  BackgroundManager,\n  type BackgroundManagerEvent,\n  type BackgroundOutputQuery,\n} from './background-manager.js';\nimport { errorMessage } from '../utils/errors.js';\n\nconst CHARS_PER_TOKEN = 4;\nconst LMX_PREFLIGHT_TIMEOUT_MS = 8_000;\nconst NO_MODEL_LOADED_MESSAGE = 'No Model Loaded - Use Opta Menu to begin.';\n\ninterface CodedTurnError extends Error {\n  turnErrorCode?: TurnErrorCode;\n}\n\ninterface ManagedSession {\n  sessionId: string;\n  model: string;\n  title?: string;\n  createdAt: string;\n  updatedAt: string;\n  messages: AgentMessage[];\n  toolCallCount: number;\n  queue: TurnQueue;\n  activeTurn?: QueuedTurn;\n  activeAbort?: AbortController;\n  seq: number;\n}\n\ntype SessionSubscriber = (event: V3Envelope) => void;\n\nexport class SessionManager {\n  private readonly sessions = new Map<string, ManagedSession>();\n  private readonly subscribers = new Map<string, Set<SessionSubscriber>>();\n  private readonly permissionCoordinator = new PermissionCoordinator();\n  private readonly toolWorkers = new ToolWorkerPool();\n  private readonly backgroundManager = new BackgroundManager({\n    maxConcurrent: 5,\n    defaultTimeout: 300_000,\n    maxBufferSize: 1_048_576,\n  });\n  private readonly unsubscribeBackgroundEvents: () => void;\n  private ingressSeq = 0;\n\n  constructor(\n    private readonly daemonId: string,\n    private readonly getConfig: () => Promise<OptaConfig> = async () => loadConfig()\n  ) {\n    this.unsubscribeBackgroundEvents = this.backgroundManager.subscribe((event) => {\n      void this.handleBackgroundEvent(event);\n    });\n  }\n\n  async hydrateFromDisk(): Promise<void> {\n    const sessionIds = await listStoredSessions();\n    for (const sessionId of sessionIds) {\n      const snapshot = await readSessionSnapshot(sessionId);\n      if (!snapshot) continue;\n      this.sessions.set(sessionId, {\n        sessionId: snapshot.sessionId,\n        model: snapshot.model,\n        title: snapshot.title,\n        createdAt: snapshot.createdAt,\n        updatedAt: snapshot.updatedAt,\n        messages: snapshot.messages,\n        toolCallCount: snapshot.toolCallCount,\n        queue: new TurnQueue(),\n        seq: snapshot.seq,\n      });\n    }\n  }\n\n  private sessionToSnapshot(session: ManagedSession): SessionSnapshot {\n    const writers = new Set<string>();\n    for (const queued of session.queue.toArray()) {\n      writers.add(queued.writerId);\n    }\n    if (session.activeTurn) writers.add(session.activeTurn.writerId);\n\n    return {\n      sessionId: session.sessionId,\n      model: session.model,\n      title: session.title,\n      createdAt: session.createdAt,\n      updatedAt: session.updatedAt,\n      activeTurnId: session.activeTurn?.turnId,\n      queuedTurns: session.queue.size,\n      toolCallCount: session.toolCallCount,\n      writerCount: writers.size,\n    };\n  }\n\n  async createSession(req: CreateSessionRequest): Promise<SessionSnapshot> {\n    const cfg = await this.getConfig();\n    const sessionId = req.sessionId ?? nanoid(12);\n\n    const now = new Date().toISOString();\n    let existing = this.sessions.get(sessionId);\n    if (!existing && await hasSessionStore(sessionId)) {\n      const snapshot = await readSessionSnapshot(sessionId);\n      if (snapshot) {\n        existing = {\n          sessionId,\n          model: snapshot.model,\n          title: snapshot.title,\n          createdAt: snapshot.createdAt,\n          updatedAt: snapshot.updatedAt,\n          messages: snapshot.messages,\n          toolCallCount: snapshot.toolCallCount,\n          queue: new TurnQueue(),\n          seq: snapshot.seq,\n        };\n      }\n    }\n\n    const session = existing ?? {\n      sessionId,\n      model: req.model ?? cfg.model.default,\n      title: req.title,\n      createdAt: now,\n      updatedAt: now,\n      messages: this.normalizeMessages(req.messages),\n      toolCallCount: 0,\n      queue: new TurnQueue(),\n      seq: 0,\n    };\n\n    this.sessions.set(sessionId, session);\n    await this.persistSnapshot(session);\n    await this.emit(session, 'session.snapshot', {\n      snapshot: this.sessionToSnapshot(session),\n      messages: session.messages,\n    });\n\n    return this.sessionToSnapshot(session);\n  }\n\n  async getSession(sessionId: string): Promise<SessionSnapshot | null> {\n    const session = this.sessions.get(sessionId);\n    if (!session) return null;\n    return this.sessionToSnapshot(session);\n  }\n\n  async getSessionMessages(sessionId: string): Promise<AgentMessage[] | null> {\n    const session = this.sessions.get(sessionId);\n    if (!session) return null;\n    return session.messages;\n  }\n\n  async submitTurn(sessionId: string, payload: ClientSubmitTurn): Promise<{ turnId: string; queued: number }> {\n    const session = this.sessions.get(sessionId);\n    if (!session) {\n      throw new Error(`Session not found: ${sessionId}`);\n    }\n\n    const turn: QueuedTurn = {\n      turnId: nanoid(12),\n      ingressSeq: ++this.ingressSeq,\n      sessionId,\n      clientId: payload.clientId,\n      writerId: payload.writerId,\n      content: payload.content,\n      mode: payload.mode,\n      metadata: payload.metadata,\n      createdAt: new Date().toISOString(),\n    };\n\n    session.queue.enqueue(turn);\n    session.updatedAt = new Date().toISOString();\n    await this.emit(session, 'turn.queued', {\n      turnId: turn.turnId,\n      writerId: turn.writerId,\n      clientId: turn.clientId,\n      queueSize: session.queue.size,\n    });\n    await this.persistSnapshot(session);\n\n    void this.processSessionQueue(sessionId);\n    return { turnId: turn.turnId, queued: session.queue.size };\n  }\n\n  async cancelSessionTurns(sessionId: string, opts: { turnId?: string; writerId?: string }): Promise<number> {\n    const session = this.sessions.get(sessionId);\n    if (!session) return 0;\n\n    let cancelled = 0;\n    if (opts.turnId) {\n      cancelled += session.queue.cancelByTurnId(opts.turnId) ? 1 : 0;\n    } else if (opts.writerId) {\n      cancelled += session.queue.cancelByWriter(opts.writerId);\n    }\n\n    // Active turn cancellation: cooperative abort via AbortController.\n    const active = session.activeTurn;\n    if (active && session.activeAbort) {\n      const matchesTurn = opts.turnId ? active.turnId === opts.turnId : false;\n      const matchesWriter = opts.writerId ? active.writerId === opts.writerId : false;\n      if (matchesTurn || matchesWriter) {\n        session.activeAbort.abort();\n        cancelled += 1;\n      }\n    }\n\n    if (cancelled > 0) {\n      await this.emit(session, 'session.cancelled', {\n        cancelled,\n        turnId: opts.turnId,\n        writerId: opts.writerId,\n      });\n      await this.persistSnapshot(session);\n    }\n    return cancelled;\n  }\n\n  resolvePermission(sessionId: string, decision: PermissionDecision): { ok: boolean; conflict: boolean; message?: string } {\n    const session = this.sessions.get(sessionId);\n    if (!session) return { ok: false, conflict: false, message: 'Session not found' };\n    const result = this.permissionCoordinator.resolve(decision.requestId, decision.decision);\n    return result;\n  }\n\n  async getEventsAfter(sessionId: string, afterSeq: number): Promise<V3Envelope[]> {\n    return readSessionEventsAfter(sessionId, afterSeq);\n  }\n\n  subscribe(sessionId: string, cb: SessionSubscriber): () => void {\n    const existing = this.subscribers.get(sessionId) ?? new Set<SessionSubscriber>();\n    existing.add(cb);\n    this.subscribers.set(sessionId, existing);\n    return () => {\n      const current = this.subscribers.get(sessionId);\n      if (!current) return;\n      current.delete(cb);\n      if (current.size === 0) this.subscribers.delete(sessionId);\n    };\n  }\n\n  getRuntimeStats(): {\n    sessionCount: number;\n    activeTurnCount: number;\n    queuedTurnCount: number;\n    subscriberCount: number;\n    ingressSeq: number;\n    toolWorkers: { workers: number; busy: number; queued: number };\n  } {\n    let activeTurnCount = 0;\n    let queuedTurnCount = 0;\n    for (const session of this.sessions.values()) {\n      if (session.activeTurn) activeTurnCount += 1;\n      queuedTurnCount += session.queue.size;\n    }\n    let subscriberCount = 0;\n    for (const set of this.subscribers.values()) {\n      subscriberCount += set.size;\n    }\n    return {\n      sessionCount: this.sessions.size,\n      activeTurnCount,\n      queuedTurnCount,\n      subscriberCount,\n      ingressSeq: this.ingressSeq,\n      toolWorkers: this.toolWorkers.getStats(),\n    };\n  }\n\n  async listBackgroundProcesses(sessionId?: string): Promise<BackgroundProcessSnapshot[]> {\n    if (sessionId && !this.sessions.has(sessionId)) {\n      throw new Error(`Session not found: ${sessionId}`);\n    }\n    return this.backgroundManager.list(sessionId);\n  }\n\n  async startBackgroundProcess(input: {\n    sessionId: string;\n    command: string;\n    label?: string;\n    cwd?: string;\n    timeoutMs?: number;\n  }): Promise<BackgroundProcessSnapshot> {\n    if (!this.sessions.has(input.sessionId)) {\n      throw new Error(`Session not found: ${input.sessionId}`);\n    }\n    await this.refreshBackgroundOptions();\n    return this.backgroundManager.start(input);\n  }\n\n  getBackgroundStatus(processId: string): BackgroundProcessSnapshot | null {\n    return this.backgroundManager.status(processId);\n  }\n\n  getBackgroundOutput(processId: string, query: BackgroundOutputQuery): BackgroundOutputSlice | null {\n    return this.backgroundManager.output(processId, query);\n  }\n\n  async killBackgroundProcess(processId: string, signal: BackgroundSignal = 'SIGTERM'): Promise<{\n    killed: boolean;\n    process: BackgroundProcessSnapshot;\n  } | null> {\n    return this.backgroundManager.kill(processId, signal);\n  }\n\n  async close(): Promise<void> {\n    this.unsubscribeBackgroundEvents();\n    const cfg = await this.getConfig().catch(() => null);\n    if (cfg) {\n      this.backgroundManager.updateOptions({\n        maxConcurrent: cfg.background.maxConcurrent,\n        defaultTimeout: cfg.background.defaultTimeout,\n        maxBufferSize: cfg.background.maxBufferSize,\n      });\n    }\n    if (cfg?.background.killOnSessionEnd ?? true) {\n      await this.backgroundManager.close();\n    }\n    await this.toolWorkers.close();\n  }\n\n  private normalizeMessages(raw?: unknown[]): AgentMessage[] {\n    if (!Array.isArray(raw)) return [];\n    return raw.filter((item): item is AgentMessage => {\n      if (!item || typeof item !== 'object') return false;\n      const maybe = item as Partial<AgentMessage>;\n      return typeof maybe.role === 'string';\n    });\n  }\n\n  private runToolWithDaemonPolicy(name: string, argsJson: string, signal?: AbortSignal): Promise<string> {\n    if (name === 'ask_user') {\n      return Promise.resolve(\n        'Error: ask_user is unavailable in daemon mode. Resolve permissions from an attached client instead.'\n      );\n    }\n    return this.toolWorkers.runTool(name, argsJson, signal);\n  }\n\n  private throwIfTurnAborted(session: ManagedSession): void {\n    if (!session.activeAbort?.signal.aborted) return;\n    const err = new Error('Turn cancelled');\n    err.name = 'AbortError';\n    throw err;\n  }\n\n  private newTurnError(message: string, code?: TurnErrorCode): CodedTurnError {\n    const err = new Error(message) as CodedTurnError;\n    if (code) err.turnErrorCode = code;\n    return err;\n  }\n\n  private normalizeErrorCode(err: unknown): string | undefined {\n    if (!err || typeof err !== 'object') return undefined;\n    const raw = (err as { code?: unknown }).code;\n    return typeof raw === 'string' ? raw.toLowerCase() : undefined;\n  }\n\n  private inferTransportErrorCode(err: unknown, message: string): TurnErrorCode | undefined {\n    const lower = message.toLowerCase();\n    const code = this.normalizeErrorCode(err);\n\n    if (code === 'econnrefused' || lower.includes('econnrefused') || lower.includes('connection refused')) {\n      return 'lmx-connection-refused';\n    }\n\n    if (\n      code === 'econnreset' ||\n      lower.includes('econnreset') ||\n      lower.includes('websocket closed') ||\n      lower.includes('socket closed') ||\n      lower.includes('socket hang up') ||\n      lower.includes('connection closed')\n    ) {\n      return 'lmx-ws-closed';\n    }\n\n    if (\n      code === 'etimedout' ||\n      code === 'esockettimedout' ||\n      code === 'econnaborted' ||\n      lower.includes('timed out') ||\n      lower.includes('timeout')\n    ) {\n      return 'lmx-timeout';\n    }\n\n    return undefined;\n  }\n\n  private resolveTurnErrorCode(err: unknown, message: string): TurnErrorCode | undefined {\n    if (err && typeof err === 'object') {\n      const coded = (err as { turnErrorCode?: unknown }).turnErrorCode;\n      if (\n        coded === 'no-model-loaded' ||\n        coded === 'lmx-ws-closed' ||\n        coded === 'lmx-timeout' ||\n        coded === 'lmx-connection-refused'\n      ) {\n        return coded;\n      }\n    }\n\n    if (message.toLowerCase().includes('no model loaded')) return 'no-model-loaded';\n    return this.inferTransportErrorCode(err, message);\n  }\n\n  private async runTurnModelPreflight(session: ManagedSession, config: OptaConfig): Promise<void> {\n    if (config.provider.active !== 'lmx') return;\n\n    this.throwIfTurnAborted(session);\n\n    const targetModel = normalizeConfiguredModelId(session.model);\n    let loadedModelIds: string[] = [];\n    try {\n      const lmx = new LmxClient({\n        host: config.connection.host,\n        fallbackHosts: config.connection.fallbackHosts,\n        port: config.connection.port,\n        adminKey: config.connection.adminKey,\n        timeoutMs: LMX_PREFLIGHT_TIMEOUT_MS,\n        maxRetries: 0,\n      });\n      const loaded = await lmx.models({\n        timeoutMs: LMX_PREFLIGHT_TIMEOUT_MS,\n        maxRetries: 0,\n      });\n      loadedModelIds = loaded.models.map((model) => model.model_id);\n    } catch (err) {\n      this.throwIfTurnAborted(session);\n      const detail = errorMessage(err);\n      const code = this.inferTransportErrorCode(err, detail) ?? 'no-model-loaded';\n      throw this.newTurnError(`${NO_MODEL_LOADED_MESSAGE} LMX preflight failed: ${detail}`, code);\n    }\n\n    this.throwIfTurnAborted(session);\n    if (loadedModelIds.length === 0) {\n      throw this.newTurnError(NO_MODEL_LOADED_MESSAGE, 'no-model-loaded');\n    }\n\n    const canonicalModelId = targetModel\n      ? findMatchingModelId(targetModel, loadedModelIds)\n      : undefined;\n    if (!canonicalModelId) {\n      if (!targetModel) {\n        throw this.newTurnError(`${NO_MODEL_LOADED_MESSAGE} Session model is not configured.`, 'no-model-loaded');\n      }\n      throw this.newTurnError(`${NO_MODEL_LOADED_MESSAGE} Session model \"${session.model}\" is not loaded.`, 'no-model-loaded');\n    }\n\n    if (session.model !== canonicalModelId) {\n      session.model = canonicalModelId;\n      session.updatedAt = new Date().toISOString();\n      await this.persistSnapshot(session);\n    }\n  }\n\n  private async processSessionQueue(sessionId: string): Promise<void> {\n    const session = this.sessions.get(sessionId);\n    if (!session || session.activeTurn) return;\n\n    const turn = session.queue.dequeue();\n    if (!turn) return;\n    session.activeTurn = turn;\n    session.activeAbort = new AbortController();\n    session.updatedAt = new Date().toISOString();\n    await this.persistSnapshot(session);\n\n    const turnStart = Date.now();\n    let firstTokenMs: number | null = null;\n    let completionTokens = 0;\n    let promptTokens = 0;\n    let toolCalls = 0;\n\n    try {\n      const cfg = await this.getConfig();\n      await this.runTurnModelPreflight(session, cfg);\n      this.throwIfTurnAborted(session);\n\n      await this.emit(session, 'turn.start', {\n        turnId: turn.turnId,\n        writerId: turn.writerId,\n        clientId: turn.clientId,\n        mode: turn.mode,\n      });\n\n      const run = await agentLoop(turn.content, cfg, {\n        existingMessages: session.messages,\n        sessionId,\n        silent: true,\n        signal: session.activeAbort.signal,\n        toolExecutor: (name, argsJson, signal) => this.runToolWithDaemonPolicy(name, argsJson, signal),\n        onStream: {\n          onToken: (text) => {\n            if (firstTokenMs === null) firstTokenMs = Date.now() - turnStart;\n            completionTokens += Math.ceil(text.length / CHARS_PER_TOKEN);\n            void this.emit(session, 'turn.token', { turnId: turn.turnId, text });\n          },\n          onThinking: (text) => {\n            void this.emit(session, 'turn.thinking', { turnId: turn.turnId, text });\n          },\n          onToolStart: (name, id, args) => {\n            toolCalls++;\n            void this.emit(session, 'tool.start', { turnId: turn.turnId, name, id, args });\n          },\n          onToolEnd: (name, id, result) => {\n            void this.emit(session, 'tool.end', { turnId: turn.turnId, name, id, result });\n          },\n          onUsage: (usage) => {\n            promptTokens = usage.promptTokens;\n          },\n          onPermissionRequest: async (toolName, args) => {\n            const { request, decision } = this.permissionCoordinator.request(sessionId, toolName, args);\n            await this.emit(session, 'permission.request', {\n              turnId: turn.turnId,\n              requestId: request.requestId,\n              toolName,\n              args,\n            });\n            const resolved = await decision;\n            await this.emit(session, 'permission.resolved', {\n              turnId: turn.turnId,\n              requestId: request.requestId,\n              decision: resolved,\n            });\n            return resolved;\n          },\n        },\n      });\n\n      session.messages = run.messages;\n      session.toolCallCount += run.toolCallCount;\n      session.updatedAt = new Date().toISOString();\n\n      const elapsed = (Date.now() - turnStart) / 1000;\n      const payload: TurnDonePayload = {\n        turnId: turn.turnId,\n        writerId: turn.writerId,\n        clientId: turn.clientId,\n        stats: {\n          tokens: completionTokens,\n          promptTokens,\n          completionTokens,\n          toolCalls,\n          elapsed,\n          speed: elapsed > 0.1 ? completionTokens / elapsed : 0,\n          firstTokenLatencyMs: firstTokenMs,\n        },\n      };\n      await this.emit(session, 'turn.done', payload);\n      await this.emit(session, 'session.updated', {\n        snapshot: this.sessionToSnapshot(session),\n      });\n      await this.persistSnapshot(session);\n    } catch (err) {\n      const aborted = err instanceof Error && err.name === 'AbortError';\n      const message = aborted ? 'Turn cancelled' : err instanceof Error ? err.message : String(err);\n      const code = aborted ? undefined : this.resolveTurnErrorCode(err, message);\n      const payload: TurnErrorPayload = {\n        turnId: turn.turnId,\n        writerId: turn.writerId,\n        clientId: turn.clientId,\n        message,\n      };\n      if (code) payload.code = code;\n\n      await this.emit(session, 'turn.error', payload);\n      if (!aborted) {\n        await logDaemonEvent({\n          level: 'error',\n          daemonId: this.daemonId,\n          sessionId,\n          msg: 'turn processing failed',\n          data: { turnId: turn.turnId, message },\n        });\n      }\n    } finally {\n      session.activeTurn = undefined;\n      session.activeAbort = undefined;\n      session.updatedAt = new Date().toISOString();\n      await this.persistSnapshot(session);\n      if (session.queue.size > 0) {\n        setImmediate(() => {\n          void this.processSessionQueue(sessionId);\n        });\n      }\n    }\n  }\n\n  private async persistSnapshot(session: ManagedSession): Promise<void> {\n    const stored: StoredSessionSnapshot = {\n      sessionId: session.sessionId,\n      model: session.model,\n      title: session.title,\n      createdAt: session.createdAt,\n      updatedAt: session.updatedAt,\n      messages: session.messages,\n      toolCallCount: session.toolCallCount,\n      seq: session.seq,\n    };\n    await writeSessionSnapshot(stored);\n  }\n\n  private async handleBackgroundEvent(event: BackgroundManagerEvent): Promise<void> {\n    const session = this.sessions.get(event.sessionId);\n    if (!session) return;\n\n    if (event.type === 'output') {\n      await this.emit(session, 'background.output', event.payload);\n    } else {\n      await this.emit(session, 'background.status', event.payload);\n    }\n    session.updatedAt = new Date().toISOString();\n    await this.persistSnapshot(session);\n  }\n\n  private async refreshBackgroundOptions(): Promise<void> {\n    const config = await this.getConfig();\n    this.backgroundManager.updateOptions({\n      maxConcurrent: config.background.maxConcurrent,\n      defaultTimeout: config.background.defaultTimeout,\n      maxBufferSize: config.background.maxBufferSize,\n    });\n  }\n\n  private async emit(\n    session: ManagedSession,\n    event: V3Envelope['event'],\n    payload: unknown\n  ): Promise<void> {\n    session.seq += 1;\n    const envelope = makeEnvelope(\n      {\n        daemonId: this.daemonId,\n        sessionId: session.sessionId,\n        seq: session.seq,\n      },\n      event,\n      payload\n    );\n\n    await appendSessionEvent(session.sessionId, envelope);\n    const watchers = this.subscribers.get(session.sessionId);\n    if (watchers) {\n      for (const cb of watchers) {\n        try {\n          cb(envelope);\n        } catch {\n          // Ignore subscriber errors so one bad client does not poison the session.\n        }\n      }\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/daemon/session-store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/daemon/telemetry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/daemon/turn-queue.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/daemon/worker-pool-worker.ts","messages":[{"ruleId":"@typescript-eslint/no-misused-promises","severity":1,"message":"Promise returned in function argument where a void return was expected.","line":34,"column":28,"nodeType":"ArrowFunctionExpression","messageId":"voidReturnArgument","endLine":46,"endColumn":4},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":38,"column":7,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":38,"endColumn":18,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[1205,1206],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":40,"column":7,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":40,"endColumn":18,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[1290,1291],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { parentPort } from 'node:worker_threads';\n\ninterface ToolJob {\n  id: string;\n  tool: string;\n  argsJson: string;\n}\n\nlet cachedExecuteTool: ((name: string, argsJson: string) => Promise<string>) | null = null;\nlet runtimeReady = false;\n\nasync function ensureRuntimeReady(): Promise<void> {\n  if (runtimeReady) return;\n  runtimeReady = true;\n  if (import.meta.url.endsWith('.ts')) {\n    const { register } = await import('tsx/esm/api');\n    register();\n  }\n}\n\nasync function loadExecuteTool(): Promise<(name: string, argsJson: string) => Promise<string>> {\n  if (cachedExecuteTool) return cachedExecuteTool;\n  await ensureRuntimeReady();\n  const mod = await import('../core/tools/executors.js');\n  const executeTool = (mod as { executeTool?: (name: string, argsJson: string) => Promise<string> }).executeTool;\n  if (typeof executeTool !== 'function') {\n    throw new Error('Worker tool runtime missing executeTool export');\n  }\n  cachedExecuteTool = executeTool;\n  return executeTool;\n}\n\nif (parentPort) {\n  parentPort.on('message', async (job: ToolJob) => {\n    try {\n      const executeTool = await loadExecuteTool();\n      const result = await executeTool(job.tool, job.argsJson);\n      parentPort!.postMessage({ id: job.id, ok: true, result });\n    } catch (err) {\n      parentPort!.postMessage({\n        id: job.id,\n        ok: false,\n        error: err instanceof Error ? err.message : String(err),\n      });\n    }\n  });\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/daemon/worker-pool.ts","messages":[{"ruleId":"@typescript-eslint/require-await","severity":1,"message":"Async method 'close' has no 'await' expression.","line":83,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":83,"endColumn":14,"suggestions":[{"messageId":"removeAsync","fix":{"range":[1878,1906],"text":"close(): void"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":257,"column":35,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":257,"endColumn":49}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { existsSync } from 'node:fs';\nimport { cpus } from 'node:os';\nimport { dirname, join } from 'node:path';\nimport { fileURLToPath, pathToFileURL } from 'node:url';\nimport { Worker } from 'node:worker_threads';\nimport { nanoid } from 'nanoid';\n\ninterface WorkerResponse {\n  id: string;\n  ok: boolean;\n  result?: string;\n  error?: string;\n}\n\ninterface ToolJob {\n  id: string;\n  tool: string;\n  argsJson: string;\n  signal?: AbortSignal;\n  aborted: boolean;\n  settled: boolean;\n  onAbort?: () => void;\n  resolve: (value: string) => void;\n  reject: (err: Error) => void;\n}\n\ninterface WorkerSlot {\n  worker: Worker;\n  busy: boolean;\n  disposed: boolean;\n  currentJob?: ToolJob;\n}\n\nfunction makeAbortError(message: string): Error {\n  const err = new Error(message);\n  err.name = 'AbortError';\n  return err;\n}\n\nexport class ToolWorkerPool {\n  private readonly maxWorkers: number;\n  private readonly queue: ToolJob[] = [];\n  private readonly workers: WorkerSlot[] = [];\n  private closed = false;\n\n  constructor(maxWorkers: number = defaultWorkerCount()) {\n    this.maxWorkers = Math.max(1, maxWorkers);\n  }\n\n  async runTool(tool: string, argsJson: string, signal?: AbortSignal): Promise<string> {\n    if (this.closed) {\n      throw new Error('Tool worker pool is closed');\n    }\n    if (signal?.aborted) {\n      throw makeAbortError('Tool execution cancelled');\n    }\n\n    return new Promise<string>((resolve, reject) => {\n      const job: ToolJob = {\n        id: nanoid(10),\n        tool,\n        argsJson,\n        signal,\n        aborted: false,\n        settled: false,\n        resolve,\n        reject,\n      };\n\n      if (signal) {\n        const onAbort = () => {\n          this.abortJob(job);\n        };\n        job.onAbort = onAbort;\n        signal.addEventListener('abort', onAbort, { once: true });\n      }\n\n      this.queue.push(job);\n      this.dispatch();\n    });\n  }\n\n  async close(): Promise<void> {\n    this.closed = true;\n\n    while (this.queue.length > 0) {\n      const job = this.queue.shift();\n      if (!job) continue;\n      this.rejectJob(job, new Error('Tool worker pool closed'));\n    }\n\n    const snapshots = [...this.workers];\n    for (const slot of snapshots) {\n      if (slot.currentJob) {\n        this.rejectJob(slot.currentJob, new Error('Tool worker pool closed'));\n        slot.currentJob = undefined;\n      }\n      this.detachWorker(slot);\n    }\n  }\n\n  getStats(): { workers: number; busy: number; queued: number } {\n    const workers = this.workers.length;\n    const busy = this.workers.reduce((count, slot) => count + (slot.busy ? 1 : 0), 0);\n    return { workers, busy, queued: this.queue.length };\n  }\n\n  private dispatch(): void {\n    if (this.closed) return;\n\n    while (this.queue.length > 0) {\n      const nextWorker = this.getIdleOrCreateWorker();\n      if (!nextWorker) return;\n      const nextJob = this.queue.shift();\n      if (!nextJob) return;\n      if (nextJob.aborted) {\n        this.rejectJob(nextJob, makeAbortError('Tool execution cancelled'));\n        continue;\n      }\n      this.assignJob(nextWorker, nextJob);\n    }\n  }\n\n  private getIdleOrCreateWorker(): WorkerSlot | null {\n    const idle = this.workers.find((slot) => !slot.busy && !slot.disposed);\n    if (idle) return idle;\n    if (this.workers.length >= this.maxWorkers) return null;\n    return this.createWorker();\n  }\n\n  private createWorker(): WorkerSlot {\n    const workerPath = this.resolveWorkerPath();\n    const execArgv = workerPath.pathname.endsWith('.ts') ? ['--import', 'tsx'] : [];\n    const worker = new Worker(workerPath, { execArgv });\n\n    const slot: WorkerSlot = {\n      worker,\n      busy: false,\n      disposed: false,\n    };\n\n    worker.on('message', (message: WorkerResponse) => {\n      if (slot.disposed || !slot.currentJob) return;\n      const job = slot.currentJob;\n      if (message.id !== job.id) return;\n      slot.currentJob = undefined;\n      slot.busy = false;\n      if (message.ok) {\n        this.resolveJob(job, message.result ?? '');\n      } else {\n        this.rejectJob(job, new Error(message.error ?? 'Unknown worker error'));\n      }\n      this.dispatch();\n    });\n\n    worker.on('error', (err) => {\n      if (slot.disposed) return;\n      this.failWorker(slot, err instanceof Error ? err : new Error(String(err)));\n    });\n\n    worker.on('exit', (code) => {\n      if (slot.disposed) return;\n      const error = code === 0\n        ? new Error('Worker exited before returning a result')\n        : new Error(`Worker exited with code ${code}`);\n      this.failWorker(slot, error);\n    });\n\n    this.workers.push(slot);\n    return slot;\n  }\n\n  private assignJob(slot: WorkerSlot, job: ToolJob): void {\n    slot.busy = true;\n    slot.currentJob = job;\n    slot.worker.postMessage({\n      id: job.id,\n      tool: job.tool,\n      argsJson: job.argsJson,\n    });\n  }\n\n  private failWorker(slot: WorkerSlot, err: Error): void {\n    const job = slot.currentJob;\n    slot.currentJob = undefined;\n    slot.busy = false;\n    if (job) {\n      this.rejectJob(job, err);\n    }\n    this.detachWorker(slot);\n    this.dispatch();\n  }\n\n  private detachWorker(slot: WorkerSlot): void {\n    if (slot.disposed) return;\n    slot.disposed = true;\n    const idx = this.workers.indexOf(slot);\n    if (idx >= 0) {\n      this.workers.splice(idx, 1);\n    }\n    slot.worker.removeAllListeners();\n    void slot.worker.terminate();\n  }\n\n  private abortJob(job: ToolJob): void {\n    if (job.settled || job.aborted) return;\n    job.aborted = true;\n\n    const queuedIndex = this.queue.findIndex((item) => item.id === job.id);\n    if (queuedIndex >= 0) {\n      this.queue.splice(queuedIndex, 1);\n      this.rejectJob(job, makeAbortError('Tool execution cancelled'));\n      return;\n    }\n\n    const active = this.workers.find((slot) => slot.currentJob?.id === job.id);\n    if (!active || !active.currentJob) return;\n    this.rejectJob(job, makeAbortError('Tool execution cancelled'));\n    active.currentJob = undefined;\n    active.busy = false;\n    this.detachWorker(active);\n    this.dispatch();\n  }\n\n  private resolveJob(job: ToolJob, value: string): void {\n    if (job.settled) return;\n    job.settled = true;\n    if (job.signal && job.onAbort) {\n      job.signal.removeEventListener('abort', job.onAbort);\n    }\n    job.resolve(value);\n  }\n\n  private rejectJob(job: ToolJob, err: Error): void {\n    if (job.settled) return;\n    job.settled = true;\n    if (job.signal && job.onAbort) {\n      job.signal.removeEventListener('abort', job.onAbort);\n    }\n    job.reject(err);\n  }\n\n  private resolveWorkerPath(): URL {\n    const selfPath = fileURLToPath(import.meta.url);\n    const ext = selfPath.endsWith('.ts') ? '.ts' : '.js';\n    const baseDir = dirname(selfPath);\n\n    // Source layout: src/daemon/worker-pool.ts -> src/daemon/worker-pool-worker.ts\n    // Bundled layout: dist/chunk-*.js -> dist/daemon/worker-pool-worker.js\n    const candidates = [\n      join(baseDir, `worker-pool-worker${ext}`),\n      join(baseDir, 'daemon', `worker-pool-worker${ext}`),\n      join(baseDir, '..', 'daemon', `worker-pool-worker${ext}`),\n    ];\n\n    const found = candidates.find((p) => existsSync(p));\n    return pathToFileURL(found ?? candidates[0]!);\n  }\n}\n\nfunction defaultWorkerCount(): number {\n  const envRaw = process.env['OPTA_DAEMON_TOOL_WORKERS'];\n  if (envRaw) {\n    const parsed = Number.parseInt(envRaw, 10);\n    if (Number.isFinite(parsed) && parsed > 0) {\n      return parsed;\n    }\n  }\n  const cpuCount = cpus().length;\n  return Math.max(1, Math.min(8, cpuCount - 1));\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/daemon/ws-server.ts","messages":[{"ruleId":"@typescript-eslint/require-await","severity":1,"message":"Async function 'registerWsServer' has no 'await' expression.","line":25,"column":8,"nodeType":"FunctionDeclaration","messageId":"missingAwait","endLine":25,"endColumn":39,"suggestions":[{"messageId":"removeAsync","fix":{"range":[776,864],"text":"function registerWsServer(app: FastifyInstance, deps: WsServerDeps): void"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'message' may use Object's default stringification format ('[object Object]') when stringified.","line":87,"column":36,"nodeType":"Identifier","messageId":"baseToString","endLine":87,"endColumn":43}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { FastifyInstance } from 'fastify';\nimport type WebSocket from 'ws';\nimport type { RawData } from 'ws';\nimport { WsInboundSchema } from '../protocol/v3/ws.js';\nimport type { V3Envelope } from '../protocol/v3/types.js';\nimport type { SessionManager } from './session-manager.js';\n\nexport interface WsServerDeps {\n  sessionManager: SessionManager;\n  token: string;\n}\n\nfunction readBearer(header: string | undefined): string | null {\n  if (!header) return null;\n  const trimmed = header.trim();\n  if (!trimmed.toLowerCase().startsWith('bearer ')) return null;\n  return trimmed.slice(7).trim() || null;\n}\n\nfunction sendJson(socket: WebSocket, payload: unknown): void {\n  if (socket.readyState !== socket.OPEN) return;\n  socket.send(JSON.stringify(payload));\n}\n\nexport async function registerWsServer(app: FastifyInstance, deps: WsServerDeps): Promise<void> {\n  app.get('/v3/ws', { websocket: true }, (socket, req) => {\n    const query = req.query as { sessionId?: string; afterSeq?: string; token?: string };\n    const bearer = readBearer(req.headers.authorization);\n    const token = bearer ?? query.token;\n    if (!token || token !== deps.token) {\n      sendJson(socket, { error: 'Unauthorized' });\n      socket.close(4001, 'unauthorized');\n      return;\n    }\n\n    const sessionId = query.sessionId;\n    const afterSeq = Number.parseInt(query.afterSeq ?? '0', 10);\n    if (!sessionId) {\n      sendJson(socket, { error: 'Missing sessionId query parameter' });\n      socket.close(4000, 'missing sessionId');\n      return;\n    }\n\n    const startAfterSeq = Number.isFinite(afterSeq) ? afterSeq : 0;\n    let cursorSeq = startAfterSeq;\n    let replaying = true;\n    const bufferedLive: V3Envelope[] = [];\n\n    const flushBufferedLive = () => {\n      if (bufferedLive.length === 0) return;\n      bufferedLive.sort((a, b) => a.seq - b.seq);\n      for (const event of bufferedLive) {\n        if (event.seq <= cursorSeq) continue;\n        cursorSeq = event.seq;\n        sendJson(socket, event);\n      }\n      bufferedLive.length = 0;\n    };\n\n    const unsubscribe = deps.sessionManager.subscribe(sessionId, (event) => {\n      if (event.seq <= cursorSeq) return;\n      if (replaying) {\n        bufferedLive.push(event);\n        return;\n      }\n      cursorSeq = event.seq;\n      sendJson(socket, event);\n    });\n\n    void deps.sessionManager.getEventsAfter(sessionId, startAfterSeq).then((events) => {\n      events.sort((a, b) => a.seq - b.seq);\n      for (const event of events) {\n        if (event.seq <= cursorSeq) continue;\n        cursorSeq = event.seq;\n        sendJson(socket, event);\n      }\n    }).catch(() => {\n      // Keep live stream operational even if replay read fails.\n    }).finally(() => {\n      replaying = false;\n      flushBufferedLive();\n    });\n\n    socket.on('message', (message: RawData) => {\n      let parsed: unknown;\n      try {\n        parsed = JSON.parse(String(message));\n      } catch {\n        sendJson(socket, { error: 'Invalid JSON payload' });\n        return;\n      }\n\n      const decoded = WsInboundSchema.safeParse(parsed);\n      if (!decoded.success) {\n        sendJson(socket, { error: 'Invalid WS payload', details: decoded.error.issues });\n        return;\n      }\n\n      const inbound = decoded.data;\n      if (inbound.type === 'turn.submit') {\n        void deps.sessionManager.submitTurn(inbound.sessionId, {\n          clientId: inbound.clientId,\n          writerId: inbound.writerId,\n          content: inbound.content,\n          mode: inbound.mode,\n          metadata: inbound.metadata,\n        }).then((queued) => {\n          sendJson(socket, { type: 'ack', action: 'turn.submit', ...queued });\n        }).catch((err: unknown) => {\n          sendJson(socket, { error: err instanceof Error ? err.message : String(err) });\n        });\n        return;\n      }\n\n      if (inbound.type === 'permission.resolve') {\n        const result = deps.sessionManager.resolvePermission(inbound.sessionId, {\n          requestId: inbound.requestId,\n          decision: inbound.decision,\n          decidedBy: inbound.decidedBy,\n        });\n        sendJson(socket, { type: 'ack', action: 'permission.resolve', result });\n        return;\n      }\n\n      if (inbound.type === 'turn.cancel') {\n        void deps.sessionManager.cancelSessionTurns(inbound.sessionId, {\n          turnId: inbound.turnId,\n          writerId: inbound.writerId,\n        }).then((cancelled) => {\n          sendJson(socket, { type: 'ack', action: 'turn.cancel', cancelled });\n        }).catch((err: unknown) => {\n          sendJson(socket, { error: err instanceof Error ? err.message : String(err) });\n        });\n      }\n    });\n\n    socket.on('close', () => {\n      unsubscribe();\n    });\n    socket.on('error', () => {\n      unsubscribe();\n    });\n  });\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/git/checkpoints.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":128,"column":24,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":128,"endColumn":60,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[3534,3535],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Checkpoint system for Opta CLI.\n *\n * Saves git diffs as patch files after each file-modifying tool call,\n * allowing mid-task undo via `git apply -R`.\n *\n * Checkpoint directory layout:\n *   <cwd>/.opta/checkpoints/<sessionId>/\n *     index.json    metadata for all checkpoints in this session\n *     1.patch       diff patch for checkpoint #1\n *     2.patch       diff patch for checkpoint #2\n *     ...\n */\n\nimport { mkdir, writeFile, readFile, rm } from 'node:fs/promises';\nimport { join } from 'node:path';\nimport { execa } from 'execa';\nimport { gitDiff } from './utils.js';\n\n/**\n * Metadata for a single checkpoint.\n */\nexport interface Checkpoint {\n  n: number;\n  tool: string;\n  path: string;\n  timestamp: string;\n}\n\n/**\n * Shape of the index.json file stored in each session's checkpoint directory.\n */\ninterface CheckpointIndex {\n  session: string;\n  checkpoints: Checkpoint[];\n}\n\n/**\n * Returns the checkpoint directory path for a given session.\n */\nfunction checkpointDir(cwd: string, sessionId: string): string {\n  return join(cwd, '.opta', 'checkpoints', sessionId);\n}\n\n/**\n * Creates a checkpoint by saving the current diff for `filePath` as a patch file.\n *\n * No-op if the file has no changes (empty diff).\n */\nexport async function createCheckpoint(\n  cwd: string,\n  sessionId: string,\n  n: number,\n  tool: string,\n  filePath: string,\n): Promise<void> {\n  const diff = await gitDiff(cwd, filePath);\n  if (!diff) return; // No changes  nothing to checkpoint\n\n  const dir = checkpointDir(cwd, sessionId);\n  await mkdir(dir, { recursive: true });\n\n  // Write the patch file.\n  // execa strips the trailing newline from stdout, but git apply requires it.\n  const patchContent = diff.endsWith('\\n') ? diff : diff + '\\n';\n  const patchPath = join(dir, `${n}.patch`);\n  await writeFile(patchPath, patchContent, 'utf-8');\n\n  // Read or create index.json\n  const indexPath = join(dir, 'index.json');\n  let index: CheckpointIndex;\n  try {\n    const raw = await readFile(indexPath, 'utf-8');\n    index = JSON.parse(raw) as CheckpointIndex;\n  } catch (err) {\n    const code = (err as NodeJS.ErrnoException | undefined)?.code;\n    if (code !== 'ENOENT' && code !== 'ENOTDIR') {\n      console.error(`Failed to read checkpoint index at ${indexPath}, creating new:`, err);\n    }\n    index = { session: sessionId, checkpoints: [] };\n  }\n\n  // Append the new checkpoint\n  index.checkpoints.push({\n    n,\n    tool,\n    path: filePath,\n    timestamp: new Date().toISOString(),\n  });\n\n  await writeFile(indexPath, JSON.stringify(index, null, 2), 'utf-8');\n}\n\n/**\n * Returns all checkpoints for a session, in order.\n * Returns an empty array if the session has no checkpoints.\n */\nexport async function listCheckpoints(\n  cwd: string,\n  sessionId: string,\n): Promise<Checkpoint[]> {\n  const indexPath = join(checkpointDir(cwd, sessionId), 'index.json');\n  try {\n    const raw = await readFile(indexPath, 'utf-8');\n    const index = JSON.parse(raw) as CheckpointIndex;\n    return index.checkpoints;\n  } catch {\n    return [];\n  }\n}\n\n/**\n * Undoes a checkpoint by applying its patch in reverse.\n *\n * Without `n`, undoes the last checkpoint.\n * With `n`, undoes the specific checkpoint.\n */\nexport async function undoCheckpoint(\n  cwd: string,\n  sessionId: string,\n  n?: number,\n): Promise<void> {\n  const checkpoints = await listCheckpoints(cwd, sessionId);\n  if (checkpoints.length === 0) {\n    throw new Error(`No checkpoints found for session \"${sessionId}\"`);\n  }\n\n  const targetN = n ?? checkpoints[checkpoints.length - 1]!.n;\n  const patchPath = join(checkpointDir(cwd, sessionId), `${targetN}.patch`);\n\n  await execa('git', ['apply', '-R', patchPath], { cwd });\n}\n\n/**\n * Reads the raw patch content for a specific checkpoint.\n * Returns an empty string if the patch file does not exist.\n */\nexport async function readPatchContent(\n  cwd: string,\n  sessionId: string,\n  n: number,\n): Promise<string> {\n  const patchPath = join(checkpointDir(cwd, sessionId), `${n}.patch`);\n  try {\n    return await readFile(patchPath, 'utf-8');\n  } catch {\n    return '';\n  }\n}\n\n/**\n * Computes a diff stat summary (additions, deletions) from a patch string.\n * Returns { additions, deletions } line counts.\n */\nexport function patchStat(patch: string): { additions: number; deletions: number } {\n  let additions = 0;\n  let deletions = 0;\n  for (const line of patch.split('\\n')) {\n    if (line.startsWith('+') && !line.startsWith('+++')) additions++;\n    if (line.startsWith('-') && !line.startsWith('---')) deletions++;\n  }\n  return { additions, deletions };\n}\n\n/**\n * Undoes ALL checkpoints for a session, in reverse order.\n * Throws if any individual undo fails.\n */\nexport async function undoAllCheckpoints(\n  cwd: string,\n  sessionId: string,\n): Promise<number> {\n  const checkpoints = await listCheckpoints(cwd, sessionId);\n  if (checkpoints.length === 0) {\n    throw new Error(`No checkpoints found for session \"${sessionId}\"`);\n  }\n\n  // Undo in reverse order to avoid patch conflicts\n  const reversed = [...checkpoints].reverse();\n  let undone = 0;\n  for (const cp of reversed) {\n    const patchPath = join(checkpointDir(cwd, sessionId), `${cp.n}.patch`);\n    try {\n      await execa('git', ['apply', '-R', patchPath], { cwd });\n      undone++;\n    } catch {\n      // Patch may not apply cleanly if already reverted  skip\n    }\n  }\n  return undone;\n}\n\n/**\n * Removes all checkpoint data for a session.\n * No-op if the session directory doesn't exist.\n */\nexport async function cleanupCheckpoints(\n  cwd: string,\n  sessionId: string,\n): Promise<void> {\n  const dir = checkpointDir(cwd, sessionId);\n  await rm(dir, { recursive: true, force: true });\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/git/commit.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":27,"column":23,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":27,"endColumn":33},{"ruleId":"@typescript-eslint/restrict-plus-operands","severity":1,"message":"Invalid operand for a '+' operation. Operands must each be a number or string, allowing a string + any of: `any`, `boolean`, `null`, `RegExp`, `undefined`. Got `ContentPart[]`.","line":29,"column":32,"nodeType":"CallExpression","messageId":"invalid","endLine":29,"endColumn":53},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'content.slice(0, 200)' may use Object's default stringification format ('[object Object]') when stringified.","line":29,"column":32,"nodeType":"CallExpression","messageId":"baseToString","endLine":29,"endColumn":53},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'truncated' may use Object's default stringification format ('[object Object]') when stringified.","line":30,"column":29,"nodeType":"Identifier","messageId":"baseToString","endLine":30,"endColumn":38},{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":1,"message":"Invalid type \"string | ContentPart[]\" of template literal expression.","line":30,"column":29,"nodeType":"Identifier","messageId":"invalidType","endLine":30,"endColumn":38},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":63,"column":49,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":63,"endColumn":51,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1920,1922],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":1,"message":"Invalid type \"unknown\" of template literal expression.","line":68,"column":49,"nodeType":"Identifier","messageId":"invalidType","endLine":68,"endColumn":52}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Auto-commit module for Opta CLI.\n *\n * Generates commit messages via the LLM and commits session changes.\n * Uses `execa` with array arguments (no shell interpolation)\n * and `reject: false` for safe error handling.\n */\n\nimport { execa } from 'execa';\nimport { debug } from '../core/debug.js';\nimport type { AgentMessage } from '../core/agent.js';\n\n/**\n * Extracts user + assistant messages into a text summary\n * suitable for commit message generation.\n *\n * Filters to only user and assistant roles (with content),\n * truncates each message to 200 characters.\n */\nexport function getSessionSummary(messages: AgentMessage[]): string {\n  return messages\n    .filter(\n      (m) =>\n        (m.role === 'user' || m.role === 'assistant') && m.content != null,\n    )\n    .map((m) => {\n      const content = m.content!;\n      const truncated =\n        content.length > 200 ? content.slice(0, 200) + '...' : content;\n      return `[${m.role}] ${truncated}`;\n    })\n    .join('\\n');\n}\n\n/**\n * Sends a session summary to the LLM to generate a conventional commit message.\n * Falls back to a default message on error.\n */\nexport async function generateCommitMessage(\n  messages: AgentMessage[],\n  client: import('openai').default,\n  model: string,\n): Promise<string> {\n  const summary = getSessionSummary(messages);\n  const fallback = 'feat: apply AI-assisted changes';\n\n  if (!summary.trim()) return fallback;\n\n  try {\n    const response = await client.chat.completions.create({\n      model,\n      messages: [\n        {\n          role: 'system',\n          content:\n            'Generate a concise git commit message (max 72 chars for subject line) for these changes. Use conventional commit format (feat/fix/refactor/docs). Reply with ONLY the commit message, no explanation.',\n        },\n        { role: 'user', content: summary },\n      ],\n      max_tokens: 100,\n    });\n\n    const message = response.choices[0]?.message?.content?.trim();\n    if (!message) return fallback;\n\n    return message;\n  } catch (err) {\n    debug(`Failed to generate commit message: ${err}`);\n    return fallback;\n  }\n}\n\n/**\n * Stages specified files via `git add`, verifies staged changes exist,\n * then commits with the given message.\n *\n * Returns true on success, false if nothing was staged or commit fails.\n */\nexport async function commitSessionChanges(\n  cwd: string,\n  files: string[],\n  message: string,\n): Promise<boolean> {\n  if (files.length === 0) {\n    debug('commitSessionChanges: no files provided');\n    return false;\n  }\n\n  // Stage the specified files\n  const addResult = await execa('git', ['add', ...files], {\n    cwd,\n    reject: false,\n  });\n\n  if (addResult.exitCode !== 0) {\n    debug(`git add failed: ${addResult.stderr}`);\n    return false;\n  }\n\n  // Verify there are staged changes\n  const diffResult = await execa(\n    'git',\n    ['diff', '--cached', '--name-only'],\n    { cwd, reject: false },\n  );\n\n  if (diffResult.exitCode !== 0 || !diffResult.stdout.trim()) {\n    debug('No staged changes after git add');\n    return false;\n  }\n\n  // Commit\n  const commitResult = await execa('git', ['commit', '-m', message], {\n    cwd,\n    reject: false,\n  });\n\n  if (commitResult.exitCode !== 0) {\n    debug(`git commit failed: ${commitResult.stderr}`);\n    return false;\n  }\n\n  return true;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/git/utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/hooks/integration.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/hooks/manager.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":142,"column":32,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":142,"endColumn":34,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[3850,3852],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/require-await","severity":1,"message":"Async method 'fire' has no 'await' expression.","line":193,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":193,"endColumn":22,"suggestions":[{"messageId":"removeAsync","fix":{"range":[5439,5525],"text":"fire(\n    _event: HookEvent,\n    _context: HookContext,\n  ): HookResult"},"desc":"Remove 'async'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Hook system for Opta CLI lifecycle events.\n *\n * Users configure shell commands that fire at lifecycle points (session start/end,\n * tool pre/post, compaction, errors). Zero hooks configured = zero cost via\n * NoOpHookManager singleton.\n */\n\nimport { execa } from 'execa';\n\n//  Types \n\nexport type HookEvent =\n  | 'session.start'\n  | 'session.end'\n  | 'tool.pre'\n  | 'tool.post'\n  | 'compact'\n  | 'error';\n\nexport interface HookDefinition {\n  event: HookEvent;\n  command: string;\n  matcher?: string;\n  timeout?: number;\n  background?: boolean;\n}\n\nexport interface HookContext {\n  event: HookEvent;\n  session_id: string;\n  cwd: string;\n  tool_name?: string;\n  tool_args?: string;\n  tool_result?: string;\n  error_message?: string;\n  model?: string;\n}\n\nexport interface HookResult {\n  cancelled: boolean;\n  reason?: string;\n}\n\n//  Constants \n\nconst NOOP_RESULT: HookResult = Object.freeze({ cancelled: false });\nconst DEFAULT_TIMEOUT = 10_000;\n\n/** Only these env vars are passed to hook subprocesses (security: prevents API key leaks). */\nexport const ALLOWED_ENV_KEYS = new Set(['PATH', 'HOME', 'USER', 'SHELL', 'TERM', 'LANG', 'LC_ALL', 'NODE_ENV', 'TMPDIR']);\n\n//  Compiled hook (internal) \n\ninterface CompiledHook extends HookDefinition {\n  matcherRegex?: RegExp;\n}\n\n//  HookManager \n\nexport class HookManager {\n  protected readonly hooks: CompiledHook[];\n\n  constructor(definitions: HookDefinition[]) {\n    this.hooks = definitions.map((def) => ({\n      ...def,\n      matcherRegex: def.matcher ? new RegExp(def.matcher) : undefined,\n    }));\n  }\n\n  /**\n   * Factory: returns NoOpHookManager when no hooks are configured,\n   * or a full HookManager when hooks exist.\n   */\n  static create(definitions?: HookDefinition[]): HookManager {\n    if (!definitions || definitions.length === 0) {\n      return noopSingleton;\n    }\n    return new HookManager(definitions);\n  }\n\n  /**\n   * Fire all hooks matching the given event + context.\n   * For tool.pre: non-zero exit code = cancellation.\n   */\n  async fire(event: HookEvent, context: HookContext): Promise<HookResult> {\n    const matching = this.hooks.filter((h) => {\n      if (h.event !== event) return false;\n      // Matcher only applies to tool.pre / tool.post\n      if (h.matcherRegex && context.tool_name) {\n        return h.matcherRegex.test(context.tool_name);\n      }\n      // If hook has a matcher but no tool_name in context, skip\n      if (h.matcherRegex && !context.tool_name) return false;\n      return true;\n    });\n\n    for (const hook of matching) {\n      if (hook.background) {\n        // Fire and forget\n        this.runHook(hook, context).catch(() => {});\n        continue;\n      }\n\n      const result = await this.runHook(hook, context);\n      // Only tool.pre can cancel\n      if (event === 'tool.pre' && result.cancelled) {\n        return result;\n      }\n    }\n\n    return NOOP_RESULT;\n  }\n\n  /**\n   * Execute a single hook command with env vars from context.\n   */\n  protected async runHook(\n    hook: CompiledHook,\n    context: HookContext,\n  ): Promise<HookResult> {\n    const env = this.buildEnv(context);\n    const timeout = hook.timeout ?? DEFAULT_TIMEOUT;\n\n    try {\n      const result = await execa('sh', ['-c', hook.command], {\n        env,\n        extendEnv: false,\n        timeout,\n        reject: false,\n      });\n\n      // Timeout  do not treat as cancellation\n      if (result.timedOut) {\n        return NOOP_RESULT;\n      }\n\n      // Only tool.pre hooks can cancel via non-zero exit\n      if (context.event === 'tool.pre' && result.exitCode !== 0) {\n        return {\n          cancelled: true,\n          reason: result.stderr?.trim() || 'Hook exited with non-zero status',\n        };\n      }\n    } catch {\n      // Timeout or other error  do not cancel, just swallow\n    }\n\n    return NOOP_RESULT;\n  }\n\n  /**\n   * Build environment variables from HookContext.\n   * Only passes an allowlist of safe env vars (PATH, HOME, etc.) plus OPTA_* vars.\n   * This prevents leaking API keys or secrets to hook subprocesses.\n   */\n  protected buildEnv(context: HookContext): Record<string, string> {\n    const env: Record<string, string> = {};\n\n    // Only pass safe env vars from the allowlist\n    for (const key of ALLOWED_ENV_KEYS) {\n      const val = process.env[key];\n      if (val !== undefined) env[key] = val;\n    }\n\n    // Also pass OPTA_* vars from process.env\n    for (const [key, val] of Object.entries(process.env)) {\n      if (key.startsWith('OPTA_') && val !== undefined) env[key] = val;\n    }\n\n    // Add hook-specific OPTA_ vars\n    env.OPTA_EVENT = context.event;\n    env.OPTA_SESSION_ID = context.session_id;\n    env.OPTA_CWD = context.cwd;\n\n    if (context.model) env['OPTA_MODEL'] = context.model;\n    if (context.tool_name) env['OPTA_TOOL_NAME'] = context.tool_name;\n    if (context.tool_args) env['OPTA_TOOL_ARGS'] = context.tool_args;\n    if (context.tool_result) env['OPTA_TOOL_RESULT'] = context.tool_result.slice(0, 2048);\n    if (context.error_message) env['OPTA_ERROR'] = context.error_message;\n\n    return env;\n  }\n}\n\n//  NoOpHookManager \n\nexport class NoOpHookManager extends HookManager {\n  constructor() {\n    super([]);\n  }\n\n  override async fire(\n    _event: HookEvent,\n    _context: HookContext,\n  ): Promise<HookResult> {\n    return NOOP_RESULT;\n  }\n}\n\nconst noopSingleton = new NoOpHookManager();\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/index.ts","messages":[{"ruleId":"@typescript-eslint/no-floating-promises","severity":1,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":33,"column":3,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":36,"endColumn":6,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[966,966],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[966,966],"text":"await "},"desc":"Add await operator."}]},{"ruleId":"@typescript-eslint/no-unnecessary-type-conversion","severity":1,"message":"Passing a boolean to Boolean() does not change the type or value of the boolean.","line":55,"column":23,"nodeType":"Identifier","messageId":"unnecessaryTypeConversion","endLine":55,"endColumn":30,"suggestions":[{"messageId":"suggestRemove","fix":{"range":[1668,1720],"text":"(process.stdin.isTTY && process.stdout.isTTY)"},"desc":"Remove the type conversion."},{"messageId":"suggestSatisfies","data":{"type":"boolean"},"fix":{"range":[1668,1720],"text":"(process.stdin.isTTY && process.stdout.isTTY) satisfies boolean"},"desc":"Instead, assert that the value satisfies the boolean type."}]},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `DoOptions`.","line":168,"column":29,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":168,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `EmbedOptions`.","line":183,"column":23,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":183,"endColumn":27},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `BenchmarkOptions`.","line":225,"column":21,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":225,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `StatusOptions`.","line":234,"column":18,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":234,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string | undefined`.","line":277,"column":18,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":277,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `ModelsOptions | undefined`.","line":277,"column":102,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":277,"endColumn":106},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string | undefined`.","line":303,"column":22,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":303,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string | undefined`.","line":303,"column":30,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":303,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `EnvCommandOptions`.","line":303,"column":36,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":303,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string | undefined`.","line":315,"column":18,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":315,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string | undefined`.","line":315,"column":26,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":315,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string | undefined`.","line":315,"column":31,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":315,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `ConfigOptions | undefined`.","line":315,"column":38,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":315,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `AccountAuthOptions`.","line":330,"column":25,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":330,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `AccountAuthOptions`.","line":340,"column":24,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":340,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `AccountCommandOptions`.","line":349,"column":25,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":349,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `KeyCreateOptions | undefined`.","line":371,"column":21,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":371,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `KeyShowOptions | undefined`.","line":382,"column":19,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":382,"endColumn":23},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `KeyCopyOptions | undefined`.","line":391,"column":19,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":391,"endColumn":23},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `AccountCommandOptions`.","line":400,"column":25,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":400,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string | undefined`.","line":416,"column":20,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":416,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string | undefined`.","line":416,"column":28,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":416,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `SessionsOptions | undefined`.","line":416,"column":32,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":416,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `McpListOptions`.","line":429,"column":19,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":429,"endColumn":23},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `{ env?: string | undefined; }`.","line":438,"column":33,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":438,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `InitOptions`.","line":495,"column":16,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":495,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `DiffOptions | undefined`.","line":504,"column":16,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":504,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string | undefined`.","line":514,"column":17,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":514,"endColumn":23},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `ServeOptions | undefined`.","line":514,"column":25,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":514,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `UpdateOptions`.","line":541,"column":25,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":541,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":553,"column":22,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":553,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .port on an `any` value.","line":553,"column":27,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":553,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":554,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":554,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .host on an `any` value.","line":554,"column":18,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":554,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":555,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":555,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .model on an `any` value.","line":555,"column":19,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":555,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `DaemonCmdOptions`.","line":571,"column":23,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":571,"endColumn":27},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `DaemonCmdOptions`.","line":591,"column":22,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":591,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `DaemonCmdOptions`.","line":600,"column":31,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":600,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any` assigned to a parameter of type `DaemonCmdOptions`.","line":609,"column":22,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":609,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":619,"column":29,"nodeType":"Property","messageId":"anyAssignment","endLine":619,"endColumn":69},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .json on an `any` value.","line":619,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":619,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .format on an `any` value.","line":619,"column":63,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":619,"endColumn":69}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":45,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n\nimport { Command } from 'commander';\nimport chalk from 'chalk';\nimport { VERSION } from './core/version.js';\nimport { EXIT, ExitError } from './core/errors.js';\nimport { setVerbose, setDebug } from './core/debug.js';\n\n// --- SIGINT handler ---\nexport let isShuttingDown = false;\n\nasync function cleanup(): Promise<void> {\n  try {\n    const { shutdownProcessManager, forceKillAllProcesses } = await import('./core/tools/index.js');\n    forceKillAllProcesses();\n    await shutdownProcessManager();\n  } catch {\n    // Best effort cleanup\n  }\n}\n\nprocess.on('SIGINT', () => {\n  if (isShuttingDown) process.exit(EXIT.SIGINT); // Second SIGINT = force kill\n  isShuttingDown = true;\n  console.log('\\n' + chalk.dim('Interrupted.'));\n\n  // Grace timeout: force exit after 3 seconds if cleanup hangs\n  const graceTimer = setTimeout(() => {\n    process.exit(EXIT.SIGINT);\n  }, 3000);\n  graceTimer.unref(); // Don't keep process alive just for this timer\n\n  cleanup().finally(() => {\n    clearTimeout(graceTimer);\n    process.exit(EXIT.SIGINT);\n  });\n});\n\nconst program = new Command();\n\nprogram\n  .name('opta')\n  .description('Agentic AI coding CLI powered by local LLMs')\n  .version(VERSION, '-V, --version')\n  .option('-v, --verbose', 'detailed output')\n  .option('--debug', 'debug info including API calls')\n  .hook('preAction', (thisCommand) => {\n    const opts = thisCommand.opts<{ verbose?: boolean; debug?: boolean }>();\n    if (opts.verbose) setVerbose(true);\n    if (opts.debug) setDebug(true);\n  });\n\n// Default action  launch chat/menu in interactive terminals, help in non-interactive contexts.\nprogram.action(async () => {\n  const interactive = Boolean(process.stdin.isTTY && process.stdout.isTTY);\n  if (!interactive) {\n    program.outputHelp();\n    return;\n  }\n  await runChat({ tui: true });\n});\n\nprogram.addHelpText('after', `\nExamples:\n  $ opta chat                    Start interactive session\n  $ opta tui                     Start full-screen terminal UI\n  $ opta do \"fix the auth bug\"   One-shot task\n  $ opta embed \"semantic query\"  Generate an embedding via Opta LMX\n  $ opta rerank \"release notes\" --documents \"notes|commits|chat\"\n  $ opta benchmark --serve       Generate + host benchmark showcase apps\n  $ opta env save laptop         Save current host/model as a named profile\n  $ opta env use laptop          Switch to that profile\n  $ opta update                  Update CLI, LMX, and Plus\n  $ opta daemon start            Start background daemon\n  $ opta status                  Check connection\n  $ opta models                  Open interactive model manager\n`);\n\n// --- Commands (lazy loaded) ---\n\ntype ChatCommandOptions = {\n  resume?: string;\n  plan?: boolean;\n  review?: boolean;\n  research?: boolean;\n  model?: string;\n  format?: string;\n  commit?: boolean;\n  checkpoints?: boolean;\n  auto?: boolean;\n  dangerous?: boolean;\n  yolo?: boolean;\n  tui?: boolean;\n};\n\nfunction addChatOptions(command: Command): Command {\n  return command\n    .option('-r, --resume <id>', 'resume a previous session')\n    .option('--plan', 'plan mode  read-only, design implementation approach')\n    .option('--review', 'code review mode  read-only, structured review output')\n    .option('--research', 'research mode  explore ideas, gather information')\n    .option('-m, --model <name>', 'override default model')\n    .option('-f, --format <type>', 'output format: text (default) or json')\n    .option('--no-commit', 'disable auto-commit at task end')\n    .option('--no-checkpoints', 'disable checkpoint creation')\n    .option('-a, --auto', 'auto-accept file edits without prompting')\n    .option('--dangerous', 'bypass all permission prompts')\n    .option('--yolo', 'alias for --dangerous')\n    .option('--tui', 'use full-screen terminal UI');\n}\n\nasync function runChat(opts: ChatCommandOptions): Promise<void> {\n  const { startChat } = await import('./commands/chat.js');\n  await startChat(opts);\n}\n\naddChatOptions(\n  program\n    .command('chat')\n  .description('Start an interactive AI chat session')\n)\n  .addHelpText('after', `\nExamples:\n  $ opta chat                    New session\n  $ opta chat --resume abc123    Resume session\n  $ opta chat --model qwen2.5    Use specific model\n  $ opta chat --tui              Full-screen mode\n`)\n  .action(async (opts: ChatCommandOptions) => {\n    await runChat(opts);\n  });\n\naddChatOptions(\n  program\n    .command('tui')\n    .description('Start full-screen terminal UI (alias for `opta chat --tui`)')\n)\n  .addHelpText('after', `\nExamples:\n  $ opta tui                     New full-screen session\n  $ opta tui --resume abc123     Resume session in full-screen mode\n  $ opta tui --model qwen2.5     Use specific model in full-screen mode\n`)\n  .action(async (opts: ChatCommandOptions) => {\n    await runChat({ ...opts, tui: true });\n  });\n\nprogram\n  .command('do <task...>')\n  .description('Execute a coding task using the agent loop')\n  .option('-m, --model <name>', 'use specific model for this task')\n  .option('-f, --format <type>', 'output format: text (default) or json')\n  .option('-q, --quiet', 'suppress output (exit code only, errors to stderr)')\n  .option('-o, --output <path>', 'write result to file')\n  .option('--no-commit', 'disable auto-commit at task end')\n  .option('--no-checkpoints', 'disable checkpoint creation')\n  .option('-a, --auto', 'auto-accept file edits without prompting')\n  .option('--dangerous', 'bypass all permission prompts')\n  .option('--yolo', 'alias for --dangerous')\n  .addHelpText('after', `\nExamples:\n  $ opta do \"refactor auth module\"\n  $ opta do \"fix bug in utils.ts\" --model qwen2.5\n  $ opta do \"run tests\" --format json\n`)\n  .action(async (task: string[], opts) => {\n    const { executeTask } = await import('./commands/do.js');\n    await executeTask(task, opts);\n  });\n\nprogram\n  .command('embed <text...>')\n  .description('Create embeddings via Opta LMX helper nodes')\n  .option('-m, --model <id>', 'embedding model id')\n  .option('--json', 'machine-readable output')\n  .addHelpText('after', `\nExamples:\n  $ opta embed \"hello world\"\n  $ opta embed \"semantic search query\" --model snowflake/arctic-embed-m-v2.0\n`)\n  .action(async (text: string[], opts) => {\n    const { embed } = await import('./commands/embed.js');\n    await embed(text, opts);\n  });\n\nprogram\n  .command('rerank <query...>')\n  .description('Rerank candidate documents via Opta LMX')\n  .requiredOption('-d, --documents <docs>', 'pipe-separated documents, e.g. \"doc1|doc2|doc3\"')\n  .option('-m, --model <id>', 'reranker model id')\n  .option('-k, --top-k <n>', 'return top N results')\n  .option('--json', 'machine-readable output')\n  .addHelpText('after', `\nExamples:\n  $ opta rerank \"what changed?\" --documents \"release notes|commit log|meeting notes\"\n  $ opta rerank \"auth failures\" --documents \"ticket|postmortem|chat\" --top-k 2 --json\n`)\n  .action(async (query: string[], opts: { documents: string; model?: string; topK?: string; json?: boolean }) => {\n    const { rerank } = await import('./commands/rerank.js');\n    await rerank(query, opts);\n  });\n\nprogram\n  .command('benchmark')\n  .description('Generate Opta benchmark suite apps (landing, chess, AI-news research)')\n  .option('-o, --output <dir>', 'output directory (default: ./apps/opta-benchmark-suite)')\n  .option('--query <text>', 'override AI news research query')\n  .option('--words <n>', 'minimum words for AI news report (>=500)', '650')\n  .option('--max-results <n>', 'max research results/citations to request', '10')\n  .option('--provider-order <list>', 'comma-separated provider order (tavily,gemini,exa,brave,groq)')\n  .option('--serve', 'serve generated suite over local HTTP')\n  .option('--host <host>', 'host for --serve (default: 127.0.0.1)', '127.0.0.1')\n  .option('--port <port>', 'port for --serve (default: 4789)', '4789')\n  .option('--force', 'allow using an existing output directory')\n  .option('--json', 'machine-readable output')\n  .addHelpText('after', `\nExamples:\n  $ opta benchmark\n  $ opta benchmark --serve\n  $ opta benchmark --output ./apps/demo-suite --words 800\n  $ opta benchmark --provider-order tavily,exa,brave\n`)\n  .action(async (opts) => {\n    const { benchmark } = await import('./commands/benchmark.js');\n    await benchmark(opts);\n  });\n\nprogram\n  .command('status')\n  .description('Check Opta LMX server health and loaded models')\n  .option('--json', 'machine-readable output')\n  .action(async (opts) => {\n    const { status } = await import('./commands/status.js');\n    await status(opts);\n  });\n\nprogram\n  .command('models')\n  .description('List and manage loaded models')\n  .argument('[action]', 'list | manage | dashboard | scan | use | info | load | unload | stop | swap | alias | aliases | unalias | download | delete | benchmark | predictor | helpers | quantize | agents | skills | rag | health | browse-local | browse-library')\n  .argument('[args...]', 'model query args (for swap: <running> <replacement>)')\n  .option('--json', 'machine-readable output')\n  .addHelpText('after', `\nExamples:\n  $ opta models                     Interactive manager (TTY) or list output\n  $ opta models manage              Force interactive manager\n  $ opta models use                 Pick default model via keyboard\n  $ opta models load minimax        Fuzzy match and load a model\n  $ opta models swap                Interactive swap (choose old/new)\n  $ opta models dashboard           At-a-glance model health + aliases\n  $ opta models predictor           Predictor stats and next-model guess\n  $ opta models helpers             Helper node health dashboard\n  $ opta models quantize list       List quantization jobs\n  $ opta models quantize start mistralai/Mistral-7B-Instruct-v0.3 --bits 4\n  $ opta models agents list --status running\n  $ opta models agents start --prompt \"triage failures\" --roles planner,executor\n  $ opta models skills tools\n  $ opta models skills run ai26-3c-productivity-writing-plans --args '{\"topic\":\"routing\"}'\n  $ opta models rag collections\n  $ opta models rag ingest docs --file ./README.md --chunking markdown_headers\n  $ opta models health --ready --admin\n  $ opta models alias glm5 inferencerlabs/GLM-5-MLX-4.8bit\n  $ opta models scan                Full local/cloud model inventory\n  $ opta models browse-local        Browse downloaded models + history\n  $ opta models browse-library      Browse full downloadable library\n`)\n  .action(async (action, args, opts) => {\n    const rawArgs = (args as string[] | undefined) ?? [];\n    const query = rawArgs.length > 0 ? rawArgs.join(' ') : undefined;\n    const first = rawArgs[0];\n    const rest = rawArgs.slice(1).join(' ').trim();\n    const swapFrom = first;\n    const swapTo = rest || undefined;\n\n    const { models } = await import('./commands/models.js');\n    const expectsSplitArgs = action === 'swap' || action === 'alias';\n    await models(action, expectsSplitArgs ? swapFrom : query, expectsSplitArgs ? swapTo : undefined, opts);\n  });\n\nprogram\n  .command('env')\n  .description('Manage named environment profiles')\n  .argument('[action]', 'list | show | save | use | delete')\n  .argument('[name]', 'profile name')\n  .option('--host <host>', 'override connection host when saving')\n  .option('--port <port>', 'override connection port when saving')\n  .option('--admin-key <key>', 'override connection admin key when saving (empty string clears)')\n  .option('--model <id>', 'override default model when saving')\n  .option('--provider <name>', 'provider for profile (lmx|anthropic)')\n  .option('--mode <name>', 'default mode (safe|auto|plan|review|research|dangerous|ci)')\n  .option('--json', 'machine-readable output')\n  .addHelpText('after', `\nExamples:\n  $ opta env                         List all environment profiles\n  $ opta env save laptop             Save current settings as \"laptop\"\n  $ opta env save mono --host 192.168.188.11 --port 1234\n  $ opta env use laptop              Apply a saved profile\n  $ opta env show laptop             Show profile details\n  $ opta env delete old-server       Remove a profile\n`)\n  .action(async (action, name, opts) => {\n    const { envCommand } = await import('./commands/env.js');\n    await envCommand(action, name, opts);\n  });\n\nprogram\n  .command('config')\n  .description('Manage configuration')\n  .argument('[action]', 'get | set | list | reset | menu')\n  .argument('[key]', 'config key')\n  .argument('[value]', 'config value')\n  .option('--json', 'output as JSON')\n  .action(async (action, key, value, opts) => {\n    const { config } = await import('./commands/config.js');\n    await config(action, key, value, opts);\n  });\n\nconst accountCmd = program\n  .command('account')\n  .description('Manage Supabase-native account authentication');\n\naccountCmd\n  .command('signup')\n  .description('Create an account using email or phone + password')\n  .requiredOption('--identifier <emailOrPhone>', 'email or phone')\n  .option('--name <name>', 'display name')\n  .option('--json', 'machine-readable output')\n  .action(async (opts) => {\n    const { accountSignup } = await import('./commands/account.js');\n    await accountSignup(opts);\n  });\n\naccountCmd\n  .command('login')\n  .description('Log in with email or phone + password')\n  .requiredOption('--identifier <emailOrPhone>', 'email or phone')\n  .option('--json', 'machine-readable output')\n  .action(async (opts) => {\n    const { accountLogin } = await import('./commands/account.js');\n    await accountLogin(opts);\n  });\n\naccountCmd\n  .command('status')\n  .description('Show local account session status')\n  .option('--json', 'machine-readable output')\n  .action(async (opts) => {\n    const { accountStatus } = await import('./commands/account.js');\n    await accountStatus(opts);\n  });\n\nconst keyCmd = program\n  .command('key')\n  .description('Manage Opta inference API keys for OpenAI-compatible clients');\n\nkeyCmd\n  .command('create')\n  .description('Create or rotate inference API key and sync to Studio LMX')\n  .option('--value <key>', 'use explicit key value instead of generating one')\n  .option('--no-remote', 'skip syncing key to Studio LMX config')\n  .option('--no-copy', 'skip copying key to clipboard')\n  .option('--json', 'machine-readable output')\n  .addHelpText('after', `\nExamples:\n  $ opta key create\n  $ opta key create --no-remote\n  $ opta key create --value opta_sk_custom_123\n`)\n  .action(async (opts) => {\n    const { keyCreate } = await import('./commands/key.js');\n    await keyCreate(opts);\n  });\n\nkeyCmd\n  .command('show')\n  .description('Show current inference API key (masked by default)')\n  .option('--reveal', 'print full key value')\n  .option('--copy', 'copy key to clipboard')\n  .option('--json', 'machine-readable output')\n  .action(async (opts) => {\n    const { keyShow } = await import('./commands/key.js');\n    await keyShow(opts);\n  });\n\nkeyCmd\n  .command('copy')\n  .description('Copy current inference API key to clipboard')\n  .option('--json', 'machine-readable output')\n  .action(async (opts) => {\n    const { keyCopy } = await import('./commands/key.js');\n    await keyCopy(opts);\n  });\n\naccountCmd\n  .command('logout')\n  .description('Log out and clear local account session')\n  .option('--json', 'machine-readable output')\n  .action(async (opts) => {\n    const { accountLogout } = await import('./commands/account.js');\n    await accountLogout(opts);\n  });\n\nprogram\n  .command('sessions')\n  .description('Manage chat sessions')\n  .argument('[action]', 'resume | delete | export | search')\n  .argument('[id]', 'session id or search query')\n  .option('--json', 'machine-readable output')\n  .option('--model <name>', 'filter by model name')\n  .option('--source <mode>', 'session source: local | lmx | hybrid (default: hybrid)', 'hybrid')\n  .option('--since <date>', 'filter sessions after date (ISO or relative: 7d, 2w, 1m)')\n  .option('--tag <tag>', 'filter by tag')\n  .option('--limit <n>', 'limit results (default 20)')\n  .action(async (action, id, opts) => {\n    const { sessions } = await import('./commands/sessions.js');\n    await sessions(action, id, opts);\n  });\n\nconst mcpCmd = program\n  .command('mcp')\n  .description('Manage MCP (Model Context Protocol) servers');\n\nmcpCmd\n  .command('list')\n  .description('Show configured MCP servers')\n  .option('--json', 'machine-readable output')\n  .action(async (opts) => {\n    const { mcpList } = await import('./commands/mcp.js');\n    await mcpList(opts);\n  });\n\nmcpCmd\n  .command('add <name> <command>')\n  .description('Add a stdio MCP server')\n  .option('--env <pairs>', 'environment variables (KEY=VAL,KEY2=VAL2)')\n  .action(async (name: string, command: string, opts) => {\n    const { mcpAdd } = await import('./commands/mcp.js');\n    await mcpAdd(name, command, opts);\n  });\n\nmcpCmd\n  .command('add-playwright')\n  .description('Add a Playwright MCP server using browser config defaults')\n  .option('--name <name>', 'server name (default: playwright)')\n  .option('--mode <mode>', 'browser mode: isolated|attach')\n  .option('--command <command>', 'command runner (default: npx)')\n  .option('--package <name>', 'MCP package name (default: @playwright/mcp@latest)')\n  .option('--allowed-hosts <hosts>', 'comma-separated host allowlist')\n  .option('--blocked-origins <origins>', 'comma-separated origin blocklist')\n  .option('--env <pairs>', 'environment variables (KEY=VAL,KEY2=VAL2)')\n  .action(async (opts: {\n    name?: string;\n    mode?: string;\n    command?: string;\n    package?: string;\n    allowedHosts?: string;\n    blockedOrigins?: string;\n    env?: string;\n  }) => {\n    const { mcpAddPlaywright } = await import('./commands/mcp.js');\n    await mcpAddPlaywright({\n      name: opts.name,\n      mode: opts.mode === 'attach' ? 'attach' : opts.mode === 'isolated' ? 'isolated' : undefined,\n      command: opts.command,\n      packageName: opts.package,\n      allowedHosts: opts.allowedHosts?.split(',').map((value) => value.trim()).filter(Boolean),\n      blockedOrigins: opts.blockedOrigins?.split(',').map((value) => value.trim()).filter(Boolean),\n      env: opts.env,\n    });\n  });\n\nmcpCmd\n  .command('remove <name>')\n  .description('Remove an MCP server')\n  .action(async (name: string) => {\n    const { mcpRemove } = await import('./commands/mcp.js');\n    await mcpRemove(name);\n  });\n\nmcpCmd\n  .command('test <name>')\n  .description('Test connection to an MCP server')\n  .action(async (name: string) => {\n    const { mcpTest } = await import('./commands/mcp.js');\n    await mcpTest(name);\n  });\n\nprogram\n  .command('init')\n  .description('Initialize OPIS project intelligence docs')\n  .option('-y, --yes', 'skip prompts, use defaults (CI mode)')\n  .option('--force', 'overwrite existing APP.md')\n  .action(async (opts) => {\n    const { init } = await import('./commands/init.js');\n    await init(opts);\n  });\n\nprogram\n  .command('diff')\n  .description('Show changes made in a session (V2)')\n  .option('-s, --session <id>', 'session to diff')\n  .action(async (opts) => {\n    const { diff } = await import('./commands/diff.js');\n    await diff(opts);\n  });\n\nprogram\n  .command('serve')\n  .description('Manage the remote Opta LMX inference server')\n  .argument('[action]', 'start | stop | restart | logs (default: status)')\n  .option('--json', 'machine-readable output')\n  .action(async (action, opts) => {\n    const { serve } = await import('./commands/serve.js');\n    await serve(action, opts);\n  });\n\nprogram\n  .command('update')\n  .description('Update Opta components (CLI, LMX, Plus; optional Web) on local/remote targets')\n  .option('-c, --components <list>', 'comma-separated components: cli,lmx,plus,web (default: cli,lmx,plus)')\n  .option('-t, --target <mode>', 'target mode: auto|local|remote|both (default: auto)', 'auto')\n  .option('--remote-host <host>', 'override remote host (default: connection.host)')\n  .option('--remote-user <user>', 'override SSH user (default: connection.ssh.user)')\n  .option('--identity-file <path>', 'override SSH identity file (default: connection.ssh.identityFile)')\n  .option('--local-root <path>', 'override local 1-Apps root')\n  .option('--remote-root <path>', 'override remote 1-Apps root')\n  .option('--dry-run', 'show planned commands without executing')\n  .option('--no-build', 'skip build/install/restart steps')\n  .option('--no-pull', 'skip git fetch/pull steps')\n  .option('--json', 'machine-readable output')\n  .addHelpText('after', `\nExamples:\n  $ opta update\n  $ opta update --components web --target local\n  $ opta update --components lmx --target both\n  $ opta update --target remote --remote-host Mono512\n  $ opta update --dry-run --json\n`)\n  .action(async (opts) => {\n    const { updateCommand } = await import('./commands/update.js');\n    await updateCommand(opts);\n  });\n\nprogram\n  .command('server')\n  .description('Start an HTTP API server for non-interactive use')\n  .option('-p, --port <port>', 'server port', '3456')\n  .option('--host <host>', 'server bind address', '127.0.0.1')\n  .option('-m, --model <name>', 'override default model')\n  .action(async (opts) => {\n    const { startServer } = await import('./commands/server.js');\n    await startServer({\n      port: parseInt(opts.port, 10),\n      host: opts.host,\n      model: opts.model,\n    });\n  });\n\nconst daemonCmd = program\n  .command('daemon')\n  .description('Manage Opta Level 3 daemon runtime');\n\ndaemonCmd\n  .command('start')\n  .description('Start daemon in background (or attach if already running)')\n  .option('--host <host>', 'bind host', '127.0.0.1')\n  .option('--port <port>', 'preferred port', '9999')\n  .option('--json', 'machine-readable output')\n  .action(async (opts) => {\n    const { daemonStart } = await import('./commands/daemon.js');\n    await daemonStart(opts);\n  });\n\ndaemonCmd\n  .command('run')\n  .description('Run daemon in foreground (internal)')\n  .option('--host <host>', 'bind host', '127.0.0.1')\n  .option('--port <port>', 'preferred port', '9999')\n  .option('--token <token>', 'daemon session token')\n  .option('--model <name>', 'model override for this daemon process')\n  .action(async (opts: { host: string; port: string; token?: string; model?: string }) => {\n    const { daemonRun } = await import('./commands/daemon.js');\n    await daemonRun(opts);\n  });\n\ndaemonCmd\n  .command('stop')\n  .description('Stop daemon')\n  .action(async (opts) => {\n    const { daemonStop } = await import('./commands/daemon.js');\n    await daemonStop(opts);\n  });\n\ndaemonCmd\n  .command('status')\n  .description('Show daemon status')\n  .option('--json', 'machine-readable output')\n  .action(async (opts) => {\n    const { daemonStatusCommand } = await import('./commands/daemon.js');\n    await daemonStatusCommand(opts);\n  });\n\ndaemonCmd\n  .command('logs')\n  .description('Show daemon logs')\n  .option('--json', 'machine-readable output')\n  .action(async (opts) => {\n    const { daemonLogs } = await import('./commands/daemon.js');\n    await daemonLogs(opts);\n  });\n\nprogram\n  .command('doctor')\n  .description('Check Opta setup, inference auth, and host failover')\n  .option('--json', 'machine-readable output')\n  .option('-f, --format <type>', 'output format (text, json)')\n  .action(async (opts) => {\n    // --json is the canonical flag; --format json is kept for backwards compat\n    const effectiveOpts = { format: opts.json ? 'json' : opts.format };\n    const { runDoctor } = await import('./commands/doctor.js');\n    await runDoctor(effectiveOpts);\n  });\n\nprogram\n  .command('completions <shell>')\n  .description('Generate shell completions (bash/zsh/fish)')\n  .action(async (shell: string) => {\n    const { completions } = await import('./commands/completions.js');\n    await completions(shell);\n  });\n\nconst keychainCmd = program\n  .command('keychain')\n  .description('Manage API keys in the OS secure keychain (macOS Keychain / Linux secret-tool)');\n\nkeychainCmd\n  .command('status')\n  .description('Show keychain availability and stored key presence')\n  .action(async () => {\n    const { runKeychainCommand } = await import('./commands/keychain.js');\n    await runKeychainCommand('status');\n  });\n\nkeychainCmd\n  .command('set-anthropic <key>')\n  .description('Store an Anthropic API key in the OS keychain')\n  .action(async (key: string) => {\n    const { runKeychainCommand } = await import('./commands/keychain.js');\n    await runKeychainCommand('set-anthropic', key);\n  });\n\nkeychainCmd\n  .command('set-lmx <key>')\n  .description('Store an LMX API key in the OS keychain')\n  .action(async (key: string) => {\n    const { runKeychainCommand } = await import('./commands/keychain.js');\n    await runKeychainCommand('set-lmx', key);\n  });\n\nkeychainCmd\n  .command('delete-anthropic')\n  .description('Remove the Anthropic API key from the OS keychain')\n  .action(async () => {\n    const { runKeychainCommand } = await import('./commands/keychain.js');\n    await runKeychainCommand('delete-anthropic');\n  });\n\nkeychainCmd\n  .command('delete-lmx')\n  .description('Remove the LMX API key from the OS keychain')\n  .action(async () => {\n    const { runKeychainCommand } = await import('./commands/keychain.js');\n    await runKeychainCommand('delete-lmx');\n  });\n\nprogram.parseAsync().catch((err: unknown) => {\n  if (err instanceof ExitError) {\n    process.exit(err.exitCode);\n  }\n  throw err;\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/journal/session-log.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":40,"column":15,"nodeType":"LogicalExpression","messageId":"neverNullish","endLine":40,"endColumn":55},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, value is always truthy.","line":50,"column":11,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":50,"endColumn":15},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":249,"column":25,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":249,"endColumn":41},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":266,"column":25,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":266,"endColumn":41},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":281,"column":30,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":281,"endColumn":46},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":305,"column":29,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":305,"endColumn":45},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":306,"column":34,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":306,"endColumn":50},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":330,"column":17,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":330,"endColumn":38},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":392,"column":19,"nodeType":"LogicalExpression","messageId":"neverNullish","endLine":392,"endColumn":45}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { mkdir, readFile, writeFile } from 'node:fs/promises';\nimport { join, isAbsolute } from 'node:path';\nimport { hostname } from 'node:os';\nimport { execa } from 'execa';\nimport type { Session } from '../memory/store.js';\n\nexport interface SessionLogOptions {\n  cwd?: string;\n  logsDir?: string;\n  user?: string;\n  device?: string;\n  timezone?: string;\n  now?: Date;\n}\n\nexport interface SessionLogResult {\n  path: string;\n  fileName: string;\n}\n\ninterface FileChanges {\n  created: Set<string>;\n  modified: Set<string>;\n  deleted: Set<string>;\n}\n\ninterface DateTimeParts {\n  date: string;\n  time: string;\n  compactTime: string;\n}\n\nconst DEFAULT_LOGS_DIR = '12-Session-Logs';\n\nfunction safeEnvUser(): string {\n  return process.env['USER'] ?? process.env['USERNAME'] ?? 'unknown';\n}\n\nfunction safeDeviceName(): string {\n  const raw = process.env['OPTA_DEVICE'] ?? hostname() ?? 'device';\n  return raw.split('.')[0] ?? raw;\n}\n\nfunction toSessionText(input: Session['messages'][number]['content']): string {\n  if (typeof input === 'string') return input;\n  if (!Array.isArray(input)) return '';\n\n  return input\n    .map((part) => {\n      if (part && typeof part === 'object' && 'type' in part && part.type === 'text' && 'text' in part) {\n        const text = part.text;\n        return typeof text === 'string' ? text : '';\n      }\n      return '';\n    })\n    .filter(Boolean)\n    .join('\\n');\n}\n\nfunction slugify(raw: string, fallback: string, maxLength = 48): string {\n  const normalized = raw\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, '-')\n    .replace(/^-+|-+$/g, '')\n    .replace(/-{2,}/g, '-');\n\n  if (!normalized) return fallback;\n  return normalized.slice(0, maxLength).replace(/-+$/g, '') || fallback;\n}\n\nexport function buildSessionLogFileName(\n  parts: DateTimeParts,\n  device: string,\n  summary: string,\n): string {\n  const safeDevice = slugify(device, 'device', 24);\n  const safeSummary = slugify(summary, 'session', 56);\n  return `${parts.date}-${parts.compactTime}-${safeDevice}-${safeSummary}.md`;\n}\n\nfunction formatDuration(startIso: string | undefined, end: Date): string {\n  const startMs = startIso ? Date.parse(startIso) : NaN;\n  const endMs = end.getTime();\n  const totalSeconds = Number.isFinite(startMs) ? Math.max(0, Math.round((endMs - startMs) / 1000)) : 0;\n\n  const hours = Math.floor(totalSeconds / 3600);\n  const minutes = Math.floor((totalSeconds % 3600) / 60);\n  const seconds = totalSeconds % 60;\n\n  return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;\n}\n\nfunction localDateTimeParts(date: Date): DateTimeParts {\n  const year = date.getFullYear();\n  const month = String(date.getMonth() + 1).padStart(2, '0');\n  const day = String(date.getDate()).padStart(2, '0');\n  const hour = String(date.getHours()).padStart(2, '0');\n  const minute = String(date.getMinutes()).padStart(2, '0');\n\n  return {\n    date: `${year}-${month}-${day}`,\n    time: `${hour}:${minute}`,\n    compactTime: `${hour}${minute}`,\n  };\n}\n\nfunction zonedDateTimeParts(date: Date, timezone?: string): DateTimeParts {\n  if (!timezone || timezone === 'local') {\n    return localDateTimeParts(date);\n  }\n\n  try {\n    const formatter = new Intl.DateTimeFormat('en-US', {\n      timeZone: timezone,\n      hour12: false,\n      year: 'numeric',\n      month: '2-digit',\n      day: '2-digit',\n      hour: '2-digit',\n      minute: '2-digit',\n    });\n\n    const mapped = Object.fromEntries(\n      formatter\n        .formatToParts(date)\n        .filter((part) => part.type !== 'literal')\n        .map((part) => [part.type, part.value]),\n    ) as Record<string, string>;\n\n    const year = mapped['year'];\n    const month = mapped['month'];\n    const day = mapped['day'];\n    const hour = mapped['hour'];\n    const minute = mapped['minute'];\n\n    if (!year || !month || !day || !hour || !minute) {\n      return localDateTimeParts(date);\n    }\n\n    return {\n      date: `${year}-${month}-${day}`,\n      time: `${hour}:${minute}`,\n      compactTime: `${hour}${minute}`,\n    };\n  } catch {\n    return localDateTimeParts(date);\n  }\n}\n\nasync function detectRepoRoot(cwd: string): Promise<string> {\n  const result = await execa('git', ['rev-parse', '--show-toplevel'], {\n    cwd,\n    reject: false,\n  });\n\n  if (result.exitCode === 0 && result.stdout.trim()) {\n    return result.stdout.trim();\n  }\n\n  return cwd;\n}\n\nasync function resolveLogsDir(baseCwd: string, configuredDir?: string): Promise<string> {\n  const root = await detectRepoRoot(baseCwd);\n  const dir = configuredDir?.trim() || DEFAULT_LOGS_DIR;\n  return isAbsolute(dir) ? dir : join(root, dir);\n}\n\nexport function parseGitStatusPorcelain(output: string): FileChanges {\n  const created = new Set<string>();\n  const modified = new Set<string>();\n  const deleted = new Set<string>();\n\n  for (const line of output.split('\\n')) {\n    if (!line.trim()) continue;\n    const status = line.slice(0, 2);\n    if (status.length < 2) continue;\n\n    let file = line.slice(3).trim();\n    if (!file) continue;\n\n    if (status.includes('R') || status.includes('C')) {\n      const renamedTo = file.split(' -> ').pop();\n      if (renamedTo) file = renamedTo.trim();\n    }\n\n    if (status === '??' || status.includes('A')) {\n      created.add(file);\n      continue;\n    }\n\n    if (status.includes('D')) {\n      deleted.add(file);\n      continue;\n    }\n\n    modified.add(file);\n  }\n\n  return { created, modified, deleted };\n}\n\nasync function collectGitChanges(cwd: string): Promise<FileChanges> {\n  const result = await execa('git', ['status', '--porcelain'], {\n    cwd,\n    reject: false,\n  });\n\n  if (result.exitCode !== 0) {\n    return { created: new Set(), modified: new Set(), deleted: new Set() };\n  }\n\n  return parseGitStatusPorcelain(result.stdout);\n}\n\nasync function collectCheckpointPaths(cwd: string, sessionId: string): Promise<string[]> {\n  const indexPath = join(cwd, '.opta', 'checkpoints', sessionId, 'index.json');\n\n  try {\n    const raw = await readFile(indexPath, 'utf-8');\n    const parsed = JSON.parse(raw) as {\n      checkpoints?: Array<{ path?: unknown }>;\n    };\n\n    return (parsed.checkpoints ?? [])\n      .map((checkpoint) => checkpoint.path)\n      .filter((path): path is string => typeof path === 'string' && path.trim().length > 0);\n  } catch {\n    return [];\n  }\n}\n\nfunction mergeCheckpointPaths(changes: FileChanges, checkpointPaths: string[]): void {\n  for (const path of checkpointPaths) {\n    if (changes.created.has(path) || changes.modified.has(path) || changes.deleted.has(path)) continue;\n    changes.modified.add(path);\n  }\n}\n\nfunction markdownList(items: string[]): string {\n  if (items.length === 0) return '- (none)';\n  return items.map((item) => `- ${item}`).join('\\n');\n}\n\nfunction extractIssues(session: Session): string[] {\n  const issues: string[] = [];\n  const issueRegex = /\\b(error|failed|failure|exception|timeout|denied|invalid)\\b/i;\n\n  for (const message of session.messages ?? []) {\n    const text = toSessionText(message.content).trim();\n    if (!text) continue;\n    if (!issueRegex.test(text)) continue;\n\n    const compact = text.replace(/\\s+/g, ' ').slice(0, 160);\n    issues.push(compact);\n    if (issues.length >= 5) break;\n  }\n\n  return issues;\n}\n\nfunction extractDecisions(session: Session): string[] {\n  const decisions: string[] = [];\n  const decisionRegex = /\\b(decision|decided|choose|selected|plan|approach)\\b/i;\n\n  for (const message of session.messages ?? []) {\n    if (message.role !== 'assistant') continue;\n    const text = toSessionText(message.content).trim();\n    if (!text) continue;\n    if (!decisionRegex.test(text)) continue;\n\n    const compact = text.replace(/\\s+/g, ' ').slice(0, 160);\n    decisions.push(compact);\n    if (decisions.length >= 5) break;\n  }\n\n  return decisions;\n}\n\nfunction extractNextSteps(session: Session): string[] {\n  const assistantMessages = (session.messages ?? []).filter((message) => message.role === 'assistant');\n  const lastAssistant = assistantMessages[assistantMessages.length - 1];\n  const text = lastAssistant ? toSessionText(lastAssistant.content).trim() : '';\n\n  if (!text) {\n    return ['Continue from the latest session context.'];\n  }\n\n  const compact = text.replace(/\\s+/g, ' ');\n  const sentence = compact.split(/(?<=[.!?])\\s+/)[0] ?? compact;\n  return [sentence.slice(0, 180)];\n}\n\nfunction renderSessionLogMarkdown(params: {\n  session: Session;\n  dateTime: DateTimeParts;\n  user: string;\n  device: string;\n  duration: string;\n  changes: FileChanges;\n  checkpointCount: number;\n}): string {\n  const { session, dateTime, user, device, duration, changes, checkpointCount } = params;\n\n  const userMessageCount = (session.messages ?? []).filter((message) => message.role === 'user').length;\n  const assistantMessageCount = (session.messages ?? []).filter((message) => message.role === 'assistant').length;\n  const issues = extractIssues(session);\n  const decisions = extractDecisions(session);\n  const nextSteps = extractNextSteps(session);\n\n  const created = [...changes.created].sort();\n  const modified = [...changes.modified].sort();\n  const deleted = [...changes.deleted].sort();\n\n  const tagLine = Array.isArray(session.tags) && session.tags.length > 0 ? session.tags.join(', ') : '(none)';\n\n  return `---\ndate: ${dateTime.date}\ntime: ${dateTime.time}\ndevice: ${device}\nuser: ${user}\nmodel: ${session.model || 'unknown'}\nduration: ${duration}\n---\n\n## Summary\n- Session: ${session.id}\n- Title: ${session.title || '(untitled)'}\n- Messages: user=${userMessageCount}, assistant=${assistantMessageCount}\n- Tool calls: ${session.toolCallCount ?? 0}\n\n## Files Changed\n### Created\n${markdownList(created)}\n\n### Modified\n${markdownList(modified)}\n\n### Deleted\n${markdownList(deleted)}\n\n## Status Changes\n- Created: ${session.created || '(unknown)'}\n- Updated: ${session.updated || '(unknown)'}\n- Compacted: ${session.compacted ? 'yes' : 'no'}\n- Checkpoints: ${checkpointCount}\n\n## Decisions Made\n${markdownList(decisions)}\n\n## Issues Encountered\n${markdownList(issues)}\n\n## Next Steps\n${markdownList(nextSteps)}\n\n## Notes\n- CWD: ${session.cwd || process.cwd()}\n- Tags: ${tagLine}\n`;\n}\n\nasync function writeUniqueFile(dir: string, fileName: string, content: string): Promise<string> {\n  const baseName = fileName.replace(/\\.md$/, '');\n\n  for (let attempt = 0; attempt < 50; attempt++) {\n    const suffix = attempt === 0 ? '' : `-${attempt + 1}`;\n    const candidate = join(dir, `${baseName}${suffix}.md`);\n\n    try {\n      await writeFile(candidate, content, { encoding: 'utf-8', flag: 'wx' });\n      return candidate;\n    } catch (err) {\n      const code = (err as NodeJS.ErrnoException).code;\n      if (code === 'EEXIST') continue;\n      throw err;\n    }\n  }\n\n  throw new Error(`Unable to create unique session log file for ${fileName}`);\n}\n\nexport async function writeSessionLog(\n  session: Session,\n  options: SessionLogOptions = {},\n): Promise<SessionLogResult> {\n  const now = options.now ?? new Date();\n  const timezone = options.timezone ?? 'local';\n  const dateTime = zonedDateTimeParts(now, timezone);\n  const user = options.user?.trim() || safeEnvUser();\n  const device = options.device?.trim() || safeDeviceName();\n  const baseCwd = options.cwd ?? session.cwd ?? process.cwd();\n  const logsDir = await resolveLogsDir(baseCwd, options.logsDir);\n\n  await mkdir(logsDir, { recursive: true });\n\n  const summarySource = session.title || session.id || 'session';\n  const fileName = buildSessionLogFileName(dateTime, device, summarySource);\n  const changes = await collectGitChanges(baseCwd);\n  const checkpointPaths = await collectCheckpointPaths(baseCwd, session.id);\n  mergeCheckpointPaths(changes, checkpointPaths);\n\n  const duration = formatDuration(session.created, now);\n  const markdown = renderSessionLogMarkdown({\n    session,\n    dateTime,\n    user,\n    device,\n    duration,\n    changes,\n    checkpointCount: checkpointPaths.length,\n  });\n\n  const path = await writeUniqueFile(logsDir, fileName, markdown);\n\n  return {\n    path,\n    fileName: path.split('/').pop() ?? fileName,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/journal/update-log.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":147,"column":32,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":147,"endColumn":41},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'value' will use Object's default stringification format ('[object Object]') when stringified.","line":207,"column":40,"nodeType":"Identifier","messageId":"baseToString","endLine":207,"endColumn":45}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { mkdir, readFile, readdir, writeFile } from 'node:fs/promises';\nimport { isAbsolute, join } from 'node:path';\nimport { execa } from 'execa';\n\nexport interface UpdateStep {\n  target: string;\n  component: string;\n  step: string;\n  status: string;\n  message: string;\n}\n\nexport interface UpdateLogInput {\n  summary: string;\n  commandInputs: Record<string, unknown>;\n  steps: UpdateStep[];\n  cwd?: string;\n  logsDir?: string;\n  timezone?: string;\n  author?: string;\n  rangeStart?: number;\n  rangeEnd?: number;\n  slug?: string;\n  versionBefore?: string;\n  versionAfter?: string;\n  commit?: string;\n  promoted?: boolean;\n  category?: string;\n  now?: Date;\n}\n\nexport interface UpdateLogResult {\n  id: number;\n  path: string;\n  fileName: string;\n}\n\ninterface DateTimeParts {\n  date: string;\n  time: string;\n}\n\nconst DEFAULT_LOGS_DIR = 'updates';\n\nfunction safeAuthor(): string {\n  return process.env['USER'] ?? process.env['USERNAME'] ?? 'unknown';\n}\n\nfunction localDateTimeParts(date: Date): DateTimeParts {\n  const year = date.getFullYear();\n  const month = String(date.getMonth() + 1).padStart(2, '0');\n  const day = String(date.getDate()).padStart(2, '0');\n  const hour = String(date.getHours()).padStart(2, '0');\n  const minute = String(date.getMinutes()).padStart(2, '0');\n\n  return {\n    date: `${year}-${month}-${day}`,\n    time: `${hour}:${minute}`,\n  };\n}\n\nfunction zonedDateTimeParts(date: Date, timezone?: string): DateTimeParts {\n  if (!timezone || timezone === 'local') {\n    return localDateTimeParts(date);\n  }\n\n  try {\n    const formatter = new Intl.DateTimeFormat('en-US', {\n      timeZone: timezone,\n      hour12: false,\n      year: 'numeric',\n      month: '2-digit',\n      day: '2-digit',\n      hour: '2-digit',\n      minute: '2-digit',\n    });\n\n    const mapped = Object.fromEntries(\n      formatter\n        .formatToParts(date)\n        .filter((part) => part.type !== 'literal')\n        .map((part) => [part.type, part.value]),\n    ) as Record<string, string>;\n\n    const year = mapped['year'];\n    const month = mapped['month'];\n    const day = mapped['day'];\n    const hour = mapped['hour'];\n    const minute = mapped['minute'];\n\n    if (!year || !month || !day || !hour || !minute) {\n      return localDateTimeParts(date);\n    }\n\n    return {\n      date: `${year}-${month}-${day}`,\n      time: `${hour}:${minute}`,\n    };\n  } catch {\n    return localDateTimeParts(date);\n  }\n}\n\nasync function detectRepoRoot(cwd: string): Promise<string> {\n  const result = await execa('git', ['rev-parse', '--show-toplevel'], {\n    cwd,\n    reject: false,\n  });\n\n  if (result.exitCode === 0 && result.stdout.trim()) {\n    return result.stdout.trim();\n  }\n\n  return cwd;\n}\n\nasync function resolveLogsDir(baseCwd: string, configuredDir?: string): Promise<string> {\n  const root = await detectRepoRoot(baseCwd);\n  const dir = configuredDir?.trim() || DEFAULT_LOGS_DIR;\n  return isAbsolute(dir) ? dir : join(root, dir);\n}\n\nfunction slugify(raw: string, fallback = 'update', maxLength = 60): string {\n  const normalized = raw\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, '-')\n    .replace(/^-+|-+$/g, '')\n    .replace(/-{2,}/g, '-');\n\n  if (!normalized) return fallback;\n  return normalized.slice(0, maxLength).replace(/-+$/g, '') || fallback;\n}\n\nexport function buildUpdateLogFileName(id: number, date: string, slug: string): string {\n  const padded = String(id).padStart(3, '0');\n  const safeSlug = slugify(slug, 'update');\n  return `${padded}_${date}_${safeSlug}.md`;\n}\n\nfunction parseExistingUpdateIds(files: string[]): number[] {\n  const ids: number[] = [];\n\n  for (const file of files) {\n    const match = file.match(/^(\\d{3})_\\d{4}-\\d{2}-\\d{2}_.+\\.md$/);\n    if (!match) continue;\n\n    const id = Number.parseInt(match[1]!, 10);\n    if (Number.isFinite(id)) ids.push(id);\n  }\n\n  return ids;\n}\n\nexport async function allocateNextUpdateId(\n  dir: string,\n  rangeStart = 1,\n  rangeEnd = 999,\n): Promise<number> {\n  await mkdir(dir, { recursive: true });\n\n  const files = await readdir(dir).catch(() => [] as string[]);\n  const ids = parseExistingUpdateIds(files).filter((id) => id >= rangeStart && id <= rangeEnd);\n  const currentMax = ids.length > 0 ? Math.max(...ids) : rangeStart - 1;\n  const next = currentMax + 1;\n\n  if (next > rangeEnd) {\n    throw new Error(`Update ID range exhausted (${rangeStart}-${rangeEnd})`);\n  }\n\n  return next;\n}\n\nasync function resolveVersion(baseCwd: string): Promise<string> {\n  const packagePath = join(baseCwd, 'package.json');\n\n  try {\n    const raw = await readFile(packagePath, 'utf-8');\n    const parsed = JSON.parse(raw) as { version?: unknown };\n    return typeof parsed.version === 'string' ? parsed.version : 'unknown';\n  } catch {\n    return 'unknown';\n  }\n}\n\nasync function resolveCommit(baseCwd: string): Promise<string> {\n  const result = await execa('git', ['rev-parse', '--short', 'HEAD'], {\n    cwd: baseCwd,\n    reject: false,\n  });\n\n  if (result.exitCode === 0 && result.stdout.trim()) {\n    return result.stdout.trim();\n  }\n\n  return 'unknown';\n}\n\nfunction stringifyCommandInputs(commandInputs: Record<string, unknown>): string {\n  const keys = Object.keys(commandInputs).sort();\n  if (keys.length === 0) return '- (none)';\n\n  return keys\n    .map((key) => {\n      const value = commandInputs[key];\n      if (value === undefined) return `- \\`${key}\\`: (unset)`;\n      if (typeof value === 'object') return `- \\`${key}\\`: \\`${JSON.stringify(value)}\\``;\n      return `- \\`${key}\\`: \\`${String(value)}\\``;\n    })\n    .join('\\n');\n}\n\nfunction summarizeSteps(steps: UpdateStep[]): { ok: number; skip: number; fail: number } {\n  let ok = 0;\n  let skip = 0;\n  let fail = 0;\n\n  for (const step of steps) {\n    if (step.status === 'ok') ok++;\n    else if (step.status === 'skip') skip++;\n    else if (step.status === 'fail') fail++;\n  }\n\n  return { ok, skip, fail };\n}\n\nfunction escapeCell(value: string): string {\n  return value.replace(/\\|/g, '\\\\|').replace(/\\n+/g, ' ').trim();\n}\n\nfunction renderStepTable(steps: UpdateStep[]): string {\n  if (steps.length === 0) return '- (no steps recorded)';\n\n  const lines = [\n    '| Target | Component | Step | Status | Message |',\n    '| --- | --- | --- | --- | --- |',\n  ];\n\n  for (const step of steps) {\n    lines.push(`| ${escapeCell(step.target)} | ${escapeCell(step.component)} | ${escapeCell(step.step)} | ${escapeCell(step.status)} | ${escapeCell(step.message)} |`);\n  }\n\n  return lines.join('\\n');\n}\n\nfunction renderUpdateLogMarkdown(params: {\n  id: number;\n  dateTime: DateTimeParts;\n  author: string;\n  versionBefore: string;\n  versionAfter: string;\n  commit: string;\n  promoted: boolean;\n  category: string;\n  summary: string;\n  commandInputs: Record<string, unknown>;\n  steps: UpdateStep[];\n}): string {\n  const {\n    id,\n    dateTime,\n    author,\n    versionBefore,\n    versionAfter,\n    commit,\n    promoted,\n    category,\n    summary,\n    commandInputs,\n    steps,\n  } = params;\n\n  const counts = summarizeSteps(steps);\n\n  return `---\nid: ${String(id).padStart(3, '0')}\ndate: ${dateTime.date}\ntime: ${dateTime.time}\nauthor: ${author}\nversion_before: ${versionBefore}\nversion_after: ${versionAfter}\ncommit: ${commit}\npromoted: ${promoted}\ncategory: ${category}\n---\n\n## Summary\n- ${summary}\n- Steps: total=${steps.length}, ok=${counts.ok}, skip=${counts.skip}, fail=${counts.fail}\n\n## Command Inputs\n${stringifyCommandInputs(commandInputs)}\n\n## Step Results\n${renderStepTable(steps)}\n`;\n}\n\nexport async function writeUpdateLog(input: UpdateLogInput): Promise<UpdateLogResult> {\n  const now = input.now ?? new Date();\n  const timezone = input.timezone ?? 'local';\n  const dateTime = zonedDateTimeParts(now, timezone);\n  const rangeStart = input.rangeStart ?? 1;\n  const rangeEnd = input.rangeEnd ?? 999;\n  const baseCwd = input.cwd ?? process.cwd();\n  const repoRoot = await detectRepoRoot(baseCwd);\n  const logsDir = await resolveLogsDir(baseCwd, input.logsDir);\n  const author = input.author?.trim() || safeAuthor();\n  const promoted = input.promoted ?? rangeStart >= 200;\n  const category = input.category ?? (promoted ? 'promotion' : 'development');\n\n  await mkdir(logsDir, { recursive: true });\n\n  const versionBefore = input.versionBefore ?? await resolveVersion(repoRoot);\n  const versionAfter = input.versionAfter ?? await resolveVersion(repoRoot);\n  const commit = input.commit ?? await resolveCommit(repoRoot);\n\n  for (let attempt = 0; attempt < 60; attempt++) {\n    const id = await allocateNextUpdateId(logsDir, rangeStart, rangeEnd);\n    const slugSource = input.slug || input.summary;\n    const fileName = buildUpdateLogFileName(id, dateTime.date, slugSource);\n    const path = join(logsDir, fileName);\n\n    const markdown = renderUpdateLogMarkdown({\n      id,\n      dateTime,\n      author,\n      versionBefore,\n      versionAfter,\n      commit,\n      promoted,\n      category,\n      summary: input.summary,\n      commandInputs: input.commandInputs,\n      steps: input.steps,\n    });\n\n    try {\n      await writeFile(path, markdown, { encoding: 'utf-8', flag: 'wx' });\n      return { id, path, fileName };\n    } catch (err) {\n      const code = (err as NodeJS.ErrnoException).code;\n      if (code === 'EEXIST') continue;\n      throw err;\n    }\n  }\n\n  throw new Error('Unable to allocate update log ID after multiple attempts');\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/keychain/api-keys.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/keychain/index.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":146,"column":72,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":146,"endColumn":74,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[4924,4926],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, comparison is always true, since `undefined !== 44` is true.","line":147,"column":9,"nodeType":"BinaryExpression","messageId":"comparisonBetweenLiteralTypes","endLine":147,"endColumn":24},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":180,"column":72,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":180,"endColumn":74,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[5981,5983],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, comparison is always true, since `undefined !== 44` is true.","line":181,"column":9,"nodeType":"BinaryExpression","messageId":"comparisonBetweenLiteralTypes","endLine":181,"endColumn":24},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, value is always truthy.","line":232,"column":11,"nodeType":"MemberExpression","messageId":"alwaysTruthy","endLine":232,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * keychain/index.ts  Cross-platform secure credential store.\n *\n * Uses OS-native CLIs only. No native addons, no node-gyp.\n *\n *   macOS   security(1) add/find/delete-generic-password\n *   Linux   secret-tool(1) if available in PATH\n *   Other   no-op (returns null / false)\n *\n * All public functions are fail-safe: errors are logged at verbose level\n * and never thrown to the caller.\n */\n\nimport { execFile as _execFile, spawn } from 'node:child_process';\nimport { promisify } from 'node:util';\nimport { verbose } from '../core/debug.js';\n\nconst execFile = promisify(_execFile);\n\n// ---------------------------------------------------------------------------\n// Internal platform detection\n// ---------------------------------------------------------------------------\n\nconst PLATFORM = process.platform;\n\n/** Cached result for Linux secret-tool availability check. */\nlet _secretToolAvailable: boolean | null = null;\n\nasync function checkSecretToolAvailable(): Promise<boolean> {\n  if (_secretToolAvailable !== null) return _secretToolAvailable;\n  try {\n    await execFile('which', ['secret-tool']);\n    _secretToolAvailable = true;\n  } catch {\n    _secretToolAvailable = false;\n  }\n  return _secretToolAvailable;\n}\n\n// ---------------------------------------------------------------------------\n// Public API\n// ---------------------------------------------------------------------------\n\n/**\n * Returns true if the current platform has a usable keychain backend.\n *\n * - macOS: always true (security CLI is part of macOS)\n * - Linux: true only if secret-tool is in PATH (sync check uses cached result)\n * - Other: always false\n *\n * Note: on Linux this may return false on first call before the async check\n * completes. Call isKeychainAvailable() after at least one async operation\n * for an accurate result, or use the async variant internally.\n */\nexport function isKeychainAvailable(): boolean {\n  if (PLATFORM === 'darwin') return true;\n  if (PLATFORM === 'linux') return _secretToolAvailable === true;\n  return false;\n}\n\n/**\n * Retrieve a secret from the OS keychain.\n *\n * @param service  Keychain service name (e.g. 'opta-cli')\n * @param account  Account name within the service (e.g. 'anthropic-api-key')\n * @returns The stored secret string, or null if not found or on error.\n */\nexport async function getSecret(service: string, account: string): Promise<string | null> {\n  if (PLATFORM === 'darwin') {\n    return macosGetSecret(service, account);\n  }\n  if (PLATFORM === 'linux') {\n    const available = await checkSecretToolAvailable();\n    if (!available) return null;\n    return linuxGetSecret(service, account);\n  }\n  verbose(`keychain: getSecret called on unsupported platform (${PLATFORM})`);\n  return null;\n}\n\n/**\n * Store a secret in the OS keychain.\n *\n * @param service  Keychain service name\n * @param account  Account name within the service\n * @param secret   The plaintext secret to store\n */\nexport async function setSecret(service: string, account: string, secret: string): Promise<void> {\n  if (PLATFORM === 'darwin') {\n    await macosSetSecret(service, account, secret);\n    return;\n  }\n  if (PLATFORM === 'linux') {\n    const available = await checkSecretToolAvailable();\n    if (!available) {\n      verbose('keychain: setSecret  secret-tool not available, skipping');\n      return;\n    }\n    await linuxSetSecret(service, account, secret);\n    return;\n  }\n  verbose(`keychain: setSecret called on unsupported platform (${PLATFORM}), skipping`);\n}\n\n/**\n * Delete a secret from the OS keychain.\n *\n * Does not throw if the secret does not exist.\n *\n * @param service  Keychain service name\n * @param account  Account name within the service\n */\nexport async function deleteSecret(service: string, account: string): Promise<void> {\n  if (PLATFORM === 'darwin') {\n    await macosDeleteSecret(service, account);\n    return;\n  }\n  if (PLATFORM === 'linux') {\n    const available = await checkSecretToolAvailable();\n    if (!available) {\n      verbose('keychain: deleteSecret  secret-tool not available, skipping');\n      return;\n    }\n    await linuxDeleteSecret(service, account);\n    return;\n  }\n  verbose(`keychain: deleteSecret called on unsupported platform (${PLATFORM}), skipping`);\n}\n\n// ---------------------------------------------------------------------------\n// macOS implementation  security(1)\n// ---------------------------------------------------------------------------\n\nasync function macosGetSecret(service: string, account: string): Promise<string | null> {\n  try {\n    // -w prints the password only (no other output)\n    const { stdout } = await execFile('security', [\n      'find-generic-password',\n      '-s', service,\n      '-a', account,\n      '-w',\n    ]);\n    return stdout.trimEnd();\n  } catch (err: unknown) {\n    // Exit code 44 = item not found  not an error for our purposes\n    const exitCode = (err as NodeJS.ErrnoException & { code?: number })?.code;\n    if (exitCode !== 44) {\n      const msg = err instanceof Error ? err.message : String(err);\n      verbose(`keychain(macOS): find-generic-password failed  ${msg}`);\n    }\n    return null;\n  }\n}\n\nasync function macosSetSecret(service: string, account: string, secret: string): Promise<void> {\n  try {\n    // -U updates the entry if it already exists\n    await execFile('security', [\n      'add-generic-password',\n      '-s', service,\n      '-a', account,\n      '-w', secret,\n      '-U',\n    ]);\n  } catch (err: unknown) {\n    const msg = err instanceof Error ? err.message : String(err);\n    verbose(`keychain(macOS): add-generic-password failed  ${msg}`);\n  }\n}\n\nasync function macosDeleteSecret(service: string, account: string): Promise<void> {\n  try {\n    await execFile('security', [\n      'delete-generic-password',\n      '-s', service,\n      '-a', account,\n    ]);\n  } catch (err: unknown) {\n    // Exit code 44 = item not found  treat as success (idempotent delete)\n    const exitCode = (err as NodeJS.ErrnoException & { code?: number })?.code;\n    if (exitCode !== 44) {\n      const msg = err instanceof Error ? err.message : String(err);\n      verbose(`keychain(macOS): delete-generic-password failed  ${msg}`);\n    }\n  }\n}\n\n// ---------------------------------------------------------------------------\n// Linux implementation  secret-tool(1)\n// ---------------------------------------------------------------------------\n\nasync function linuxGetSecret(service: string, account: string): Promise<string | null> {\n  try {\n    const { stdout } = await execFile('secret-tool', [\n      'lookup',\n      'service', service,\n      'account', account,\n    ]);\n    return stdout.trimEnd();\n  } catch (err: unknown) {\n    const msg = err instanceof Error ? err.message : String(err);\n    verbose(`keychain(Linux): secret-tool lookup failed  ${msg}`);\n    return null;\n  }\n}\n\nasync function linuxSetSecret(service: string, account: string, secret: string): Promise<void> {\n  return new Promise<void>((resolve) => {\n    try {\n      // secret-tool store reads the password from stdin.\n      // We use spawn (not execFile) here so we can write to stdin directly.\n      const child = spawn('secret-tool', [\n        'store',\n        `--label=${service}`,\n        'service', service,\n        'account', account,\n      ], { stdio: ['pipe', 'ignore', 'ignore'] });\n\n      child.on('error', (err) => {\n        verbose(`keychain(Linux): secret-tool store failed  ${err.message}`);\n        resolve();\n      });\n\n      child.on('close', (code) => {\n        if (code !== 0) {\n          verbose(`keychain(Linux): secret-tool store exited with code ${String(code)}`);\n        }\n        resolve();\n      });\n\n      // Write the secret to stdin then close the pipe\n      if (child.stdin) {\n        child.stdin.write(secret);\n        child.stdin.end();\n      }\n    } catch (err: unknown) {\n      const msg = err instanceof Error ? err.message : String(err);\n      verbose(`keychain(Linux): secret-tool store spawn failed  ${msg}`);\n      resolve();\n    }\n  });\n}\n\nasync function linuxDeleteSecret(service: string, account: string): Promise<void> {\n  try {\n    await execFile('secret-tool', [\n      'clear',\n      'service', service,\n      'account', account,\n    ]);\n  } catch (err: unknown) {\n    const msg = err instanceof Error ? err.message : String(err);\n    verbose(`keychain(Linux): secret-tool clear failed  ${msg}`);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/learning/hooks.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/learning/ledger.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, value is always truthy.","line":47,"column":10,"nodeType":"Literal","messageId":"alwaysTruthy","endLine":47,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { mkdir, open, readFile, rename, unlink, writeFile } from 'node:fs/promises';\nimport { dirname, join } from 'node:path';\nimport {\n  LearningLedgerEntrySchema,\n  type CaptureLevel,\n  type LearningEntryKind,\n  type LearningLedgerEntry,\n} from './types.js';\nimport { sleep } from '../utils/common.js';\n\nconst LEDGER_RELATIVE_PATH = join('.opta', 'learning', 'ledger.jsonl');\n\nexport interface LedgerStoreOptions {\n  cwd?: string;\n  lockTimeoutMs?: number;\n  lockRetryMs?: number;\n}\n\nexport interface LedgerReadOptions {\n  cwd?: string;\n}\n\nexport interface LedgerQuery {\n  kinds?: LearningEntryKind[];\n  captureLevels?: CaptureLevel[];\n  tags?: string[];\n  text?: string;\n  from?: string | Date;\n  to?: string | Date;\n  limit?: number;\n}\n\nexport function learningLedgerPath(cwd = process.cwd()): string {\n  return join(cwd, LEDGER_RELATIVE_PATH);\n}\n\nfunction learningLedgerDir(cwd = process.cwd()): string {\n  return dirname(learningLedgerPath(cwd));\n}\n\nfunction learningLedgerLockPath(cwd = process.cwd()): string {\n  return `${learningLedgerPath(cwd)}.lock`;\n}\n\nasync function acquireLock(lockPath: string, timeoutMs: number, retryMs: number) {\n  const start = Date.now();\n  while (true) {\n    try {\n      return await open(lockPath, 'wx');\n    } catch (error) {\n      const err = error as NodeJS.ErrnoException;\n      if (err.code !== 'EEXIST') {\n        throw err;\n      }\n      if (Date.now() - start >= timeoutMs) {\n        throw new Error(`Timed out waiting for ledger lock: ${lockPath}`);\n      }\n      await sleep(retryMs);\n    }\n  }\n}\n\nfunction parseDate(value?: string | Date): number | undefined {\n  if (value === undefined) return undefined;\n  const millis = new Date(value).getTime();\n  return Number.isNaN(millis) ? undefined : millis;\n}\n\nfunction matchesFreeText(entry: LearningLedgerEntry, rawText: string): boolean {\n  const text = rawText.trim().toLowerCase();\n  if (!text) return true;\n\n  const haystack = [\n    entry.id,\n    entry.kind,\n    entry.captureLevel,\n    entry.topic,\n    entry.content,\n    entry.tags.join(' '),\n    entry.evidence.map((item) => `${item.label} ${item.uri}`).join(' '),\n  ]\n    .join(' ')\n    .toLowerCase();\n\n  return text\n    .split(/\\s+/)\n    .filter(Boolean)\n    .every((token) => haystack.includes(token));\n}\n\nasync function readLedgerFile(path: string): Promise<string> {\n  try {\n    return await readFile(path, 'utf-8');\n  } catch (error) {\n    const err = error as NodeJS.ErrnoException;\n    if (err.code === 'ENOENT') {\n      return '';\n    }\n    throw err;\n  }\n}\n\nexport async function appendLedgerEntry(\n  entry: LearningLedgerEntry,\n  options: LedgerStoreOptions = {},\n): Promise<void> {\n  const cwd = options.cwd ?? process.cwd();\n  const lockTimeoutMs = options.lockTimeoutMs ?? 5000;\n  const lockRetryMs = options.lockRetryMs ?? 20;\n  const ledgerPath = learningLedgerPath(cwd);\n  const ledgerDir = learningLedgerDir(cwd);\n  const lockPath = learningLedgerLockPath(cwd);\n  const parsed = LearningLedgerEntrySchema.parse(entry);\n\n  await mkdir(ledgerDir, { recursive: true });\n  const lockHandle = await acquireLock(lockPath, lockTimeoutMs, lockRetryMs);\n  let tempPath = '';\n\n  try {\n    const current = await readLedgerFile(ledgerPath);\n    tempPath = `${ledgerPath}.${process.pid}.${Date.now()}.tmp`;\n    await writeFile(tempPath, `${current}${JSON.stringify(parsed)}\\n`, 'utf-8');\n    await rename(tempPath, ledgerPath);\n  } finally {\n    if (tempPath) {\n      await unlink(tempPath).catch(() => {});\n    }\n    await lockHandle.close().catch(() => {});\n    await unlink(lockPath).catch(() => {});\n  }\n}\n\nexport async function readLedgerEntries(\n  options: LedgerReadOptions = {},\n): Promise<LearningLedgerEntry[]> {\n  const cwd = options.cwd ?? process.cwd();\n  const raw = await readLedgerFile(learningLedgerPath(cwd));\n  if (!raw.trim()) return [];\n\n  const lines = raw.split('\\n').filter((line) => line.trim().length > 0);\n  const parsed: LearningLedgerEntry[] = [];\n\n  for (const [index, line] of lines.entries()) {\n    let json: unknown;\n    try {\n      json = JSON.parse(line);\n    } catch {\n      throw new Error(`Invalid ledger entry at line ${index + 1}: malformed JSON`);\n    }\n\n    const result = LearningLedgerEntrySchema.safeParse(json);\n    if (!result.success) {\n      const issue = result.error.issues[0]?.message ?? 'schema mismatch';\n      throw new Error(`Invalid ledger entry at line ${index + 1}: ${issue}`);\n    }\n    parsed.push(result.data);\n  }\n\n  return parsed;\n}\n\nexport async function queryLedgerEntries(\n  query: LedgerQuery = {},\n  options: LedgerReadOptions = {},\n): Promise<LearningLedgerEntry[]> {\n  const entries = await readLedgerEntries(options);\n  const fromMs = parseDate(query.from);\n  const toMs = parseDate(query.to);\n  const tags = query.tags ?? [];\n  const kinds = query.kinds ?? [];\n  const captureLevels = query.captureLevels ?? [];\n\n  let filtered = entries.filter((entry) => {\n    if (kinds.length > 0 && !kinds.includes(entry.kind)) {\n      return false;\n    }\n    if (captureLevels.length > 0 && !captureLevels.includes(entry.captureLevel)) {\n      return false;\n    }\n    if (tags.length > 0 && !tags.every((tag) => entry.tags.includes(tag))) {\n      return false;\n    }\n\n    const ts = new Date(entry.ts).getTime();\n    if (fromMs !== undefined && ts < fromMs) {\n      return false;\n    }\n    if (toMs !== undefined && ts > toMs) {\n      return false;\n    }\n\n    if (query.text && !matchesFreeText(entry, query.text)) {\n      return false;\n    }\n\n    return true;\n  });\n\n  filtered = filtered.sort((a, b) => b.ts.localeCompare(a.ts));\n  if (query.limit !== undefined && query.limit > 0) {\n    filtered = filtered.slice(0, query.limit);\n  }\n\n  return filtered;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/learning/retrieval.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/learning/summarizer.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":46,"column":5,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":46,"endColumn":22,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[1324,1325],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { LearningLedgerEntry } from './types.js';\n\nexport interface LedgerSummaryOptions {\n  from?: string | Date;\n  to?: string | Date;\n}\n\nfunction parseDate(value?: string | Date): number | undefined {\n  if (value === undefined) return undefined;\n  const millis = new Date(value).getTime();\n  return Number.isNaN(millis) ? undefined : millis;\n}\n\nfunction dateKey(ts: string): string {\n  return new Date(ts).toISOString().slice(0, 10);\n}\n\nexport function summarizeLedgerByDate(\n  entries: LearningLedgerEntry[],\n  options: LedgerSummaryOptions = {},\n): string {\n  const fromMs = parseDate(options.from);\n  const toMs = parseDate(options.to);\n\n  const filtered = entries\n    .filter((entry) => {\n      const ts = new Date(entry.ts).getTime();\n      if (fromMs !== undefined && ts < fromMs) return false;\n      if (toMs !== undefined && ts > toMs) return false;\n      return true;\n    })\n    .sort((a, b) => b.ts.localeCompare(a.ts));\n\n  const lines: string[] = ['# Learning Ledger Summary', ''];\n  if (filtered.length === 0) {\n    lines.push('_No entries found._');\n    return `${lines.join('\\n')}\\n`;\n  }\n\n  const grouped = new Map<string, LearningLedgerEntry[]>();\n  for (const entry of filtered) {\n    const key = dateKey(entry.ts);\n    if (!grouped.has(key)) {\n      grouped.set(key, []);\n    }\n    grouped.get(key)!.push(entry);\n  }\n\n  const sortedDates = Array.from(grouped.keys()).sort((a, b) =>\n    b.localeCompare(a),\n  );\n  for (const day of sortedDates) {\n    lines.push(`## ${day}`, '');\n    for (const entry of grouped.get(day) ?? []) {\n      lines.push(`- **${entry.kind}** ${entry.topic}`);\n      lines.push(`  ${entry.content}`);\n      if (entry.tags.length > 0) {\n        lines.push(`  Tags: ${entry.tags.join(', ')}`);\n      }\n      if (entry.evidence.length > 0) {\n        const refs = entry.evidence\n          .map((item) => `[${item.label}](${item.uri})`)\n          .join(', ');\n        lines.push(`  Evidence: ${refs}`);\n      }\n    }\n    lines.push('');\n  }\n\n  return `${lines.join('\\n').trimEnd()}\\n`;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/learning/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/lmx/api-key.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/lmx/client.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":1058,"column":48,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":1058,"endColumn":62},{"ruleId":"@typescript-eslint/no-misused-spread","severity":1,"message":"Using the spread operator on an array in an object will result in a list of indices.","line":1074,"column":40,"nodeType":"SpreadElement","messageId":"noArraySpreadInObject","endLine":1074,"endColumn":56},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, value is always truthy.","line":1161,"column":15,"nodeType":"MemberExpression","messageId":"alwaysTruthy","endLine":1161,"endColumn":25},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":1358,"column":29,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":1358,"endColumn":44},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":1359,"column":23,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":1359,"endColumn":42}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { debug } from '../core/debug.js';\nimport { getContextLimit } from '../core/models.js';\nimport { errorMessage } from '../utils/errors.js';\nimport { sleep } from '../utils/common.js';\nimport type { ZodType } from 'zod';\n\n//  Structured LMX Error \n\nexport class LmxApiError extends Error {\n  constructor(\n    public readonly status: number,\n    public readonly code: string,\n    message: string,\n  ) {\n    super(message);\n    this.name = 'LmxApiError';\n  }\n}\n\n// --- Public Response Types (what commands consume) ---\n\nexport interface LmxHealthResponse {\n  status: 'ok' | 'degraded' | 'error';\n  version?: string;\n  uptime_seconds?: number;\n}\n\nexport interface LmxModelDetail {\n  model_id: string;\n  status: 'loaded' | 'loading' | 'unloading';\n  memory_bytes?: number;\n  context_length?: number;\n  is_default?: boolean;\n  loaded_at?: string;\n  request_count?: number;\n}\n\nexport interface LmxStatusResponse {\n  status: string;\n  version?: string;\n  uptime_seconds?: number;\n  models: LmxModelDetail[];\n  memory?: {\n    used_bytes: number;\n    total_bytes: number;\n    threshold: number;\n  };\n}\n\nexport interface LmxModelsResponse {\n  models: LmxModelDetail[];\n}\n\nexport type LmxLoadStatus = 'loaded' | 'download_required' | 'downloading';\n\nexport interface LmxLoadResponse {\n  model_id: string;\n  status: LmxLoadStatus;\n  memory_bytes?: number;\n  load_time_seconds?: number;\n  estimated_size_bytes?: number;\n  estimated_size_human?: string;\n  confirmation_token?: string;\n  download_id?: string;\n  message?: string;\n  confirm_url?: string;\n  progress_url?: string;\n}\n\nexport interface LmxUnloadResponse {\n  model_id: string;\n  status: 'unloaded';\n  freed_bytes?: number;\n}\n\nexport interface LmxAvailableModel {\n  repo_id: string;\n  local_path: string;\n  size_bytes: number;\n  downloaded_at?: number;\n}\n\nexport interface LmxPreset {\n  name: string;\n  description?: string;\n  model: string;\n  parameters?: Record<string, unknown>;\n  system_prompt?: string;\n  routing_alias?: string;\n  auto_load?: boolean;\n  performance?: Record<string, unknown>;\n}\n\nexport interface LmxPresetsResponse {\n  presets: LmxPreset[];\n  count: number;\n}\n\nexport interface LmxStackRole {\n  preferences: string[];\n  resolved_model: string | null;\n  loaded: boolean;\n}\n\nexport interface LmxStackResponse {\n  roles: Record<string, LmxStackRole>;\n  helper_nodes: Record<string, unknown>;\n  loaded_models: string[];\n  default_model: string | null;\n}\n\nexport interface LmxMemoryResponse {\n  total_unified_memory_gb: number;\n  used_gb: number;\n  available_gb: number;\n  threshold_percent: number;\n  models: Record<string, { memory_gb: number; loaded: boolean }>;\n}\n\nexport interface LmxDownloadResponse {\n  downloadId: string;\n  repoId: string;\n  estimatedSizeBytes?: number;\n  status: string;\n}\n\nexport interface LmxDownloadProgress {\n  downloadId: string;\n  repoId: string;\n  status: 'pending' | 'downloading' | 'completed' | 'failed';\n  progressPercent: number;\n  downloadedBytes: number;\n  totalBytes: number;\n  filesCompleted: number;\n  filesTotal: number;\n  error?: string;\n}\n\nexport interface LmxDeleteResponse {\n  modelId: string;\n  freedBytes: number;\n}\n\nexport interface LmxModelPerformance {\n  modelId: string;\n  backendType: string;\n  loadedAt: string;\n  requestCount: number;\n  lastUsedAt?: string;\n  memoryGb: number;\n  contextLength: number;\n  useBatching: boolean;\n  performanceOverrides: Record<string, unknown>;\n  globalDefaults: Record<string, unknown>;\n}\n\nexport interface LmxMetricsSummary {\n  totalRequests: number;\n  totalTokens: number;\n  avgLatencyMs: number;\n  errorRate: number;\n  [key: string]: unknown;\n}\n\nexport interface LmxBenchmarkRun {\n  run: number;\n  tokensGenerated: number;\n  timeToFirstTokenMs: number;\n  totalTimeMs: number;\n  tokensPerSecond: number;\n}\n\nexport interface LmxBenchmarkResult {\n  modelId: string;\n  backendType: string;\n  prompt: string;\n  maxTokens: number;\n  runs: number;\n  results: LmxBenchmarkRun[];\n  avgTokensPerSecond: number;\n  avgTimeToFirstTokenMs: number;\n  avgTotalTimeMs: number;\n}\n\nexport interface LmxBenchmarkPersistRequest {\n  modelId: string;\n  prompt?: string;\n  numOutputTokens?: number;\n  runs?: number;\n  temperature?: number;\n  warmupRuns?: number;\n}\n\nexport interface LmxBenchmarkPersistStats {\n  ttft_p50_sec: number;\n  ttft_p95_sec: number;\n  ttft_mean_sec: number;\n  toks_per_sec_p50: number;\n  toks_per_sec_p95: number;\n  toks_per_sec_mean: number;\n  prompt_tokens: number;\n  output_tokens: number;\n  runs_completed: number;\n  warmup_runs_discarded: number;\n  output_text: string;\n  output_token_count: number;\n  completed_naturally: boolean;\n  repetition_ratio: number;\n  coherence_flag: 'ok' | 'truncated' | 'repetitive' | 'garbled';\n  tool_call?: Record<string, unknown> | null;\n  skills: Array<Record<string, unknown>>;\n  [key: string]: unknown;\n}\n\nexport interface LmxBenchmarkPersistResult {\n  model_id: string;\n  backend: string;\n  timestamp: string;\n  status: 'ok' | 'insufficient_data';\n  hardware: string;\n  lmx_version: string;\n  prompt_preview: string;\n  stats: LmxBenchmarkPersistStats;\n  [key: string]: unknown;\n}\n\nexport interface LmxBenchmarkResultsOptions {\n  modelId?: string;\n}\n\nexport interface LmxConfigReloadResult {\n  success: boolean;\n  updated: string[];\n}\n\nexport interface LmxLoadModelOptions extends LmxRequestOptions {\n  backend?: string;\n  autoDownload?: boolean;\n  performanceOverrides?: Record<string, unknown>;\n  keepAliveSec?: number;\n  allowUnsupportedRuntime?: boolean;\n}\n\nexport interface LmxPresetDetailResponse extends LmxPreset {\n  [key: string]: unknown;\n}\n\nexport interface LmxPresetReloadResult {\n  success?: boolean;\n  presets_loaded?: number;\n  [key: string]: unknown;\n}\n\nexport interface LmxProbeModelOptions {\n  modelId: string;\n  timeoutSec?: number;\n  allowUnsupportedRuntime?: boolean;\n}\n\nexport interface LmxProbeModelResult {\n  model_id?: string;\n  success?: boolean;\n  [key: string]: unknown;\n}\n\nexport interface LmxModelCompatibilityOptions {\n  modelId?: string;\n  backend?: string;\n  outcome?: string;\n  sinceTs?: number;\n  limit?: number;\n  includeSummary?: boolean;\n}\n\nexport interface LmxModelCompatibilityResult {\n  summary?: Record<string, unknown>;\n  [key: string]: unknown;\n}\n\nexport interface LmxAutotuneModelOptions {\n  modelId: string;\n  prompt?: string;\n  maxTokens?: number;\n  temperature?: number;\n  runs?: number;\n  profiles?: Array<Record<string, unknown> | string>;\n  allowUnsupportedRuntime?: boolean;\n}\n\nexport interface LmxAutotuneModelResult {\n  model_id?: string;\n  success?: boolean;\n  [key: string]: unknown;\n}\n\nexport interface LmxAutotuneRecordOptions {\n  backend?: string;\n  backendVersion?: string;\n}\n\nexport interface LmxAutotuneRecordResult {\n  model_id?: string;\n  backend?: string;\n  backend_version?: string;\n  [key: string]: unknown;\n}\n\nexport interface LmxQuantizeRequest {\n  sourceModel: string;\n  outputPath?: string;\n  bits?: 4 | 8;\n  groupSize?: number;\n  mode?: 'affine' | 'symmetric';\n}\n\nexport interface LmxQuantizeStartResult {\n  job_id: string;\n  source_model: string;\n  output_path: string;\n  bits: number;\n  mode: string;\n  status: string;\n}\n\nexport interface LmxQuantizeJobResult {\n  job_id?: string;\n  source_model?: string;\n  output_path?: string;\n  bits?: number;\n  group_size?: number;\n  mode?: string;\n  status?: string;\n  started_at?: number;\n  completed_at?: number;\n  duration_sec?: number;\n  output_size_bytes?: number;\n  output_size_gb?: number;\n  error?: string;\n}\n\nexport interface LmxQuantizeJobsResult {\n  jobs: LmxQuantizeJobResult[];\n  count: number;\n}\n\nexport interface LmxPredictorStats {\n  predicted_next?: string | null;\n  [key: string]: unknown;\n}\n\nexport interface LmxHelpersHealth {\n  helpers?: Record<string, unknown>;\n  live_checks?: Record<string, boolean>;\n  configured_count?: number;\n  all_healthy?: boolean;\n  [key: string]: unknown;\n}\n\nexport interface LmxAgentRunStep {\n  id?: string;\n  role?: string;\n  order?: number;\n  status?: string;\n  input?: string;\n  output?: string | null;\n  error?: string | null;\n  created_at?: number;\n  started_at?: number | null;\n  completed_at?: number | null;\n  [key: string]: unknown;\n}\n\nexport interface LmxAgentRunRequest {\n  strategy?: string;\n  prompt?: string;\n  roles?: string[];\n  model?: string;\n  role_models?: Record<string, string>;\n  max_parallelism?: number;\n  timeout_sec?: number | null;\n  priority?: string;\n  metadata?: Record<string, unknown>;\n  submitted_by?: string | null;\n  [key: string]: unknown;\n}\n\nexport interface LmxAgentRunResult {\n  object?: string;\n  id: string;\n  status: string;\n  request?: LmxAgentRunRequest;\n  steps?: LmxAgentRunStep[];\n  result?: unknown;\n  output?: unknown;\n  error?: string | null;\n  resolved_model?: string | null;\n  created_at?: number;\n  updated_at?: number;\n  [key: string]: unknown;\n}\n\nexport interface LmxAgentRunListResult {\n  object?: string;\n  data: LmxAgentRunResult[];\n  total: number;\n}\n\nexport interface LmxAgentRunCreatePayload {\n  request?: Record<string, unknown>;\n  agent?: string;\n  input?: Record<string, unknown>;\n  metadata?: Record<string, unknown>;\n}\n\nexport interface LmxSkillSummary {\n  schema?: string;\n  name?: string;\n  namespace?: string;\n  version?: string;\n  qualified_name?: string;\n  reference?: string;\n  description?: string;\n  kind?: string;\n  timeout_sec?: number;\n  permission_tags?: string[];\n  risk_tags?: string[];\n  input_schema?: Record<string, unknown>;\n  [key: string]: unknown;\n}\n\nexport interface LmxSkillListResult {\n  object?: string;\n  data: LmxSkillSummary[];\n}\n\nexport interface LmxSkillTool {\n  name: string;\n  description?: string;\n  inputSchema?: Record<string, unknown>;\n  namespace?: string | null;\n  version?: string | null;\n  aliases?: string[];\n  [key: string]: unknown;\n}\n\nexport interface LmxSkillMcpToolsResult {\n  tools: LmxSkillTool[];\n  list_changed_at?: string;\n}\n\nexport interface LmxSkillExecuteRequest {\n  arguments?: Record<string, unknown> | string;\n  approved?: boolean;\n  timeoutSec?: number;\n}\n\nexport interface LmxSkillExecuteResponse {\n  skill?: string;\n  ok?: boolean;\n  output?: unknown;\n  error?: string | null;\n  duration_ms?: number;\n  timed_out?: boolean;\n  denied?: boolean;\n  requires_approval?: boolean;\n  [key: string]: unknown;\n}\n\nexport interface LmxSkillMcpCallRequest {\n  name: string;\n  arguments?: Record<string, unknown> | string;\n  approved?: boolean;\n}\n\nexport interface LmxSkillMcpCallResponse {\n  skill_name?: string;\n  kind?: string;\n  ok?: boolean;\n  output?: unknown;\n  error?: string | null;\n  duration_ms?: number;\n  timed_out?: boolean;\n  denied?: boolean;\n  requires_approval?: boolean;\n  [key: string]: unknown;\n}\n\nexport interface LmxSkillOpenClawInvokeRequest {\n  name?: string;\n  tool?: string;\n  toolName?: string;\n  arguments?: Record<string, unknown> | string;\n  input?: Record<string, unknown> | string;\n  params?: Record<string, unknown> | string;\n  approved?: boolean;\n  timeoutSec?: number;\n}\n\nexport interface LmxSkillOpenClawInvokeResponse {\n  object?: string;\n  tool?: string;\n  ok?: boolean;\n  result?: unknown;\n  error?: string | null;\n  duration_ms?: number;\n  timed_out?: boolean;\n  denied?: boolean;\n  requires_approval?: boolean;\n  [key: string]: unknown;\n}\n\nexport interface LmxRagCollectionInfo {\n  name: string;\n  document_count: number;\n  embedding_dimensions: number;\n}\n\nexport interface LmxRagCollectionsResult {\n  total_documents: number;\n  collection_count: number;\n  collections: LmxRagCollectionInfo[];\n}\n\nexport interface LmxRagQueryRequest {\n  collection: string;\n  query: string;\n  topK?: number;\n  minScore?: number;\n  model?: string;\n  includeEmbeddings?: boolean;\n  searchMode?: 'vector' | 'keyword' | 'hybrid';\n  rerank?: boolean;\n  rerankTopK?: number;\n}\n\nexport interface LmxRagQueryResultRow {\n  id?: string;\n  text?: string;\n  score?: number;\n  metadata?: Record<string, unknown>;\n  embedding?: number[] | null;\n  [key: string]: unknown;\n}\n\nexport interface LmxRagQueryResult {\n  collection?: string;\n  query?: string;\n  results?: LmxRagQueryResultRow[];\n  total_in_collection?: number;\n  duration_ms?: number;\n  [key: string]: unknown;\n}\n\nexport interface LmxRagIngestRequest {\n  collection: string;\n  documents: string[];\n  metadata?: Array<Record<string, unknown>>;\n  chunkSize?: number;\n  chunkOverlap?: number;\n  chunking?: 'auto' | 'text' | 'code' | 'markdown_headers' | 'none';\n  model?: string;\n}\n\nexport interface LmxRagIngestResult {\n  collection?: string;\n  documents_ingested?: number;\n  chunks_created?: number;\n  document_ids?: string[];\n  duration_ms?: number;\n  [key: string]: unknown;\n}\n\nexport interface LmxRagContextRequest {\n  query: string;\n  collections: string[];\n  topKPerCollection?: number;\n  minScore?: number;\n  maxContextTokens?: number;\n  model?: string;\n  rerank?: boolean;\n}\n\nexport interface LmxRagContextResult {\n  context?: string;\n  sources?: Array<Record<string, unknown>>;\n  total_chunks?: number;\n  estimated_tokens?: number;\n  duration_ms?: number;\n  [key: string]: unknown;\n}\n\nexport interface LmxSessionListOptions {\n  limit?: number;\n  offset?: number;\n  model?: string;\n  tag?: string;\n  since?: string;\n}\n\nexport interface LmxSessionSearchOptions {\n  query: string;\n  limit?: number;\n}\n\nexport interface LmxSessionSummary {\n  id: string;\n  title: string;\n  model: string;\n  tags: string[];\n  created: string;\n  updated: string;\n  message_count: number;\n}\n\nexport interface LmxSessionMessage {\n  role: string;\n  content?: string | unknown[] | null;\n  tool_calls?: unknown[] | null;\n  tool_call_id?: string | null;\n}\n\nexport interface LmxSessionFull {\n  id: string;\n  title: string;\n  model: string;\n  tags: string[];\n  created: string;\n  updated: string;\n  cwd: string;\n  messages: LmxSessionMessage[];\n  tool_call_count: number;\n  compacted: boolean;\n}\n\nexport interface LmxSessionListResult {\n  sessions: LmxSessionSummary[];\n  total: number;\n}\n\nexport interface LmxSessionDeleteResult {\n  deleted: boolean;\n}\n\nexport interface LmxEmbeddingsRequest {\n  input: string | string[];\n  model: string;\n  encodingFormat?: string;\n}\n\nexport interface LmxEmbeddingItem {\n  object: string;\n  embedding: number[];\n  index: number;\n}\n\nexport interface LmxEmbeddingsUsage {\n  prompt_tokens: number;\n  total_tokens: number;\n}\n\nexport interface LmxEmbeddingsResponse {\n  object: string;\n  data: LmxEmbeddingItem[];\n  model: string;\n  usage: LmxEmbeddingsUsage;\n  [key: string]: unknown;\n}\n\nexport interface LmxRerankRequest {\n  model: string;\n  query: string;\n  documents: string[];\n  topN?: number;\n}\n\nexport interface LmxRerankDocumentResult {\n  index: number;\n  relevance_score: number;\n  document?: {\n    text: string;\n  };\n  [key: string]: unknown;\n}\n\nexport interface LmxRerankResponse {\n  results: LmxRerankDocumentResult[];\n  model: string;\n  usage?: {\n    total_tokens: number;\n  };\n  [key: string]: unknown;\n}\n\nexport interface LmxAnthropicMessage {\n  role: string;\n  content: string | Array<Record<string, unknown>>;\n}\n\nexport interface LmxAnthropicMessagesRequest {\n  model: string;\n  messages: LmxAnthropicMessage[];\n  maxTokens?: number;\n  system?: string;\n  temperature?: number;\n  topP?: number;\n  stream?: boolean;\n  stopSequences?: string[];\n}\n\nexport interface LmxAnthropicMessagesResponse {\n  id?: string;\n  type?: string;\n  role?: string;\n  model?: string;\n  content?: Array<Record<string, unknown>>;\n  stop_reason?: string | null;\n  stop_sequence?: string | null;\n  usage?: {\n    input_tokens?: number;\n    output_tokens?: number;\n  };\n  [key: string]: unknown;\n}\n\n// --- Raw LMX Server Response Types (what the API actually returns) ---\n\ninterface RawAdminModelDetail {\n  id: string;\n  loaded: boolean;\n  memory_gb: number;\n  loaded_at: number;\n  use_batching: boolean;\n  request_count: number;\n  last_used_at: number;\n  context_length?: number | null;\n}\n\ninterface RawAdminModelsResponse {\n  loaded: RawAdminModelDetail[];\n  count: number;\n}\n\ninterface RawAdminStatusResponse {\n  version: string;\n  uptime_seconds: number;\n  loaded_models: number;\n  models: string[];\n  memory: {\n    total_gb: number;\n    used_gb: number;\n    available_gb: number;\n    usage_percent: number;\n    threshold_percent: number;\n  };\n}\n\ninterface RawAdminLoadResponse {\n  success?: boolean;\n  status?: string;\n  model_id: string;\n  memory_after_load_gb?: number;\n  time_to_load_ms?: number;\n  estimated_size_bytes?: number;\n  estimated_size_human?: string;\n  confirmation_token?: string;\n  download_id?: string;\n  message?: string;\n  confirm_url?: string;\n  progress_url?: string;\n}\n\ninterface RawAdminUnloadResponse {\n  success: boolean;\n  model_id: string;\n  memory_freed_gb?: number;\n}\n\ninterface RawDownloadResponse {\n  download_id: string;\n  repo_id: string;\n  estimated_size_bytes?: number;\n  status: string;\n}\n\ninterface RawDownloadProgressResponse {\n  download_id: string;\n  repo_id: string;\n  status: string;\n  progress_percent: number;\n  downloaded_bytes: number;\n  total_bytes: number;\n  files_completed: number;\n  files_total: number;\n  error?: string;\n}\n\ninterface RawDeleteResponse {\n  success: boolean;\n  model_id: string;\n  freed_bytes: number;\n}\n\ninterface RawModelPerformanceResponse {\n  model_id: string;\n  backend_type: string;\n  loaded_at: number;\n  request_count: number;\n  last_used_at?: number;\n  memory_gb: number;\n  context_length: number;\n  use_batching: boolean;\n  performance: Record<string, unknown>;\n  global_defaults: Record<string, unknown>;\n}\n\ninterface RawBenchmarkResult {\n  run: number;\n  tokens_generated: number;\n  time_to_first_token_ms: number;\n  total_time_ms: number;\n  tokens_per_second: number;\n}\n\ninterface RawBenchmarkResponse {\n  model_id: string;\n  backend_type: string;\n  prompt: string;\n  max_tokens: number;\n  runs: number;\n  results: RawBenchmarkResult[];\n  avg_tokens_per_second: number;\n  avg_time_to_first_token_ms: number;\n  avg_total_time_ms: number;\n}\n\n// --- Context Limit Lookup ---\n// Delegates to the canonical MODEL_PROFILES in core/models.ts.\n\nexport function lookupContextLimit(modelId: string): number {\n  return getContextLimit(modelId);\n}\n\nconst GB_TO_BYTES = 1e9;\nconst DEFAULT_TIMEOUT_MS = 30_000;\nconst DEFAULT_MAX_RETRIES = 2;\nconst DEFAULT_BACKOFF_MS = 250;\nconst DEFAULT_BACKOFF_MULTIPLIER = 1.8;\nconst DEFAULT_HOST_FAILURE_COOLDOWN_MS = 20_000;\nconst RETRYABLE_HTTP_STATUS = new Set([408, 425, 429, 500, 502, 503, 504]);\n\nexport interface LmxRequestOptions {\n  timeoutMs?: number;\n  maxRetries?: number;\n}\n\ninterface HostAttemptFailure {\n  host: string;\n  detail: string;\n}\n\ntype HostCircuitState = 'closed' | 'open' | 'half_open';\n\nfunction mapHttpErrorCode(status: number): string {\n  if (status === 403) return 'unauthorized';\n  if (status === 404) return 'not_found';\n  if (status === 409) return 'conflict';\n  if (status === 507) return 'out_of_memory';\n  if (status === 408 || status === 504) return 'timeout';\n  if (status === 429) return 'rate_limited';\n  if (status >= 500) return 'server_error';\n  return `http_${status}`;\n}\n\nfunction parseApiErrorMessage(body: string, statusText: string): string {\n  const fallback = statusText || 'request failed';\n  const trimmedBody = body.trim();\n  if (!trimmedBody) return fallback;\n\n  try {\n    const parsed = JSON.parse(trimmedBody) as unknown;\n    const extracted = errorMessage(parsed).trim();\n    if (extracted && extracted !== '[object Object]' && extracted !== '{}') {\n      return extracted;\n    }\n  } catch {\n    // Not JSON  return raw text below.\n  }\n\n  return trimmedBody || fallback;\n}\n\nfunction isAbortFailure(err: unknown): boolean {\n  return err instanceof DOMException\n    ? err.name === 'AbortError' || err.name === 'TimeoutError'\n    : err instanceof Error && /abort|timeout/i.test(err.message);\n}\n\nfunction buildQueryString(\n  query: Record<string, string | number | boolean | undefined>,\n): string {\n  const params = new URLSearchParams();\n  for (const [key, value] of Object.entries(query)) {\n    if (value !== undefined) {\n      params.set(key, String(value));\n    }\n  }\n  const serialized = params.toString();\n  return serialized ? `?${serialized}` : '';\n}\n\n// --- LMX Admin Client ---\n\nexport class LmxClient {\n  private readonly port: number;\n  private readonly hosts: string[];\n  private activeHostIndex: number;\n  private readonly headers: Record<string, string>;\n  private readonly timeoutMs: number;\n  private readonly maxRetries: number;\n  private readonly backoffMs: number;\n  private readonly backoffMultiplier: number;\n  private readonly hostFailureCooldownMs: number;\n  private readonly hostCooldownUntilMs: Map<string, number>;\n\n  constructor(opts: {\n    host: string;\n    fallbackHosts?: string[];\n    port: number;\n    adminKey?: string;\n    timeoutMs?: number;\n    maxRetries?: number;\n    backoffMs?: number;\n    backoffMultiplier?: number;\n  }) {\n    this.port = opts.port;\n    const hosts = [opts.host, ...(opts.fallbackHosts ?? [])]\n      .map((host) => host.trim())\n      .filter((host) => host.length > 0);\n    const seen = new Set<string>();\n    this.hosts = [];\n    for (const host of hosts) {\n      const key = host.toLowerCase();\n      if (seen.has(key)) continue;\n      seen.add(key);\n      this.hosts.push(host);\n    }\n    if (this.hosts.length === 0) {\n      this.hosts.push('localhost');\n    }\n    this.activeHostIndex = 0;\n    this.headers = { 'Content-Type': 'application/json' };\n    this.timeoutMs = Math.max(1000, opts.timeoutMs ?? DEFAULT_TIMEOUT_MS);\n    this.maxRetries = Math.max(0, opts.maxRetries ?? DEFAULT_MAX_RETRIES);\n    this.backoffMs = Math.max(1, opts.backoffMs ?? DEFAULT_BACKOFF_MS);\n    this.backoffMultiplier = Math.max(1, opts.backoffMultiplier ?? DEFAULT_BACKOFF_MULTIPLIER);\n    this.hostFailureCooldownMs = DEFAULT_HOST_FAILURE_COOLDOWN_MS;\n    this.hostCooldownUntilMs = new Map();\n    if (opts.adminKey) {\n      this.headers['X-Admin-Key'] = opts.adminKey;\n    }\n  }\n\n  private retryDelayMs(attempt: number): number {\n    return Math.round(this.backoffMs * Math.pow(this.backoffMultiplier, attempt));\n  }\n\n  private hostKey(host: string): string {\n    return host.toLowerCase();\n  }\n\n  private clearHostCooldown(host: string): void {\n    this.hostCooldownUntilMs.delete(this.hostKey(host));\n  }\n\n  private markHostFailure(host: string): void {\n    this.hostCooldownUntilMs.set(this.hostKey(host), Date.now() + this.hostFailureCooldownMs);\n  }\n\n  private hostIndex(host: string): number {\n    return this.hosts.findIndex((candidate) => this.hostKey(candidate) === this.hostKey(host));\n  }\n\n  private hostCooldownUntil(host: string): number | undefined {\n    return this.hostCooldownUntilMs.get(this.hostKey(host));\n  }\n\n  private hostState(host: string, nowMs: number): HostCircuitState {\n    const cooldownUntilMs = this.hostCooldownUntil(host);\n    if (cooldownUntilMs === undefined) return 'closed';\n    if (cooldownUntilMs > nowMs) return 'open';\n    return 'half_open';\n  }\n\n  private pushUniqueHost(hosts: string[], host: string): void {\n    if (!hosts.some((candidate) => this.hostKey(candidate) === this.hostKey(host))) {\n      hosts.push(host);\n    }\n  }\n\n  private hostCandidates(): string[] {\n    const nowMs = Date.now();\n    const activeHost = this.getActiveHost();\n    const activeHostIndex = this.hostIndex(activeHost);\n    const states = new Map<string, HostCircuitState>();\n    for (const host of this.hosts) {\n      states.set(host, this.hostState(host, nowMs));\n    }\n\n    const closedHosts = this.hosts.filter((host) => states.get(host) === 'closed');\n    const halfOpenHosts = this.hosts.filter((host) => states.get(host) === 'half_open');\n    const openHosts = this.hosts.filter((host) => states.get(host) === 'open');\n\n    const candidates: string[] = [];\n\n    // If a more-preferred host has cooled down, probe it first (half-open).\n    const preferredProbeHost = halfOpenHosts.find((host) => {\n      const index = this.hostIndex(host);\n      return index >= 0 && index < activeHostIndex;\n    });\n    if (preferredProbeHost) {\n      this.pushUniqueHost(candidates, preferredProbeHost);\n    }\n\n    if (states.get(activeHost) !== 'open') {\n      this.pushUniqueHost(candidates, activeHost);\n    }\n\n    for (const host of closedHosts) {\n      this.pushUniqueHost(candidates, host);\n    }\n\n    for (const host of halfOpenHosts) {\n      this.pushUniqueHost(candidates, host);\n    }\n\n    if (candidates.length > 0) return candidates;\n\n    // All hosts are cooling down: probe the one closest to leaving cooldown first.\n    const coolingHostsByExpiry = [...openHosts].sort((a, b) => {\n      const aCooldownUntil = this.hostCooldownUntil(a) ?? Number.MAX_SAFE_INTEGER;\n      const bCooldownUntil = this.hostCooldownUntil(b) ?? Number.MAX_SAFE_INTEGER;\n      if (aCooldownUntil !== bCooldownUntil) {\n        return aCooldownUntil - bCooldownUntil;\n      }\n      return this.hostIndex(a) - this.hostIndex(b);\n    });\n    return coolingHostsByExpiry.length > 0 ? coolingHostsByExpiry : [...this.hosts];\n  }\n\n  private setActiveHost(host: string): void {\n    const index = this.hostIndex(host);\n    if (index >= 0) {\n      this.activeHostIndex = index;\n    }\n  }\n\n  getActiveHost(): string {\n    return this.hosts[this.activeHostIndex] ?? this.hosts[0]!;\n  }\n\n  getConfiguredHosts(): readonly string[] {\n    return [...this.hosts];\n  }\n\n  private async fetch<T>(\n    path: string,\n    init?: RequestInit,\n    validator?: ZodType<T>,\n    requestOptions?: LmxRequestOptions,\n  ): Promise<T> {\n    const timeoutMs = Math.max(1000, requestOptions?.timeoutMs ?? this.timeoutMs);\n    const maxRetries = Math.max(0, requestOptions?.maxRetries ?? this.maxRetries);\n    const attempts = maxRetries + 1;\n    const headers = { ...this.headers, ...init?.headers };\n    const hostFailures: HostAttemptFailure[] = [];\n\n    for (const host of this.hostCandidates()) {\n      const url = `http://${host}:${this.port}${path}`;\n      debug(`LMX ${init?.method ?? 'GET'} ${url}`);\n      let hostFailure: string | null = null;\n\n      for (let attempt = 0; attempt < attempts; attempt += 1) {\n        let response: Response;\n        const timeoutSignal = AbortSignal.timeout(timeoutMs);\n        const signal = init?.signal ? AbortSignal.any([init.signal, timeoutSignal]) : timeoutSignal;\n        try {\n          response = await fetch(url, {\n            ...init,\n            headers,\n            signal,\n          });\n        } catch (err) {\n          const method = (init?.method ?? 'GET').toUpperCase();\n          const idempotentMethod = method === 'GET' || method === 'HEAD' || method === 'OPTIONS';\n          const timedOut = isAbortFailure(err);\n          const retryable = timedOut ? idempotentMethod : true;\n          if (retryable && attempt < attempts - 1) {\n            await sleep(this.retryDelayMs(attempt));\n            continue;\n          }\n          const message = timedOut\n            ? `request timed out after ${Math.round(timeoutMs / 1000)}s`\n            : errorMessage(err);\n          hostFailure = message;\n          break;\n        }\n\n        if (!response.ok) {\n          const body = await response.text().catch(() => '');\n          const code = mapHttpErrorCode(response.status);\n          const message = parseApiErrorMessage(body, response.statusText);\n          if (RETRYABLE_HTTP_STATUS.has(response.status) && attempt < attempts - 1) {\n            await sleep(this.retryDelayMs(attempt));\n            continue;\n          }\n          if (RETRYABLE_HTTP_STATUS.has(response.status)) {\n            hostFailure = `HTTP ${response.status} ${message}`;\n            break;\n          }\n          throw new LmxApiError(response.status, code, `${host}: ${message}`);\n        }\n\n        const data: unknown = await response.json();\n        this.clearHostCooldown(host);\n        this.setActiveHost(host);\n        if (validator) return validator.parse(data);\n        return data as T;\n      }\n\n      if (hostFailure) {\n        this.markHostFailure(host);\n        hostFailures.push({ host, detail: hostFailure });\n      }\n    }\n\n    if (hostFailures.length > 0) {\n      const summary = hostFailures.map((entry) => `${entry.host} -> ${entry.detail}`).join('; ');\n      throw new LmxApiError(\n        0,\n        'connection_error',\n        `LMX request failed across ${hostFailures.length} host${hostFailures.length === 1 ? '' : 's'}: ${summary}`,\n      );\n    }\n    throw new LmxApiError(0, 'connection_error', 'request failed after retries');\n  }\n\n  async health(opts?: LmxRequestOptions): Promise<LmxHealthResponse> {\n    return this.fetch<LmxHealthResponse>('/healthz', undefined, undefined, opts);\n  }\n\n  async status(opts?: LmxRequestOptions): Promise<LmxStatusResponse> {\n    const raw = await this.fetch<RawAdminStatusResponse>('/admin/status', undefined, undefined, opts);\n    return {\n      status: 'ok',\n      version: raw.version,\n      uptime_seconds: raw.uptime_seconds,\n      models: raw.models.map((id) => ({\n        model_id: id,\n        status: 'loaded' as const,\n      })),\n      memory: raw.memory\n        ? {\n            used_bytes: raw.memory.used_gb * GB_TO_BYTES,\n            total_bytes: raw.memory.total_gb * GB_TO_BYTES,\n            threshold: raw.memory.threshold_percent,\n          }\n        : undefined,\n    };\n  }\n\n  async models(opts?: LmxRequestOptions): Promise<LmxModelsResponse> {\n    const raw = await this.fetch<RawAdminModelsResponse>('/admin/models', undefined, undefined, opts);\n    return {\n      models: raw.loaded.map((m) => ({\n        model_id: m.id,\n        status: 'loaded' as const,\n        memory_bytes: m.memory_gb ? m.memory_gb * GB_TO_BYTES : undefined,\n        context_length: m.context_length ?? lookupContextLimit(m.id),\n        loaded_at: m.loaded_at ? new Date(m.loaded_at * 1000).toISOString() : undefined,\n        request_count: m.request_count,\n      })),\n    };\n  }\n\n  private normalizeLoadResponse(raw: RawAdminLoadResponse): LmxLoadResponse {\n    const status = raw.status === 'download_required' || raw.status === 'downloading'\n      ? raw.status\n      : 'loaded';\n    return {\n      model_id: raw.model_id,\n      status,\n      memory_bytes: raw.memory_after_load_gb\n        ? raw.memory_after_load_gb * GB_TO_BYTES\n        : undefined,\n      load_time_seconds: raw.time_to_load_ms\n        ? raw.time_to_load_ms / 1000\n        : undefined,\n      estimated_size_bytes: raw.estimated_size_bytes,\n      estimated_size_human: raw.estimated_size_human,\n      confirmation_token: raw.confirmation_token,\n      download_id: raw.download_id,\n      message: raw.message,\n      confirm_url: raw.confirm_url,\n      progress_url: raw.progress_url,\n    };\n  }\n\n  async loadModel(\n    modelId: string,\n    opts?: LmxLoadModelOptions,\n  ): Promise<LmxLoadResponse> {\n    const raw = await this.fetch<RawAdminLoadResponse>('/admin/models/load', {\n      method: 'POST',\n      body: JSON.stringify({\n        model_id: modelId,\n        backend: opts?.backend,\n        auto_download: opts?.autoDownload,\n        performance_overrides: opts?.performanceOverrides,\n        keep_alive_sec: opts?.keepAliveSec,\n        allow_unsupported_runtime: opts?.allowUnsupportedRuntime,\n      }),\n    }, undefined, {\n      timeoutMs: opts?.timeoutMs,\n      maxRetries: opts?.maxRetries,\n    });\n    return this.normalizeLoadResponse(raw);\n  }\n\n  async confirmLoad(\n    confirmationToken: string,\n    opts?: LmxRequestOptions,\n  ): Promise<LmxLoadResponse> {\n    const raw = await this.fetch<RawAdminLoadResponse>(\n      '/admin/models/load/confirm',\n      {\n        method: 'POST',\n        body: JSON.stringify({\n          confirmation_token: confirmationToken,\n        }),\n      },\n      undefined,\n      opts,\n    );\n    return this.normalizeLoadResponse(raw);\n  }\n\n  async unloadModel(\n    modelId: string,\n    opts?: { timeoutMs?: number; maxRetries?: number },\n  ): Promise<LmxUnloadResponse> {\n    const raw = await this.fetch<RawAdminUnloadResponse>('/admin/models/unload', {\n      method: 'POST',\n      body: JSON.stringify({ model_id: modelId }),\n    }, undefined, {\n      timeoutMs: opts?.timeoutMs,\n      maxRetries: opts?.maxRetries,\n    });\n    return {\n      model_id: raw.model_id,\n      status: 'unloaded',\n      freed_bytes: raw.memory_freed_gb\n        ? raw.memory_freed_gb * GB_TO_BYTES\n        : undefined,\n    };\n  }\n\n  async available(opts?: LmxRequestOptions): Promise<LmxAvailableModel[]> {\n    return this.fetch<LmxAvailableModel[]>('/admin/models/available', undefined, undefined, opts);\n  }\n\n  async presets(opts?: LmxRequestOptions): Promise<LmxPresetsResponse> {\n    return this.fetch<LmxPresetsResponse>('/admin/presets', undefined, undefined, opts);\n  }\n\n  async presetDetail(name: string, requestOptions?: LmxRequestOptions): Promise<LmxPresetDetailResponse> {\n    return this.fetch<LmxPresetDetailResponse>(\n      `/admin/presets/${encodeURIComponent(name)}`,\n      undefined,\n      undefined,\n      requestOptions,\n    );\n  }\n\n  async reloadPresets(requestOptions?: LmxRequestOptions): Promise<LmxPresetReloadResult> {\n    return this.fetch<LmxPresetReloadResult>('/admin/presets/reload', { method: 'POST' }, undefined, requestOptions);\n  }\n\n  async stack(opts?: LmxRequestOptions): Promise<LmxStackResponse> {\n    return this.fetch<LmxStackResponse>('/admin/stack', undefined, undefined, opts);\n  }\n\n  async memory(opts?: LmxRequestOptions): Promise<LmxMemoryResponse> {\n    return this.fetch<LmxMemoryResponse>('/admin/memory', undefined, undefined, opts);\n  }\n\n  async downloadModel(\n    repoId: string,\n    opts?: { revision?: string; allowPatterns?: string[]; ignorePatterns?: string[] },\n  ): Promise<LmxDownloadResponse> {\n    const raw = await this.fetch<RawDownloadResponse>('/admin/models/download', {\n      method: 'POST',\n      body: JSON.stringify({\n        repo_id: repoId,\n        revision: opts?.revision,\n        allow_patterns: opts?.allowPatterns,\n        ignore_patterns: opts?.ignorePatterns,\n      }),\n    });\n    return {\n      downloadId: raw.download_id,\n      repoId: raw.repo_id,\n      estimatedSizeBytes: raw.estimated_size_bytes,\n      status: raw.status,\n    };\n  }\n\n  async downloadProgress(downloadId: string): Promise<LmxDownloadProgress> {\n    const raw = await this.fetch<RawDownloadProgressResponse>(\n      `/admin/models/download/${encodeURIComponent(downloadId)}/progress`,\n    );\n    return {\n      downloadId: raw.download_id,\n      repoId: raw.repo_id,\n      status: raw.status as LmxDownloadProgress['status'],\n      progressPercent: raw.progress_percent,\n      downloadedBytes: raw.downloaded_bytes,\n      totalBytes: raw.total_bytes,\n      filesCompleted: raw.files_completed,\n      filesTotal: raw.files_total,\n      error: raw.error,\n    };\n  }\n\n  async deleteModel(modelId: string): Promise<LmxDeleteResponse> {\n    const raw = await this.fetch<RawDeleteResponse>(\n      `/admin/models/${encodeURIComponent(modelId)}`,\n      { method: 'DELETE' },\n    );\n    return {\n      modelId: raw.model_id,\n      freedBytes: raw.freed_bytes,\n    };\n  }\n\n  async modelPerformance(modelId: string): Promise<LmxModelPerformance> {\n    const raw = await this.fetch<RawModelPerformanceResponse>(\n      `/admin/models/${encodeURIComponent(modelId)}/performance`,\n    );\n    return {\n      modelId: raw.model_id,\n      backendType: raw.backend_type,\n      loadedAt: new Date(raw.loaded_at * 1000).toISOString(),\n      requestCount: raw.request_count,\n      lastUsedAt: raw.last_used_at ? new Date(raw.last_used_at * 1000).toISOString() : undefined,\n      memoryGb: raw.memory_gb,\n      contextLength: raw.context_length,\n      useBatching: raw.use_batching,\n      performanceOverrides: raw.performance ?? {},\n      globalDefaults: raw.global_defaults ?? {},\n    };\n  }\n\n  async probeModel(opts: LmxProbeModelOptions, requestOptions?: LmxRequestOptions): Promise<LmxProbeModelResult> {\n    return this.fetch<LmxProbeModelResult>(\n      '/admin/models/probe',\n      {\n        method: 'POST',\n        body: JSON.stringify({\n          model_id: opts.modelId,\n          timeout_sec: opts.timeoutSec,\n          allow_unsupported_runtime: opts.allowUnsupportedRuntime,\n        }),\n      },\n      undefined,\n      requestOptions,\n    );\n  }\n\n  async modelCompatibility(\n    opts: LmxModelCompatibilityOptions = {},\n    requestOptions?: LmxRequestOptions,\n  ): Promise<LmxModelCompatibilityResult> {\n    return this.fetch<LmxModelCompatibilityResult>(\n      `/admin/models/compatibility${buildQueryString({\n        model_id: opts.modelId,\n        backend: opts.backend,\n        outcome: opts.outcome,\n        since_ts: opts.sinceTs,\n        limit: opts.limit,\n        include_summary: opts.includeSummary,\n      })}`,\n      undefined,\n      undefined,\n      requestOptions,\n    );\n  }\n\n  async autotuneModel(\n    opts: LmxAutotuneModelOptions,\n    requestOptions?: LmxRequestOptions,\n  ): Promise<LmxAutotuneModelResult> {\n    return this.fetch<LmxAutotuneModelResult>(\n      '/admin/models/autotune',\n      {\n        method: 'POST',\n        body: JSON.stringify({\n          model_id: opts.modelId,\n          prompt: opts.prompt,\n          max_tokens: opts.maxTokens,\n          temperature: opts.temperature,\n          runs: opts.runs,\n          profiles: opts.profiles,\n          allow_unsupported_runtime: opts.allowUnsupportedRuntime,\n        }),\n      },\n      undefined,\n      requestOptions,\n    );\n  }\n\n  async autotuneRecord(\n    modelId: string,\n    opts?: LmxAutotuneRecordOptions,\n    requestOptions?: LmxRequestOptions,\n  ): Promise<LmxAutotuneRecordResult> {\n    return this.fetch<LmxAutotuneRecordResult>(\n      `/admin/models/${encodeURIComponent(modelId)}/autotune${buildQueryString({\n        backend: opts?.backend,\n        backend_version: opts?.backendVersion,\n      })}`,\n      undefined,\n      undefined,\n      requestOptions,\n    );\n  }\n\n  async metricsJson(opts?: LmxRequestOptions): Promise<LmxMetricsSummary> {\n    return this.fetch<LmxMetricsSummary>('/admin/metrics/json', undefined, undefined, opts);\n  }\n\n  async reloadConfig(opts?: LmxRequestOptions): Promise<LmxConfigReloadResult> {\n    return this.fetch<LmxConfigReloadResult>('/admin/config/reload', { method: 'POST' }, undefined, opts);\n  }\n\n  async quantizeStart(\n    request: LmxQuantizeRequest,\n    opts?: LmxRequestOptions,\n  ): Promise<LmxQuantizeStartResult> {\n    return this.fetch<LmxQuantizeStartResult>(\n      '/admin/quantize',\n      {\n        method: 'POST',\n        body: JSON.stringify({\n          source_model: request.sourceModel,\n          output_path: request.outputPath,\n          bits: request.bits,\n          group_size: request.groupSize,\n          mode: request.mode,\n        }),\n      },\n      undefined,\n      opts,\n    );\n  }\n\n  async quantizeStatus(jobId: string, opts?: LmxRequestOptions): Promise<LmxQuantizeJobResult> {\n    return this.fetch<LmxQuantizeJobResult>(\n      `/admin/quantize/${encodeURIComponent(jobId)}`,\n      undefined,\n      undefined,\n      opts,\n    );\n  }\n\n  async quantizeJobs(opts?: LmxRequestOptions): Promise<LmxQuantizeJobsResult> {\n    return this.fetch<LmxQuantizeJobsResult>('/admin/quantize', undefined, undefined, opts);\n  }\n\n  async predictorStats(opts?: LmxRequestOptions): Promise<LmxPredictorStats> {\n    return this.fetch<LmxPredictorStats>('/admin/predictor', undefined, undefined, opts);\n  }\n\n  async helpersHealth(opts?: LmxRequestOptions): Promise<LmxHelpersHealth> {\n    return this.fetch<LmxHelpersHealth>('/admin/helpers', undefined, undefined, opts);\n  }\n\n  async listSessions(\n    opts: LmxSessionListOptions = {},\n    requestOptions?: LmxRequestOptions,\n  ): Promise<LmxSessionListResult> {\n    return this.fetch<LmxSessionListResult>(\n      `/admin/sessions${buildQueryString({\n        limit: opts.limit,\n        offset: opts.offset,\n        model: opts.model,\n        tag: opts.tag,\n        since: opts.since,\n      })}`,\n      undefined,\n      undefined,\n      requestOptions,\n    );\n  }\n\n  async searchSessions(\n    opts: LmxSessionSearchOptions,\n    requestOptions?: LmxRequestOptions,\n  ): Promise<LmxSessionSummary[]> {\n    return this.fetch<LmxSessionSummary[]>(\n      `/admin/sessions/search${buildQueryString({\n        q: opts.query,\n        limit: opts.limit,\n      })}`,\n      undefined,\n      undefined,\n      requestOptions,\n    );\n  }\n\n  async getSession(sessionId: string, opts?: LmxRequestOptions): Promise<LmxSessionFull> {\n    return this.fetch<LmxSessionFull>(\n      `/admin/sessions/${encodeURIComponent(sessionId)}`,\n      undefined,\n      undefined,\n      opts,\n    );\n  }\n\n  async deleteSession(sessionId: string, opts?: LmxRequestOptions): Promise<LmxSessionDeleteResult> {\n    return this.fetch<LmxSessionDeleteResult>(\n      `/admin/sessions/${encodeURIComponent(sessionId)}`,\n      { method: 'DELETE' },\n      undefined,\n      opts,\n    );\n  }\n\n  async createEmbeddings(\n    request: LmxEmbeddingsRequest,\n    opts?: LmxRequestOptions,\n  ): Promise<LmxEmbeddingsResponse> {\n    return this.fetch<LmxEmbeddingsResponse>(\n      '/v1/embeddings',\n      {\n        method: 'POST',\n        body: JSON.stringify({\n          input: request.input,\n          model: request.model,\n          encoding_format: request.encodingFormat,\n        }),\n      },\n      undefined,\n      opts,\n    );\n  }\n\n  async rerankDocuments(\n    request: LmxRerankRequest,\n    opts?: LmxRequestOptions,\n  ): Promise<LmxRerankResponse> {\n    return this.fetch<LmxRerankResponse>(\n      '/v1/rerank',\n      {\n        method: 'POST',\n        body: JSON.stringify({\n          model: request.model,\n          query: request.query,\n          documents: request.documents,\n          top_n: request.topN,\n        }),\n      },\n      undefined,\n      opts,\n    );\n  }\n\n  async runBenchmarkAndPersist(\n    request: LmxBenchmarkPersistRequest,\n    opts?: LmxRequestOptions,\n  ): Promise<LmxBenchmarkPersistResult> {\n    return this.fetch<LmxBenchmarkPersistResult>(\n      '/admin/benchmark/run',\n      {\n        method: 'POST',\n        body: JSON.stringify({\n          model_id: request.modelId,\n          prompt: request.prompt,\n          num_output_tokens: request.numOutputTokens,\n          runs: request.runs,\n          temperature: request.temperature,\n          warmup_runs: request.warmupRuns,\n        }),\n      },\n      undefined,\n      {\n        timeoutMs: opts?.timeoutMs ?? 180_000,\n        maxRetries: opts?.maxRetries ?? 0,\n      },\n    );\n  }\n\n  async listBenchmarkResults(\n    opts: LmxBenchmarkResultsOptions = {},\n    requestOptions?: LmxRequestOptions,\n  ): Promise<LmxBenchmarkPersistResult[]> {\n    return this.fetch<LmxBenchmarkPersistResult[]>(\n      `/admin/benchmark/results${buildQueryString({\n        model_id: opts.modelId,\n      })}`,\n      undefined,\n      undefined,\n      requestOptions,\n    );\n  }\n\n  async anthropicMessages(\n    request: LmxAnthropicMessagesRequest,\n    opts?: LmxRequestOptions,\n  ): Promise<LmxAnthropicMessagesResponse> {\n    return this.fetch<LmxAnthropicMessagesResponse>(\n      '/v1/messages',\n      {\n        method: 'POST',\n        body: JSON.stringify({\n          model: request.model,\n          messages: request.messages,\n          max_tokens: request.maxTokens,\n          system: request.system,\n          temperature: request.temperature,\n          top_p: request.topP,\n          stream: request.stream,\n          stop_sequences: request.stopSequences,\n        }),\n      },\n      undefined,\n      opts,\n    );\n  }\n\n  async agentRuns(\n    opts: { limit?: number; offset?: number; status?: string } = {},\n    requestOptions?: LmxRequestOptions,\n  ): Promise<LmxAgentRunListResult> {\n    return this.fetch<LmxAgentRunListResult>(\n      `/v1/agents/runs${buildQueryString({\n        limit: opts.limit,\n        offset: opts.offset,\n        status: opts.status,\n      })}`,\n      undefined,\n      undefined,\n      requestOptions,\n    );\n  }\n\n  async createAgentRun(\n    payload: LmxAgentRunCreatePayload,\n    requestOptions?: LmxRequestOptions & { idempotencyKey?: string },\n  ): Promise<LmxAgentRunResult> {\n    const idempotencyKey = requestOptions?.idempotencyKey?.trim();\n    const headers = idempotencyKey ? { 'Idempotency-Key': idempotencyKey } : undefined;\n    const opts: LmxRequestOptions | undefined = requestOptions\n      ? { timeoutMs: requestOptions.timeoutMs, maxRetries: requestOptions.maxRetries }\n      : undefined;\n    return this.fetch<LmxAgentRunResult>(\n      '/v1/agents/runs',\n      {\n        method: 'POST',\n        headers,\n        body: JSON.stringify({\n          request: payload.request,\n          agent: payload.agent,\n          input: payload.input,\n          metadata: payload.metadata,\n        }),\n      },\n      undefined,\n      opts,\n    );\n  }\n\n  async agentRun(runId: string, opts?: LmxRequestOptions): Promise<LmxAgentRunResult> {\n    return this.fetch<LmxAgentRunResult>(\n      `/v1/agents/runs/${encodeURIComponent(runId)}`,\n      undefined,\n      undefined,\n      opts,\n    );\n  }\n\n  async cancelAgentRun(runId: string, opts?: LmxRequestOptions): Promise<LmxAgentRunResult> {\n    return this.fetch<LmxAgentRunResult>(\n      `/v1/agents/runs/${encodeURIComponent(runId)}/cancel`,\n      { method: 'POST' },\n      undefined,\n      opts,\n    );\n  }\n\n  async skillsList(\n    opts: { latestOnly?: boolean } = {},\n    requestOptions?: LmxRequestOptions,\n  ): Promise<LmxSkillListResult> {\n    return this.fetch<LmxSkillListResult>(\n      `/v1/skills${buildQueryString({\n        latest_only: opts.latestOnly,\n      })}`,\n      undefined,\n      undefined,\n      requestOptions,\n    );\n  }\n\n  async skillDetail(skillName: string, opts?: LmxRequestOptions): Promise<LmxSkillSummary> {\n    return this.fetch<LmxSkillSummary>(\n      `/v1/skills/${encodeURIComponent(skillName)}`,\n      undefined,\n      undefined,\n      opts,\n    );\n  }\n\n  async skillMcpTools(opts?: LmxRequestOptions): Promise<LmxSkillMcpToolsResult> {\n    return this.fetch<LmxSkillMcpToolsResult>('/v1/skills/mcp/tools', undefined, undefined, opts);\n  }\n\n  async skillExecute(\n    skillName: string,\n    request: LmxSkillExecuteRequest,\n    opts?: LmxRequestOptions,\n  ): Promise<LmxSkillExecuteResponse> {\n    return this.fetch<LmxSkillExecuteResponse>(\n      `/v1/skills/${encodeURIComponent(skillName)}/execute`,\n      {\n        method: 'POST',\n        body: JSON.stringify({\n          arguments: request.arguments,\n          approved: request.approved,\n          timeout_sec: request.timeoutSec,\n        }),\n      },\n      undefined,\n      opts,\n    );\n  }\n\n  async skillMcpCall(\n    request: LmxSkillMcpCallRequest,\n    opts?: LmxRequestOptions,\n  ): Promise<LmxSkillMcpCallResponse> {\n    return this.fetch<LmxSkillMcpCallResponse>(\n      '/v1/skills/mcp/call',\n      {\n        method: 'POST',\n        body: JSON.stringify({\n          name: request.name,\n          arguments: request.arguments,\n          approved: request.approved,\n        }),\n      },\n      undefined,\n      opts,\n    );\n  }\n\n  async skillOpenClawInvoke(\n    request: LmxSkillOpenClawInvokeRequest,\n    opts?: LmxRequestOptions,\n  ): Promise<LmxSkillOpenClawInvokeResponse> {\n    return this.fetch<LmxSkillOpenClawInvokeResponse>(\n      '/v1/skills/openclaw/invoke',\n      {\n        method: 'POST',\n        body: JSON.stringify({\n          name: request.name,\n          tool: request.tool,\n          tool_name: request.toolName,\n          arguments: request.arguments,\n          input: request.input,\n          params: request.params,\n          approved: request.approved,\n          timeout_sec: request.timeoutSec,\n        }),\n      },\n      undefined,\n      opts,\n    );\n  }\n\n  async ragCollections(opts?: LmxRequestOptions): Promise<LmxRagCollectionsResult> {\n    return this.fetch<LmxRagCollectionsResult>('/v1/rag/collections', undefined, undefined, opts);\n  }\n\n  async ragDeleteCollection(collection: string, opts?: LmxRequestOptions): Promise<Record<string, never>> {\n    return this.fetch<Record<string, never>>(\n      `/v1/rag/collections/${encodeURIComponent(collection)}`,\n      { method: 'DELETE' },\n      undefined,\n      opts,\n    );\n  }\n\n  async ragQuery(\n    request: LmxRagQueryRequest,\n    opts?: LmxRequestOptions,\n  ): Promise<LmxRagQueryResult> {\n    return this.fetch<LmxRagQueryResult>(\n      '/v1/rag/query',\n      {\n        method: 'POST',\n        body: JSON.stringify({\n          collection: request.collection,\n          query: request.query,\n          top_k: request.topK,\n          min_score: request.minScore,\n          model: request.model,\n          include_embeddings: request.includeEmbeddings,\n          search_mode: request.searchMode,\n          rerank: request.rerank,\n          rerank_top_k: request.rerankTopK,\n        }),\n      },\n      undefined,\n      opts,\n    );\n  }\n\n  async ragIngest(\n    request: LmxRagIngestRequest,\n    opts?: LmxRequestOptions,\n  ): Promise<LmxRagIngestResult> {\n    return this.fetch<LmxRagIngestResult>(\n      '/v1/rag/ingest',\n      {\n        method: 'POST',\n        body: JSON.stringify({\n          collection: request.collection,\n          documents: request.documents,\n          metadata: request.metadata,\n          chunk_size: request.chunkSize,\n          chunk_overlap: request.chunkOverlap,\n          chunking: request.chunking,\n          model: request.model,\n        }),\n      },\n      undefined,\n      opts,\n    );\n  }\n\n  async ragContext(\n    request: LmxRagContextRequest,\n    opts?: LmxRequestOptions,\n  ): Promise<LmxRagContextResult> {\n    return this.fetch<LmxRagContextResult>(\n      '/v1/rag/context',\n      {\n        method: 'POST',\n        body: JSON.stringify({\n          query: request.query,\n          collections: request.collections,\n          top_k_per_collection: request.topKPerCollection,\n          min_score: request.minScore,\n          max_context_tokens: request.maxContextTokens,\n          model: request.model,\n          rerank: request.rerank,\n        }),\n      },\n      undefined,\n      opts,\n    );\n  }\n\n  async benchmarkModel(\n    modelId: string,\n    opts?: { prompt?: string; maxTokens?: number; runs?: number; temperature?: number },\n  ): Promise<LmxBenchmarkResult> {\n    const raw = await this.fetch<RawBenchmarkResponse>(\n      '/admin/benchmark',\n      {\n        method: 'POST',\n        body: JSON.stringify({\n          model_id: modelId,\n          prompt: opts?.prompt ?? 'Hello! Please write a short paragraph about the nature of time.',\n          max_tokens: opts?.maxTokens ?? 128,\n          runs: opts?.runs ?? 3,\n          temperature: opts?.temperature ?? 0.0,\n        }),\n      },\n      undefined,\n      {\n        // Benchmarks can legitimately run much longer than normal admin requests.\n        timeoutMs: 180_000,\n        maxRetries: 0,\n      },\n    );\n    return {\n      modelId: raw.model_id,\n      backendType: raw.backend_type,\n      prompt: raw.prompt,\n      maxTokens: raw.max_tokens,\n      runs: raw.runs,\n      results: raw.results.map((r) => ({\n        run: r.run,\n        tokensGenerated: r.tokens_generated,\n        timeToFirstTokenMs: r.time_to_first_token_ms,\n        totalTimeMs: r.total_time_ms,\n        tokensPerSecond: r.tokens_per_second,\n      })),\n      avgTokensPerSecond: raw.avg_tokens_per_second,\n      avgTimeToFirstTokenMs: raw.avg_time_to_first_token_ms,\n      avgTotalTimeMs: raw.avg_total_time_ms,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/lmx/connection.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":128,"column":25,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":128,"endColumn":44},{"ruleId":"@typescript-eslint/require-await","severity":1,"message":"Async method 'return' has no 'await' expression.","line":137,"column":7,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":137,"endColumn":21,"suggestions":[{"messageId":"removeAsync","fix":{"range":[3577,3583],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'raw' may use Object's default stringification format ('[object Object]') when stringified.","line":147,"column":30,"nodeType":"Identifier","messageId":"baseToString","endLine":147,"endColumn":33},{"ruleId":"@typescript-eslint/require-await","severity":1,"message":"Async function 'streamLmxChatWebSocket' has no 'await' expression.","line":349,"column":8,"nodeType":"FunctionDeclaration","messageId":"missingAwait","endLine":349,"endColumn":45,"suggestions":[{"messageId":"removeAsync","fix":{"range":[9365,9532],"text":"function streamLmxChatWebSocket(\n  host: string,\n  port: number,\n  request: LmxChatStreamRequest,\n  options?: LmxWsStreamOptions\n): AsyncIterable<Chunk>"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, value is `never`.","line":524,"column":86,"nodeType":"Identifier","messageId":"never","endLine":524,"endColumn":95}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import WebSocket, { type RawData } from 'ws';\nimport type OpenAI from 'openai';\n\nexport type LmxConnectionState = 'connected' | 'degraded' | 'disconnected';\n\nexport interface LmxConnectionResult {\n  state: LmxConnectionState;\n  latencyMs: number;\n  modelsLoaded?: number;\n  reason?: string;\n}\n\ninterface ProbeOptions {\n  timeoutMs?: number;\n  adminKey?: string;\n}\n\ninterface LmxWsStreamOptions {\n  adminKey?: string;\n  signal?: AbortSignal;\n  handshakeTimeoutMs?: number;\n  idleTimeoutMs?: number;\n}\n\nexport interface LmxChatStreamRequest {\n  model: string;\n  messages: unknown[];\n  temperature?: number | null;\n  max_tokens?: number | null;\n  top_p?: number | null;\n  stop?: string | string[] | null;\n  tools?: unknown;\n  tool_choice?: unknown;\n  response_format?: unknown;\n  frequency_penalty?: number | null;\n  presence_penalty?: number | null;\n  num_ctx?: number | null;\n}\n\ntype Chunk = OpenAI.Chat.Completions.ChatCompletionChunk;\n\nconst DEFAULT_WS_HANDSHAKE_TIMEOUT_MS = 5_000;\nconst DEFAULT_WS_IDLE_TIMEOUT_MS = 30_000;\n\ninterface LmxWsMessage {\n  type?: string;\n  request_id?: string;\n  content?: unknown;\n  model?: unknown;\n  finish_reason?: unknown;\n  usage?: {\n    prompt_tokens?: unknown;\n    completion_tokens?: unknown;\n    total_tokens?: unknown;\n  };\n  tool_call?: {\n    index?: unknown;\n    id?: unknown;\n    name?: unknown;\n    arguments?: unknown;\n  };\n  error?: unknown;\n}\n\nfunction makeAbortError(message: string): Error {\n  const err = new Error(message);\n  err.name = 'AbortError';\n  return err;\n}\n\nexport function isAbortError(err: unknown): boolean {\n  if (!(err instanceof Error)) return false;\n  if (err.name === 'AbortError') return true;\n  const lowered = err.message.toLowerCase();\n  return lowered.includes('aborted') || lowered.includes('cancelled');\n}\n\nfunction coerceNumber(value: unknown, fallback: number): number {\n  if (typeof value === 'number' && Number.isFinite(value)) return value;\n  if (typeof value === 'string') {\n    const parsed = Number(value);\n    if (Number.isFinite(parsed)) return parsed;\n  }\n  return fallback;\n}\n\nclass AsyncChunkQueue implements AsyncIterable<Chunk> {\n  private readonly items: Chunk[] = [];\n  private readonly waiters: Array<{\n    resolve: (value: IteratorResult<Chunk>) => void;\n    reject: (err: Error) => void;\n  }> = [];\n  private done = false;\n  private failure: Error | null = null;\n\n  push(chunk: Chunk): void {\n    if (this.done || this.failure) return;\n    const waiter = this.waiters.shift();\n    if (waiter) {\n      waiter.resolve({ value: chunk, done: false });\n      return;\n    }\n    this.items.push(chunk);\n  }\n\n  finish(): void {\n    if (this.done || this.failure) return;\n    this.done = true;\n    while (this.waiters.length > 0) {\n      const waiter = this.waiters.shift();\n      waiter?.resolve({ value: undefined as unknown as Chunk, done: true });\n    }\n  }\n\n  fail(err: Error): void {\n    if (this.done || this.failure) return;\n    this.failure = err;\n    while (this.waiters.length > 0) {\n      const waiter = this.waiters.shift();\n      waiter?.reject(err);\n    }\n  }\n\n  [Symbol.asyncIterator](): AsyncIterator<Chunk> {\n    return {\n      next: async () => {\n        if (this.items.length > 0) {\n          const value = this.items.shift()!;\n          return { value, done: false };\n        }\n        if (this.failure) throw this.failure;\n        if (this.done) return { value: undefined as unknown as Chunk, done: true };\n        return new Promise<IteratorResult<Chunk>>((resolve, reject) => {\n          this.waiters.push({ resolve, reject });\n        });\n      },\n      return: async () => {\n        this.finish();\n        return { value: undefined as unknown as Chunk, done: true };\n      },\n    };\n  }\n}\n\nfunction parseWsJson(raw: RawData): LmxWsMessage | null {\n  try {\n    return JSON.parse(String(raw)) as LmxWsMessage;\n  } catch {\n    return null;\n  }\n}\n\nfunction makeChunkBase(requestId: string, model: string): Omit<Chunk, 'choices'> {\n  return {\n    id: requestId,\n    object: 'chat.completion.chunk',\n    created: Math.floor(Date.now() / 1000),\n    model,\n  };\n}\n\nfunction toContentChunk(requestId: string, model: string, content: string): Chunk {\n  return {\n    ...makeChunkBase(requestId, model),\n    choices: [\n      {\n        index: 0,\n        delta: { content },\n        finish_reason: null,\n      },\n    ],\n  };\n}\n\nfunction toToolChunk(\n  requestId: string,\n  model: string,\n  toolCall: NonNullable<LmxWsMessage['tool_call']>\n): Chunk {\n  const index = coerceNumber(toolCall.index, 0);\n  const hasId = typeof toolCall.id === 'string' && toolCall.id.length > 0;\n  const hasName = typeof toolCall.name === 'string' && toolCall.name.length > 0;\n  const hasArgs = typeof toolCall.arguments === 'string';\n  const fn: { name?: string; arguments?: string } = {};\n  if (hasName) fn.name = toolCall.name as string;\n  if (hasArgs) fn.arguments = toolCall.arguments as string;\n\n  return {\n    ...makeChunkBase(requestId, model),\n    choices: [\n      {\n        index: 0,\n        delta: {\n          tool_calls: [\n            {\n              index,\n              ...(hasId ? { id: toolCall.id as string, type: 'function' as const } : {}),\n              ...(hasName || hasArgs ? { function: fn } : {}),\n            },\n          ],\n        },\n        finish_reason: null,\n      },\n    ],\n  };\n}\n\nfunction toDoneChunk(\n  requestId: string,\n  model: string,\n  finishReason: 'length' | 'stop' | 'tool_calls' | 'content_filter' | 'function_call' | null,\n  usage?: LmxWsMessage['usage']\n): Chunk {\n  const promptTokens = coerceNumber(usage?.prompt_tokens, 0);\n  const completionTokens = coerceNumber(usage?.completion_tokens, 0);\n  const totalTokens = coerceNumber(usage?.total_tokens, promptTokens + completionTokens);\n  return {\n    ...makeChunkBase(requestId, model),\n    choices: [\n      {\n        index: 0,\n        delta: {},\n        finish_reason: finishReason,\n      },\n    ],\n    usage: {\n      prompt_tokens: promptTokens,\n      completion_tokens: completionTokens,\n      total_tokens: totalTokens,\n    },\n  };\n}\n\nfunction normalizeFinishReason(\n  value: unknown\n): 'length' | 'stop' | 'tool_calls' | 'content_filter' | 'function_call' | null {\n  if (value === null) return null;\n  if (value === 'length' || value === 'tool_calls' || value === 'content_filter' || value === 'function_call') {\n    return value;\n  }\n  return 'stop';\n}\n\nfunction buildSignal(timeoutMs: number, external?: AbortSignal): AbortSignal {\n  if (!external) return AbortSignal.timeout(timeoutMs);\n  return AbortSignal.any([external, AbortSignal.timeout(timeoutMs)]);\n}\n\n/**\n * Probe Opta LMX reachability using the lightweight health endpoints first.\n *\n * Order:\n * 1) /healthz (liveness, unauthenticated)\n * 2) /readyz (readiness + loaded model count)\n * 3) /v1/models (fallback for older servers without /readyz)\n */\nexport async function probeLmxConnection(\n  host: string,\n  port: number,\n  options?: ProbeOptions\n): Promise<LmxConnectionResult> {\n  const timeoutMs = options?.timeoutMs ?? 2000;\n  const base = `http://${host}:${port}`;\n  const started = Date.now();\n\n  // 1) Liveness\n  try {\n    const res = await fetch(`${base}/healthz`, {\n      signal: buildSignal(timeoutMs),\n    });\n    if (!res.ok) {\n      return {\n        state: 'degraded',\n        latencyMs: Date.now() - started,\n        reason: `healthz_http_${res.status}`,\n      };\n    }\n  } catch (err) {\n    return {\n      state: 'disconnected',\n      latencyMs: Date.now() - started,\n      reason: err instanceof Error ? err.message : 'healthz_failed',\n    };\n  }\n\n  // 2) Readiness (best signal for UX status)\n  try {\n    const readyRes = await fetch(`${base}/readyz`, {\n      signal: buildSignal(timeoutMs),\n    });\n    if (readyRes.ok) {\n      const data = (await readyRes.json()) as { models_loaded?: number };\n      return {\n        state: 'connected',\n        latencyMs: Date.now() - started,\n        modelsLoaded: data.models_loaded,\n      };\n    }\n    // No models loaded = alive but not ready\n    if (readyRes.status === 503) {\n      return {\n        state: 'degraded',\n        latencyMs: Date.now() - started,\n        modelsLoaded: 0,\n        reason: 'no_models_loaded',\n      };\n    }\n  } catch {\n    // Ignore and fall back to /v1/models for compatibility.\n  }\n\n  // 3) Fallback for older LMX versions\n  try {\n    const headers: Record<string, string> = {};\n    if (options?.adminKey) headers['X-Admin-Key'] = options.adminKey;\n    const modelsRes = await fetch(`${base}/v1/models`, {\n      signal: buildSignal(timeoutMs),\n      headers,\n    });\n    if (!modelsRes.ok) {\n      return {\n        state: 'degraded',\n        latencyMs: Date.now() - started,\n        reason: `models_http_${modelsRes.status}`,\n      };\n    }\n    const data = (await modelsRes.json()) as { data?: unknown[] };\n    const count = Array.isArray(data.data) ? data.data.length : undefined;\n    return {\n      state: count && count > 0 ? 'connected' : 'degraded',\n      latencyMs: Date.now() - started,\n      modelsLoaded: count,\n    };\n  } catch (err) {\n    return {\n      state: 'degraded',\n      latencyMs: Date.now() - started,\n      reason: err instanceof Error ? err.message : 'models_failed',\n    };\n  }\n}\n\n/**\n * Preferred low-latency transport for daemon-side LMX streaming.\n *\n * Uses /v1/chat/stream (WebSocket) and emits OpenAI-compatible chunks so the\n * existing stream collector can remain provider-agnostic.\n */\nexport async function streamLmxChatWebSocket(\n  host: string,\n  port: number,\n  request: LmxChatStreamRequest,\n  options?: LmxWsStreamOptions\n): Promise<AsyncIterable<Chunk>> {\n  if (options?.signal?.aborted) {\n    throw makeAbortError('LMX stream aborted before start');\n  }\n\n  const queue = new AsyncChunkQueue();\n  const protocol = 'ws';\n  const url = `${protocol}://${host}:${port}/v1/chat/stream`;\n  const headers: Record<string, string> = {};\n  if (options?.adminKey) {\n    headers['X-Admin-Key'] = options.adminKey;\n  }\n  const handshakeTimeoutMs = Math.max(0, options?.handshakeTimeoutMs ?? DEFAULT_WS_HANDSHAKE_TIMEOUT_MS);\n  const idleTimeoutMs = Math.max(0, options?.idleTimeoutMs ?? DEFAULT_WS_IDLE_TIMEOUT_MS);\n\n  const socket = new WebSocket(url, { headers });\n  let requestId: string | null = null;\n  let model = request.model;\n  let completed = false;\n  let cleaned = false;\n  let sawContentChunk = false;\n  let sawToolChunk = false;\n  let handshakeTimer: NodeJS.Timeout | null = null;\n  let idleTimer: NodeJS.Timeout | null = null;\n\n  const closeSocket = () => {\n    if (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING) {\n      socket.once('error', () => {\n        // Suppress ws close races during teardown.\n      });\n      try {\n        socket.close();\n      } catch {\n        // Ignore close races while cleaning up failure/abort paths.\n      }\n    }\n  };\n\n  const clearHandshakeTimer = () => {\n    if (!handshakeTimer) return;\n    clearTimeout(handshakeTimer);\n    handshakeTimer = null;\n  };\n\n  const clearIdleTimer = () => {\n    if (!idleTimer) return;\n    clearTimeout(idleTimer);\n    idleTimer = null;\n  };\n\n  const restartIdleTimer = () => {\n    if (idleTimeoutMs <= 0) return;\n    clearIdleTimer();\n    idleTimer = setTimeout(() => {\n      if (completed) return;\n      fail(new Error(`LMX websocket idle timeout after ${idleTimeoutMs}ms`));\n    }, idleTimeoutMs);\n  };\n\n  const cleanup = () => {\n    if (cleaned) return;\n    cleaned = true;\n    clearHandshakeTimer();\n    clearIdleTimer();\n    socket.removeAllListeners();\n    options?.signal?.removeEventListener('abort', onAbort);\n  };\n\n  const fail = (err: Error) => {\n    cleanup();\n    queue.fail(err);\n    closeSocket();\n  };\n\n  const finish = () => {\n    cleanup();\n    queue.finish();\n    closeSocket();\n  };\n\n  const onAbort = () => {\n    const abortErr = makeAbortError('LMX stream aborted');\n    if (requestId && socket.readyState === WebSocket.OPEN) {\n      socket.send(JSON.stringify({\n        type: 'chat.cancel',\n        request_id: requestId,\n      }));\n    }\n    fail(abortErr);\n  };\n\n  socket.once('open', () => {\n    clearHandshakeTimer();\n    restartIdleTimer();\n    if (options?.signal?.aborted) {\n      onAbort();\n      return;\n    }\n    socket.send(JSON.stringify({\n      type: 'chat.request',\n      stream: true,\n      ...request,\n    }));\n  });\n\n  socket.on('message', (raw: RawData) => {\n    if (completed) return;\n    restartIdleTimer();\n    const data = parseWsJson(raw);\n    if (!data || typeof data.type !== 'string') return;\n    if (typeof data.request_id === 'string' && data.request_id) {\n      requestId = data.request_id;\n    }\n    if (typeof data.model === 'string' && data.model) {\n      model = data.model;\n    }\n\n    if (data.type === 'chat.token') {\n      if (typeof data.content !== 'string' || !data.content) return;\n      sawContentChunk = true;\n      queue.push(toContentChunk(requestId ?? 'chatcmpl-lmx', model, data.content));\n      return;\n    }\n\n    if (data.type === 'chat.tool_call' && data.tool_call) {\n      sawToolChunk = true;\n      queue.push(toToolChunk(requestId ?? 'chatcmpl-lmx', model, data.tool_call));\n      return;\n    }\n\n    if (data.type === 'chat.done' || data.type === 'chat.complete' || data.type === 'chat.completed' || data.type === 'done') {\n      completed = true;\n      const finishReason = normalizeFinishReason(data.finish_reason);\n      queue.push(toDoneChunk(requestId ?? 'chatcmpl-lmx', model, finishReason, data.usage));\n      finish();\n      return;\n    }\n\n    if (data.type === 'chat.error') {\n      completed = true;\n      const message = typeof data.error === 'string' && data.error ? data.error : 'LMX websocket error';\n      fail(new Error(message));\n    }\n  });\n\n  socket.once('error', (err) => {\n    if (completed) return;\n    fail(err instanceof Error ? err : new Error(String(err)));\n  });\n\n  socket.once('close', (code, reasonBuf) => {\n    if (completed) return;\n    if (options?.signal?.aborted) {\n      fail(makeAbortError('LMX stream aborted'));\n      return;\n    }\n\n    // Some LMX builds close cleanly (1000) immediately after final token/tool-call\n    // without emitting an explicit chat.done frame.\n    if (code === 1000 && (sawContentChunk || sawToolChunk)) {\n      completed = true;\n      queue.push(toDoneChunk(\n        requestId ?? 'chatcmpl-lmx',\n        model,\n        sawToolChunk ? 'tool_calls' : 'stop',\n      ));\n      finish();\n      return;\n    }\n\n    const reason = Buffer.isBuffer(reasonBuf) ? reasonBuf.toString('utf-8') : String(reasonBuf ?? '');\n    const details = reason ? ` (code ${code}: ${reason})` : ` (code ${code})`;\n    fail(new Error(`LMX websocket stream closed unexpectedly${details}`));\n  });\n\n  if (handshakeTimeoutMs > 0) {\n    handshakeTimer = setTimeout(() => {\n      if (completed) return;\n      fail(new Error(`LMX websocket handshake timed out after ${handshakeTimeoutMs}ms`));\n    }, handshakeTimeoutMs);\n  }\n  options?.signal?.addEventListener('abort', onAbort, { once: true });\n  return queue;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/lmx/endpoints.ts","messages":[{"ruleId":"@typescript-eslint/return-await","severity":1,"message":"Returning an awaited promise is not allowed in this context.","line":140,"column":10,"nodeType":"AwaitExpression","messageId":"disallowedPromiseAwait","endLine":319,"endColumn":5,"fix":{"range":[3855,3861],"text":""}},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, comparison is always true, since `\"disconnected\" === \"disconnected\"` is true.","line":260,"column":74,"nodeType":"BinaryExpression","messageId":"comparisonBetweenLiteralTypes","endLine":260,"endColumn":106},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, comparison is always true, since `\"disconnected\" === \"disconnected\"` is true.","line":278,"column":54,"nodeType":"BinaryExpression","messageId":"comparisonBetweenLiteralTypes","endLine":278,"endColumn":93}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import type { LmxConnectionState } from './connection.js';\nimport { probeLmxConnection } from './connection.js';\n\nexport interface LmxEndpointConfig {\n  host: string;\n  port: number;\n  adminKey?: string;\n  fallbackHosts?: string[];\n}\n\nexport interface ResolvedLmxEndpoint {\n  host: string;\n  port: number;\n  source: 'primary' | 'fallback';\n  state: LmxConnectionState | 'unknown';\n}\n\ninterface ResolveEndpointOptions {\n  timeoutMs?: number;\n  signal?: AbortSignal;\n  /** Delay before committing to a fallback host when primary is still in flight. */\n  primaryGraceMs?: number;\n}\n\nconst DEFAULT_PROBE_TIMEOUT_MS = 1_500;\nconst ENDPOINT_CACHE_TTL_MS = 30_000;\nconst DEFAULT_PRIMARY_GRACE_MS = 125;\n\ninterface CachedEndpoint {\n  host: string;\n  expiresAt: number;\n}\n\nconst endpointCache = new Map<string, CachedEndpoint>();\n\ninterface ProbeOutcome {\n  host: string;\n  index: number;\n  source: 'primary' | 'fallback';\n  state: LmxConnectionState;\n  completionOrder: number;\n}\n\nfunction normalizeHost(host: string): string {\n  return host.trim();\n}\n\nexport function listCandidateHosts(config: Pick<LmxEndpointConfig, 'host' | 'fallbackHosts'>): string[] {\n  const hosts = [config.host, ...(config.fallbackHosts ?? [])]\n    .map(normalizeHost)\n    .filter((host) => host.length > 0);\n\n  const deduped: string[] = [];\n  const seen = new Set<string>();\n  for (const host of hosts) {\n    const key = host.toLowerCase();\n    if (seen.has(key)) continue;\n    seen.add(key);\n    deduped.push(host);\n  }\n\n  return deduped;\n}\n\nfunction makeCacheKey(port: number, hosts: readonly string[]): string {\n  return `${port}|${hosts.map((host) => host.toLowerCase()).join(',')}`;\n}\n\nfunction cacheEndpoint(key: string, host: string): void {\n  endpointCache.set(key, {\n    host,\n    expiresAt: Date.now() + ENDPOINT_CACHE_TTL_MS,\n  });\n}\n\nexport function clearLmxEndpointCache(): void {\n  endpointCache.clear();\n}\n\nfunction makeAbortError(message: string): Error {\n  const err = new Error(message);\n  err.name = 'AbortError';\n  return err;\n}\n\nfunction selectEarliest(\n  outcomes: Iterable<ProbeOutcome>,\n  predicate: (outcome: ProbeOutcome) => boolean,\n): ProbeOutcome | undefined {\n  let selected: ProbeOutcome | undefined;\n  for (const outcome of outcomes) {\n    if (!predicate(outcome)) continue;\n    if (!selected || outcome.completionOrder < selected.completionOrder) {\n      selected = outcome;\n    }\n  }\n  return selected;\n}\n\nexport async function resolveLmxEndpoint(\n  config: LmxEndpointConfig,\n  options?: ResolveEndpointOptions,\n): Promise<ResolvedLmxEndpoint> {\n  if (options?.signal?.aborted) {\n    throw makeAbortError('LMX endpoint resolution aborted');\n  }\n\n  const candidates = listCandidateHosts(config);\n  const normalizedPrimary = normalizeHost(config.host);\n  const primaryHost = candidates[0] ?? (normalizedPrimary.length > 0 ? normalizedPrimary : 'localhost');\n  const cacheKey = makeCacheKey(config.port, candidates);\n\n  const cached = endpointCache.get(cacheKey);\n  if (cached && cached.expiresAt > Date.now()) {\n    const stillPresent = candidates.some((host) => host.toLowerCase() === cached.host.toLowerCase());\n    if (stillPresent) {\n      return {\n        host: cached.host,\n        port: config.port,\n        source: cached.host.toLowerCase() === primaryHost.toLowerCase() ? 'primary' : 'fallback',\n        state: 'unknown',\n      };\n    }\n  }\n\n  if (candidates.length === 0) {\n    return {\n      host: primaryHost,\n      port: config.port,\n      source: 'primary',\n      state: 'unknown',\n    };\n  }\n\n  const timeoutMs = Math.max(250, options?.timeoutMs ?? DEFAULT_PROBE_TIMEOUT_MS);\n  const primaryGraceMs = Math.max(0, Math.min(timeoutMs, options?.primaryGraceMs ?? DEFAULT_PRIMARY_GRACE_MS));\n  const primaryIndex = candidates.findIndex((host) => host.toLowerCase() === primaryHost.toLowerCase());\n  const signal = options?.signal;\n\n  return await new Promise<ResolvedLmxEndpoint>((resolve, reject) => {\n    let settled = false;\n    let remaining = candidates.length;\n    let completionOrder = 0;\n    const outcomes = new Map<number, ProbeOutcome>();\n    let pendingFallbackConnected: ProbeOutcome | undefined;\n    let fallbackGraceTimer: ReturnType<typeof setTimeout> | undefined;\n\n    const cleanup = () => {\n      if (fallbackGraceTimer) {\n        clearTimeout(fallbackGraceTimer);\n        fallbackGraceTimer = undefined;\n      }\n      signal?.removeEventListener('abort', onAbort);\n    };\n\n    const settle = (endpoint: ResolvedLmxEndpoint) => {\n      if (settled) return;\n      settled = true;\n      cleanup();\n      if (endpoint.state === 'connected' || endpoint.state === 'degraded') {\n        cacheEndpoint(cacheKey, endpoint.host);\n      }\n      resolve(endpoint);\n    };\n\n    const settleUnknownPrimary = () => {\n      settle({\n        host: primaryHost,\n        port: config.port,\n        source: 'primary',\n        state: 'unknown',\n      });\n    };\n\n    const settleOutcome = (outcome: ProbeOutcome) => {\n      settle({\n        host: outcome.host,\n        port: config.port,\n        source: outcome.source,\n        state: outcome.state,\n      });\n    };\n\n    const onAbort = () => {\n      if (settled) return;\n      settled = true;\n      cleanup();\n      reject(makeAbortError('LMX endpoint resolution aborted'));\n    };\n\n    const getPrimaryOutcome = () => (primaryIndex >= 0 ? outcomes.get(primaryIndex) : undefined);\n\n    const finalizeIfAllDone = () => {\n      if (settled || remaining > 0) return;\n\n      const primaryOutcome = getPrimaryOutcome();\n      if (primaryOutcome?.state === 'connected') {\n        settleOutcome(primaryOutcome);\n        return;\n      }\n\n      const fallbackConnected = selectEarliest(\n        outcomes.values(),\n        (outcome) => outcome.source === 'fallback' && outcome.state === 'connected',\n      );\n      if (fallbackConnected) {\n        settleOutcome(fallbackConnected);\n        return;\n      }\n\n      if (primaryOutcome?.state === 'degraded') {\n        settleOutcome(primaryOutcome);\n        return;\n      }\n\n      const fallbackDegraded = selectEarliest(\n        outcomes.values(),\n        (outcome) => outcome.source === 'fallback' && outcome.state === 'degraded',\n      );\n      if (fallbackDegraded) {\n        settleOutcome(fallbackDegraded);\n        return;\n      }\n\n      settleUnknownPrimary();\n    };\n\n    const armFallbackGraceTimer = () => {\n      if (settled || fallbackGraceTimer || !pendingFallbackConnected) return;\n      fallbackGraceTimer = setTimeout(() => {\n        fallbackGraceTimer = undefined;\n        if (settled) return;\n\n        const primaryOutcome = getPrimaryOutcome();\n        if (primaryOutcome?.state === 'connected') {\n          settleOutcome(primaryOutcome);\n          return;\n        }\n\n        if (pendingFallbackConnected) {\n          settleOutcome(pendingFallbackConnected);\n        }\n      }, primaryGraceMs);\n    };\n\n    const handleOutcome = (outcome: ProbeOutcome) => {\n      if (settled) return;\n\n      outcomes.set(outcome.index, outcome);\n      remaining -= 1;\n\n      const primaryOutcome = getPrimaryOutcome();\n\n      if (outcome.source === 'primary') {\n        if (outcome.state === 'connected') {\n          settleOutcome(outcome);\n          return;\n        }\n\n        if (pendingFallbackConnected && (outcome.state === 'degraded' || outcome.state === 'disconnected')) {\n          settleOutcome(pendingFallbackConnected);\n          return;\n        }\n      } else if (outcome.state === 'connected') {\n        if (\n          !pendingFallbackConnected\n          || outcome.completionOrder < pendingFallbackConnected.completionOrder\n        ) {\n          pendingFallbackConnected = outcome;\n        }\n\n        if (primaryOutcome) {\n          if (primaryOutcome.state === 'connected') {\n            settleOutcome(primaryOutcome);\n            return;\n          }\n\n          if (primaryOutcome.state === 'degraded' || primaryOutcome.state === 'disconnected') {\n            settleOutcome(pendingFallbackConnected);\n            return;\n          }\n        } else {\n          armFallbackGraceTimer();\n        }\n      }\n\n      finalizeIfAllDone();\n    };\n\n    signal?.addEventListener('abort', onAbort, { once: true });\n    if (signal?.aborted) {\n      onAbort();\n      return;\n    }\n\n    for (const [index, host] of candidates.entries()) {\n      const source = host.toLowerCase() === primaryHost.toLowerCase() ? 'primary' : 'fallback';\n      void probeLmxConnection(host, config.port, {\n        timeoutMs,\n        adminKey: config.adminKey,\n      }).then((probe) => {\n        handleOutcome({\n          host,\n          index,\n          source,\n          state: probe.state,\n          completionOrder: completionOrder++,\n        });\n      }).catch(() => {\n        handleOutcome({\n          host,\n          index,\n          source,\n          state: 'disconnected',\n          completionOrder: completionOrder++,\n        });\n      });\n    }\n  });\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/lmx/model-catalog.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":79,"column":23,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":79,"endColumn":37}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * model-catalog.ts  User-configurable model groups for the /model picker.\n *\n * A ModelGroup is the single unit of configuration: name, label, color, patterns.\n * Groups are checked in array order; the first group whose patterns match wins.\n * Any model that matches no group falls into the last group if it has empty\n * patterns (treat it as a catch-all), or into an implicit \"Other\" bucket.\n *\n * Users can replace DEFAULT_GROUPS entirely via config.model.groups, or manage\n * groups with /model group commands.\n *\n * Pattern syntax (each string in the patterns array):\n *   \"dolphin\"          plain substring  case-insensitive contains match\n *   \"/deepseek-r1/i\"   regex  string wrapped in //flags parsed as RegExp\n */\n\nexport interface ModelGroup {\n  name: string;\n  label: string;\n  color?: string;\n  /** Plain substrings or \"/regex/flags\" strings. */\n  patterns: string[];\n}\n\n/** Built-in groups  used when the user has not defined custom groups. */\nexport const DEFAULT_GROUPS: ModelGroup[] = [\n  {\n    name: 'jailbroken',\n    label: ' Jailbroken',\n    color: '#f87171',\n    patterns: ['dolphin', 'airoboros', 'manticore', 'samantha', 'abliterat', 'uncensored', 'wizard-vicuna', 'jailbreak'],\n  },\n  {\n    name: 'embedding',\n    label: ' Embedding',\n    color: '#60a5fa',\n    patterns: ['embed', 'bge-', 'bge_', 'e5-', 'all-minilm', 'gte-'],\n  },\n  {\n    name: 'vision',\n    label: ' Vision',\n    color: '#34d399',\n    patterns: ['llava', 'moondream', 'minicpm-v', 'internvl', 'pixtral', 'paligemma', 'cogvlm', 'idefics', '-vl', 'vision'],\n  },\n  {\n    name: 'reasoning',\n    label: ' Reasoning',\n    color: '#a78bfa',\n    patterns: ['deepseek-r1', 'r1-distill', '-r1', 'qwq', 'thinking', 'reasoning', 'o1-', 'o3-'],\n  },\n  {\n    name: 'coding',\n    label: ' Coding',\n    color: '#22d3ee',\n    patterns: ['coder', 'codestral', 'starcoder', 'granite-code', 'devstral', 'wizardcoder', 'codegemma', 'codellama', 'code-llama'],\n  },\n  {\n    name: 'fast',\n    label: ' Fast',\n    color: '#fbbf24',\n    patterns: ['tinyllama', 'smollm', 'orca-mini', 'phi-1.', 'phi-2', 'gemma-2b', 'gemma-2-2b', '-1b', '-2b', '-3b'],\n  },\n  {\n    name: 'chat',\n    label: ' Chat',\n    color: '#94a3b8',\n    patterns: [], // empty = catch-all\n  },\n];\n\n/**\n * Compile a user-facing pattern string into a RegExp.\n *   \"/deepseek-r1/i\"  new RegExp(\"deepseek-r1\", \"i\")\n *   \"dolphin\"         /dolphin/i  (plain substring, case-insensitive)\n */\nexport function compilePattern(pattern: string): RegExp {\n  const regexMatch = /^\\/(.+)\\/([gimsuy]*)$/.exec(pattern);\n  if (regexMatch) {\n    return new RegExp(regexMatch[1]!, regexMatch[2] || 'i');\n  }\n  return new RegExp(pattern.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'i');\n}\n\n/**\n * Returns true if modelId matches any pattern in the group.\n * A group with empty patterns always matches (catch-all).\n */\nexport function groupMatches(modelId: string, group: ModelGroup): boolean {\n  if (group.patterns.length === 0) return true;\n  return group.patterns.some(p => compilePattern(p).test(modelId));\n}\n\n/**\n * Find the first matching group for a model ID.\n * Returns the last group if it has empty patterns (catch-all) or null if nothing matches.\n */\nexport function classifyModel(modelId: string, groups: ModelGroup[]): ModelGroup | null {\n  for (const group of groups) {\n    if (groupMatches(modelId, group)) return group;\n  }\n  return null;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/lmx/model-lifecycle.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/lmx/watchdog.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/lsp/client.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":52,"column":5,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":52,"endColumn":25,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[1366,1367],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":56,"column":5,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":56,"endColumn":25,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[1460,1461],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/require-await","severity":1,"message":"Async method 'openDocument' has no 'await' expression.","line":130,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":130,"endColumn":21,"suggestions":[{"messageId":"removeAsync","fix":{"range":[3312,3372],"text":"openDocument(uri: string, text: string): void"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":216,"column":13,"nodeType":"TSAsExpression","messageId":"neverNullish","endLine":216,"endColumn":42},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":226,"column":13,"nodeType":"TSAsExpression","messageId":"neverNullish","endLine":226,"endColumn":39},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":242,"column":13,"nodeType":"TSAsExpression","messageId":"neverNullish","endLine":242,"endColumn":36},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, value is always truthy.","line":321,"column":12,"nodeType":"Literal","messageId":"alwaysTruthy","endLine":321,"endColumn":16},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":334,"column":38,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":334,"endColumn":47},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'err['message'] ?? 'LSP error'' will use Object's default stringification format ('[object Object]') when stringified.","line":359,"column":43,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":359,"endColumn":72},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":398,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":398,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10815,10818],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10815,10818],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * LSP Client\n *\n * Manages a single LSP server process over stdio with JSON-RPC 2.0.\n * Handles: spawn, initialize handshake, document sync, requests, shutdown.\n */\n\nimport { spawn, type ChildProcess } from 'node:child_process';\nimport { readFile } from 'node:fs/promises';\nimport type {\n  Position,\n  Location,\n  SymbolInformation,\n  DocumentSymbol,\n  WorkspaceEdit,\n} from './protocol.js';\nimport { uriToFilePath } from './protocol.js';\n\nexport interface LspClientOptions {\n  command: string;\n  args: string[];\n  rootUri: string;\n  language: string;\n  cwd?: string;\n}\n\nexport class LspClient {\n  private process: ChildProcess | null = null;\n  private nextId = 1;\n  private pending = new Map<\n    number,\n    { resolve: (value: unknown) => void; reject: (reason: unknown) => void }\n  >();\n  private openDocs = new Set<string>();\n  private docVersions = new Map<string, number>();\n  private buffer = Buffer.alloc(0);\n  private readonly MAX_BUFFER_SIZE = 64 * 1024 * 1024; // 64MB\n  private initialized = false;\n\n  constructor(private opts: LspClientOptions) {}\n\n  // --- Lifecycle ---\n\n  async initialize(options?: { timeout?: number }): Promise<void> {\n    const timeout = options?.timeout ?? 10000;\n\n    this.process = spawn(this.opts.command, this.opts.args, {\n      stdio: ['pipe', 'pipe', 'pipe'],\n      cwd: this.opts.cwd,\n    });\n\n    this.process.stdout!.on('data', (data: Buffer) => {\n      this.handleData(data);\n    });\n\n    this.process.stderr!.on('data', () => {\n      // Ignore stderr, but read it to prevent pipe blocking\n    });\n\n    this.process.on('exit', (_code, _signal) => {\n      // Reject all pending requests\n      for (const [, pending] of this.pending) {\n        pending.reject(new Error('LSP server process exited'));\n      }\n      this.pending.clear();\n      this.initialized = false;\n    });\n\n    const result = await this.sendRequest(\n      'initialize',\n      {\n        processId: process.pid,\n        rootUri: this.opts.rootUri,\n        capabilities: {\n          textDocument: {\n            synchronization: {\n              dynamicRegistration: false,\n              willSave: false,\n              didSave: true,\n              willSaveWaitUntil: false,\n            },\n            definition: { dynamicRegistration: false },\n            references: { dynamicRegistration: false },\n            hover: { dynamicRegistration: false },\n            documentSymbol: {\n              dynamicRegistration: false,\n              hierarchicalDocumentSymbolSupport: true,\n            },\n            rename: { dynamicRegistration: false },\n          },\n          workspace: {\n            symbol: { dynamicRegistration: false },\n          },\n        },\n      },\n      timeout\n    );\n\n    this.initialized = true;\n\n    // Send initialized notification\n    this.sendNotification('initialized', {});\n\n    return result as undefined;\n  }\n\n  async shutdown(): Promise<void> {\n    if (!this.process || !this.initialized) {\n      if (this.process) {\n        this.process.kill();\n        this.process = null;\n      }\n      return;\n    }\n\n    try {\n      await this.sendRequest('shutdown', null, 5000);\n    } catch {\n      // Best effort\n    }\n\n    this.sendNotification('exit', null);\n    this.process.kill();\n    this.process = null;\n    this.initialized = false;\n  }\n\n  // --- Document Sync ---\n\n  async openDocument(uri: string, text: string): Promise<void> {\n    if (this.openDocs.has(uri)) return;\n\n    this.docVersions.set(uri, 1);\n    this.sendNotification('textDocument/didOpen', {\n      textDocument: {\n        uri,\n        languageId: this.opts.language,\n        version: 1,\n        text,\n      },\n    });\n    this.openDocs.add(uri);\n  }\n\n  closeDocument(uri: string): void {\n    if (!this.openDocs.has(uri)) return;\n\n    this.sendNotification('textDocument/didClose', {\n      textDocument: { uri },\n    });\n    this.openDocs.delete(uri);\n    this.docVersions.delete(uri);\n  }\n\n  notifyChange(uri: string, newText: string): void {\n    if (!this.openDocs.has(uri)) return;\n\n    const version = (this.docVersions.get(uri) ?? 1) + 1;\n    this.docVersions.set(uri, version);\n\n    this.sendNotification('textDocument/didChange', {\n      textDocument: { uri, version },\n      contentChanges: [{ text: newText }],\n    });\n  }\n\n  isDocumentOpen(uri: string): boolean {\n    return this.openDocs.has(uri);\n  }\n\n  // --- LSP Requests ---\n\n  async definition(uri: string, position: Position): Promise<Location[]> {\n    this.assertInitialized();\n    await this.ensureDocumentOpen(uri);\n\n    const result = await this.sendRequest('textDocument/definition', {\n      textDocument: { uri },\n      position,\n    });\n\n    return this.normalizeLocations(result);\n  }\n\n  async references(\n    uri: string,\n    position: Position,\n    includeDeclaration = true\n  ): Promise<Location[]> {\n    this.assertInitialized();\n    await this.ensureDocumentOpen(uri);\n\n    const result = await this.sendRequest('textDocument/references', {\n      textDocument: { uri },\n      position,\n      context: { includeDeclaration },\n    });\n\n    return this.normalizeLocations(result);\n  }\n\n  async hover(uri: string, position: Position): Promise<unknown> {\n    this.assertInitialized();\n    await this.ensureDocumentOpen(uri);\n\n    return this.sendRequest('textDocument/hover', {\n      textDocument: { uri },\n      position,\n    });\n  }\n\n  async workspaceSymbols(query: string): Promise<SymbolInformation[]> {\n    this.assertInitialized();\n\n    const result = await this.sendRequest('workspace/symbol', { query });\n    return (result as SymbolInformation[]) ?? [];\n  }\n\n  async documentSymbols(uri: string): Promise<DocumentSymbol[]> {\n    this.assertInitialized();\n    await this.ensureDocumentOpen(uri);\n\n    const result = await this.sendRequest('textDocument/documentSymbol', {\n      textDocument: { uri },\n    });\n    return (result as DocumentSymbol[]) ?? [];\n  }\n\n  async rename(\n    uri: string,\n    position: Position,\n    newName: string\n  ): Promise<WorkspaceEdit> {\n    this.assertInitialized();\n    await this.ensureDocumentOpen(uri);\n\n    const result = await this.sendRequest('textDocument/rename', {\n      textDocument: { uri },\n      position,\n      newName,\n    });\n    return (result as WorkspaceEdit) ?? { changes: {} };\n  }\n\n  // --- Internal JSON-RPC ---\n\n  private sendRequest(\n    method: string,\n    params: unknown,\n    timeout = 10000\n  ): Promise<unknown> {\n    return new Promise((resolve, reject) => {\n      if (!this.process?.stdin) {\n        reject(new Error('LSP server not running'));\n        return;\n      }\n\n      const id = this.nextId++;\n      this.pending.set(id, { resolve, reject });\n\n      const message = JSON.stringify({\n        jsonrpc: '2.0',\n        id,\n        method,\n        params,\n      });\n\n      const header = `Content-Length: ${Buffer.byteLength(message)}\\r\\n\\r\\n`;\n      this.process.stdin.write(header + message);\n\n      // Timeout\n      const timer = setTimeout(() => {\n        if (this.pending.has(id)) {\n          this.pending.delete(id);\n          reject(new Error(`LSP request \"${method}\" timed out after ${timeout}ms`));\n        }\n      }, timeout);\n\n      // Replace resolve/reject with timer-clearing versions\n      const origResolve = resolve;\n      const origReject = reject;\n      this.pending.set(id, {\n        resolve: (value) => {\n          clearTimeout(timer);\n          origResolve(value);\n        },\n        reject: (reason) => {\n          clearTimeout(timer);\n          origReject(reason);\n        },\n      });\n    });\n  }\n\n  private sendNotification(method: string, params: unknown): void {\n    if (!this.process?.stdin) return;\n\n    const message = JSON.stringify({\n      jsonrpc: '2.0',\n      method,\n      params,\n    });\n\n    const header = `Content-Length: ${Buffer.byteLength(message)}\\r\\n\\r\\n`;\n    this.process.stdin.write(header + message);\n  }\n\n  private handleData(data: Buffer): void {\n    this.buffer = Buffer.concat([this.buffer, data]);\n\n    // Guard against unbounded buffer growth from a misbehaving LSP server\n    if (this.buffer.length > this.MAX_BUFFER_SIZE) {\n      this.buffer = Buffer.alloc(0);\n      for (const [, pending] of this.pending) {\n        pending.reject(new Error('LSP buffer overflow  server sent too much data'));\n      }\n      this.pending.clear();\n      return;\n    }\n\n    while (true) {\n      // Parse Content-Length header\n      const headerEnd = this.buffer.indexOf('\\r\\n\\r\\n');\n      if (headerEnd === -1) break;\n\n      const headerStr = this.buffer.subarray(0, headerEnd).toString();\n      const match = headerStr.match(/Content-Length:\\s*(\\d+)/i);\n      if (!match) {\n        // Skip invalid header\n        this.buffer = this.buffer.subarray(headerEnd + 4);\n        continue;\n      }\n\n      const contentLength = parseInt(match[1]!, 10);\n      const totalLength = headerEnd + 4 + contentLength;\n\n      if (this.buffer.length < totalLength) break; // Need more data\n\n      const body = this.buffer.subarray(headerEnd + 4, totalLength).toString();\n      this.buffer = this.buffer.subarray(totalLength);\n\n      try {\n        const message = JSON.parse(body) as Record<string, unknown>;\n        this.handleMessage(message);\n      } catch {\n        // Skip malformed JSON\n      }\n    }\n  }\n\n  private handleMessage(message: Record<string, unknown>): void {\n    // Response (has id)\n    if ('id' in message && typeof message['id'] === 'number') {\n      const pending = this.pending.get(message['id']);\n      if (pending) {\n        this.pending.delete(message['id']);\n        if ('error' in message && message['error']) {\n          const err = message['error'] as Record<string, unknown>;\n          pending.reject(new Error(String(err['message'] ?? 'LSP error')));\n        } else {\n          pending.resolve(message['result']);\n        }\n      }\n    }\n    // Notifications from server (no id) -- ignore for now\n  }\n\n  // --- Helpers ---\n\n  private assertInitialized(): void {\n    if (!this.initialized) {\n      throw new Error('LSP client not initialized');\n    }\n  }\n\n  private async ensureDocumentOpen(uri: string): Promise<void> {\n    if (this.openDocs.has(uri)) return;\n    const filePath = uriToFilePath(uri);\n    let text = '';\n    try {\n      text = await readFile(filePath, 'utf-8');\n    } catch (error) {\n      const code = (error as NodeJS.ErrnoException).code;\n      if (code !== 'ENOENT') {\n        throw error;\n      }\n      // The requested path may not exist in scratch/test contexts.\n      // Open an empty virtual document so symbol/definition calls still route\n      // through the LSP manager without crashing.\n    }\n    await this.openDocument(uri, text);\n  }\n\n  private normalizeLocations(result: unknown): Location[] {\n    if (!result) return [];\n    if (Array.isArray(result)) return result as Location[];\n    // Single location result\n    if (typeof result === 'object' && 'uri' in (result as any)) {\n      return [result as Location];\n    }\n    return [];\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/lsp/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/lsp/manager.ts","messages":[{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['path'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":66,"column":25,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":66,"endColumn":43},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['new_name'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":93,"column":18,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":93,"endColumn":40},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['query'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":184,"column":26,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":184,"endColumn":45}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * LSP Manager\n *\n * Manages a pool of LspClient instances, one per language.\n * Handles language detection, lazy server initialization, and tool execution routing.\n */\n\nimport { execFile } from 'node:child_process';\nimport { readFile } from 'node:fs/promises';\nimport { resolve, extname } from 'node:path';\nimport { LspClient } from './client.js';\nimport { BUILTIN_SERVERS, detectLanguage } from './servers.js';\nimport { errorMessage } from '../utils/errors.js';\nimport {\n  filePathToUri,\n  toPosition,\n  formatLocations,\n  formatHoverContent,\n  formatSymbolInformation,\n  formatDocumentSymbols,\n  formatWorkspaceEdit,\n} from './protocol.js';\nimport type { LspServerConfig } from './servers.js';\n\nexport interface LspConfig {\n  enabled: boolean;\n  servers: Record<\n    string,\n    { command: string; args?: string[]; initializationOptions?: Record<string, unknown> }\n  >;\n  timeout: number;\n}\n\nexport class LspManager {\n  private clients = new Map<string, LspClient>();\n  private serverAvailable = new Map<string, boolean>();\n  private cwd: string;\n  private config: LspConfig;\n\n  constructor(opts: { cwd: string; config: LspConfig }) {\n    this.cwd = opts.cwd;\n    this.config = opts.config;\n  }\n\n  // --- Language Detection ---\n\n  getLanguage(filePath: string): string | null {\n    return detectLanguage(filePath);\n  }\n\n  // --- Tool Execution ---\n\n  async execute(\n    toolName: string,\n    args: Record<string, unknown>\n  ): Promise<string> {\n    if (!this.config.enabled) {\n      return 'LSP is disabled in config. Enable it with: opta config set lsp.enabled true';\n    }\n\n    // lsp_symbols and lsp_document_symbols have different arg patterns\n    if (toolName === 'lsp_symbols') {\n      return this.executeSymbols(args);\n    }\n\n    const path = String(args['path'] ?? '');\n\n    if (toolName === 'lsp_document_symbols') {\n      return this.executeDocumentSymbols(path);\n    }\n\n    // All other tools need path, line, character\n    const line = Number(args['line'] ?? 1);\n    const character = Number(args['character'] ?? 0);\n\n    switch (toolName) {\n      case 'lsp_definition':\n        return this.executeDefinition(path, line, character);\n      case 'lsp_references':\n        return this.executeReferences(\n          path,\n          line,\n          character,\n          args['include_declaration'] !== false\n        );\n      case 'lsp_hover':\n        return this.executeHover(path, line, character);\n      case 'lsp_rename':\n        return this.executeRename(\n          path,\n          line,\n          character,\n          String(args['new_name'] ?? '')\n        );\n      default:\n        return `Unknown LSP tool: ${toolName}`;\n    }\n  }\n\n  // --- File Change Notification ---\n\n  async notifyFileChanged(absolutePath: string): Promise<void> {\n    const language = detectLanguage(absolutePath);\n    if (!language) return;\n\n    const client = this.clients.get(language);\n    if (!client) return;\n\n    const uri = filePathToUri(absolutePath);\n\n    try {\n      const text = await readFile(absolutePath, 'utf-8');\n      if (client.isDocumentOpen(uri)) {\n        client.notifyChange(uri, text);\n      } else {\n        // Close and re-open to refresh\n        client.closeDocument(uri);\n        await client.openDocument(uri, text);\n      }\n    } catch {\n      // File may have been deleted, ignore\n    }\n  }\n\n  // --- Shutdown ---\n\n  async shutdownAll(): Promise<void> {\n    const shutdowns = Array.from(this.clients.values()).map((client) =>\n      client.shutdown().catch(() => {})\n    );\n    await Promise.all(shutdowns);\n    this.clients.clear();\n    this.serverAvailable.clear();\n  }\n\n  // --- Private: Tool Executors ---\n\n  private async executeDefinition(\n    path: string,\n    line: number,\n    character: number\n  ): Promise<string> {\n    const client = await this.getClientForFile(path);\n    if (typeof client === 'string') return client; // fallback message\n\n    const uri = this.resolveUri(path);\n    const pos = toPosition(line, character);\n    const result = await client.definition(uri, pos);\n    return formatLocations(result, this.cwd);\n  }\n\n  private async executeReferences(\n    path: string,\n    line: number,\n    character: number,\n    includeDeclaration: boolean\n  ): Promise<string> {\n    const client = await this.getClientForFile(path);\n    if (typeof client === 'string') return client;\n\n    const uri = this.resolveUri(path);\n    const pos = toPosition(line, character);\n    const result = await client.references(uri, pos, includeDeclaration);\n    return formatLocations(result, this.cwd);\n  }\n\n  private async executeHover(\n    path: string,\n    line: number,\n    character: number\n  ): Promise<string> {\n    const client = await this.getClientForFile(path);\n    if (typeof client === 'string') return client;\n\n    const uri = this.resolveUri(path);\n    const pos = toPosition(line, character);\n    const result = await client.hover(uri, pos);\n    return formatHoverContent(result);\n  }\n\n  private async executeSymbols(\n    args: Record<string, unknown>\n  ): Promise<string> {\n    const query = String(args['query'] ?? '');\n\n    // For workspace symbols, we need at least one client running.\n    // Try to use any existing client, or check if we can start one.\n    let client: LspClient | null = null;\n\n    if (this.clients.size > 0) {\n      client = this.clients.values().next().value ?? null;\n    } else {\n      // Try TypeScript first as the most common\n      const tsClient = await this.getClientForFile('_.ts');\n      if (typeof tsClient === 'string') {\n        return 'No symbols found.';\n      }\n      client = tsClient;\n    }\n\n    if (!client) return 'No symbols found.';\n\n    const result = await client.workspaceSymbols(query);\n    return formatSymbolInformation(result, this.cwd);\n  }\n\n  private async executeDocumentSymbols(path: string): Promise<string> {\n    const client = await this.getClientForFile(path);\n    if (typeof client === 'string') return client;\n\n    const uri = this.resolveUri(path);\n    const result = await client.documentSymbols(uri);\n    return formatDocumentSymbols(result);\n  }\n\n  private async executeRename(\n    path: string,\n    line: number,\n    character: number,\n    newName: string\n  ): Promise<string> {\n    const client = await this.getClientForFile(path);\n    if (typeof client === 'string') return client;\n\n    const uri = this.resolveUri(path);\n    const pos = toPosition(line, character);\n    const result = await client.rename(uri, pos, newName);\n    return formatWorkspaceEdit(result, this.cwd);\n  }\n\n  // --- Private: Client Management ---\n\n  private async getClientForFile(\n    path: string\n  ): Promise<LspClient | string> {\n    const language = detectLanguage(path);\n    if (!language) {\n      const ext = extname(path) || '(no extension)';\n      return `No LSP server configured for ${ext} files. Use search_files to find definitions instead.`;\n    }\n\n    // Check if client already exists\n    const existing = this.clients.get(language);\n    if (existing) return existing;\n\n    // Check if we already know the server is unavailable\n    if (this.serverAvailable.has(language) && !this.serverAvailable.get(language)) {\n      return this.fallbackMessage(language);\n    }\n\n    // Try to find and start the server\n    const serverConfig = this.getServerConfig(language);\n    if (!serverConfig) {\n      this.serverAvailable.set(language, false);\n      return this.fallbackMessage(language);\n    }\n\n    // Check if binary is on PATH\n    const available = await this.checkBinary(serverConfig.command);\n    this.serverAvailable.set(language, available);\n\n    if (!available) {\n      return this.fallbackMessage(language);\n    }\n\n    // Spawn and initialize\n    try {\n      const rootUri = filePathToUri(this.cwd);\n      const client = new LspClient({\n        command: serverConfig.command,\n        args: serverConfig.args,\n        rootUri,\n        language,\n        cwd: this.cwd,\n      });\n\n      await client.initialize({ timeout: this.config.timeout });\n      this.clients.set(language, client);\n      return client;\n    } catch (err) {\n      const msg = errorMessage(err);\n      this.serverAvailable.set(language, false);\n      return `LSP server for ${language} failed to start: ${msg}\\n\\nUse search_files as a fallback.`;\n    }\n  }\n\n  private getServerConfig(language: string): LspServerConfig | null {\n    // User overrides take precedence\n    const userConfig = this.config.servers[language];\n    if (userConfig) {\n      const builtin = BUILTIN_SERVERS[language];\n      return {\n        command: userConfig.command,\n        args: userConfig.args ?? [],\n        initializationOptions: userConfig.initializationOptions ?? {},\n        rootPatterns: builtin?.rootPatterns ?? [],\n        fileExtensions: builtin?.fileExtensions ?? [],\n        installHint: `(custom server: ${userConfig.command})`,\n      };\n    }\n\n    return BUILTIN_SERVERS[language] ?? null;\n  }\n\n  private async checkBinary(command: string): Promise<boolean> {\n    return new Promise((resolve) => {\n      execFile('which', [command], (error) => {\n        resolve(!error);\n      });\n    });\n  }\n\n  private resolveUri(path: string): string {\n    const absolute = resolve(this.cwd, path);\n    return filePathToUri(absolute);\n  }\n\n  private fallbackMessage(language: string): string {\n    const server = BUILTIN_SERVERS[language];\n    if (!server) {\n      return `No LSP server configured for ${language}. Use search_files to find definitions instead.`;\n    }\n\n    return (\n      `LSP server \"${server.command}\" is not available.\\n` +\n      `Install it with: ${server.installHint}\\n\\n` +\n      `Suggested alternative: Use search_files to find definitions:\\n` +\n      `  search_files({ pattern: \"<symbol_name>\", glob: \"*${server.fileExtensions[0] ?? '.*'}\" })`\n    );\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/lsp/protocol.ts","messages":[{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":1,"message":"Invalid type \"unknown\" of template literal expression.","line":150,"column":41,"nodeType":"MemberExpression","messageId":"invalidType","endLine":150,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .language on an `any` value.","line":161,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":161,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .value on an `any` value.","line":161,"column":50,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":161,"endColumn":55},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .value on an `any` value.","line":164,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":164,"endColumn":35},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'contents' will use Object's default stringification format ('[object Object]') when stringified.","line":171,"column":17,"nodeType":"Identifier","messageId":"baseToString","endLine":171,"endColumn":25},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, value is always falsy.","line":178,"column":7,"nodeType":"UnaryExpression","messageId":"alwaysFalsy","endLine":178,"endColumn":15},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, value is always falsy.","line":195,"column":7,"nodeType":"UnaryExpression","messageId":"alwaysFalsy","endLine":195,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * LSP Protocol Helpers\n *\n * Pure functions for converting between LSP types and human-readable formats.\n * No I/O, no side effects.\n */\n\nimport { relative } from 'node:path';\n\n// --- Types ---\n\nexport interface Position {\n  line: number;\n  character: number;\n}\n\nexport interface Range {\n  start: Position;\n  end: Position;\n}\n\nexport interface Location {\n  uri: string;\n  range: Range;\n}\n\nexport interface SymbolInformation {\n  name: string;\n  kind: number;\n  location: Location;\n  containerName?: string;\n}\n\nexport interface DocumentSymbol {\n  name: string;\n  kind: number;\n  range: Range;\n  selectionRange: Range;\n  children?: DocumentSymbol[];\n}\n\nexport interface TextEdit {\n  range: Range;\n  newText: string;\n}\n\nexport interface WorkspaceEdit {\n  changes?: Record<string, TextEdit[]>;\n}\n\n// --- Symbol Kind Names ---\n\nconst SYMBOL_KIND_NAMES: Record<number, string> = {\n  1: 'File',\n  2: 'Module',\n  3: 'Namespace',\n  4: 'Package',\n  5: 'Class',\n  6: 'Method',\n  7: 'Property',\n  8: 'Field',\n  9: 'Constructor',\n  10: 'Enum',\n  11: 'Interface',\n  12: 'Function',\n  13: 'Variable',\n  14: 'Constant',\n  15: 'String',\n  16: 'Number',\n  17: 'Boolean',\n  18: 'Array',\n  19: 'Object',\n  20: 'Key',\n  21: 'Null',\n  22: 'EnumMember',\n  23: 'Struct',\n  24: 'Event',\n  25: 'Operator',\n  26: 'TypeParameter',\n};\n\nfunction symbolKindName(kind: number): string {\n  return SYMBOL_KIND_NAMES[kind] ?? `Kind(${kind})`;\n}\n\n// --- URI Conversion ---\n\nexport function filePathToUri(filePath: string): string {\n  // Encode path components (spaces, brackets, etc.) but not slashes\n  const encoded = filePath\n    .split('/')\n    .map((part) => encodeURIComponent(part))\n    .join('/');\n  return `file://${encoded}`;\n}\n\nexport function uriToFilePath(uri: string): string {\n  // Strip file:// prefix and decode\n  const path = uri.replace(/^file:\\/\\//, '');\n  return decodeURIComponent(path);\n}\n\n// --- Position Conversion ---\n\nexport function toPosition(line: number, character: number): Position {\n  return {\n    line: Math.max(0, line - 1),\n    character,\n  };\n}\n\n// --- Formatting ---\n\nexport function formatLocation(loc: Location, cwd: string): string {\n  const filePath = uriToFilePath(loc.uri);\n  const rel = relative(cwd, filePath);\n  const line = loc.range.start.line + 1; // 0-based -> 1-based\n  const char = loc.range.start.character;\n  return `${rel}:${line}:${char}`;\n}\n\nexport function formatLocations(\n  locs: Location[] | null | undefined,\n  cwd: string\n): string {\n  if (!locs || locs.length === 0) return 'No results found.';\n  return locs.map((loc) => formatLocation(loc, cwd)).join('\\n');\n}\n\nexport function formatHoverContent(hover: unknown): string {\n  if (!hover) return 'No hover information.';\n\n  const h = hover as Record<string, unknown>;\n  const contents = h['contents'];\n\n  if (!contents) return 'No hover information.';\n\n  // String content\n  if (typeof contents === 'string') return contents;\n\n  // MarkupContent: { kind, value }\n  if (\n    typeof contents === 'object' &&\n    !Array.isArray(contents) &&\n    'value' in (contents as Record<string, unknown>)\n  ) {\n    const c = contents as Record<string, unknown>;\n    // MarkedString with language: { language, value }\n    if ('language' in c && typeof c['language'] === 'string') {\n      return `\\`\\`\\`${c['language']}\\n${c['value']}\\n\\`\\`\\``;\n    }\n    return String(c['value']);\n  }\n\n  // Array of MarkedStrings\n  if (Array.isArray(contents)) {\n    return contents\n      .map((item) => {\n        if (typeof item === 'string') return item;\n        if (typeof item === 'object' && item && 'language' in item) {\n          return `\\`\\`\\`${item.language}\\n${item.value}\\n\\`\\`\\``;\n        }\n        if (typeof item === 'object' && item && 'value' in item) {\n          return String(item.value);\n        }\n        return String(item);\n      })\n      .join('\\n\\n');\n  }\n\n  return String(contents);\n}\n\nexport function formatSymbolInformation(\n  symbols: SymbolInformation[],\n  cwd: string\n): string {\n  if (!symbols || symbols.length === 0) return 'No symbols found.';\n\n  return symbols\n    .map((sym) => {\n      const filePath = uriToFilePath(sym.location.uri);\n      const rel = relative(cwd, filePath);\n      const line = sym.location.range.start.line + 1;\n      const kind = symbolKindName(sym.kind);\n      return `${sym.name} (${kind})  ${rel}:${line}`;\n    })\n    .join('\\n');\n}\n\nexport function formatDocumentSymbols(\n  symbols: DocumentSymbol[],\n  indent: number = 0\n): string {\n  if (!symbols || symbols.length === 0) {\n    return indent === 0 ? 'No symbols found.' : '';\n  }\n\n  const lines: string[] = [];\n  const prefix = '  '.repeat(indent);\n\n  for (const sym of symbols) {\n    const kind = symbolKindName(sym.kind);\n    const line = sym.range.start.line + 1;\n    lines.push(`${prefix}${sym.name} (${kind})  line ${line}`);\n    if (sym.children && sym.children.length > 0) {\n      const childText = formatDocumentSymbols(sym.children, indent + 1);\n      if (childText) lines.push(childText);\n    }\n  }\n\n  return lines.join('\\n');\n}\n\nexport function formatWorkspaceEdit(\n  edit: WorkspaceEdit | null | undefined,\n  cwd: string\n): string {\n  if (!edit || !edit.changes) return 'No changes.';\n\n  const entries = Object.entries(edit.changes);\n  if (entries.length === 0) return 'No changes.';\n\n  const lines: string[] = [];\n\n  for (const [uri, edits] of entries) {\n    const filePath = uriToFilePath(uri);\n    const rel = relative(cwd, filePath);\n    lines.push(`${rel}:`);\n    for (const e of edits) {\n      const line = e.range.start.line + 1;\n      const char = e.range.start.character;\n      lines.push(`  line ${line}:${char} -> \"${e.newText}\"`);\n    }\n  }\n\n  return lines.join('\\n');\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/lsp/servers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/mcp/cache.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/mcp/client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/mcp/registry.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":64,"column":57,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":64,"endColumn":59,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[2395,2397],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":76,"column":59,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":76,"endColumn":61,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[2888,2890],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":90,"column":31,"nodeType":"ChainExpression","messageId":"neverNullish","endLine":90,"endColumn":50},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":90,"column":41,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":90,"endColumn":43,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[3350,3352],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":92,"column":29,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":92,"endColumn":31,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[3432,3434],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":95,"column":12,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":95,"endColumn":14,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[3458,3460],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":96,"column":15,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":96,"endColumn":17,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[3485,3487],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":99,"column":39,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":99,"endColumn":41,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[3592,3594],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":151,"column":27,"nodeType":"ChainExpression","messageId":"neverNullish","endLine":151,"endColumn":51},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":151,"column":42,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":151,"endColumn":44,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[5391,5393],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":157,"column":22,"nodeType":"ChainExpression","messageId":"neverNullish","endLine":157,"endColumn":41},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":157,"column":32,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":157,"endColumn":34,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[5578,5580],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":170,"column":18,"nodeType":"ChainExpression","messageId":"neverNullish","endLine":170,"endColumn":37},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":170,"column":28,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":170,"endColumn":30,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[5984,5986],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":171,"column":18,"nodeType":"ChainExpression","messageId":"neverNullish","endLine":171,"endColumn":37},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":171,"column":28,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":171,"endColumn":30,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[6028,6030],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":193,"column":24,"nodeType":"ChainExpression","messageId":"neverNullish","endLine":193,"endColumn":50},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":193,"column":36,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":193,"endColumn":38,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[6913,6915],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":253,"column":11,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":253,"endColumn":38},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":264,"column":57,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":264,"endColumn":77},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":271,"column":11,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":271,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":288,"column":11,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":288,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":307,"column":17,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":307,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .path on an `any` value.","line":308,"column":20,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":308,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .path on an `any` value.","line":309,"column":83,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":309,"endColumn":87},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":400,"column":5,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":400,"endColumn":32},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['task'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":437,"column":25,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":437,"endColumn":43},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['scope']' will use Object's default stringification format ('[object Object]') when stringified.","line":447,"column":39,"nodeType":"MemberExpression","messageId":"baseToString","endLine":447,"endColumn":52},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['mode']' will use Object's default stringification format ('[object Object]') when stringified.","line":451,"column":37,"nodeType":"MemberExpression","messageId":"baseToString","endLine":451,"endColumn":49},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args['plan'] ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":467,"column":25,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":467,"endColumn":43},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":470,"column":23,"nodeType":"TSAsExpression","messageId":"neverNullish","endLine":470,"endColumn":103}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":31,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { TOOL_SCHEMAS, SUB_AGENT_TOOL_SCHEMAS, executeTool } from '../core/tools/index.js';\nimport { connectMcpServer, type McpConnection } from './client.js';\nimport { ToolResultCache } from './cache.js';\nimport { debug } from '../core/debug.js';\nimport { errorMessage } from '../utils/errors.js';\nimport { estimateTokens } from '../utils/tokens.js';\nimport type { OptaConfig } from '../core/config.js';\nimport type { SubAgentContext } from '../core/subagent.js';\nimport { LspManager } from '../lsp/manager.js';\nimport { resolve } from 'node:path';\nimport { loadCustomTools, toToolSchema, executeCustomTool, type CustomToolDef } from '../tools/custom.js';\nimport { createPlaywrightMcpServerConfig } from '../browser/mcp-bootstrap.js';\nimport { resolveLmxApiKey } from '../lmx/api-key.js';\n\ninterface ToolSchema {\n  type: 'function';\n  function: {\n    name: string;\n    description: string;\n    parameters: Record<string, unknown>;\n  };\n}\n\nexport interface ToolRegistry {\n  schemas: ToolSchema[];\n  execute: (\n    name: string,\n    argsJson: string,\n    parentCtx?: SubAgentContext,\n    signal?: AbortSignal\n  ) => Promise<string>;\n  close: () => Promise<void>;\n}\n\ninterface SubAgentCallbacks {\n  onSubAgentSpawn?: (id: string, label: string, dependsOn?: number) => void;\n  onSubAgentProgress?: (event: import('../core/subagent-events.js').SubAgentProgressEvent) => void;\n  onSubAgentDone?: (agentId: string, result: string) => void;\n}\n\ninterface BuildToolRegistryOptions {\n  executeLocalTool?: (name: string, argsJson: string, signal?: AbortSignal) => Promise<string>;\n  onSubAgentSpawn?: (id: string, label: string, dependsOn?: number) => void;\n  onSubAgentProgress?: (event: import('../core/subagent-events.js').SubAgentProgressEvent) => void;\n  onSubAgentDone?: (agentId: string, result: string) => void;\n}\n\nconst PLAYWRIGHT_MCP_SERVER_KEY = 'playwright';\n\nfunction normalizeStringList(values: string[] | undefined): string[] {\n  if (!values || values.length === 0) return [];\n  const seen = new Set<string>();\n  const normalized: string[] = [];\n  for (const value of values) {\n    const candidate = value.trim();\n    if (!candidate || seen.has(candidate)) continue;\n    seen.add(candidate);\n    normalized.push(candidate);\n  }\n  return normalized;\n}\n\nfunction resolvePlaywrightAllowedHosts(browser: OptaConfig['browser']): string[] {\n  const policyHosts = normalizeStringList(browser.policy?.allowedHosts);\n  const hasPolicyOverride = policyHosts.some((host) => host !== '*');\n  const sourceHosts = hasPolicyOverride\n    ? policyHosts\n    : normalizeStringList(browser.globalAllowedHosts);\n\n  // Preserve previous behavior: wildcard means unrestricted, so omit the flag.\n  if (sourceHosts.includes('*')) return [];\n  return sourceHosts;\n}\n\nfunction resolvePlaywrightBlockedOrigins(browser: OptaConfig['browser']): string[] {\n  const policyBlocked = normalizeStringList(browser.policy?.blockedOrigins);\n  if (policyBlocked.length > 0) return policyBlocked;\n  return normalizeStringList(browser.blockedOrigins);\n}\n\nexport async function buildToolRegistry(\n  config: OptaConfig,\n  mode: string = 'normal',\n  options?: BuildToolRegistryOptions,\n): Promise<ToolRegistry> {\n  const connections: McpConnection[] = [];\n  const mcpSchemas: ToolSchema[] = [];\n  const mcpRoutes = new Map<string, McpConnection>();\n\n  const mergedServers = { ...(config.mcp?.servers ?? {}) };\n  const browser = config.browser;\n  const browserMcp = browser?.mcp;\n\n  if (\n    browser?.enabled &&\n    browserMcp?.enabled &&\n    !(PLAYWRIGHT_MCP_SERVER_KEY in mergedServers)\n  ) {\n    const browserMode = browser.attach?.enabled ? 'attach' : browser.mode;\n    const allowedHosts = resolvePlaywrightAllowedHosts(browser);\n    const blockedOrigins = resolvePlaywrightBlockedOrigins(browser);\n\n    mergedServers[PLAYWRIGHT_MCP_SERVER_KEY] = createPlaywrightMcpServerConfig({\n      command: browserMcp.command,\n      packageName: browserMcp.package,\n      mode: browserMode,\n      allowedHosts,\n      blockedOrigins,\n    });\n  }\n\n  const serverEntries = Object.entries(mergedServers);\n\n  // Connect all MCP servers in parallel for faster startup\n  const connectResults = await Promise.allSettled(\n    serverEntries.map(([name, serverConfig]) =>\n      connectMcpServer(name, serverConfig).then(conn => ({ name, conn }))\n    )\n  );\n\n  for (const result of connectResults) {\n    if (result.status === 'fulfilled') {\n      const { name, conn } = result.value;\n      connections.push(conn);\n\n      for (const tool of conn.tools) {\n        const namespacedName = `mcp__${name}__${tool.name}`;\n        mcpSchemas.push({\n          type: 'function',\n          function: {\n            name: namespacedName,\n            description: `[${name}] ${tool.description}`,\n            parameters: tool.inputSchema,\n          },\n        });\n        mcpRoutes.set(namespacedName, conn);\n      }\n\n      debug(`MCP \"${name}\": ${conn.tools.length} tools registered`);\n    } else {\n      // Extract server name from the settled result  map index matches serverEntries order\n      const idx = connectResults.indexOf(result);\n      const name = serverEntries[idx]?.[0] ?? 'unknown';\n      const msg = errorMessage(result.reason);\n      debug(`MCP \"${name}\" failed to connect: ${msg}`);\n      console.warn(`  MCP server \"${name}\" unavailable: ${msg}`);\n    }\n  }\n\n  // Conditionally include sub-agent tools\n  const subAgentEnabled = config.subAgent?.enabled ?? true;\n  const subAgentSchemas = subAgentEnabled\n    ? (SUB_AGENT_TOOL_SCHEMAS as ToolSchema[])\n    : [];\n\n  // Conditionally include LSP tools\n  const lspEnabled = config.lsp?.enabled ?? true;\n  const LSP_TOOL_NAMES = new Set([\n    'lsp_definition', 'lsp_references', 'lsp_hover',\n    'lsp_symbols', 'lsp_document_symbols', 'lsp_rename',\n  ]);\n\n  // Initialize LspManager if LSP is enabled\n  let lspManager: LspManager | null = null;\n  if (lspEnabled) {\n    lspManager = new LspManager({\n      cwd: process.cwd(),\n      config: {\n        enabled: true,\n        servers: config.lsp?.servers ?? {},\n        timeout: config.lsp?.timeout ?? 10000,\n      },\n    });\n  }\n\n  // Filter out LSP tools from base schemas if disabled\n  const baseSchemas = lspEnabled\n    ? (TOOL_SCHEMAS as ToolSchema[])\n    : (TOOL_SCHEMAS as ToolSchema[]).filter(s => !LSP_TOOL_NAMES.has(s.function.name));\n\n  // Load custom tools from .opta/tools/*.json\n  const customToolDefs = await loadCustomTools(process.cwd());\n  const customSchemas = customToolDefs.map(toToolSchema) as ToolSchema[];\n  const customRoutes = new Map<string, CustomToolDef>();\n  for (const tool of customToolDefs) {\n    customRoutes.set(`custom__${tool.name}`, tool);\n  }\n  if (customToolDefs.length > 0) {\n    debug(`Custom tools: ${customToolDefs.length} loaded (${customToolDefs.map(t => t.name).join(', ')})`);\n  }\n\n  const totalTools = baseSchemas.length + mcpSchemas.length + subAgentSchemas.length + customSchemas.length;\n  const contextLimit = config.model?.contextLimit ?? 32768;\n  // ~256 tokens of context per tool is a reasonable budget; exceeding this\n  // means tool schemas consume too much of the model's working memory.\n  const toolThreshold = Math.floor(contextLimit / 256);\n  if (totalTools > toolThreshold) {\n    const schemaJson = JSON.stringify(baseSchemas) + JSON.stringify(subAgentSchemas) + JSON.stringify(mcpSchemas) + JSON.stringify(customSchemas);\n    const estimatedTokens = estimateTokens(schemaJson);\n    console.warn(\n      `  ${totalTools} tools (~${estimatedTokens} tokens) may degrade inference on ${(contextLimit / 1024).toFixed(0)}K context. Consider: lsp.enabled=false or reducing MCP servers.`\n    );\n  }\n\n  const allSchemas = [...baseSchemas, ...subAgentSchemas, ...mcpSchemas, ...customSchemas];\n\n  const WRITE_TOOL_NAMES = new Set([\n    'edit_file', 'write_file', 'multi_edit', 'delete_file',\n    'run_command', 'save_memory', 'bg_start', 'bg_kill',\n    'spawn_agent', 'delegate_task', 'lsp_rename',\n  ]);\n\n  const filteredSchemas = mode === 'plan'\n    ? allSchemas.filter(s => !WRITE_TOOL_NAMES.has(s.function.name) && !s.function.name.startsWith('custom__'))\n    : allSchemas;\n\n  // Build a self-reference for sub-agent tool execution\n  const registryRef: { current: ToolRegistry | null } = { current: null };\n\n  // Capture sub-agent callbacks from options for use inside execute() closure\n  const subAgentCallbacks: SubAgentCallbacks = {\n    onSubAgentSpawn: options?.onSubAgentSpawn,\n    onSubAgentProgress: options?.onSubAgentProgress,\n    onSubAgentDone: options?.onSubAgentDone,\n  };\n\n  // TTL cache for read-only tool results (avoids redundant file reads in multi-turn convos)\n  const cache = new ToolResultCache();\n\n  const registry: ToolRegistry = {\n    schemas: filteredSchemas,\n    async execute(name: string, argsJson: string, parentCtx?: SubAgentContext, signal?: AbortSignal): Promise<string> {\n      // Check cache for read-only tools\n      if (cache.isCacheable(name)) {\n        const cacheKey = ToolResultCache.key(name, argsJson);\n        const cached = cache.get(cacheKey);\n        if (cached !== undefined) {\n          debug(`Cache hit: ${name}`);\n          return cached;\n        }\n      }\n\n      // Flush cache on write operations\n      if (cache.isWriteTool(name) && cache.size > 0) {\n        debug(`Cache flush: ${name} (${cache.size} entries)`);\n        cache.flush();\n      }\n\n      const mcpConn = mcpRoutes.get(name);\n      if (mcpConn) {\n        let args: Record<string, unknown>;\n        try {\n          args = JSON.parse(argsJson);\n        } catch {\n          return 'Error: Invalid JSON arguments';\n        }\n        // Strip namespace: mcp__server__toolname -> toolname\n        const originalName = name.split('__').slice(2).join('__');\n        return mcpConn.call(originalName, args);\n      }\n\n      // Route sub-agent tools (pass context explicitly for concurrency safety)\n      if (name === 'spawn_agent' || name === 'delegate_task') {\n        return execSubAgentTool(name, argsJson, config, registryRef.current!, parentCtx, subAgentCallbacks);\n      }\n\n      // Route LSP tools through LspManager\n      if (lspManager && LSP_TOOL_NAMES.has(name)) {\n        let args: Record<string, unknown>;\n        try {\n          args = JSON.parse(argsJson);\n        } catch {\n          return 'Error: Invalid JSON arguments';\n        }\n        const result = await lspManager.execute(name, args);\n        // Cache LSP read results\n        if (cache.isCacheable(name)) {\n          cache.set(ToolResultCache.key(name, argsJson), result);\n        }\n        return result;\n      }\n\n      // Route custom tools\n      const customTool = customRoutes.get(name);\n      if (customTool) {\n        let args: Record<string, unknown>;\n        try {\n          args = JSON.parse(argsJson);\n        } catch {\n          return 'Error: Invalid JSON arguments for custom tool';\n        }\n        return executeCustomTool(customTool, args);\n      }\n\n      // Execute standard tools, then notify LSP of file changes\n      const localToolExecutor = options?.executeLocalTool ?? executeTool;\n      const result = await localToolExecutor(name, argsJson, signal);\n\n      // Cache read-only tool results\n      if (cache.isCacheable(name)) {\n        cache.set(ToolResultCache.key(name, argsJson), result);\n      }\n\n      // Notify LSP of file changes after write operations\n      if (lspManager && (name === 'edit_file' || name === 'write_file' || name === 'multi_edit')) {\n        try {\n          const args = JSON.parse(argsJson);\n          if (args.path) {\n            await lspManager.notifyFileChanged(resolve(process.cwd(), String(args.path)));\n          }\n        } catch {\n          // Best effort - don't fail the tool execution\n        }\n      }\n\n      return result;\n    },\n    async close() {\n      // Shutdown LSP servers\n      if (lspManager) {\n        await lspManager.shutdownAll();\n      }\n\n      for (const conn of connections) {\n        try {\n          await conn.close();\n        } catch {\n          // Best-effort cleanup\n        }\n      }\n    },\n  };\n\n  registryRef.current = registry;\n  return registry;\n}\n\n// --- Sub-Agent Tool Execution ---\n\n/**\n * Resolve the model name to use for LMX sub-agent inference.\n *\n * When the main session is running a cloud provider model (anthropic/, zen/,\n * google/, etc.), the sub-agent cannot use that model because it connects\n * directly to LMX at config.connection.host:port/v1.\n *\n * Resolution order:\n *   1. If model is already an LMX-native HuggingFace repo (mlx-community/ etc.)  use as-is\n *   2. Query LMX admin API for the first loaded model  use that\n *   3. Fall back to config.model.default as-is\n */\nasync function resolveLmxModel(config: OptaConfig): Promise<string> {\n  const model = config.model.default;\n\n  // Known LMX-compatible HuggingFace org prefixes\n  const LMX_ORG_PREFIXES = [\n    'mlx-community', 'lmstudio-community', 'inferencerlabs',\n    'unsloth', 'bartowski', 'TheBloke', 'NousResearch',\n  ];\n\n  const firstSlash = model.indexOf('/');\n  const org = firstSlash > 0 ? model.slice(0, firstSlash) : '';\n\n  if (LMX_ORG_PREFIXES.includes(org)) {\n    return model; // Already a valid LMX model ID\n  }\n\n  // Model has a cloud provider prefix  query LMX for the loaded model\n  try {\n    const headers: Record<string, string> = {};\n    if (config.connection.adminKey) {\n      headers['X-Admin-Key'] = config.connection.adminKey;\n    }\n    const resp = await fetch(\n      `http://${config.connection.host}:${config.connection.port}/admin/models`,\n      { headers, signal: AbortSignal.timeout(3000) },\n    );\n    if (resp.ok) {\n      const data = await resp.json() as { loaded?: Array<{ id: string }> };\n      const firstLoaded = data.loaded?.[0]?.id;\n      if (firstLoaded) return firstLoaded;\n    }\n  } catch {\n    // LMX unreachable  fall through to default\n  }\n\n  return model; // Last resort: use as-is\n}\n\nasync function execSubAgentTool(\n  name: string,\n  argsJson: string,\n  config: OptaConfig,\n  registry: ToolRegistry,\n  parentCtx?: SubAgentContext,\n  callbacks?: SubAgentCallbacks,\n): Promise<string> {\n  let args: Record<string, unknown>;\n  try {\n    args = JSON.parse(argsJson);\n  } catch {\n    return 'Error: Invalid JSON arguments for sub-agent tool';\n  }\n\n  // Lazy-load sub-agent modules\n  const { spawnSubAgent, formatSubAgentResult, createSubAgentContext } = await import('../core/subagent.js');\n  const { nanoid } = await import('nanoid');\n\n  // Resolve the model to use for LMX sub-agent calls first (needed for childContext).\n  // If the main session switched to a cloud model (anthropic/, zen/, etc.),\n  // the sub-agent must still use the LMX-loaded model  not the cloud model name.\n  const lmxModel = await resolveLmxModel(config);\n  const subAgentConfig = lmxModel !== config.model.default\n    ? { ...config, model: { ...config.model, default: lmxModel } }\n    : config;\n\n  // Validate depth before spawning (uses explicit context, not mutable registry state)\n  let childContext: SubAgentContext;\n  try {\n    childContext = createSubAgentContext(\n      parentCtx?.parentSessionId ?? 'root',\n      parentCtx,\n      subAgentConfig,\n    );\n  } catch (err) {\n    return `Error: ${errorMessage(err)}`;\n  }\n\n  // Create an OpenAI client for the sub-agent (direct LMX connection)\n  const { default: OpenAI } = await import('openai');\n  const client = new OpenAI({\n    baseURL: `http://${config.connection.host}:${config.connection.port}/v1`,\n    apiKey: resolveLmxApiKey(config.connection),\n  });\n\n  if (name === 'spawn_agent') {\n    const task = String(args['task'] ?? '');\n    if (!task) return 'Error: task is required for spawn_agent';\n\n    const agentId = nanoid(8);\n    callbacks?.onSubAgentSpawn?.(agentId, task.slice(0, 40), undefined);\n\n    const result = await spawnSubAgent(\n      {\n        id: agentId,\n        description: task,\n        scope: args['scope'] ? String(args['scope']) : undefined,\n        budget: args['max_tool_calls']\n          ? { maxToolCalls: Number(args['max_tool_calls']) }\n          : undefined,\n        mode: args['mode'] ? String(args['mode']) : undefined,\n        onProgress: callbacks?.onSubAgentProgress,\n      },\n      subAgentConfig,\n      client,\n      registry,\n      childContext,\n    );\n\n    callbacks?.onSubAgentDone?.(agentId, result.response);\n    return formatSubAgentResult(result);\n  }\n\n  if (name === 'delegate_task') {\n    const { executeDelegation } = await import('../core/orchestrator.js');\n\n    const plan = String(args['plan'] ?? '');\n    if (!plan) return 'Error: plan is required for delegate_task';\n\n    const subtasks = (args['subtasks'] as Array<{ task: string; scope?: string; depends_on?: number }>) ?? [];\n    if (!Array.isArray(subtasks) || subtasks.length === 0) {\n      return 'Error: subtasks array is required for delegate_task';\n    }\n\n    try {\n      return await executeDelegation(\n        { plan, subtasks },\n        subAgentConfig,\n        client,\n        registry,\n        (task, cfg, cli, reg) => spawnSubAgent(task, cfg, cli, reg, childContext),\n        {\n          onAgentSpawn: callbacks?.onSubAgentSpawn,\n          onAgentProgress: callbacks?.onSubAgentProgress,\n          onAgentDone: callbacks?.onSubAgentDone,\n        },\n      );\n    } catch (err) {\n      return `Error: ${errorMessage(err)}`;\n    }\n  }\n\n  return `Error: Unknown sub-agent tool \"${name}\"`;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/memory/analytics.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":43,"column":24,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":43,"endColumn":63}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export interface AnalyticsSessionSummary {\n  id: string;\n  model: string;\n  created: string;\n  messageCount: number;\n  toolCallCount: number;\n  title: string;\n}\n\nexport class SessionAnalytics {\n  private sessions: AnalyticsSessionSummary[];\n\n  constructor(sessions: AnalyticsSessionSummary[]) {\n    this.sessions = sessions;\n  }\n\n  get totalSessions(): number {\n    return this.sessions.length;\n  }\n\n  get totalMessages(): number {\n    return this.sessions.reduce((sum, s) => sum + s.messageCount, 0);\n  }\n\n  get totalToolCalls(): number {\n    return this.sessions.reduce((sum, s) => sum + s.toolCallCount, 0);\n  }\n\n  get avgMessagesPerSession(): number {\n    if (this.sessions.length === 0) return 0;\n    return this.totalMessages / this.sessions.length;\n  }\n\n  get modelBreakdown(): Record<string, number> {\n    const counts: Record<string, number> = {};\n    for (const s of this.sessions) {\n      counts[s.model] = (counts[s.model] ?? 0) + 1;\n    }\n    return counts;\n  }\n\n  sessionsToday(today?: string): number {\n    const d = today ?? new Date().toISOString().split('T')[0]!;\n    return this.sessions.filter(s => s.created.startsWith(d)).length;\n  }\n\n  get mostUsedModel(): string {\n    const breakdown = this.modelBreakdown;\n    let max = 0;\n    let model = 'none';\n    for (const [m, count] of Object.entries(breakdown)) {\n      if (count > max) {\n        max = count;\n        model = m;\n      }\n    }\n    return model;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/memory/history.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/memory/recovery.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/memory/store.ts","messages":[{"ruleId":"@typescript-eslint/no-dynamic-delete","severity":1,"message":"Do not delete dynamically computed property keys.","line":131,"column":24,"nodeType":"Identifier","messageId":"dynamicDelete","endLine":131,"endColumn":26},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":191,"column":15,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":191,"endColumn":27},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":195,"column":24,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":195,"endColumn":45},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":270,"column":34,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":270,"endColumn":36,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[7283,7285],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":280,"column":21,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":280,"endColumn":33}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { mkdir, readFile, writeFile, readdir, rm } from 'node:fs/promises';\nimport { join } from 'node:path';\nimport { homedir } from 'node:os';\nimport { nanoid } from 'nanoid';\nimport { z } from 'zod';\n\n// --- Types ---\n\nimport type { AgentMessage, ContentPart } from '../core/agent.js';\n\n// Re-export AgentMessage from agent.ts (canonical source)\nexport type { AgentMessage, ContentPart };\n\nexport interface Session {\n  id: string;\n  created: string;\n  updated: string;\n  model: string;\n  cwd: string;\n  title: string;\n  tags: string[];\n  messages: AgentMessage[];\n  toolCallCount: number;\n  compacted: boolean;\n}\n\n// --- Zod Schema for Session Validation ---\n\nconst ContentPartSchema = z.union([\n  z.object({ type: z.literal('text'), text: z.string() }),\n  z.object({ type: z.literal('image_url'), image_url: z.object({ url: z.string() }) }),\n]);\n\nconst AgentMessageSchema = z.object({\n  role: z.enum(['system', 'user', 'assistant', 'tool']),\n  content: z.union([z.string(), z.array(ContentPartSchema), z.null()]),\n  tool_calls: z\n    .array(\n      z.object({\n        id: z.string(),\n        type: z.literal('function'),\n        function: z.object({ name: z.string(), arguments: z.string() }),\n      })\n    )\n    .optional(),\n  tool_call_id: z.string().optional(),\n});\n\nconst SessionSchema = z.object({\n  id: z.string(),\n  created: z.string(),\n  updated: z.string(),\n  model: z.string(),\n  cwd: z.string(),\n  title: z.string(),\n  tags: z.array(z.string()).default([]),\n  messages: z.array(AgentMessageSchema),\n  toolCallCount: z.number(),\n  compacted: z.boolean(),\n});\n\nfunction parseSession(data: string): Session | null {\n  try {\n    const parsed: unknown = JSON.parse(data);\n    const result = SessionSchema.safeParse(parsed);\n    if (!result.success) return null;\n    return result.data as Session;\n  } catch {\n    return null;\n  }\n}\n\nexport interface SessionSummary {\n  id: string;\n  title: string;\n  tags: string[];\n  model: string;\n  created: string;\n  messageCount: number;\n  toolCallCount: number;\n}\n\n// --- Paths ---\n\nfunction sessionsDir(): string {\n  return join(homedir(), '.config', 'opta', 'sessions');\n}\n\nfunction sessionPath(id: string): string {\n  return join(sessionsDir(), `${id}.json`);\n}\n\n// --- Session Index (fast resume) ---\n\nconst INDEX_FILE = 'index.json';\n\ninterface SessionIndex {\n  entries: Record<string, { title: string; model: string; tags: string[]; created: string; messageCount: number }>;\n  updatedAt: string;\n}\n\nasync function loadIndex(): Promise<SessionIndex> {\n  try {\n    const data = await readFile(join(sessionsDir(), INDEX_FILE), 'utf-8');\n    return JSON.parse(data) as SessionIndex;\n  } catch {\n    return { entries: {}, updatedAt: new Date().toISOString() };\n  }\n}\n\nasync function saveIndex(index: SessionIndex): Promise<void> {\n  index.updatedAt = new Date().toISOString();\n  await mkdir(sessionsDir(), { recursive: true });\n  await writeFile(join(sessionsDir(), INDEX_FILE), JSON.stringify(index, null, 2));\n}\n\nexport async function updateSessionIndex(id: string, session: Session): Promise<void> {\n  const index = await loadIndex();\n  index.entries[id] = {\n    title: session.title,\n    model: session.model,\n    tags: session.tags,\n    created: session.created,\n    messageCount: session.messages.length,\n  };\n  await saveIndex(index);\n}\n\nexport async function removeFromIndex(id: string): Promise<void> {\n  const index = await loadIndex();\n  delete index.entries[id];\n  await saveIndex(index);\n}\n\n// --- CRUD ---\n\nexport async function createSession(model: string): Promise<Session> {\n  const now = new Date().toISOString();\n  const session: Session = {\n    id: nanoid(12),\n    created: now,\n    updated: now,\n    model,\n    cwd: process.cwd(),\n    title: '',\n    tags: [],\n    messages: [],\n    toolCallCount: 0,\n    compacted: false,\n  };\n  await saveSession(session);\n  return session;\n}\n\nexport async function loadSession(id: string): Promise<Session> {\n  const data = await readFile(sessionPath(id), 'utf-8');\n  const session = parseSession(data);\n  if (!session) {\n    throw new Error(`Corrupt or invalid session file: ${id}`);\n  }\n  return session;\n}\n\nexport async function saveSession(session: Session): Promise<void> {\n  session.updated = new Date().toISOString();\n  const dir = sessionsDir();\n  await mkdir(dir, { recursive: true });\n  await writeFile(sessionPath(session.id), JSON.stringify(session, null, 2), 'utf-8');\n  await updateSessionIndex(session.id, session);\n}\n\nexport async function listSessions(): Promise<SessionSummary[]> {\n  const dir = sessionsDir();\n  let files: string[];\n  try {\n    files = await readdir(dir);\n  } catch {\n    return [];\n  }\n\n  const summaries: SessionSummary[] = [];\n  for (const file of files) {\n    if (!file.endsWith('.json') || file === INDEX_FILE) continue;\n    try {\n      const data = await readFile(join(dir, file), 'utf-8');\n      const session = parseSession(data);\n      if (!session) continue; // Skip corrupt/invalid session files\n      summaries.push({\n        id: session.id,\n        title: session.title || '(untitled)',\n        tags: session.tags ?? [],\n        model: session.model,\n        created: session.created,\n        messageCount: session.messages.filter((m) => m.role !== 'system').length,\n        toolCallCount: session.toolCallCount ?? 0,\n      });\n    } catch {\n      // Skip unreadable session files\n    }\n  }\n\n  return summaries.sort((a, b) => b.created.localeCompare(a.created));\n}\n\nexport async function deleteSession(id: string): Promise<void> {\n  await rm(sessionPath(id), { force: true });\n  await removeFromIndex(id);\n}\n\nexport async function exportSession(id: string): Promise<string> {\n  const session = await loadSession(id);\n  return JSON.stringify(session, null, 2);\n}\n\n// --- Search ---\n\n/**\n * Fuzzy search sessions by query string.\n * Matches against session ID prefix, title, model, tags, and message content.\n * Returns results sorted by relevance score (highest first).\n */\nexport async function searchSessions(query: string): Promise<SessionSummary[]> {\n  const all = await listSessions();\n  const q = query.toLowerCase();\n\n  // Load full session files in parallel for content search\n  const dir = sessionsDir();\n  let files: string[];\n  try {\n    files = await readdir(dir);\n  } catch {\n    files = [];\n  }\n\n  // Build a map of session ID -> full session (for content matching)\n  const sessionContentMap = new Map<string, Session>();\n  await Promise.all(\n    files.filter(f => f.endsWith('.json') && f !== INDEX_FILE).map(async (file) => {\n      try {\n        const data = await readFile(join(dir, file), 'utf-8');\n        const session = parseSession(data);\n        if (session) sessionContentMap.set(session.id, session);\n      } catch {\n        // Skip unreadable files\n      }\n    })\n  );\n\n  const scored = all.map(summary => {\n    let score = 0;\n\n    // Exact ID prefix match (highest priority)\n    if (summary.id.toLowerCase().startsWith(q)) {\n      score += 100;\n    } else if (summary.id.toLowerCase().includes(q)) {\n      score += 50;\n    }\n\n    // Title match\n    const title = summary.title.toLowerCase();\n    if (title === q) {\n      score += 90;\n    } else if (title.startsWith(q)) {\n      score += 70;\n    } else if (title.includes(q)) {\n      score += 40;\n    }\n\n    // Tag match\n    const tagMatch = summary.tags?.some(t => t.toLowerCase().includes(q));\n    if (tagMatch) score += 60;\n\n    // Model match\n    if (summary.model.toLowerCase().includes(q)) {\n      score += 20;\n    }\n\n    // Word-level fuzzy: check if all query words appear somewhere\n    const queryWords = q.split(/\\s+/);\n    const tagStr = (summary.tags ?? []).join(' ');\n    const haystack = `${summary.id} ${summary.title} ${summary.model} ${tagStr}`.toLowerCase();\n    const allWordsMatch = queryWords.every(w => haystack.includes(w));\n    if (allWordsMatch && queryWords.length > 1) {\n      score += 30;\n    }\n\n    // Search message content (first 6 messages only for performance)\n    const fullSession = sessionContentMap.get(summary.id);\n    if (fullSession) {\n      const contentMessages = fullSession.messages.slice(0, 6);\n      for (const msg of contentMessages) {\n        const content = typeof msg.content === 'string' ? msg.content : '';\n        if (content.toLowerCase().includes(q)) {\n          score += 40; // content match\n          break; // one match is enough\n        }\n      }\n    }\n\n    return { session: summary, score };\n  });\n\n  return scored\n    .filter(s => s.score > 0)\n    .sort((a, b) => b.score - a.score)\n    .map(s => s.session);\n}\n\n// --- Tag & Rename ---\n\nexport async function tagSession(id: string, tags: string[]): Promise<void> {\n  const session = await loadSession(id);\n  session.tags = [...new Set([...session.tags, ...tags])];\n  await saveSession(session);\n}\n\nexport async function untagSession(id: string, tags: string[]): Promise<void> {\n  const session = await loadSession(id);\n  session.tags = session.tags.filter(t => !tags.includes(t));\n  await saveSession(session);\n}\n\nexport async function renameSession(id: string, title: string): Promise<void> {\n  const session = await loadSession(id);\n  session.title = title;\n  await saveSession(session);\n}\n\n// --- Helpers ---\n\nexport function generateTitle(firstMessage: string): string {\n  return firstMessage.trim().slice(0, 60).replace(/\\n/g, ' ');\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/policy/engine.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, value is always truthy.","line":67,"column":10,"nodeType":"Literal","messageId":"alwaysTruthy","endLine":67,"endColumn":14},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, comparison is always true, since `\"full\" === \"full\"` is true.","line":139,"column":7,"nodeType":"BinaryExpression","messageId":"comparisonBetweenLiteralTypes","endLine":139,"endColumn":29}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { mkdir, open, readFile, rename, unlink, writeFile } from 'node:fs/promises';\nimport { dirname, join } from 'node:path';\nimport {\n  PolicyConfigSchema,\n  PolicyRequestSchema,\n  type PolicyAuditEntry,\n  type PolicyConfig,\n  type PolicyDecisionResult,\n  type PolicyRequest,\n} from './types.js';\nimport { sleep } from '../utils/common.js';\n\nconst AUDIT_RELATIVE_PATH = join('.opta', 'policy', 'audit.jsonl');\n\nexport interface PolicyEngineOptions {\n  cwd?: string;\n  now?: () => Date;\n  lockTimeoutMs?: number;\n  lockRetryMs?: number;\n}\n\nfunction toErrorMessage(error: unknown): string {\n  if (error instanceof Error) return error.message;\n  return String(error);\n}\n\nfunction fallbackAction(request: unknown): string {\n  if (\n    request !== null &&\n    request !== undefined &&\n    typeof request === 'object' &&\n    'action' in request &&\n    typeof (request as { action?: unknown }).action === 'string'\n  ) {\n    return (request as { action: string }).action;\n  }\n  return 'unknown-action';\n}\n\nfunction fallbackAutonomous(request: unknown): boolean {\n  if (\n    request !== null &&\n    request !== undefined &&\n    typeof request === 'object' &&\n    'autonomous' in request &&\n    typeof (request as { autonomous?: unknown }).autonomous === 'boolean'\n  ) {\n    return (request as { autonomous: boolean }).autonomous;\n  }\n  return true;\n}\n\nexport function policyAuditPath(cwd = process.cwd()): string {\n  return join(cwd, AUDIT_RELATIVE_PATH);\n}\n\nfunction policyAuditDir(cwd = process.cwd()): string {\n  return dirname(policyAuditPath(cwd));\n}\n\nfunction policyAuditLockPath(cwd = process.cwd()): string {\n  return `${policyAuditPath(cwd)}.lock`;\n}\n\nasync function acquireLock(lockPath: string, timeoutMs: number, retryMs: number) {\n  const start = Date.now();\n  while (true) {\n    try {\n      return await open(lockPath, 'wx');\n    } catch (error) {\n      const err = error as NodeJS.ErrnoException;\n      if (err.code !== 'EEXIST') {\n        throw err;\n      }\n      if (Date.now() - start >= timeoutMs) {\n        throw new Error(`Timed out waiting for policy audit lock: ${lockPath}`);\n      }\n      await sleep(retryMs);\n    }\n  }\n}\n\nasync function readAuditFile(path: string): Promise<string> {\n  try {\n    return await readFile(path, 'utf-8');\n  } catch (error) {\n    const err = error as NodeJS.ErrnoException;\n    if (err.code === 'ENOENT') {\n      return '';\n    }\n    throw err;\n  }\n}\n\nasync function appendAuditEntryAtomic(\n  entry: PolicyAuditEntry,\n  options: PolicyEngineOptions,\n): Promise<void> {\n  const cwd = options.cwd ?? process.cwd();\n  const timeoutMs = options.lockTimeoutMs ?? 5000;\n  const retryMs = options.lockRetryMs ?? 20;\n  const auditPath = policyAuditPath(cwd);\n  const auditDir = policyAuditDir(cwd);\n  const lockPath = policyAuditLockPath(cwd);\n\n  await mkdir(auditDir, { recursive: true });\n  const lockHandle = await acquireLock(lockPath, timeoutMs, retryMs);\n  let tempPath = '';\n\n  try {\n    const current = await readAuditFile(auditPath);\n    tempPath = `${auditPath}.${process.pid}.${Date.now()}.tmp`;\n    await writeFile(tempPath, `${current}${JSON.stringify(entry)}\\n`, 'utf-8');\n    await rename(tempPath, auditPath);\n  } finally {\n    if (tempPath) {\n      await unlink(tempPath).catch(() => {});\n    }\n    await lockHandle.close().catch(() => {});\n    await unlink(lockPath).catch(() => {});\n  }\n}\n\nfunction evaluateFullMode(\n  config: PolicyConfig,\n  request: PolicyRequest,\n  ts: string,\n): PolicyDecisionResult {\n  if (!config.enabled || config.mode === 'off') {\n    return {\n      decision: 'allow',\n      reason: 'Policy disabled or mode is off.',\n      mode: config.mode,\n      action: request.action,\n      ts,\n    };\n  }\n\n  if (config.mode === 'full' && config.gateAllAutonomy && request.autonomous) {\n    return {\n      decision: 'gate',\n      reason: 'Full mode gate-all rule requires approval for autonomous actions.',\n      mode: config.mode,\n      action: request.action,\n      ts,\n    };\n  }\n\n  return {\n    decision: 'allow',\n    reason: 'Allowed by full policy mode checks.',\n    mode: config.mode,\n    action: request.action,\n    ts,\n  };\n}\n\nfunction shouldFailClosed(config: unknown): boolean {\n  const parsed = PolicyConfigSchema.safeParse(config);\n  if (parsed.success) {\n    return parsed.data.failureMode === 'closed';\n  }\n  return true;\n}\n\nfunction failClosedDecision(\n  request: unknown,\n  ts: string,\n  reason: string,\n): PolicyDecisionResult {\n  return {\n    decision: 'deny',\n    reason: `Fail-closed: ${reason}`,\n    mode: 'full',\n    action: fallbackAction(request),\n    ts,\n  };\n}\n\nfunction failOpenDecision(\n  request: unknown,\n  ts: string,\n  reason: string,\n): PolicyDecisionResult {\n  return {\n    decision: 'allow',\n    reason: `Fail-open fallback: ${reason}`,\n    mode: 'full',\n    action: fallbackAction(request),\n    ts,\n  };\n}\n\nasync function auditIfEnabled(\n  config: PolicyConfig,\n  request: PolicyRequest,\n  decision: PolicyDecisionResult,\n  options: PolicyEngineOptions,\n): Promise<void> {\n  if (!config.audit.enabled) return;\n\n  await appendAuditEntryAtomic(\n    {\n      ...decision,\n      autonomous: request.autonomous,\n      actor: request.actor,\n      metadata: request.metadata,\n    },\n    options,\n  );\n}\n\nexport async function evaluatePolicyRequest(\n  configInput: PolicyConfig,\n  requestInput: PolicyRequest,\n  options: PolicyEngineOptions = {},\n): Promise<PolicyDecisionResult> {\n  const now = options.now ?? (() => new Date());\n  const ts = now().toISOString();\n\n  try {\n    const parsedConfig = PolicyConfigSchema.parse(configInput);\n    const parsedRequest = PolicyRequestSchema.parse(requestInput);\n\n    const decision = evaluateFullMode(parsedConfig, parsedRequest, ts);\n    await auditIfEnabled(parsedConfig, parsedRequest, decision, options);\n    return decision;\n  } catch (error) {\n    const reason = toErrorMessage(error);\n    if (shouldFailClosed(configInput)) {\n      const denied = failClosedDecision(requestInput, ts, reason);\n      const parsedConfig = PolicyConfigSchema.safeParse(configInput);\n      if (parsedConfig.success && parsedConfig.data.audit.enabled) {\n        await appendAuditEntryAtomic(\n          {\n            ...denied,\n            autonomous: fallbackAutonomous(requestInput),\n            actor: 'policy-engine',\n            metadata: { error: reason },\n          },\n          options,\n        ).catch(() => {});\n      }\n      return denied;\n    }\n\n    return failOpenDecision(requestInput, ts, reason);\n  }\n}\n\nexport class PolicyEngine {\n  constructor(\n    private readonly config: PolicyConfig,\n    private readonly options: PolicyEngineOptions = {},\n  ) {}\n\n  async decide(request: PolicyRequest): Promise<PolicyDecisionResult> {\n    return evaluatePolicyRequest(this.config, request, this.options);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/policy/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/protocol/v3/events.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/protocol/v3/http.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/protocol/v3/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/protocol/v3/ws.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/providers/anthropic.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":26,"column":40,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":26,"endColumn":42,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[931,933],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":26,"column":51,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":26,"endColumn":53,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[942,944],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/require-await","severity":1,"message":"Async method 'listModels' has no 'await' expression.","line":48,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":48,"endColumn":19,"suggestions":[{"messageId":"removeAsync","fix":{"range":[1501,1549],"text":"listModels(): ProviderModelInfo[]"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":59,"column":40,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":59,"endColumn":42,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[2037,2039],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":59,"column":51,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":59,"endColumn":53,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[2048,2050],"text":"."},"desc":"Remove unnecessary optional chain"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Anthropic provider  uses the Anthropic SDK with an OpenAI-compatible wrapper.\n *\n * The agent loop uses OpenAI SDK types, so we use Anthropic's OpenAI compatibility\n * layer (@anthropic-ai/sdk provides an OpenAI-compatible client) rather than\n * converting message formats manually.\n */\n\nimport type { ProviderClient, ProviderModelInfo, ProviderHealthResult } from './base.js';\nimport type { OptaConfig } from '../core/config.js';\nimport { errorMessage } from '../utils/errors.js';\n\nexport class AnthropicProvider implements ProviderClient {\n  readonly name = 'anthropic';\n  private client: import('openai').default | null = null;\n  private config: OptaConfig;\n\n  constructor(config: OptaConfig) {\n    this.config = config;\n  }\n\n  async getClient(): Promise<import('openai').default> {\n    if (this.client) return this.client;\n\n    const { default: OpenAI } = await import('openai');\n    const apiKey = this.config.provider?.anthropic?.apiKey || process.env['ANTHROPIC_API_KEY'] || '';\n\n    if (!apiKey) {\n      throw new Error(\n        'Anthropic API key required.\\n\\n' +\n        'Set it via:\\n' +\n        '  opta config set provider.anthropic.apiKey sk-ant-...\\n' +\n        '  or export ANTHROPIC_API_KEY=sk-ant-...'\n      );\n    }\n\n    // Use Anthropic's OpenAI-compatible endpoint\n    this.client = new OpenAI({\n      baseURL: 'https://api.anthropic.com/v1/',\n      apiKey,\n      defaultHeaders: {\n        'anthropic-version': '2023-06-01',\n      },\n    });\n    return this.client;\n  }\n\n  async listModels(): Promise<ProviderModelInfo[]> {\n    // Anthropic doesn't have a models list endpoint; return known models\n    return [\n      { id: 'claude-opus-4-6', name: 'Claude Opus 4.6', contextLength: 200000 },\n      { id: 'claude-sonnet-4-5-20250929', name: 'Claude Sonnet 4.5', contextLength: 200000 },\n      { id: 'claude-haiku-4-5-20251001', name: 'Claude Haiku 4.5', contextLength: 200000 },\n    ];\n  }\n\n  async health(): Promise<ProviderHealthResult> {\n    const start = Date.now();\n    const apiKey = this.config.provider?.anthropic?.apiKey || process.env['ANTHROPIC_API_KEY'] || '';\n\n    if (!apiKey) {\n      return {\n        ok: false,\n        latencyMs: Date.now() - start,\n        error: 'No API key configured',\n      };\n    }\n\n    try {\n      // Simple connectivity check  HEAD request to API\n      const res = await fetch('https://api.anthropic.com/v1/messages', {\n        method: 'POST',\n        headers: {\n          'x-api-key': apiKey,\n          'anthropic-version': '2023-06-01',\n          'content-type': 'application/json',\n        },\n        body: JSON.stringify({ model: 'claude-haiku-4-5-20251001', max_tokens: 1, messages: [{ role: 'user', content: 'hi' }] }),\n        signal: AbortSignal.timeout(10000),\n      });\n      return {\n        ok: res.ok,\n        latencyMs: Date.now() - start,\n        error: res.ok ? undefined : `HTTP ${res.status}`,\n      };\n    } catch (err) {\n      return {\n        ok: false,\n        latencyMs: Date.now() - start,\n        error: errorMessage(err),\n      };\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/providers/base.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/providers/fallback.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":31,"column":35,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":31,"endColumn":37,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1071,1073],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":31,"column":46,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":31,"endColumn":48,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1082,1084],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/return-await","severity":1,"message":"Returning an awaited promise is required in this context.","line":43,"column":16,"nodeType":"CallExpression","messageId":"requiredPromiseAwait","endLine":43,"endColumn":40,"suggestions":[{"messageId":"requiredPromiseAwaitSuggestion","fix":{"range":[1518,1518],"text":"await "},"desc":"Add `await` before the expression. Use caution as this may impact control flow."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Fallback provider  wraps LMX with automatic Anthropic degradation.\n *\n * When fallbackOnFailure is enabled, attempts LMX first for every operation.\n * On connection failure, transparently falls back to the Anthropic provider.\n */\n\nimport type { ProviderClient, ProviderModelInfo, ProviderHealthResult } from './base.js';\nimport type { OptaConfig } from '../core/config.js';\n\nexport class FallbackProvider implements ProviderClient {\n  readonly name = 'lmx+fallback';\n  private primary: ProviderClient;\n  private fallback: ProviderClient | null = null;\n  private config: OptaConfig;\n  private usingFallback = false;\n\n  constructor(primary: ProviderClient, config: OptaConfig) {\n    this.primary = primary;\n    this.config = config;\n  }\n\n  private async getFallback(): Promise<ProviderClient> {\n    if (this.fallback) return this.fallback;\n    const { AnthropicProvider } = await import('./anthropic.js');\n    this.fallback = new AnthropicProvider(this.config);\n    return this.fallback;\n  }\n\n  private hasFallbackKey(): boolean {\n    return !!(this.config.provider?.anthropic?.apiKey || process.env['ANTHROPIC_API_KEY']);\n  }\n\n  async getClient(): Promise<import('openai').default> {\n    // Try primary (LMX) first with a quick health check\n    try {\n      const health = await this.primary.health();\n      if (health.ok) {\n        if (this.usingFallback) {\n          console.error('[opta] LMX recovered  switching back from Anthropic fallback');\n          this.usingFallback = false;\n        }\n        return this.primary.getClient();\n      }\n    } catch {\n      // Health check failed  try fallback\n    }\n\n    // LMX unreachable  try Anthropic fallback\n    if (this.hasFallbackKey()) {\n      if (!this.usingFallback) {\n        console.error('[opta] LMX unreachable  falling back to Anthropic');\n        this.usingFallback = true;\n      }\n      const fb = await this.getFallback();\n      return fb.getClient();\n    }\n\n    // No fallback available  return primary client anyway (will fail at request time)\n    return this.primary.getClient();\n  }\n\n  async listModels(): Promise<ProviderModelInfo[]> {\n    try {\n      return await this.primary.listModels();\n    } catch {\n      if (this.hasFallbackKey()) {\n        const fb = await this.getFallback();\n        return fb.listModels();\n      }\n      throw new Error('LMX unreachable and no Anthropic fallback configured');\n    }\n  }\n\n  async health(): Promise<ProviderHealthResult> {\n    const primary = await this.primary.health();\n    if (primary.ok) return primary;\n\n    if (this.hasFallbackKey()) {\n      const fb = await this.getFallback();\n      const fallback = await fb.health();\n      return {\n        ...fallback,\n        error: fallback.ok\n          ? `LMX down, using Anthropic fallback (${primary.error})`\n          : `Both LMX and Anthropic unreachable`,\n      };\n    }\n\n    return primary;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/providers/lmx.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/providers/manager.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":24,"column":18,"nodeType":"ChainExpression","messageId":"neverNullish","endLine":24,"endColumn":41},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":24,"column":33,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":24,"endColumn":35,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[969,971],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":25,"column":35,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":25,"endColumn":37,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1022,1024],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":27,"column":28,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":27,"endColumn":59},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":34,"column":33,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":34,"endColumn":35,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1479,1481],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":34,"column":44,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":34,"endColumn":46,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1490,1492],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":44,"column":18,"nodeType":"ChainExpression","messageId":"neverNullish","endLine":44,"endColumn":41},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":44,"column":33,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":44,"endColumn":35,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1827,1829],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":53,"column":24,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":53,"endColumn":26,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[2127,2129],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":87,"column":18,"nodeType":"ChainExpression","messageId":"neverNullish","endLine":87,"endColumn":41},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":87,"column":33,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":87,"endColumn":35,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[3241,3243],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/return-await","severity":1,"message":"Returning an awaited promise is required in this context.","line":108,"column":14,"nodeType":"CallExpression","messageId":"requiredPromiseAwait","endLine":108,"endColumn":33,"suggestions":[{"messageId":"requiredPromiseAwaitSuggestion","fix":{"range":[4171,4171],"text":"await "},"desc":"Add `await` before the expression. Use caution as this may impact control flow."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":118,"column":39,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":118,"endColumn":41,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[4542,4544],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":118,"column":50,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":118,"endColumn":52,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[4553,4555],"text":"."},"desc":"Remove unnecessary optional chain"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Provider manager  factory for selecting the active LLM provider.\n *\n * Reads config.provider.active to determine which provider to use.\n * When fallbackOnFailure is enabled, wraps LMX in a FallbackProvider\n * that auto-degrades to Anthropic on connection failure.\n * Caches provider instances by config key to avoid re-creation.\n *\n * Zero-config fallback:\n * probeProvider() performs a fast LMX health check (2s) before the first\n * agent turn. If LMX is unreachable it silently returns an Anthropic provider.\n * This lets fresh installs work immediately when ANTHROPIC_API_KEY is set.\n */\n\nimport type { ProviderClient } from './base.js';\nimport type { OptaConfig } from '../core/config.js';\nimport { resolveLmxApiKey } from '../lmx/api-key.js';\nimport { verbose } from '../core/debug.js';\n\nlet cachedProvider: ProviderClient | null = null;\nlet cachedProviderKey = '';\n\nfunction providerCacheKey(config: OptaConfig): string {\n  const active = config.provider?.active ?? 'lmx';\n  const fallback = config.provider?.fallbackOnFailure ? '+fb' : '';\n  if (active === 'lmx') {\n    const fallbackHosts = (config.connection.fallbackHosts ?? [])\n      .map((host) => host.trim().toLowerCase())\n      .filter((host) => host.length > 0)\n      .join(',');\n    const apiKeyPrefix = resolveLmxApiKey(config.connection).slice(0, 8);\n    return `lmx${fallback}|${config.connection.host}:${config.connection.port}|${fallbackHosts}|${apiKeyPrefix}`;\n  }\n  const apiKey = config.provider?.anthropic?.apiKey || process.env['ANTHROPIC_API_KEY'] || '';\n  return `anthropic|${apiKey.slice(0, 8)}`;\n}\n\nexport async function getProvider(config: OptaConfig): Promise<ProviderClient> {\n  const key = providerCacheKey(config);\n  if (cachedProvider && cachedProviderKey === key) {\n    return cachedProvider;\n  }\n\n  const active = config.provider?.active ?? 'lmx';\n\n  if (active === 'anthropic') {\n    const { AnthropicProvider } = await import('./anthropic.js');\n    cachedProvider = new AnthropicProvider(config);\n  } else {\n    const { LmxProvider } = await import('./lmx.js');\n    const lmx = new LmxProvider(config);\n\n    if (config.provider?.fallbackOnFailure) {\n      const { FallbackProvider } = await import('./fallback.js');\n      cachedProvider = new FallbackProvider(lmx, config);\n    } else {\n      cachedProvider = lmx;\n    }\n  }\n\n  cachedProviderKey = key;\n  return cachedProvider;\n}\n\n/** Reset the cached provider (useful for testing or config reload). */\nexport function resetProviderCache(): void {\n  cachedProvider = null;\n  cachedProviderKey = '';\n}\n\n/**\n * Zero-config provider probe.\n *\n * Performs a fast health check against the configured LMX endpoint\n * (2 second timeout). If LMX is reachable, returns the normal LMX\n * provider. If LMX is unreachable or not configured:\n *\n *   - ANTHROPIC_API_KEY is set  silently returns an Anthropic provider\n *   - No ANTHROPIC_API_KEY      throws a descriptive error\n *\n * In verbose mode (`--verbose`), logs which path was taken.\n *\n * This is the preferred entry-point for the chat startup path so that\n * first-run users with only an Anthropic key work out of the box.\n */\nexport async function probeProvider(config: OptaConfig): Promise<ProviderClient> {\n  const active = config.provider?.active ?? 'lmx';\n\n  // When the user has explicitly configured Anthropic, honour that.\n  if (active === 'anthropic') {\n    verbose('Provider probe: user configured Anthropic, skipping LMX probe');\n    const { AnthropicProvider } = await import('./anthropic.js');\n    return new AnthropicProvider(config);\n  }\n\n  // Probe LMX with a short timeout so we don't slow down normal usage.\n  const PROBE_TIMEOUT_MS = 2_000;\n  const host = config.connection.host;\n  const port = config.connection.port;\n\n  try {\n    const { probeLmxConnection } = await import('../lmx/connection.js');\n    const result = await probeLmxConnection(host, port, { timeoutMs: PROBE_TIMEOUT_MS });\n\n    if (result.state !== 'disconnected') {\n      verbose(`Provider probe: LMX reachable at ${host}:${port} (state=${result.state}, ${result.latencyMs}ms)`);\n      // LMX is reachable  use the normal provider (with FallbackProvider if configured).\n      return getProvider(config);\n    }\n\n    verbose(`Provider probe: LMX unreachable at ${host}:${port}  ${result.reason ?? 'no response'}`);\n  } catch (err) {\n    const msg = err instanceof Error ? err.message : String(err);\n    verbose(`Provider probe: LMX probe threw  ${msg}`);\n  }\n\n  // LMX is unreachable  check for Anthropic fallback.\n  const anthropicKey = config.provider?.anthropic?.apiKey || process.env['ANTHROPIC_API_KEY'] || '';\n\n  if (anthropicKey) {\n    verbose('Provider probe: falling back to Anthropic (LMX unreachable, ANTHROPIC_API_KEY present)');\n    const { AnthropicProvider } = await import('./anthropic.js');\n    return new AnthropicProvider(config);\n  }\n\n  // No fallback available  throw a clear, actionable error.\n  throw new Error(\n    `LMX unreachable at ${host}:${port} and no ANTHROPIC_API_KEY set.\\n\\n` +\n    'Fix options:\\n' +\n    '  1. Start LMX server:         opta lmx start\\n' +\n    '  2. Use Anthropic cloud:      export ANTHROPIC_API_KEY=sk-ant-...\\n' +\n    '  3. Configure a different host: opta config set connection.host <host>',\n  );\n}\n\n/** Re-export types for convenience. */\nexport type { ProviderClient } from './base.js';\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/providers/model-scan.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":109,"column":24,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":109,"endColumn":26,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[2963,2965],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":109,"column":67,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":109,"endColumn":69,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[3006,3008],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":109,"column":78,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":109,"endColumn":80,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[3017,3019],"text":"."},"desc":"Remove unnecessary optional chain"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Shared model scanning service.\n *\n * Extracts the duplicated model discovery logic from commands/models.ts\n * and commands/slash/lmx.ts into a single, reusable service.\n */\n\nimport { LmxClient } from '../lmx/client.js';\nimport type {\n  LmxModelDetail,\n  LmxAvailableModel,\n  LmxPreset,\n  LmxStackRole,\n  LmxMemoryResponse,\n  LmxRequestOptions,\n} from '../lmx/client.js';\nimport type { ProviderModelInfo } from './base.js';\nimport type { OptaConfig } from '../core/config.js';\n\n// --- Scan Result ---\n\nexport interface ScanResult {\n  loaded: LmxModelDetail[];\n  available: LmxAvailableModel[];\n  presets: LmxPreset[];\n  roles: Record<string, LmxStackRole>;\n  memory: LmxMemoryResponse | null;\n  cloud: ProviderModelInfo[];\n  cloudHealthy: boolean;\n  lmxReachable: boolean;\n}\n\nconst FAST_SCAN_REQUEST_OPTS: LmxRequestOptions = {\n  timeoutMs: 5_000,\n  maxRetries: 0,\n};\n\n// --- Formatting Helpers ---\n\nexport function shortId(id: string): string {\n  return id\n    .replace(/^mlx-community\\//, '')\n    .replace(/^huggingface\\//, '');\n}\n\nexport function fmtGB(bytes: number): string {\n  return `${(bytes / 1e9).toFixed(1)}GB`;\n}\n\nexport function fmtCtx(tokens: number): string {\n  return `${(tokens / 1000).toFixed(0)}K ctx`;\n}\n\n// --- Role Lookup ---\n\n/**\n * Build a map from model_id to the stack role names assigned to it.\n */\nexport function buildRoleMap(roles: Record<string, LmxStackRole>): Map<string, string[]> {\n  const roleMap = new Map<string, string[]>();\n  for (const [role, info] of Object.entries(roles)) {\n    if (info.resolved_model) {\n      const existing = roleMap.get(info.resolved_model) ?? [];\n      existing.push(role);\n      roleMap.set(info.resolved_model, existing);\n    }\n  }\n  return roleMap;\n}\n\n// --- Core Scan Function ---\n\n/**\n * Gather model data from LMX server and cloud providers in parallel.\n * Both the CLI `opta models scan` command and the `/scan` slash command\n * should call this instead of duplicating the query logic.\n */\nexport async function scanModels(config: OptaConfig): Promise<ScanResult> {\n  const { host, port } = config.connection;\n  const client = new LmxClient({\n    host,\n    fallbackHosts: config.connection.fallbackHosts,\n    port,\n    adminKey: config.connection.adminKey,\n  });\n\n  const result: ScanResult = {\n    loaded: [],\n    available: [],\n    presets: [],\n    roles: {},\n    memory: null,\n    cloud: [],\n    cloudHealthy: false,\n    lmxReachable: false,\n  };\n\n  // Query LMX endpoints in parallel (all may fail if LMX is down)\n  const lmxPromises = Promise.all([\n    client.models(FAST_SCAN_REQUEST_OPTS).catch(() => null),\n    client.available(FAST_SCAN_REQUEST_OPTS).catch(() => null),\n    client.presets(FAST_SCAN_REQUEST_OPTS).catch(() => null),\n    client.stack(FAST_SCAN_REQUEST_OPTS).catch(() => null),\n    client.memory(FAST_SCAN_REQUEST_OPTS).catch(() => null),\n  ]);\n\n  // Query Anthropic provider in parallel with LMX\n  const anthropicPromise = (async () => {\n    if (config.provider?.active === 'anthropic' || config.provider?.anthropic?.apiKey || process.env['ANTHROPIC_API_KEY']) {\n      try {\n        const { getProvider } = await import('./manager.js');\n        const anthropicConfig = { ...config, provider: { ...config.provider, active: 'anthropic' as const } };\n        const provider = await getProvider(anthropicConfig);\n        const models = await provider.listModels();\n        const health = await provider.health();\n        return { models, healthy: health.ok };\n      } catch {\n        return { models: [] as ProviderModelInfo[], healthy: false };\n      }\n    }\n    return { models: [] as ProviderModelInfo[], healthy: false };\n  })();\n\n  const [lmxResults, anthropicResult] = await Promise.all([lmxPromises, anthropicPromise]);\n  const [modelsRes, availRes, presetsRes, stackRes, memRes] = lmxResults;\n\n  if (modelsRes) {\n    result.loaded = modelsRes.models;\n    result.lmxReachable = true;\n  }\n  if (availRes) {\n    result.available = availRes;\n    result.lmxReachable = true;\n  }\n  if (presetsRes) {\n    result.presets = presetsRes.presets;\n  }\n  if (stackRes) {\n    result.roles = stackRes.roles;\n  }\n  if (memRes) {\n    result.memory = memRes;\n  }\n\n  result.cloud = anthropicResult.models;\n  result.cloudHealthy = anthropicResult.healthy;\n\n  return result;\n}\n\n// --- Scan Summary ---\n\nexport interface ScanSummary {\n  loadedCount: number;\n  onDiskCount: number;\n  presetCount: number;\n  cloudCount: number;\n}\n\n/**\n * Compute summary counts from a scan result.\n */\nexport function summarizeScan(scan: ScanResult): ScanSummary {\n  const loadedIds = new Set(scan.loaded.map(m => m.model_id));\n  return {\n    loadedCount: scan.loaded.length,\n    onDiskCount: scan.available.filter(a => !loadedIds.has(a.repo_id)).length,\n    presetCount: scan.presets.length,\n    cloudCount: scan.cloud.length,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/research/health.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":1,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":36,"column":13,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":36,"endColumn":46,"fix":{"range":[1115,1137],"text":""}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { createResearchRegistry } from './registry.js';\nimport { makeProviderError, toErrorMessage } from './providers/shared.js';\nimport type {\n  ResearchConfigInput,\n  ResearchProvider,\n  ResearchProviderHealth,\n  ResearchProviderId,\n} from './types.js';\n\nexport interface ResearchHealthCheckOptions {\n  config?: ResearchConfigInput | Record<string, unknown> | null;\n  providers?: ResearchProvider[];\n}\n\nexport interface ResearchHealthSummary {\n  ok: boolean;\n  checks: ResearchProviderHealth[];\n}\n\nexport async function checkResearchProviderHealth(\n  options: ResearchHealthCheckOptions = {},\n): Promise<ResearchHealthSummary> {\n  const providers = options.providers ?? createResearchRegistry(options.config);\n\n  const checks = await Promise.all(\n    providers.map(async (provider): Promise<ResearchProviderHealth> => {\n      try {\n        return await provider.healthCheck();\n      } catch (error) {\n        return {\n          provider: provider.id,\n          status: 'unhealthy',\n          latencyMs: 0,\n          checkedAt: new Date().toISOString(),\n          error: makeProviderError(\n            provider.id as ResearchProviderId,\n            'UNKNOWN_ERROR',\n            `Health check failed unexpectedly: ${toErrorMessage(error, 'unknown error')}`,\n          ),\n        };\n      }\n    }),\n  );\n\n  return {\n    ok: checks.length > 0 && checks.every((check) => check.status !== 'unhealthy'),\n    checks,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/research/providers/brave.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/research/providers/exa.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/research/providers/gemini.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":24,"column":9,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":24,"endColumn":39}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type {\n  ResearchProvider,\n  ResearchProviderConfig,\n  ResearchProviderHealth,\n  ResearchProviderResult,\n  ResearchQuery,\n} from '../types.js';\nimport {\n  asString,\n  fetchJsonWithErrors,\n  isRecord,\n  lightweightHealthPing,\n  makeProviderFailure,\n  makeProviderSuccess,\n  normalizeCitation,\n  sanitizeTimeoutMs,\n} from './shared.js';\n\nconst DEFAULT_GEMINI_BASE_URL = 'https://generativelanguage.googleapis.com/v1beta/models';\nconst DEFAULT_GEMINI_MODEL = 'gemini-2.0-flash';\n\nfunction extractGeminiAnswer(payload: Record<string, unknown>): string {\n  const candidates = Array.isArray(payload['candidates']) ? payload['candidates'] : [];\n  const firstCandidate = candidates[0];\n  if (!isRecord(firstCandidate)) return '';\n\n  const content = isRecord(firstCandidate['content']) ? firstCandidate['content'] : {};\n  const parts = Array.isArray(content['parts']) ? content['parts'] : [];\n\n  const segments: string[] = [];\n  for (const part of parts) {\n    if (!isRecord(part)) continue;\n    const text = asString(part['text']);\n    if (text) segments.push(text);\n  }\n\n  return segments.join(' ').trim();\n}\n\nfunction extractGeminiCitations(payload: Record<string, unknown>) {\n  const candidates = Array.isArray(payload['candidates']) ? payload['candidates'] : [];\n\n  const citations = [];\n  for (const candidate of candidates) {\n    if (!isRecord(candidate)) continue;\n\n    const metadata = isRecord(candidate['groundingMetadata']) ? candidate['groundingMetadata'] : {};\n    const chunks = Array.isArray(metadata['groundingChunks']) ? metadata['groundingChunks'] : [];\n\n    for (const chunk of chunks) {\n      if (!isRecord(chunk)) continue;\n      const web = isRecord(chunk['web']) ? chunk['web'] : {};\n      const citation = normalizeCitation({\n        title: web['title'],\n        url: web['uri'],\n        source: 'gemini',\n      });\n      if (citation) citations.push(citation);\n    }\n  }\n\n  return citations;\n}\n\nexport class GeminiResearchProvider implements ResearchProvider {\n  readonly id = 'gemini' as const;\n  readonly enabled: boolean;\n  readonly timeoutMs: number;\n\n  private readonly apiKey?: string;\n  private readonly baseUrl: string;\n  private readonly model: string;\n\n  constructor(config: ResearchProviderConfig = {}) {\n    this.enabled = config.enabled === true;\n    this.timeoutMs = sanitizeTimeoutMs(config.timeoutMs);\n    this.apiKey = asString(config.apiKey);\n    this.baseUrl = (asString(config.baseUrl) ?? DEFAULT_GEMINI_BASE_URL).replace(/\\/+$/, '');\n    this.model = asString(config.model) ?? DEFAULT_GEMINI_MODEL;\n  }\n\n  async search(query: ResearchQuery): Promise<ResearchProviderResult> {\n    if (!this.enabled) {\n      return makeProviderFailure(this.id, 'PROVIDER_DISABLED', 'Gemini provider is disabled.', { retryable: false });\n    }\n\n    if (!this.apiKey) {\n      return makeProviderFailure(this.id, 'MISSING_API_KEY', 'Gemini API key is missing.', { retryable: false });\n    }\n\n    const endpoint = `${this.baseUrl}/${this.model}:generateContent?key=${encodeURIComponent(this.apiKey)}`;\n\n    const response = await fetchJsonWithErrors(\n      this.id,\n      endpoint,\n      {\n        method: 'POST',\n        headers: {\n          'content-type': 'application/json',\n        },\n        body: JSON.stringify({\n          contents: [\n            {\n              role: 'user',\n              parts: [{ text: query.query }],\n            },\n          ],\n          generationConfig: {\n            temperature: 0.2,\n          },\n        }),\n        signal: AbortSignal.timeout(this.timeoutMs),\n      },\n    );\n\n    if (!response.ok) {\n      return {\n        ok: false,\n        provider: this.id,\n        error: response.error,\n      };\n    }\n\n    const payload = response.data;\n    if (!isRecord(payload)) {\n      return makeProviderFailure(this.id, 'INVALID_RESPONSE', 'Gemini payload is not an object.', { retryable: false });\n    }\n\n    const answer = extractGeminiAnswer(payload);\n    const citations = extractGeminiCitations(payload);\n\n    return makeProviderSuccess(\n      this.id,\n      query,\n      answer || 'No summary returned by Gemini.',\n      citations,\n      payload,\n    );\n  }\n\n  async healthCheck(): Promise<ResearchProviderHealth> {\n    return lightweightHealthPing({\n      provider: this.id,\n      enabled: this.enabled,\n      timeoutMs: Math.min(this.timeoutMs, 5_000),\n      url: this.baseUrl,\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/research/providers/groq.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":104,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":104,"endColumn":35}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type {\n  ResearchProvider,\n  ResearchProviderConfig,\n  ResearchProviderHealth,\n  ResearchProviderResult,\n  ResearchQuery,\n} from '../types.js';\nimport {\n  asString,\n  extractUrlsFromText,\n  fetchJsonWithErrors,\n  isRecord,\n  lightweightHealthPing,\n  makeProviderFailure,\n  makeProviderSuccess,\n  normalizeCitation,\n  sanitizeTimeoutMs,\n} from './shared.js';\n\nconst DEFAULT_GROQ_BASE_URL = 'https://api.groq.com/openai/v1';\nconst DEFAULT_GROQ_MODEL = 'llama-3.3-70b-versatile';\n\nfunction intentSystemPrompt(intent: ResearchQuery['intent']): string {\n  switch (intent) {\n    case 'coding':\n      return 'Provide technically accurate and concise developer-focused research answers with source links.';\n    case 'news':\n      return 'Summarize timely information with clear, current source references.';\n    case 'academic':\n      return 'Provide evidence-focused synthesis and include relevant source links.';\n    case 'general':\n    default:\n      return 'Provide a concise research summary and include relevant source links.';\n  }\n}\n\nexport class GroqResearchProvider implements ResearchProvider {\n  readonly id = 'groq' as const;\n  readonly enabled: boolean;\n  readonly timeoutMs: number;\n\n  private readonly apiKey?: string;\n  private readonly baseUrl: string;\n  private readonly model: string;\n\n  constructor(config: ResearchProviderConfig = {}) {\n    this.enabled = config.enabled === true;\n    this.timeoutMs = sanitizeTimeoutMs(config.timeoutMs);\n    this.apiKey = asString(config.apiKey);\n    this.baseUrl = (asString(config.baseUrl) ?? DEFAULT_GROQ_BASE_URL).replace(/\\/+$/, '');\n    this.model = asString(config.model) ?? DEFAULT_GROQ_MODEL;\n  }\n\n  async search(query: ResearchQuery): Promise<ResearchProviderResult> {\n    if (!this.enabled) {\n      return makeProviderFailure(this.id, 'PROVIDER_DISABLED', 'Groq provider is disabled.', { retryable: false });\n    }\n\n    if (!this.apiKey) {\n      return makeProviderFailure(this.id, 'MISSING_API_KEY', 'Groq API key is missing.', { retryable: false });\n    }\n\n    const response = await fetchJsonWithErrors(\n      this.id,\n      `${this.baseUrl}/chat/completions`,\n      {\n        method: 'POST',\n        headers: {\n          authorization: `Bearer ${this.apiKey}`,\n          'content-type': 'application/json',\n        },\n        body: JSON.stringify({\n          model: this.model,\n          messages: [\n            {\n              role: 'system',\n              content: intentSystemPrompt(query.intent),\n            },\n            {\n              role: 'user',\n              content: query.query,\n            },\n          ],\n          temperature: 0.2,\n        }),\n        signal: AbortSignal.timeout(this.timeoutMs),\n      },\n    );\n\n    if (!response.ok) {\n      return {\n        ok: false,\n        provider: this.id,\n        error: response.error,\n      };\n    }\n\n    const payload = response.data;\n    if (!isRecord(payload)) {\n      return makeProviderFailure(this.id, 'INVALID_RESPONSE', 'Groq payload is not an object.', { retryable: false });\n    }\n\n    const choices = Array.isArray(payload['choices']) ? payload['choices'] : [];\n    const firstChoice = choices[0];\n\n    let answer = '';\n    if (isRecord(firstChoice)) {\n      const message = isRecord(firstChoice['message']) ? firstChoice['message'] : {};\n      answer = asString(message['content']) ?? '';\n    }\n\n    const citationsFromPayload = Array.isArray(payload['citations']) ? payload['citations'] : [];\n    const mappedPayloadCitations = citationsFromPayload\n      .map((citation) => {\n        if (!isRecord(citation)) return null;\n        return normalizeCitation({\n          title: citation['title'],\n          url: citation['url'],\n          snippet: citation['snippet'],\n          source: 'groq',\n        });\n      })\n      .filter((citation): citation is NonNullable<typeof citation> => citation !== null);\n\n    const fallbackCitations = mappedPayloadCitations.length > 0\n      ? mappedPayloadCitations\n      : extractUrlsFromText(answer).map((url) => ({ url, source: 'groq' as const }));\n\n    return makeProviderSuccess(\n      this.id,\n      query,\n      answer || 'No summary returned by Groq.',\n      fallbackCitations,\n      payload,\n    );\n  }\n\n  async healthCheck(): Promise<ResearchProviderHealth> {\n    return lightweightHealthPing({\n      provider: this.id,\n      enabled: this.enabled,\n      timeoutMs: Math.min(this.timeoutMs, 5_000),\n      url: this.baseUrl,\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/research/providers/shared.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/research/providers/tavily.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/research/registry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/research/router.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":53,"column":25,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":53,"endColumn":54}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createResearchRegistry } from './registry.js';\nimport { makeProviderError, makeProviderFailure, toErrorMessage } from './providers/shared.js';\nimport type {\n  ResearchConfigInput,\n  ResearchProvider,\n  ResearchProviderId,\n  ResearchProviderResult,\n  ResearchQuery,\n  ResearchQueryIntent,\n  ResearchRouteAttempt,\n  ResearchRouteResult,\n} from './types.js';\n\nconst INTENT_FALLBACK_ORDER: Record<ResearchQueryIntent, ResearchProviderId[]> = {\n  general: ['tavily', 'exa', 'brave', 'gemini', 'groq'],\n  news: ['tavily', 'brave', 'exa', 'gemini', 'groq'],\n  academic: ['exa', 'tavily', 'gemini', 'brave', 'groq'],\n  coding: ['tavily', 'groq', 'gemini', 'exa', 'brave'],\n};\n\nexport interface RouteResearchOptions {\n  config?: ResearchConfigInput | Record<string, unknown> | null;\n  providers?: ResearchProvider[];\n  providerOrder?: ResearchProviderId[];\n}\n\nfunction uniqueOrder(input: ResearchProviderId[]): ResearchProviderId[] {\n  const seen = new Set<ResearchProviderId>();\n  const output: ResearchProviderId[] = [];\n\n  for (const providerId of input) {\n    if (seen.has(providerId)) continue;\n    seen.add(providerId);\n    output.push(providerId);\n  }\n\n  return output;\n}\n\nfunction resolveOrderedProviders(\n  providers: ResearchProvider[],\n  intent: ResearchQueryIntent,\n  explicitOrder?: ResearchProviderId[],\n): ResearchProvider[] {\n  const enabledProviders = providers.filter((provider) => provider.enabled);\n  if (enabledProviders.length === 0) return [];\n\n  const providerMap = new Map<ResearchProviderId, ResearchProvider>();\n  for (const provider of enabledProviders) {\n    providerMap.set(provider.id, provider);\n  }\n\n  const fallbackOrder = INTENT_FALLBACK_ORDER[intent] ?? INTENT_FALLBACK_ORDER.general;\n  const preferredOrder = explicitOrder && explicitOrder.length > 0\n    ? uniqueOrder([...explicitOrder, ...fallbackOrder])\n    : uniqueOrder([...fallbackOrder]);\n\n  const orderedProviders: ResearchProvider[] = [];\n\n  for (const providerId of preferredOrder) {\n    const provider = providerMap.get(providerId);\n    if (!provider) continue;\n    orderedProviders.push(provider);\n    providerMap.delete(providerId);\n  }\n\n  for (const provider of providerMap.values()) {\n    orderedProviders.push(provider);\n  }\n\n  return orderedProviders;\n}\n\nasync function executeWithTimeout(\n  provider: ResearchProvider,\n  query: ResearchQuery,\n): Promise<ResearchProviderResult> {\n  const timeoutMs = provider.timeoutMs > 0 ? provider.timeoutMs : 10_000;\n\n  return new Promise<ResearchProviderResult>((resolve) => {\n    let settled = false;\n\n    const timeoutHandle = setTimeout(() => {\n      if (settled) return;\n      settled = true;\n      resolve(\n        makeProviderFailure(\n          provider.id,\n          'TIMEOUT',\n          `Provider ${provider.id} timed out after ${timeoutMs}ms.`,\n        ),\n      );\n    }, timeoutMs);\n\n    provider\n      .search(query)\n      .then((result) => {\n        if (settled) return;\n        settled = true;\n        clearTimeout(timeoutHandle);\n        resolve(result);\n      })\n      .catch((error: unknown) => {\n        if (settled) return;\n        settled = true;\n        clearTimeout(timeoutHandle);\n        resolve(\n          makeProviderFailure(\n            provider.id,\n            'UNKNOWN_ERROR',\n            `Provider threw an unexpected error: ${toErrorMessage(error, 'unknown error')}`,\n          ),\n        );\n      });\n  });\n}\n\nexport async function routeResearchQuery(\n  query: ResearchQuery,\n  options: RouteResearchOptions = {},\n): Promise<ResearchRouteResult> {\n  const availableProviders = options.providers ?? createResearchRegistry(options.config);\n  const orderedProviders = resolveOrderedProviders(availableProviders, query.intent, options.providerOrder);\n\n  if (orderedProviders.length === 0) {\n    return {\n      ok: false,\n      error: makeProviderError('router', 'NO_PROVIDERS_ENABLED', 'No enabled research providers are configured.', {\n        retryable: false,\n      }),\n      attempts: [],\n    };\n  }\n\n  const attempts: ResearchRouteAttempt[] = [];\n\n  for (const provider of orderedProviders) {\n    const result = await executeWithTimeout(provider, query);\n\n    if (result.ok) {\n      return {\n        ok: true,\n        provider: result.provider,\n        result: result.result,\n        attempts,\n      };\n    }\n\n    attempts.push({\n      provider: provider.id,\n      error: result.error,\n    });\n  }\n\n  const attemptedProviders = attempts.map((attempt) => attempt.provider).join(', ');\n\n  return {\n    ok: false,\n    error: makeProviderError(\n      'router',\n      'ALL_PROVIDERS_FAILED',\n      attemptedProviders\n        ? `All providers failed for query \"${query.query}\": ${attemptedProviders}.`\n        : `All providers failed for query \"${query.query}\".`,\n    ),\n    attempts,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/research/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/tools/custom.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/tui/actionHistoryStore.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, value is always truthy.","line":45,"column":10,"nodeType":"Literal","messageId":"alwaysTruthy","endLine":45,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { mkdir, open, readFile, rename, stat, unlink, writeFile } from 'node:fs/promises';\nimport { homedir } from 'node:os';\nimport { dirname, join } from 'node:path';\nimport { z } from 'zod';\nimport type { ActionEvent } from './activity.js';\nimport { MAX_ACTION_HISTORY } from './activity.js';\nimport { sleep } from '../utils/common.js';\n\nconst ActionEventSchema = z.object({\n  id: z.string(),\n  at: z.number(),\n  sessionId: z.string(),\n  kind: z.enum(['turn', 'tool', 'thinking', 'slash', 'model', 'permission', 'error', 'info']),\n  status: z.enum(['running', 'ok', 'error', 'info']),\n  icon: z.string(),\n  label: z.string(),\n  detail: z.string().optional(),\n});\n\nexport const DEFAULT_ACTION_HISTORY_PATH = join(homedir(), '.config', 'opta', 'tui-action-history.jsonl');\n\nexport interface ActionHistoryStoreOptions {\n  filePath?: string;\n  maxEntries?: number;\n  lockTimeoutMs?: number;\n  lockRetryMs?: number;\n  staleLockMs?: number;\n}\n\nfunction resolvePath(options: ActionHistoryStoreOptions): string {\n  return options.filePath ?? DEFAULT_ACTION_HISTORY_PATH;\n}\n\nfunction resolveMaxEntries(options: ActionHistoryStoreOptions): number {\n  const requested = options.maxEntries ?? MAX_ACTION_HISTORY;\n  return Math.max(1, requested);\n}\n\nfunction lockPath(filePath: string): string {\n  return `${filePath}.lock`;\n}\n\nasync function acquireLock(path: string, timeoutMs: number, retryMs: number, staleLockMs: number) {\n  const started = Date.now();\n  while (true) {\n    try {\n      return await open(path, 'wx');\n    } catch (error) {\n      const err = error as NodeJS.ErrnoException;\n      if (err.code !== 'EEXIST') throw err;\n      try {\n        const info = await stat(path);\n        if (Date.now() - info.mtimeMs >= staleLockMs) {\n          await unlink(path).catch(() => {});\n          continue;\n        }\n      } catch (statError) {\n        const statErr = statError as NodeJS.ErrnoException;\n        if (statErr.code !== 'ENOENT') {\n          // Keep retrying through transient stat/unlink issues.\n        }\n      }\n      if (Date.now() - started >= timeoutMs) {\n        throw new Error(`Timed out waiting for action history lock: ${path}`);\n      }\n      await sleep(retryMs);\n    }\n  }\n}\n\nasync function readHistoryFile(filePath: string): Promise<string> {\n  try {\n    return await readFile(filePath, 'utf-8');\n  } catch (error) {\n    const err = error as NodeJS.ErrnoException;\n    if (err.code === 'ENOENT') return '';\n    throw err;\n  }\n}\n\nfunction parseHistory(raw: string, maxEntries: number): ActionEvent[] {\n  if (!raw.trim()) return [];\n  const parsed: ActionEvent[] = [];\n  const lines = raw.split('\\n').filter((line) => line.trim().length > 0);\n  for (const line of lines) {\n    let json: unknown;\n    try {\n      json = JSON.parse(line);\n    } catch {\n      continue;\n    }\n    const result = ActionEventSchema.safeParse(json);\n    if (!result.success) continue;\n    parsed.push(result.data);\n  }\n  parsed.sort((a, b) => b.at - a.at);\n  return parsed.slice(0, maxEntries);\n}\n\nfunction serializeHistory(entries: ActionEvent[]): string {\n  if (entries.length === 0) return '';\n  return `${entries.map((entry) => JSON.stringify(entry)).join('\\n')}\\n`;\n}\n\nasync function writeHistoryAtomically(filePath: string, entries: ActionEvent[]): Promise<void> {\n  const tempPath = `${filePath}.${process.pid}.${Date.now()}.tmp`;\n  await writeFile(tempPath, serializeHistory(entries), 'utf-8');\n  await rename(tempPath, filePath);\n  await unlink(tempPath).catch(() => {});\n}\n\nexport async function loadActionHistory(options: ActionHistoryStoreOptions = {}): Promise<ActionEvent[]> {\n  const filePath = resolvePath(options);\n  const maxEntries = resolveMaxEntries(options);\n  const raw = await readHistoryFile(filePath);\n  return parseHistory(raw, maxEntries);\n}\n\nexport async function appendActionHistory(\n  entry: ActionEvent,\n  options: ActionHistoryStoreOptions = {},\n): Promise<void> {\n  const filePath = resolvePath(options);\n  const maxEntries = resolveMaxEntries(options);\n  const lockTimeoutMs = options.lockTimeoutMs ?? 5000;\n  const lockRetryMs = options.lockRetryMs ?? 20;\n  const staleLockMs = options.staleLockMs ?? 15_000;\n  const parsed = ActionEventSchema.parse(entry);\n\n  await mkdir(dirname(filePath), { recursive: true });\n  const lockHandle = await acquireLock(lockPath(filePath), lockTimeoutMs, lockRetryMs, staleLockMs);\n  try {\n    const raw = await readHistoryFile(filePath);\n    const existing = parseHistory(raw, maxEntries);\n    const next = [parsed, ...existing.filter((item) => item.id !== parsed.id)].slice(0, maxEntries);\n    await writeHistoryAtomically(filePath, next);\n  } finally {\n    await lockHandle.close().catch(() => {});\n    await unlink(lockPath(filePath)).catch(() => {});\n  }\n}\n\nexport async function clearActionHistory(options: ActionHistoryStoreOptions = {}): Promise<void> {\n  const filePath = resolvePath(options);\n  const lockTimeoutMs = options.lockTimeoutMs ?? 5000;\n  const lockRetryMs = options.lockRetryMs ?? 20;\n  const staleLockMs = options.staleLockMs ?? 15_000;\n\n  await mkdir(dirname(filePath), { recursive: true });\n  const lockHandle = await acquireLock(lockPath(filePath), lockTimeoutMs, lockRetryMs, staleLockMs);\n  try {\n    await writeHistoryAtomically(filePath, []);\n  } finally {\n    await lockHandle.close().catch(() => {});\n    await unlink(lockPath(filePath)).catch(() => {});\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/tui/activity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/tui/adapter.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, comparison is always false, since `null !== null` is false.","line":231,"column":33,"nodeType":"BinaryExpression","messageId":"comparisonBetweenLiteralTypes","endLine":231,"endColumn":56}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * TUI Adapter  EventEmitter bridge between agentLoop() and the React/Ink TUI.\n *\n * Converts the streaming agent response into discrete events that React components\n * can subscribe to via useEffect, enabling real-time token display, tool call\n * visualization, and live stats updates.\n */\n\nimport { EventEmitter } from 'node:events';\nimport type { OptaConfig } from '../core/config.js';\nimport type { AgentLoopOptions, AgentLoopResult } from '../core/agent.js';\nimport type { Session } from '../memory/store.js';\nimport type { PermissionDecision } from './PermissionPrompt.js';\nimport { InsightEngine, type Insight } from '../core/insights.js';\nimport { errorMessage } from '../utils/errors.js';\nimport type { SubAgentDisplayState, SubAgentProgressEvent } from '../core/subagent-events.js';\nimport { probeLmxConnection } from '../lmx/connection.js';\nimport { resolveLmxEndpoint } from '../lmx/endpoints.js';\n\n/** Average characters per token for rough estimation. */\nconst CHARS_PER_TOKEN = 4;\n\n/** Minimum elapsed seconds before computing tokens/sec (avoids division spikes). */\nconst MIN_ELAPSED_FOR_SPEED = 0.1;\n\n// --- Event Types ---\n\nexport interface TurnStats {\n  tokens: number;\n  promptTokens: number;\n  completionTokens: number;\n  toolCalls: number;\n  elapsed: number;\n  speed: number;\n  firstTokenLatencyMs: number | null;\n}\n\nexport interface PermissionRequest {\n  id: string;\n  toolName: string;\n  args: Record<string, unknown>;\n}\n\nexport interface TuiErrorPayload {\n  message: string;\n  code?: string;\n}\n\nexport type TuiErrorEvent = string | TuiErrorPayload;\n\nexport interface TuiEventMap {\n  'token': [text: string];\n  'tool:start': [name: string, id: string, args: string];\n  'tool:end': [name: string, id: string, result: string];\n  'thinking': [text: string];\n  'turn:start': [];\n  'turn:end': [stats: TurnStats];\n  'turn:first-token': [latencyMs: number];\n  'turn:progress': [stats: { elapsed: number; speed: number; completionTokens: number }];\n  'connection:status': [status: 'checking' | 'connected' | 'disconnected' | 'error' | 'reconnecting'];\n  'error': [error: TuiErrorEvent];\n  'permission:request': [request: PermissionRequest];\n  'permission:response': [id: string, decision: PermissionDecision];\n  'title': [title: string];\n  'insight': [insight: Insight];\n  'subagent:spawn': [state: SubAgentDisplayState];\n  'subagent:progress': [event: SubAgentProgressEvent];\n  'subagent:done': [agentId: string, result: string];\n  'subagent:clear': [];\n}\n\nexport class TuiEmitter extends EventEmitter {\n  override emit<K extends keyof TuiEventMap>(event: K, ...args: TuiEventMap[K]): boolean {\n    return super.emit(event, ...args);\n  }\n\n  override on<K extends keyof TuiEventMap>(event: K, listener: (...args: TuiEventMap[K]) => void): this {\n    return super.on(event, listener as (...args: unknown[]) => void);\n  }\n\n  override off<K extends keyof TuiEventMap>(event: K, listener: (...args: TuiEventMap[K]) => void): this {\n    return super.off(event, listener as (...args: unknown[]) => void);\n  }\n}\n\n// --- Adapter: Runs agent loop and emits events ---\n\nexport interface TuiAdapterOptions {\n  config: OptaConfig;\n  session: Session;\n}\n\n/** Counter for unique permission request IDs. */\nlet permissionRequestCounter = 0;\n\n/**\n * Run the agent loop for a user message and emit streaming events.\n *\n * This creates the onStream callbacks, passes them into agentLoop,\n * and emits higher-level events (turn:start, turn:end) around it.\n */\nexport async function runAgentWithEvents(\n  emitter: TuiEmitter,\n  task: string,\n  config: OptaConfig,\n  session: Session,\n  images?: Array<{ base64: string; mimeType: string; name?: string }>,\n  mode?: string,\n): Promise<AgentLoopResult> {\n  const turnStartTime = Date.now();\n  let completionTokens = 0;\n  let toolCallCount = 0;\n  let firstTokenTime: number | null = null;\n  let apiPromptTokens = 0;\n\n  // Insight engine  observes agent events and emits  blocks\n  const insights = new InsightEngine((insight) => {\n    emitter.emit('insight', insight);\n  });\n  insights.setModel(config.model.default);\n  insights.setContextLimit(config.model.contextLimit);\n\n  emitter.emit('turn:start');\n  insights.turnStart();\n\n  // Progress timer: emits turn:progress every 500ms with live stats\n  const progressInterval = setInterval(() => {\n    const elapsed = (Date.now() - turnStartTime) / 1000;\n    const speed = elapsed > MIN_ELAPSED_FOR_SPEED\n      ? completionTokens / elapsed\n      : 0;\n    emitter.emit('turn:progress', { elapsed, speed, completionTokens });\n    insights.progress(completionTokens, speed, elapsed);\n  }, 500);\n\n  const { agentLoop } = await import('../core/agent.js');\n\n  const options: AgentLoopOptions = {\n    existingMessages: session.messages,\n    sessionId: session.id,\n    silent: true, // We handle display in the TUI\n    images,\n    mode: (mode && mode !== 'normal') ? mode as 'plan' | 'review' | 'research' : undefined,\n    onStream: {\n      onToken(text: string) {\n        // Track first token latency\n        if (firstTokenTime === null) {\n          firstTokenTime = Date.now();\n          const latencyMs = firstTokenTime - turnStartTime;\n          emitter.emit('turn:first-token', latencyMs);\n          insights.firstToken(latencyMs);\n        }\n\n        completionTokens += Math.ceil(text.length / CHARS_PER_TOKEN);\n        emitter.emit('token', text);\n      },\n      onToolStart(name: string, id: string, args: string) {\n        toolCallCount++;\n        emitter.emit('tool:start', name, id, args);\n        insights.toolStart(name, args);\n      },\n      onToolEnd(name: string, id: string, result: string) {\n        emitter.emit('tool:end', name, id, result);\n        insights.toolEnd(name, id, result);\n      },\n      onThinking(text: string) {\n        emitter.emit('thinking', text);\n      },\n      onConnectionStatus(status: 'checking' | 'connected' | 'disconnected' | 'reconnecting') {\n        emitter.emit('connection:status', status as 'checking' | 'connected' | 'disconnected' | 'error');\n        insights.connectionStatus(status);\n      },\n      onUsage(usage: { promptTokens: number; completionTokens: number }) {\n        apiPromptTokens = usage.promptTokens;\n      },\n      /**\n       * Bridge permission requests from the agent loop to the TUI.\n       *\n       * Emits a 'permission:request' event and returns a Promise that\n       * resolves when the TUI sends back a 'permission:response' event.\n       * This blocks the agent loop until the user makes a decision.\n       */\n      onPermissionRequest(toolName: string, args: Record<string, unknown>): Promise<PermissionDecision> {\n        const requestId = `perm-${++permissionRequestCounter}`;\n\n        return new Promise<PermissionDecision>((resolve) => {\n          // Listen for the response matching this request ID\n          const onResponse = (id: string, decision: PermissionDecision) => {\n            if (id === requestId) {\n              emitter.off('permission:response', onResponse);\n              resolve(decision);\n            }\n          };\n          emitter.on('permission:response', onResponse);\n\n          // Emit the request to the TUI\n          emitter.emit('permission:request', { id: requestId, toolName, args });\n        });\n      },\n    },\n    onSubAgentSpawn(id: string, label: string, dependsOn?: number) {\n      const state: SubAgentDisplayState = {\n        id,\n        label: label.slice(0, 40),\n        phase: 'spawning',\n        spawnedAtMs: Date.now(),\n        toolCallCount: 0,\n        toolHistory: [],\n        dependsOn,\n      };\n      emitter.emit('subagent:spawn', state);\n    },\n    onSubAgentProgress(event: SubAgentProgressEvent) {\n      emitter.emit('subagent:progress', event);\n    },\n    onSubAgentDone(agentId: string, result: string) {\n      emitter.emit('subagent:done', agentId, result);\n    },\n  };\n\n  try {\n    const result = await agentLoop(task, config, options);\n\n    clearInterval(progressInterval);\n\n    const elapsedMs = Date.now() - turnStartTime;\n    const elapsed = elapsedMs / 1000;\n    const speed = elapsed > MIN_ELAPSED_FOR_SPEED\n      ? completionTokens / elapsed\n      : 0;\n    const firstTokenLatencyMs = firstTokenTime !== null\n      ? firstTokenTime - turnStartTime\n      : null;\n\n    const turnStats = {\n      tokens: completionTokens,\n      promptTokens: apiPromptTokens,\n      completionTokens,\n      toolCalls: toolCallCount,\n      elapsed,\n      speed,\n      firstTokenLatencyMs,\n    };\n\n    insights.turnEnd(turnStats);\n    emitter.emit('turn:end', turnStats);\n\n    return result;\n  } catch (err) {\n    clearInterval(progressInterval);\n    const errMsg = errorMessage(err);\n    emitter.emit('error', errMsg);\n    throw err;\n  }\n}\n\nexport function createTuiEmitter(): TuiEmitter {\n  return new TuiEmitter();\n}\n\n/**\n * Check connectivity to the Opta-LMX server and emit connection status events.\n *\n * Emits 'connection:status' with 'checking', then 'connected' on success,\n * 'error' on non-OK response, or 'disconnected' on network failure.\n */\nexport async function checkConnection(emitter: TuiEmitter, config: OptaConfig): Promise<void> {\n  emitter.emit('connection:status', 'checking');\n  const endpoint = await resolveLmxEndpoint({\n    host: config.connection.host,\n    fallbackHosts: config.connection.fallbackHosts,\n    port: config.connection.port,\n    adminKey: config.connection.adminKey,\n  }, { timeoutMs: 1_500 });\n  const result = await probeLmxConnection(\n    endpoint.host,\n    config.connection.port,\n    { timeoutMs: 5000, adminKey: config.connection.adminKey }\n  );\n  if (result.state === 'connected') {\n    emitter.emit('connection:status', 'connected');\n  } else if (result.state === 'degraded') {\n    emitter.emit('connection:status', 'error');\n  } else {\n    emitter.emit('connection:status', 'disconnected');\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/tui/animations.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/tui/browser-formatters.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/tui/capture.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":26,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[846,849],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[846,849],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":30,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1022,1025],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1022,1025],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/tui/hooks/useBrowserState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/tui/hooks/useKeyboard.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/tui/hooks/usePermissionState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/tui/hooks/useSessionState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/tui/hooks/useTerminalSize.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/tui/input-highlighting.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/tui/keybindings.ts","messages":[{"ruleId":"@typescript-eslint/unbound-method","severity":1,"message":"A method that is not declared with `this: void` may cause unintentional scoping of `this` when separated from its object.\nConsider using an arrow function or explicitly `.bind()`ing the method to avoid calling the method with an unintended `this` value. \nIf a function does not access `this`, it can be annotated with `this: void`.","line":79,"column":13,"nodeType":"Identifier","messageId":"unboundWithoutThisAnnotation","endLine":79,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export interface KeyBinding {\n  key: string;\n  description: string;\n}\n\nexport interface KeybindingConfig {\n  exit: KeyBinding;\n  toggleSidebar: KeyBinding;\n  scrollUp: KeyBinding;\n  scrollDown: KeyBinding;\n  help: KeyBinding;\n  clear: KeyBinding;\n  slashMenu: KeyBinding;\n  openOptaMenu: KeyBinding;\n  openActionHistory: KeyBinding;\n  expandThinking: KeyBinding;\n  modelSwitch: KeyBinding;\n  toggleSafeMode: KeyBinding;\n  cycleMode: KeyBinding;\n  toggleBypass: KeyBinding;\n  toggleFollow: KeyBinding;\n  browserPause: KeyBinding;\n  browserKill: KeyBinding;\n  browserRefresh: KeyBinding;\n  openSettings: KeyBinding;\n  toggleAgentPanel: KeyBinding;\n}\n\nexport type KeybindingOverrides = Partial<Record<keyof KeybindingConfig, KeyBinding>>;\n\nexport function defaultKeybindings(): KeybindingConfig {\n  return {\n    exit: { key: 'ctrl+c', description: 'Exit Opta' },\n    toggleSidebar: { key: 'ctrl+b', description: 'Toggle sidebar' },\n    scrollUp: { key: 'shift+up', description: 'Scroll message list up (plain  = history nav)' },\n    scrollDown: { key: 'shift+down', description: 'Scroll message list down (plain  = history nav)' },\n    help: { key: 'ctrl+/', description: 'Show help' },\n    clear: { key: 'ctrl+l', description: 'Clear screen' },\n    slashMenu: { key: 'ctrl+k', description: 'Open command palette' },\n    openOptaMenu: { key: 'ctrl+s', description: 'Open Opta menu (also Shift+Space)' },\n    openActionHistory: { key: 'ctrl+e', description: 'Open actions history' },\n    expandThinking: { key: 'ctrl+t', description: 'Toggle live thinking pane size' },\n    modelSwitch: { key: 'ctrl+g', description: 'Switch model' },\n    toggleSafeMode: { key: 'ctrl+n', description: 'Toggle safe rendering mode' },\n    cycleMode: { key: 'shift+tab', description: 'Cycle mode (Code/Plan/Research/Review)' },\n    toggleBypass: { key: 'ctrl+y', description: 'Toggle bypass permissions' },\n    toggleFollow: { key: 'ctrl+f', description: 'Toggle follow mode (auto-scroll)' },\n    browserPause: { key: 'ctrl+p', description: 'Pause or resume browser runtime' },\n    browserKill: { key: 'ctrl+x', description: 'Kill browser runtime immediately' },\n    browserRefresh: { key: 'ctrl+r', description: 'Refresh browser runtime telemetry' },\n    openSettings: { key: 'ctrl+shift+s', description: 'Open settings overlay' },\n    toggleAgentPanel: { key: 'a', description: 'Toggle agent monitor panel' },\n  };\n}\n\nexport function mergeKeybindings(overrides?: KeybindingOverrides): KeybindingConfig {\n  const defaults = defaultKeybindings();\n  if (!overrides) return defaults;\n  const next = { ...defaults };\n  for (const key of Object.keys(defaults) as Array<keyof KeybindingConfig>) {\n    const override = overrides[key];\n    if (!override) continue;\n    if (!override.key || !override.description) continue;\n    next[key] = override;\n  }\n  return next;\n}\n\nexport function getKeybinding(\n  action: keyof KeybindingConfig,\n  overrides?: KeybindingOverrides\n): KeyBinding {\n  return mergeKeybindings(overrides)[action];\n}\n\nexport async function loadKeybindings(): Promise<KeybindingOverrides> {\n  try {\n    const { readFile } = await import('node:fs/promises');\n    const { join } = await import('node:path');\n    const configPath = join(process.cwd(), '.opta', 'keybindings.json');\n    const content = await readFile(configPath, 'utf-8');\n    const parsed = JSON.parse(content) as Partial<Record<string, KeyBinding>>;\n    const defaults = defaultKeybindings();\n    const overrides: KeybindingOverrides = {};\n    for (const key of Object.keys(defaults) as Array<keyof KeybindingConfig>) {\n      const maybe = parsed[key];\n      if (!maybe || typeof maybe !== 'object') continue;\n      if (typeof maybe.key !== 'string' || typeof maybe.description !== 'string') continue;\n      overrides[key] = maybe;\n    }\n    return overrides;\n  } catch {\n    return {};\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/tui/layout.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/tui/menu/helpers.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, comparison is always true, since `\"rag-delete\" === \"rag-delete\"` is true.","line":109,"column":7,"nodeType":"BinaryExpression","messageId":"comparisonBetweenLiteralTypes","endLine":109,"endColumn":28}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { GuidedFlowKind, StudioConnectivityState } from './types.js';\n\nexport function labelWithState(base: string, enabled: boolean): string {\n  return `${base} (${enabled ? 'on' : 'off'})`;\n}\n\nexport function connectivityLabel(state: StudioConnectivityState): string {\n  if (state === 'reachable') return 'reachable';\n  if (state === 'unreachable') return 'unreachable';\n  if (state === 'local') return 'local-only';\n  return 'checking';\n}\n\nexport function autonomyLabel(level: number, mode: 'execution' | 'ceo'): string {\n  return `L${level}/5  profile ${mode}`;\n}\n\nexport function autonomySlider(levelInput: number): string {\n  const level = Math.min(5, Math.max(1, Math.floor(levelInput)));\n  return `[${''.repeat(level)}${''.repeat(5 - level)}]`;\n}\n\nexport function guidedFlowPrompt(kind: GuidedFlowKind): { title: string; placeholder: string; destructive: boolean } {\n  if (kind === 'agent-status') {\n    return { title: 'Agent run status', placeholder: 'Enter run id (e.g. run_abc123)', destructive: false };\n  }\n  if (kind === 'agent-start') {\n    return { title: 'Start agent run', placeholder: 'Enter prompt text', destructive: false };\n  }\n  if (kind === 'agent-events') {\n    return { title: 'Agent run events', placeholder: 'Enter run id (e.g. run_abc123)', destructive: false };\n  }\n  if (kind === 'agent-cancel') {\n    return { title: 'Cancel agent run', placeholder: 'Enter run id to cancel', destructive: true };\n  }\n  if (kind === 'skill-show') {\n    return { title: 'Skill detail', placeholder: 'Enter skill name/reference', destructive: false };\n  }\n  if (kind === 'skill-run') {\n    return { title: 'Run skill', placeholder: 'Enter skill name (e.g. ai26-3c-productivity-writing-plans)', destructive: false };\n  }\n  if (kind === 'skill-mcp-call') {\n    return { title: 'Call MCP tool', placeholder: 'Enter MCP tool name (e.g. linear.search_issues)', destructive: true };\n  }\n  if (kind === 'skill-openclaw') {\n    return { title: 'Invoke OpenClaw tool', placeholder: 'Enter OpenClaw tool name', destructive: true };\n  }\n  if (kind === 'quantize-status') {\n    return { title: 'Quantize job status', placeholder: 'Enter quantize job id', destructive: false };\n  }\n  if (kind === 'rag-query') {\n    return { title: 'RAG query', placeholder: 'Enter: collection | query text', destructive: false };\n  }\n  if (kind === 'rag-ingest-file') {\n    return { title: 'RAG ingest (file path)', placeholder: 'Enter: collection | /path/to/text-file', destructive: false };\n  }\n  if (kind === 'rag-context') {\n    return { title: 'RAG context', placeholder: 'Enter: query text | collection1,collection2', destructive: false };\n  }\n  return { title: 'Delete RAG collection', placeholder: 'Enter collection name to delete', destructive: true };\n}\n\nexport function quoteCliArg(value: string): string {\n  return JSON.stringify(value);\n}\n\nexport function parseGuidedPair(value: string): { first: string; second: string } | null {\n  const delimiterIndex = value.indexOf('|');\n  if (delimiterIndex < 0) return null;\n  const first = value.slice(0, delimiterIndex).trim();\n  const second = value.slice(delimiterIndex + 1).trim();\n  if (!first || !second) return null;\n  return { first, second };\n}\n\nexport function buildGuidedCommand(kind: GuidedFlowKind, value: string): string | null {\n  const trimmed = value.trim();\n  if (!trimmed) return null;\n  if (kind === 'agent-status') return `/agents status ${trimmed}`;\n  if (kind === 'agent-start') return `/agents start --prompt ${quoteCliArg(trimmed)}`;\n  if (kind === 'agent-events') return `/agents events ${trimmed}`;\n  if (kind === 'agent-cancel') return `/agents cancel ${trimmed}`;\n  if (kind === 'skill-show') return `/lmx-skills show ${trimmed}`;\n  if (kind === 'skill-run') return `/lmx-skills run ${trimmed}`;\n  if (kind === 'skill-mcp-call') return `/lmx-skills mcp-call ${trimmed}`;\n  if (kind === 'skill-openclaw') return `/lmx-skills openclaw ${trimmed}`;\n  if (kind === 'quantize-status') return `/quantize status ${trimmed}`;\n  if (kind === 'rag-query') {\n    const pair = parseGuidedPair(trimmed);\n    if (!pair) return null;\n    return `/rag query ${pair.first} ${quoteCliArg(pair.second)}`;\n  }\n  if (kind === 'rag-ingest-file') {\n    const pair = parseGuidedPair(trimmed);\n    if (!pair) return null;\n    return `/rag ingest ${pair.first} --file ${quoteCliArg(pair.second)}`;\n  }\n  if (kind === 'rag-context') {\n    const pair = parseGuidedPair(trimmed);\n    if (!pair) return null;\n    const collections = pair.second\n      .split(',')\n      .map((entry) => entry.trim())\n      .filter(Boolean)\n      .join(',');\n    if (!collections) return null;\n    return `/rag context ${quoteCliArg(pair.first)} --collections ${collections}`;\n  }\n  if (kind === 'rag-delete') return `/rag delete ${trimmed}`;\n  return null;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/tui/menu/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/tui/optimiser-intent.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/tui/palette.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/tui/response-intent.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/tui/skill-runtime.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/tui/trigger-router.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-type-conversion","severity":1,"message":"Passing a number to Number() does not change the type or value of the number.","line":150,"column":26,"nodeType":"Identifier","messageId":"unnecessaryTypeConversion","endLine":150,"endColumn":32,"suggestions":[{"messageId":"suggestRemove","fix":{"range":[4319,4345],"text":"(left.priority ?? 0)"},"desc":"Remove the type conversion."},{"messageId":"suggestSatisfies","data":{"type":"number"},"fix":{"range":[4319,4345],"text":"(left.priority ?? 0) satisfies number"},"desc":"Instead, assert that the value satisfies the number type."}]},{"ruleId":"@typescript-eslint/no-unnecessary-type-conversion","severity":1,"message":"Passing a number to Number() does not change the type or value of the number.","line":151,"column":27,"nodeType":"Identifier","messageId":"unnecessaryTypeConversion","endLine":151,"endColumn":33,"suggestions":[{"messageId":"suggestRemove","fix":{"range":[4373,4400],"text":"(right.priority ?? 0)"},"desc":"Remove the type conversion."},{"messageId":"suggestSatisfies","data":{"type":"number"},"fix":{"range":[4373,4400],"text":"(right.priority ?? 0) satisfies number"},"desc":"Instead, assert that the value satisfies the number type."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export type TriggerWorkflowMode = 'normal' | 'plan' | 'research' | 'review';\n\nexport interface TriggerModeDefinition {\n  word: string;\n  modeHint?: TriggerWorkflowMode;\n  /**\n   * Higher values take precedence in deterministic ordering when multiple\n   * trigger words match the same prompt.\n   */\n  priority?: number;\n  capabilities?: string[];\n  skills?: string[];\n}\n\nexport interface TriggerRoutingResult {\n  matchedWords: string[];\n  matchedDefinitions: TriggerModeDefinition[];\n  requestedCapabilities: string[];\n  requestedSkills: string[];\n  requestedModes: TriggerWorkflowMode[];\n  effectiveMode: TriggerWorkflowMode;\n}\n\nconst MODE_PRECEDENCE: Record<TriggerWorkflowMode, number> = {\n  normal: 0,\n  research: 1,\n  plan: 2,\n  review: 3,\n};\n\nconst REGEX_ESCAPE_PATTERN = /[.*+?^${}()|[\\]\\\\]/g;\n\nfunction escapeRegex(value: string): string {\n  return value.replace(REGEX_ESCAPE_PATTERN, '\\\\$&');\n}\n\nfunction uniqueNormalized(items: string[]): string[] {\n  const seen = new Set<string>();\n  const normalized: string[] = [];\n\n  for (const raw of items) {\n    const candidate = raw.trim().toLowerCase();\n    if (!candidate || seen.has(candidate)) continue;\n    seen.add(candidate);\n    normalized.push(candidate);\n  }\n\n  return normalized;\n}\n\nfunction uniqueStrings(items: string[]): string[] {\n  const seen = new Set<string>();\n  const normalized: string[] = [];\n\n  for (const raw of items) {\n    const candidate = raw.trim();\n    if (!candidate || seen.has(candidate)) continue;\n    seen.add(candidate);\n    normalized.push(candidate);\n  }\n\n  return normalized;\n}\n\nfunction isKnownWorkflowMode(value: string | undefined): value is TriggerWorkflowMode {\n  return value === 'normal' || value === 'plan' || value === 'research' || value === 'review';\n}\n\nexport const DEFAULT_TRIGGER_MODE_DEFINITIONS: TriggerModeDefinition[] = [\n  {\n    word: 'review',\n    modeHint: 'review',\n    priority: 400,\n    skills: ['ai26-3b-code-quality-code-reviewer', 'ai26-3b-code-quality-requesting-code-review'],\n    capabilities: ['review'],\n  },\n  {\n    word: 'plan',\n    modeHint: 'plan',\n    priority: 300,\n    skills: ['ai26-3c-productivity-writing-plans'],\n    capabilities: ['planning'],\n  },\n  {\n    word: 'research',\n    modeHint: 'research',\n    priority: 200,\n    skills: ['ai26-3i-ai-research-perp'],\n    capabilities: ['research'],\n  },\n  {\n    word: 'browser',\n    priority: 100,\n    skills: ['playwright'],\n    capabilities: ['browser'],\n  },\n];\n\nexport function normalizeTriggerModeDefinitions(\n  definitions: TriggerModeDefinition[],\n): TriggerModeDefinition[] {\n  const normalizedWords = uniqueNormalized(definitions.map((definition) => definition.word));\n  if (normalizedWords.length === 0) return [];\n\n  const byWord = new Map<string, TriggerModeDefinition>();\n  for (const definition of definitions) {\n    const normalizedWord = definition.word.trim().toLowerCase();\n    if (!normalizedWord || byWord.has(normalizedWord)) continue;\n\n    byWord.set(normalizedWord, {\n      word: normalizedWord,\n      modeHint: definition.modeHint && isKnownWorkflowMode(definition.modeHint)\n        ? definition.modeHint\n        : undefined,\n      priority: Number.isFinite(definition.priority) ? Number(definition.priority) : 0,\n      capabilities: uniqueStrings(definition.capabilities ?? []),\n      skills: uniqueStrings(definition.skills ?? []),\n    });\n  }\n\n  return normalizedWords\n    .map((word) => byWord.get(word))\n    .filter((definition): definition is TriggerModeDefinition => Boolean(definition));\n}\n\nexport function triggerWordsFromDefinitions(\n  definitions: TriggerModeDefinition[],\n): string[] {\n  return normalizeTriggerModeDefinitions(definitions).map((definition) => definition.word);\n}\n\nexport function collectMatchedTriggerDefinitions(\n  prompt: string,\n  definitions: TriggerModeDefinition[],\n): TriggerModeDefinition[] {\n  const normalizedPrompt = prompt.trim();\n  if (!normalizedPrompt) return [];\n\n  const normalizedDefinitions = normalizeTriggerModeDefinitions(definitions);\n  const matched: TriggerModeDefinition[] = [];\n\n  for (const definition of normalizedDefinitions) {\n    const pattern = new RegExp(`\\\\b${escapeRegex(definition.word)}\\\\b`, 'i');\n    if (pattern.test(normalizedPrompt)) {\n      matched.push(definition);\n    }\n  }\n\n  return matched.sort((left, right) => {\n    const leftPriority = Number(left.priority ?? 0);\n    const rightPriority = Number(right.priority ?? 0);\n    if (leftPriority !== rightPriority) return rightPriority - leftPriority;\n    return left.word.localeCompare(right.word);\n  });\n}\n\nexport function resolveEffectiveMode(\n  currentMode: TriggerWorkflowMode,\n  modeHints: TriggerWorkflowMode[],\n): TriggerWorkflowMode {\n  const candidates = [currentMode, ...modeHints];\n  let selected: TriggerWorkflowMode = currentMode;\n  let selectedPriority = MODE_PRECEDENCE[currentMode];\n\n  for (const candidate of candidates) {\n    const priority = MODE_PRECEDENCE[candidate];\n    if (priority > selectedPriority) {\n      selected = candidate;\n      selectedPriority = priority;\n    }\n  }\n\n  return selected;\n}\n\nexport function resolveTriggerRouting(options: {\n  prompt: string;\n  currentMode: TriggerWorkflowMode;\n  definitions?: TriggerModeDefinition[];\n}): TriggerRoutingResult {\n  const definitions = options.definitions ?? DEFAULT_TRIGGER_MODE_DEFINITIONS;\n  const matchedDefinitions = collectMatchedTriggerDefinitions(options.prompt, definitions);\n  const matchedWords = matchedDefinitions.map((definition) => definition.word);\n  const requestedCapabilities = uniqueStrings(\n    matchedDefinitions.flatMap((definition) => definition.capabilities ?? []),\n  );\n  const requestedSkills = uniqueStrings(\n    matchedDefinitions.flatMap((definition) => definition.skills ?? []),\n  );\n  const requestedModes = uniqueStrings(\n    matchedDefinitions.map((definition) => definition.modeHint ?? ''),\n  ).filter((mode): mode is TriggerWorkflowMode => isKnownWorkflowMode(mode));\n  const effectiveMode = resolveEffectiveMode(options.currentMode, requestedModes);\n\n  return {\n    matchedWords,\n    matchedDefinitions,\n    requestedCapabilities,\n    requestedSkills,\n    requestedModes,\n    effectiveMode,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/tui/utils.ts","messages":[{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'path ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":56,"column":20,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":56,"endColumn":30}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Shared TUI utilities  single source of truth for display helpers\n * used across Header, Sidebar, StatusBar, WelcomeScreen, ToolCard, PermissionPrompt.\n */\n\n//  Connection State \n\nexport type ConnectionState = 'checking' | 'connected' | 'disconnected' | 'error' | 'reconnecting';\n\nexport interface ConnectionIndicator {\n  char: string;\n  color: string;\n  label: string;\n}\n\nexport function connectionDot(state?: ConnectionState, legacyStatus?: boolean): ConnectionIndicator {\n  if (state) {\n    switch (state) {\n      case 'checking': return { char: '', color: 'yellow', label: 'Checking...' };\n      case 'connected': return { char: '', color: 'green', label: 'Connected' };\n      case 'disconnected': return { char: '', color: 'red', label: 'Disconnected' };\n      case 'error': return { char: '', color: 'red', label: 'Error' };\n      case 'reconnecting': return { char: '', color: 'yellow', label: 'Reconnecting...' };\n    }\n  }\n  return { char: legacyStatus ? '' : '', color: legacyStatus ? 'green' : 'red', label: legacyStatus ? 'Connected' : 'Disconnected' };\n}\n\n//  Model Name Formatting \n\nexport function shortModelName(model: string): string {\n  return model\n    .replace(/^mlx-community\\//, '')\n    .replace(/^huggingface\\//, '');\n}\n\n//  Context Bar \n\nexport function contextBar(used: number, total: number): string {\n  const pct = Math.min(used / total, 1);\n  const filled = Math.round(pct * 10);\n  const empty = 10 - filled;\n  return '\\u25B0'.repeat(filled) + '\\u25B1'.repeat(empty);\n}\n\nexport function contextBarColor(used: number, total: number): string {\n  const pct = used / total;\n  if (pct >= 0.8) return 'red';\n  if (pct >= 0.5) return 'yellow';\n  return 'green';\n}\n\n//  Path Formatting \n\nexport function formatPath(path: unknown): string {\n  const p = String(path ?? '');\n  const parts = p.split('/');\n  if (parts.length > 3) {\n    return '.../' + parts.slice(-3).join('/');\n  }\n  return p;\n}\n\n//  Tool Icons \n\nexport const TOOL_ICONS: Record<string, string> = {\n  read_file: '\\u{1F4C4}',\n  write_file: '\\u270F\\uFE0F',\n  edit_file: '\\u{1F527}',\n  list_dir: '\\u{1F4C1}',\n  search_files: '\\u{1F50D}',\n  find_files: '\\u{1F50E}',\n  run_command: '\\u26A1',\n  ask_user: '\\u{1F4AC}',\n  delete_file: '\\u{1F5D1}',\n  multi_edit: '\\u{1F527}',\n  bg_start: '\\u{1F680}',\n  bg_kill: '\\u{1F6D1}',\n  spawn_agent: '\\u{1F916}',\n  delegate_task: '\\u{1F4CB}',\n  lsp_rename: '\\u270F\\uFE0F',\n  git_commit: '\\u{1F4BE}',\n};\n\n//  Context Formatting \n\nexport function formatContext(total?: number): string {\n  if (!total) return '\\u2014';\n  if (total >= 1024) return `${Math.round(total / 1024)}K`;\n  return String(total);\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/types.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/ui/autocomplete.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":12,"column":21,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":12,"endColumn":40,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[422,423],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":13,"column":21,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":13,"endColumn":40,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[477,478],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-require-imports').","line":43,"column":7,"severity":1,"nodeType":null,"fix":{"range":[1448,1513],"text":" "}},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, value is always truthy.","line":48,"column":11,"nodeType":"UnaryExpression","messageId":"alwaysTruthy","endLine":48,"endColumn":31}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import fg from 'fast-glob';\nimport { DEFAULT_IGNORE_GLOBS } from '../utils/ignore.js';\n\nexport function fuzzyMatch(query: string, target: string): boolean {\n  return target.toLowerCase().includes(query.toLowerCase());\n}\n\nexport function getCompletions(query: string, files: string[], limit = 15): string[] {\n  return files\n    .filter(f => fuzzyMatch(query, f))\n    .sort((a, b) => {\n      const aBase = a.split('/').pop()!.toLowerCase();\n      const bBase = b.split('/').pop()!.toLowerCase();\n      const q = query.toLowerCase();\n      // Prioritize basename-starts-with matches\n      const aStart = aBase.startsWith(q) ? 0 : 1;\n      const bStart = bBase.startsWith(q) ? 0 : 1;\n      if (aStart !== bStart) return aStart - bStart;\n      // Then by path length (shorter = more relevant)\n      return a.length - b.length;\n    })\n    .slice(0, limit);\n}\n\nexport async function getProjectFiles(cwd: string): Promise<string[]> {\n  return fg(['**/*'], {\n    cwd,\n    ignore: [...DEFAULT_IGNORE_GLOBS],\n    onlyFiles: true,\n    dot: false,\n  });\n}\n\n/**\n * Get slash command completions for TAB completion in the REPL.\n * Returns matching slash commands (with leading /) for a partial input.\n */\nexport function getSlashCompletions(partial: string): string[] {\n  // Lazy-import the command registry to avoid circular deps at module level.\n  // getAllCommands is synchronous so we can use a cached reference.\n  if (!_slashCommandsCache) {\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-require-imports\n      // Dynamic import is async, so we populate the cache on first call\n      // and return empty on the very first invocation (edge case).\n      _populateSlashCache();\n      // Return empty on first call while cache is loading\n      if (!_slashCommandsCache) return [];\n    } catch (err) {\n      console.error('Failed to get slash completions:', err);\n      return [];\n    }\n  }\n\n  const q = partial.startsWith('/') ? partial.slice(1).toLowerCase() : partial.toLowerCase();\n\n  return _slashCommandsCache\n    .filter(entry => entry.startsWith(q))\n    .map(name => `/${name}`)\n    .slice(0, 10);\n}\n\n/** Cached list of slash command names + aliases (lowercase). */\nlet _slashCommandsCache: string[] | null = null;\n\n/** Eagerly populate the slash command cache. Safe to call multiple times. */\nfunction _populateSlashCache(): void {\n  // The slash command registry uses static imports and is available synchronously\n  // once its module has been loaded. Since chat.ts already imports it, by the time\n  // TAB completion runs in the REPL the module is warm.\n  try {\n    // Use a sync require-like trick: the module is already in the ESM cache\n    // because chat.ts imported it. We rely on the caller having awaited the\n    // async version at least once before calling getSlashCompletions.\n    // This is handled by initSlashCompletionCache() below.\n  } catch (err) {\n    console.error('Failed to populate slash cache:', err);\n  }\n}\n\n/**\n * Initialize the slash command completion cache. Must be called once\n * (asynchronously) before getSlashCompletions will return results.\n * Typically called during chat startup.\n */\nexport async function initSlashCompletionCache(): Promise<void> {\n  try {\n    const { getAllCommands } = await import('../commands/slash/index.js');\n    const cmds = getAllCommands();\n    const names: string[] = [];\n    for (const cmd of cmds) {\n      names.push(cmd.command);\n      if (cmd.aliases) {\n        for (const alias of cmd.aliases) {\n          names.push(alias);\n        }\n      }\n    }\n    _slashCommandsCache = [...new Set(names)].sort();\n  } catch (err) {\n    console.error('Failed to initialize slash completion cache:', err);\n    _slashCommandsCache = [];\n  }\n}\n\n/**\n * REPL-level completer function suitable for use with readline.\n * Handles slash command completion and @file completion.\n */\nexport function replCompleter(\n  line: string,\n  callback: (err: null | Error, result: [string[], string]) => void,\n): void {\n  if (line.startsWith('/')) {\n    const completions = getSlashCompletions(line);\n    callback(null, [completions.length > 0 ? completions : [line], line]);\n    return;\n  }\n\n  // @file completion\n  const atMatch = line.match(/@(\\S*)$/);\n  if (atMatch) {\n    const partial = atMatch[1] ?? '';\n    getProjectFiles(process.cwd())\n      .then(files => {\n        const matches = getCompletions(partial, files, 10).map(f => line.slice(0, -atMatch[0].length) + `@${f}`);\n        callback(null, [matches.length > 0 ? matches : [line], line]);\n      })\n      .catch((err: unknown) => {\n        console.error('Failed to get project files for completion:', err);\n        callback(null, [[], line]);\n      });\n    return;\n  }\n\n  // No completions\n  callback(null, [[], line]);\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/ui/box.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":40,"column":18,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":40,"endColumn":27}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import chalk from 'chalk';\nimport { getTheme } from './theme.js';\nimport { formatTokens } from '../utils/tokens.js';\nimport { stripAnsi, visibleTextWidth } from '../utils/text.js';\nimport { padToWidth } from '../utils/terminal-layout.js';\n\n// --- Box Drawing ---\n\nconst BOX = { tl: '', tr: '', bl: '', br: '', h: '', v: '', ml: '', mr: '' };\n\n/**\n * Render a bordered box with a title and content lines.\n * Width auto-sizes to the longest line (min 40), capped at terminal width.\n */\nexport function box(title: string, lines: string[], { width: fixedWidth }: { width?: number } = {}): string {\n  const titleLen = visibleTextWidth(title);\n  const maxContent = Math.max(...lines.map(l => visibleTextWidth(stripAnsi(l))), 0);\n  const reportedWidth = (process.stdout.columns && process.stdout.columns > 0)\n    ? process.stdout.columns\n    : Number(process.env.COLUMNS || 0) || 0;\n  const termWidth = reportedWidth >= 20 ? reportedWidth : 80;\n  const maxWidth = Math.max(10, termWidth - 4);\n  const requestedWidth = fixedWidth ?? Math.max(maxContent + 4, titleLen + 6, 40);\n  const width = Math.max(10, Math.min(requestedWidth, maxWidth));\n  const inner = width - 2;\n\n  const out: string[] = [];\n  // Top border with title (uses theme primary for title accent)\n  const theme = getTheme();\n  const titlePart = title ? ` ${title} ` : '';\n  const topFill = inner - visibleTextWidth(titlePart);\n  out.push(\n    chalk.dim(BOX.tl) +\n    theme.primary.bold(titlePart) +\n    chalk.dim(padToWidth('', Math.max(topFill, 0), BOX.h) + BOX.tr),\n  );\n\n  // Content lines\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i]!;\n    const fitted = padToWidth(line, Math.max(inner - 1, 0));\n    out.push(chalk.dim(BOX.v) + ' ' + fitted + chalk.dim(BOX.v));\n  }\n\n  // Bottom border\n  out.push(chalk.dim(BOX.bl + padToWidth('', inner, BOX.h) + BOX.br));\n\n  return out.join('\\n');\n}\n\n/**\n * Render a horizontal divider with optional label.\n */\nexport function divider(label?: string, width = 40): string {\n  if (!label) return chalk.dim(padToWidth('', width, BOX.h));\n  const fill = width - visibleTextWidth(label) - 2;\n  return chalk.dim(BOX.ml + BOX.h) + chalk.dim(` ${label} `) + chalk.dim(padToWidth('', Math.max(fill - 3, 0), BOX.h) + BOX.mr);\n}\n\n// --- Progress Bar ---\n\n/**\n * Render a visual progress bar.\n * progressBar(0.41, 20)  \" 41%\"\n */\nexport function progressBar(ratio: number, width = 20): string {\n  const clamped = Math.max(0, Math.min(1, ratio));\n  const filled = Math.round(clamped * width);\n  const empty = width - filled;\n  const pct = Math.round(clamped * 100);\n\n  const theme = getTheme();\n  const bar = theme.info(''.repeat(filled)) + chalk.dim(''.repeat(empty));\n  const color = pct > 85 ? theme.error : pct > 70 ? theme.warning : chalk.dim;\n  return `${bar} ${color(`${pct}%`)}`;\n}\n\n// --- Formatting Helpers ---\n\n/**\n * Format a token count with K suffix.\n * @deprecated Use `formatTokens` from `../utils/tokens.js` directly.\n */\nexport const fmtTokens = formatTokens;\n\n/**\n * Right-pad a label to align values.\n * kv('Model', 'Qwen2.5-72B', 10)  \"Model:    Qwen2.5-72B\"\n */\nexport function kv(key: string, value: string, keyWidth = 10): string {\n  const pad = Math.max(keyWidth - key.length, 0);\n  return chalk.dim(key + ':') + ' '.repeat(pad + 1) + value;\n}\n\n/**\n * Status dot indicator.\n */\nexport function statusDot(ok: boolean): string {\n  const theme = getTheme();\n  return ok ? theme.success('') : theme.error('');\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/ui/brand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/ui/diff.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/ui/history.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":34,"column":14,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":34,"endColumn":39}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export class InputHistory {\n  private entries: string[] = [];\n  private index = -1;\n  private maxSize: number;\n\n  constructor(maxSize = 100) {\n    this.maxSize = maxSize;\n  }\n\n  push(entry: string): void {\n    const trimmed = entry.trim();\n    if (!trimmed) return;\n    // Deduplicate consecutive entries\n    if (this.entries.length > 0 && this.entries[this.entries.length - 1] === trimmed) return;\n    this.entries.push(trimmed);\n    if (this.entries.length > this.maxSize) this.entries.shift();\n    this.index = -1;\n  }\n\n  startNavigation(): void {\n    this.index = this.entries.length;\n  }\n\n  previous(): string {\n    if (this.entries.length === 0) return '';\n    if (this.index > 0) this.index--;\n    return this.entries[this.index] ?? '';\n  }\n\n  next(): string {\n    if (this.entries.length === 0) return '';\n    if (this.index < this.entries.length - 1) {\n      this.index++;\n      return this.entries[this.index]!;\n    }\n    this.index = this.entries.length;\n    return '';\n  }\n\n  size(): number {\n    return this.entries.length;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/ui/input.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-type-conversion","severity":1,"message":"Passing a string to String() does not change the type or value of the string.","line":47,"column":48,"nodeType":"Identifier","messageId":"unnecessaryTypeConversion","endLine":47,"endColumn":54,"suggestions":[{"messageId":"suggestRemove","fix":{"range":[1498,1519],"text":"result.reason"},"desc":"Remove the type conversion."},{"messageId":"suggestSatisfies","data":{"type":"string"},"fix":{"range":[1498,1519],"text":"(result.reason satisfies string)"},"desc":"Instead, assert that the value satisfies the string type."}]},{"ruleId":"@typescript-eslint/no-unnecessary-type-conversion","severity":1,"message":"Passing a string to String() does not change the type or value of the string.","line":50,"column":48,"nodeType":"Identifier","messageId":"unnecessaryTypeConversion","endLine":50,"endColumn":54,"suggestions":[{"messageId":"suggestRemove","fix":{"range":[1654,1675],"text":"result.reason"},"desc":"Remove the type conversion."},{"messageId":"suggestSatisfies","data":{"type":"string"},"fix":{"range":[1654,1675],"text":"(result.reason satisfies string)"},"desc":"Instead, assert that the value satisfies the string type."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":193,"column":12,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":193,"endColumn":36,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[5228,5229],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import chalk from 'chalk';\nimport { probeLmxConnection } from '../lmx/connection.js';\nimport { resolveLmxEndpoint } from '../lmx/endpoints.js';\nimport { errorMessage } from '../utils/errors.js';\n\n// --- Connection Status Indicator ---\n\nlet connectionStatus: 'connected' | 'degraded' | 'disconnected' = 'disconnected';\nlet connectionStatusDetail = '';\nlet connectionCheckInterval: ReturnType<typeof setInterval> | null = null;\n\nexport function getConnectionStatus(): 'connected' | 'degraded' | 'disconnected' {\n  return connectionStatus;\n}\n\nexport function getConnectionStatusDetail(): string {\n  return connectionStatusDetail;\n}\n\nexport function getConnectionDot(): string {\n  switch (connectionStatus) {\n    case 'connected': return chalk.green('\\u25cf');\n    case 'degraded': return chalk.yellow('\\u25cf');\n    case 'disconnected': return chalk.red('\\u25cf');\n  }\n}\n\nexport async function checkConnection(\n  host: string,\n  port: number,\n  fallbackHosts: string[] = [],\n  adminKey?: string,\n): Promise<void> {\n  try {\n    const endpoint = await resolveLmxEndpoint({\n      host,\n      fallbackHosts,\n      port,\n      adminKey,\n    }, { timeoutMs: 1000 });\n    const result = await probeLmxConnection(endpoint.host, port, { timeoutMs: 2000, adminKey });\n    if (result.state === 'connected') {\n      connectionStatus = 'connected';\n      connectionStatusDetail = '';\n    } else if (result.state === 'degraded') {\n      connectionStatus = 'degraded';\n      connectionStatusDetail = result.reason ? String(result.reason) : 'LMX reachable but not ready';\n    } else {\n      connectionStatus = 'disconnected';\n      connectionStatusDetail = result.reason ? String(result.reason) : 'LMX disconnected';\n    }\n  } catch (err) {\n    // Connection failed - set status to disconnected\n    // Log details for debugging if in verbose mode\n    if (process.env.OPTA_DEBUG) {\n      console.error('Connection check failed:', err);\n    }\n    connectionStatus = 'disconnected';\n    connectionStatusDetail = errorMessage(err);\n  }\n}\n\n/**\n * Start periodic connection checks (every 60s).\n * Returns a cleanup function to stop the interval.\n */\nexport function startConnectionMonitor(\n  host: string,\n  port: number,\n  fallbackHosts: string[] = [],\n  adminKey?: string,\n): () => void {\n  // Run initial check immediately\n  checkConnection(host, port, fallbackHosts, adminKey).catch((err: unknown) => {\n    if (process.env.OPTA_DEBUG) {\n      console.error('Initial connection check failed:', err);\n    }\n  });\n\n  // Set up periodic checks\n  connectionCheckInterval = setInterval(() => {\n    checkConnection(host, port, fallbackHosts, adminKey).catch((err: unknown) => {\n      if (process.env.OPTA_DEBUG) {\n        console.error('Periodic connection check failed:', err);\n      }\n    });\n  }, 60_000);\n\n  return () => {\n    if (connectionCheckInterval) {\n      clearInterval(connectionCheckInterval);\n      connectionCheckInterval = null;\n    }\n  };\n}\n\n// --- Input Editor ---\n\nexport interface InputEditorOptions {\n  prompt: string;\n  multiline?: boolean;\n  mode?: 'normal' | 'shell' | 'plan' | 'auto';\n}\n\nexport class InputEditor {\n  private buffer = '';\n  private cursor = 0;\n  private options: Required<InputEditorOptions>;\n\n  constructor(options: InputEditorOptions) {\n    this.options = {\n      prompt: options.prompt,\n      multiline: options.multiline ?? false,\n      mode: options.mode ?? 'normal',\n    };\n  }\n\n  getBuffer(): string {\n    return this.buffer;\n  }\n\n  getCursor(): number {\n    return this.cursor;\n  }\n\n  setBuffer(text: string): void {\n    this.buffer = text;\n    this.cursor = text.length;\n  }\n\n  deleteBackward(): void {\n    if (this.cursor === 0) return;\n    this.buffer =\n      this.buffer.slice(0, this.cursor - 1) + this.buffer.slice(this.cursor);\n    this.cursor--;\n  }\n\n  deleteForward(): void {\n    if (this.cursor >= this.buffer.length) return;\n    this.buffer =\n      this.buffer.slice(0, this.cursor) + this.buffer.slice(this.cursor + 1);\n  }\n\n  moveLeft(): void {\n    if (this.cursor > 0) this.cursor--;\n  }\n\n  moveRight(): void {\n    if (this.cursor < this.buffer.length) this.cursor++;\n  }\n\n  moveToStart(): void {\n    // Move to start of current line\n    const before = this.buffer.slice(0, this.cursor);\n    const lastNewline = before.lastIndexOf('\\n');\n    this.cursor = lastNewline + 1;\n  }\n\n  moveToEnd(): void {\n    // Move to end of current line\n    const after = this.buffer.indexOf('\\n', this.cursor);\n    this.cursor = after === -1 ? this.buffer.length : after;\n  }\n\n  insertText(text: string): void {\n    this.buffer =\n      this.buffer.slice(0, this.cursor) + text + this.buffer.slice(this.cursor);\n    this.cursor += text.length;\n  }\n\n  clear(): void {\n    this.buffer = '';\n    this.cursor = 0;\n  }\n\n  insertNewline(): void {\n    if (!this.options.multiline) return;\n    this.buffer =\n      this.buffer.slice(0, this.cursor) + '\\n' + this.buffer.slice(this.cursor);\n    this.cursor += 1;\n  }\n\n  getLineCount(): number {\n    return this.buffer.split('\\n').length;\n  }\n\n  getCursorLine(): number {\n    return this.buffer.slice(0, this.cursor).split('\\n').length - 1;\n  }\n\n  getCursorCol(): number {\n    const lines = this.buffer.slice(0, this.cursor).split('\\n');\n    return lines[lines.length - 1]!.length;\n  }\n\n  isShellMode(): boolean {\n    return this.buffer.startsWith('!');\n  }\n\n  getShellCommand(): string | null {\n    if (!this.isShellMode()) return null;\n    return this.buffer.slice(1).trim();\n  }\n\n  private cancelled = false;\n\n  handleEscape(): void {\n    if (this.buffer.length > 0) {\n      this.clear();\n    } else {\n      this.cancelled = true;\n    }\n  }\n\n  shouldCancel(): boolean {\n    return this.cancelled;\n  }\n\n  resetCancel(): void {\n    this.cancelled = false;\n  }\n\n  private pastedContent: string | null = null;\n\n  handlePaste(text: string): { isPaste: boolean; lineCount: number; abbreviated: string; fullContent: string } {\n    const lines = text.split('\\n');\n    const isPaste = lines.length > 1;\n\n    if (isPaste) {\n      this.pastedContent = text;\n      const abbreviated = `[Pasted ~${lines.length} lines]`;\n      this.insertText(abbreviated);\n      return { isPaste: true, lineCount: lines.length, abbreviated, fullContent: text };\n    }\n\n    this.insertText(text);\n    return { isPaste: false, lineCount: 1, abbreviated: text, fullContent: text };\n  }\n\n  getSubmitText(): string {\n    if (this.pastedContent) {\n      return this.buffer.replace(/\\[Pasted ~\\d+ lines\\]/, this.pastedContent);\n    }\n    return this.buffer;\n  }\n\n  setMode(mode: InputEditorOptions['mode']): void {\n    this.options.mode = mode ?? 'normal';\n  }\n\n  getEffectiveMode(): string {\n    if (this.isShellMode()) return 'shell';\n    return this.options.mode;\n  }\n\n  getPromptDisplay(): string {\n    const dot = getConnectionDot();\n    const detail = getConnectionStatusDetail();\n    const detailSuffix = detail && getConnectionStatus() !== 'connected'\n      ? chalk.dim(` (${detail.slice(0, 40)})`)\n      : '';\n    const mode = this.getEffectiveMode();\n    switch (mode) {\n      case 'shell': return `${dot} ${chalk.yellow('!')}${chalk.dim(' >')}${detailSuffix}`;\n      case 'plan': return `${dot} ${chalk.magenta('plan')}${chalk.dim(' >')}${detailSuffix}`;\n      case 'auto': return `${dot} ${chalk.yellow('auto')}${chalk.dim(' >')}${detailSuffix}`;\n      default: return `${dot} ${chalk.cyan('>')}${detailSuffix}`;\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/ui/insights.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/ui/markdown.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":20,"column":45,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":20,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":1,"message":"Unsafe return of a value of type `any[]`.","line":23,"column":36,"nodeType":"ArrayExpression","messageId":"unsafeReturn","endLine":23,"endColumn":95},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe spread of an `any` value in an array.","line":23,"column":43,"nodeType":"SpreadElement","messageId":"unsafeArraySpread","endLine":23,"endColumn":94},{"ruleId":"@typescript-eslint/no-unnecessary-type-conversion","severity":1,"message":"Passing a string to String() does not change the type or value of the string.","line":31,"column":79,"nodeType":"Identifier","messageId":"unnecessaryTypeConversion","endLine":31,"endColumn":85,"suggestions":[{"messageId":"suggestRemove","fix":{"range":[1299,1308],"text":"c"},"desc":"Remove the type conversion."},{"messageId":"suggestSatisfies","data":{"type":"string"},"fix":{"range":[1299,1308],"text":"c satisfies string"},"desc":"Instead, assert that the value satisfies the string type."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":31,"column":90,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":31,"endColumn":103},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any[]` assigned to a parameter of type `string[]`.","line":35,"column":19,"nodeType":"TSNonNullExpression","messageId":"unsafeArgument","endLine":35,"endColumn":33},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":35,"column":19,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":35,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":1,"message":"Unsafe argument of type `any[]` assigned to a parameter of type `string[]`.","line":37,"column":63,"nodeType":"TSNonNullExpression","messageId":"unsafeArgument","endLine":37,"endColumn":77},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":37,"column":63,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":37,"endColumn":77},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":50,"column":18,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":50,"endColumn":27},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":55,"column":34,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":55,"endColumn":43,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[2147,2148],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":56,"column":20,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":56,"endColumn":29},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":134,"column":12,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":134,"endColumn":14,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[4095,4097],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary optional chain on a non-nullish value.","line":154,"column":12,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":154,"endColumn":14,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[4749,4751],"text":"."},"desc":"Remove unnecessary optional chain"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import chalk from 'chalk';\nimport { isTTY } from './output.js';\nimport { visibleTextWidth } from '../utils/text.js';\nimport { fitTextToWidth } from '../utils/terminal-layout.js';\n\nlet renderer: ((md: string) => string) | null = null;\nlet rendererBackend: 'plain' | 'marked-terminal' = 'plain';\n\nfunction isTableSeparator(line: string): boolean {\n  const t = line.trim();\n  return /^\\|?\\s*:?-{3,}:?\\s*(\\|\\s*:?-{3,}:?\\s*)+\\|?$/.test(t);\n}\n\nfunction splitTableRow(line: string): string[] {\n  const trimmed = line.trim().replace(/^\\|/, '').replace(/\\|$/, '');\n  return trimmed.split('|').map(c => c.trim());\n}\n\nfunction formatTableBlock(lines: string[], width: number): string[] {\n  if (lines.length < 2 || !isTableSeparator(lines[1]!)) return lines;\n  const rows = lines.map(splitTableRow);\n  const colCount = Math.max(...rows.map(r => r.length));\n  const normalized = rows.map(r => [...r, ...Array(Math.max(0, colCount - r.length)).fill('')]);\n\n  const maxTotal = Math.max(20, width - 6);\n  const baseCol = Math.max(4, Math.floor(maxTotal / colCount) - 3);\n  const colWidths = Array.from({ length: colCount }, (_, i) =>\n    Math.min(baseCol, Math.max(4, ...normalized.map(r => visibleTextWidth(String(r[i] ?? '')))))\n  );\n\n  const render = (cells: string[]) => `| ${cells.map((c, i) => fitTextToWidth(String(c), colWidths[i]!, { pad: true })).join(' | ')} |`;\n  const rule = `|-${colWidths.map(w => '-'.repeat(w)).join('-|-')}-|`;\n\n  const out: string[] = [];\n  out.push(render(normalized[0]!));\n  out.push(rule);\n  for (let i = 2; i < normalized.length; i++) out.push(render(normalized[i]!));\n  return out;\n}\n\n/**\n * Format markdown pipe tables into aligned plain-text tables for terminal readability.\n */\nexport function formatMarkdownTables(text: string, width = 100): string {\n  if (!text.includes('|')) return text;\n  const lines = text.split('\\n');\n  const out: string[] = [];\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i]!;\n    const next = lines[i + 1];\n    if (line.includes('|') && next && isTableSeparator(next)) {\n      const block: string[] = [line, next];\n      i += 2;\n      while (i < lines.length && lines[i]!.includes('|')) {\n        block.push(lines[i]!);\n        i++;\n      }\n      i -= 1;\n      out.push(...formatTableBlock(block, width));\n    } else {\n      out.push(line);\n    }\n  }\n\n  return out.join('\\n');\n}\n\nfunction setPlainRenderer(): (md: string) => string {\n  renderer = (md: string) => md;\n  rendererBackend = 'plain';\n  return renderer;\n}\n\nasync function getRenderer(): Promise<(md: string) => string> {\n  if (renderer) return renderer;\n\n  if (!isTTY) {\n    return setPlainRenderer();\n  }\n\n  try {\n    const { Marked } = await import('marked');\n    const { markedTerminal } = await import('marked-terminal');\n\n    const marked = new Marked(\n      markedTerminal(\n        {\n          code: chalk.hex('#F59E0B'),\n          codespan: chalk.hex('#F59E0B').bold,\n          firstHeading: chalk.hex('#8B5CF6').bold.underline,\n          heading: chalk.hex('#3B82F6').bold,\n          strong: chalk.bold,\n          em: chalk.italic,\n          del: chalk.dim.strikethrough,\n          blockquote: chalk.hex('#71717A').italic,\n          link: chalk.hex('#3B82F6').underline,\n          href: chalk.hex('#3B82F6').underline,\n          listitem: chalk.reset,\n          table: chalk.reset,\n          hr: chalk.dim,\n          paragraph: chalk.reset,\n          html: chalk.dim,\n          width: 100,\n          reflowText: false,\n          showSectionPrefix: true,\n          unescape: true,\n          emoji: true,\n          tab: 2,\n        }\n      )\n    );\n\n    renderer = (md: string) => {\n      try {\n        const result = marked.parse(md, { async: false });\n        return typeof result === 'string' ? result : String(result);\n      } catch {\n        setPlainRenderer();\n        return md;\n      }\n    };\n    rendererBackend = 'marked-terminal';\n    return renderer;\n  } catch {\n    return setPlainRenderer();\n  }\n}\n\n/**\n * Render markdown text to the terminal via stdout.\n */\nexport async function renderMarkdown(text: string): Promise<void> {\n  if (!text?.trim()) return;\n  try {\n    const prepared = formatMarkdownTables(text, 100);\n    const render = await getRenderer();\n    const result = render(prepared);\n    if (result) process.stdout.write(result);\n  } catch (err) {\n    // Fallback: just print the raw text if markdown rendering fails\n    setPlainRenderer();\n    if (process.env.OPTA_DEBUG) {\n      console.error(`Markdown render failed (${rendererBackend}), using plain text:`, err);\n    }\n    process.stdout.write(text);\n  }\n}\n\n/**\n * Render markdown text to a string (for testing and programmatic use).\n */\nexport async function renderMarkdownToString(text: string): Promise<string> {\n  if (!text?.trim()) return '';\n  try {\n    const prepared = formatMarkdownTables(text, 100);\n    const render = await getRenderer();\n    return render(prepared) || '';\n  } catch (err) {\n    setPlainRenderer();\n    if (process.env.OPTA_DEBUG) {\n      console.error(`Markdown render to string failed (${rendererBackend}):`, err);\n    }\n    return text;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/ui/output.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-boolean-literal-compare","severity":1,"message":"This expression unnecessarily compares a boolean value to a boolean instead of using it directly.","line":4,"column":22,"nodeType":"BinaryExpression","messageId":"direct","endLine":4,"endColumn":51,"fix":{"range":[96,125],"text":"process.stdout.isTTY"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import chalk from 'chalk';\nimport { colorizeOptaWord } from './brand.js';\n\nexport const isTTY = process.stdout.isTTY === true;\nexport const forceColor = !!process.env['FORCE_COLOR'];\nexport const isCI = (process.env['CI'] === 'true' || !isTTY) && !forceColor;\nexport const noColor = 'NO_COLOR' in process.env;\n\n/**\n * Re-evaluate color settings at runtime (e.g. after /theme changes NO_COLOR).\n * Safe to call multiple times  updates chalk.level based on current env.\n */\nexport function applyColorSettings(): void {\n  const shouldDisable =\n    process.env['NO_COLOR'] !== undefined\n    || process.env['TERM'] === 'dumb'\n    || (!isTTY && !forceColor)\n    || (process.env['CI'] === 'true' && !forceColor);\n  chalk.level = shouldDisable ? 0 : chalk.level || 3;\n}\n\n// Apply on module load\napplyColorSettings();\n\nexport function success(message: string): void {\n  console.log(chalk.green('') + ' ' + colorizeOptaWord(message));\n}\n\nexport function warn(message: string): void {\n  console.log(chalk.yellow('') + ' ' + colorizeOptaWord(message));\n}\n\nexport function info(message: string): void {\n  console.log(chalk.dim('') + ' ' + colorizeOptaWord(message));\n}\n\nexport function error(message: string): void {\n  console.error(chalk.red('') + ' ' + colorizeOptaWord(message));\n}\n\nexport function dim(text: string): string {\n  return chalk.dim(colorizeOptaWord(text));\n}\n\nexport function heading(text: string): void {\n  console.log('\\n' + chalk.bold(colorizeOptaWord(text)));\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/ui/pane-menu.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":63,"column":19,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":63,"endColumn":41},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":64,"column":16,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":64,"endColumn":35},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":159,"column":27,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":159,"endColumn":46},{"ruleId":"@typescript-eslint/return-await","severity":1,"message":"Returning an awaited promise is not allowed in this context.","line":164,"column":10,"nodeType":"AwaitExpression","messageId":"disallowedPromiseAwait","endLine":249,"endColumn":5,"fix":{"range":[5682,5688],"text":""}},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":178,"column":23,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":178,"endColumn":46},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":236,"column":22,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":236,"endColumn":45,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[8210,8211],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":239,"column":22,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":239,"endColumn":45,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[8317,8318],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { emitKeypressEvents } from 'node:readline';\nimport chalk from 'chalk';\nimport { colorizeOptaWord } from './brand.js';\nimport { fitTextToWidth, padToWidth } from '../utils/terminal-layout.js';\nimport { clamp } from '../utils/common.js';\n\ntype ActivePane = 'sections' | 'items';\n\nexport interface PaneMenuItem {\n  id: string;\n  label: string;\n  description?: string;\n}\n\nexport interface PaneMenuSection {\n  id: string;\n  label: string;\n  color?: string;\n  items: PaneMenuItem[];\n}\n\nexport interface PaneMenuOptions {\n  title: string;\n  subtitle?: string;\n  sections: PaneMenuSection[];\n  instructions?: string;\n  loop?: boolean;\n  initialSectionIndex?: number;\n  initialItemIndex?: number;\n}\n\nexport interface PaneMenuSelection {\n  sectionId: string;\n  itemId: string;\n  sectionIndex: number;\n  itemIndex: number;\n}\n\nfunction moveIndex(current: number, delta: number, size: number, loop: boolean): number {\n  if (size <= 0) return 0;\n  if (loop) return (current + delta + size) % size;\n  return clamp(current + delta, 0, size - 1);\n}\n\nfunction windowRange(total: number, selected: number, maxRows: number): { start: number; end: number } {\n  if (total <= maxRows) return { start: 0, end: total };\n  const half = Math.floor(maxRows / 2);\n  const start = clamp(selected - half, 0, total - maxRows);\n  return { start, end: start + maxRows };\n}\n\nfunction paintChip(text: string, color?: string): string {\n  if (!color) return chalk.cyan(text);\n  return chalk.hex(color)(text);\n}\n\nfunction renderFrame(\n  options: PaneMenuOptions,\n  sectionIndex: number,\n  itemIndexes: number[],\n  activePane: ActivePane,\n): void {\n  const columns = process.stdout.columns ?? 120;\n  const rows = process.stdout.rows ?? 36;\n  const sections = options.sections;\n  const selectedSection = sections[sectionIndex];\n  const selectedItems = selectedSection?.items ?? [];\n  const itemIndex = itemIndexes[sectionIndex] ?? 0;\n\n  const usableColumns = Math.max(20, columns - 3);\n  const minLeft = 8;\n  const minRight = 10;\n  let leftWidth = clamp(Math.floor(usableColumns * 0.32), minLeft, Math.min(42, Math.max(minLeft, usableColumns - minRight)));\n  let rightWidth = usableColumns - leftWidth;\n  if (rightWidth < minRight) {\n    leftWidth = Math.max(minLeft, leftWidth - (minRight - rightWidth));\n    rightWidth = usableColumns - leftWidth;\n  }\n  const maxRows = clamp(rows - 12, 6, 18);\n\n  const leftRange = windowRange(sections.length, sectionIndex, maxRows);\n  const rightRange = windowRange(selectedItems.length, itemIndex, maxRows);\n\n  const title = colorizeOptaWord(options.title);\n  const subtitle = options.subtitle ? chalk.dim(options.subtitle) : '';\n  const instructions = options.instructions ?? '/ switch panes  / scroll (infinite)  Enter select  q exit';\n\n  process.stdout.write('\\x1b[2J\\x1b[H');\n  process.stdout.write(`${chalk.bold(title)}\\n`);\n  if (subtitle) process.stdout.write(`${subtitle}\\n`);\n  process.stdout.write(`${chalk.dim(instructions)}\\n\\n`);\n\n  const leftHeader = fitTextToWidth('Areas', leftWidth, { pad: true });\n  const rightHeader = fitTextToWidth(selectedSection?.label ?? 'Commands', rightWidth, { pad: true });\n  process.stdout.write(\n    `${activePane === 'sections' ? chalk.bgMagenta.black(` ${leftHeader} `) : chalk.magenta(` ${leftHeader} `)} ` +\n    `${activePane === 'items' ? chalk.bgCyan.black(` ${rightHeader} `) : chalk.cyan(` ${rightHeader} `)}\\n`,\n  );\n\n  for (let i = 0; i < maxRows; i++) {\n    const sIdx = leftRange.start + i;\n    const itIdx = rightRange.start + i;\n    const section = sections[sIdx];\n    const item = selectedItems[itIdx];\n\n    let left = padToWidth('', leftWidth + 2);\n    if (section) {\n      const raw = `${sIdx === sectionIndex ? '' : ''} ${section.label}`;\n      const padded = ` ${fitTextToWidth(raw, leftWidth, { pad: true })} `;\n      if (sIdx === sectionIndex) {\n        left = activePane === 'sections'\n          ? chalk.bgHex('#4c1d95').white(padded)\n          : chalk.hex('#a78bfa')(padded);\n      } else {\n        left = paintChip(padded, section.color);\n      }\n    }\n\n    let right = padToWidth('', rightWidth + 2);\n    if (item) {\n      const raw = `${itIdx === itemIndex ? '' : ''} /${item.id} ${item.description ?? ''}`;\n      const padded = ` ${fitTextToWidth(raw, rightWidth, { pad: true })} `;\n      if (itIdx === itemIndex) {\n        right = activePane === 'items'\n          ? chalk.bgHex('#0e7490').white(padded)\n          : chalk.cyan(padded);\n      } else {\n        right = chalk.dim(padded);\n      }\n    }\n\n    process.stdout.write(`${left} ${right}\\n`);\n  }\n\n  const selectedItem = selectedItems[itemIndex];\n  process.stdout.write('\\n');\n  if (selectedItem) {\n    process.stdout.write(\n      chalk.dim('Selected: ') +\n      chalk.cyan(`/${selectedItem.id}`) +\n      (selectedItem.description ? chalk.dim(`  ${selectedItem.description}`) : '') +\n      '\\n',\n    );\n  } else {\n    process.stdout.write(chalk.dim('No commands in this area') + '\\n');\n  }\n}\n\nexport async function runPaneMenu(options: PaneMenuOptions): Promise<PaneMenuSelection | null> {\n  const sections = options.sections.filter((s) => s.items.length > 0);\n  if (!process.stdin.isTTY || sections.length === 0) return null;\n\n  const loop = options.loop ?? true;\n  let sectionIndex = clamp(options.initialSectionIndex ?? 0, 0, sections.length - 1);\n  const itemIndexes = sections.map((s) => clamp(options.initialItemIndex ?? 0, 0, Math.max(0, s.items.length - 1)));\n  let activePane: ActivePane = 'sections';\n\n  emitKeypressEvents(process.stdin);\n  const previousRawMode = process.stdin.isRaw ?? false;\n  if (!previousRawMode) process.stdin.setRawMode(true);\n  process.stdin.resume();\n  process.stdout.write('\\x1b[?25l');\n\n  return await new Promise<PaneMenuSelection | null>((resolve) => {\n    const cleanup = (): void => {\n      process.stdin.off('keypress', onKeypress);\n      if (!previousRawMode && process.stdin.isTTY) process.stdin.setRawMode(false);\n      process.stdout.write('\\x1b[?25h');\n    };\n\n    const finish = (value: PaneMenuSelection | null): void => {\n      cleanup();\n      process.stdout.write('\\x1b[0m\\n');\n      resolve(value);\n    };\n\n    const onKeypress = (_str: string, key: { name?: string; ctrl?: boolean }): void => {\n      const section = sections[sectionIndex]!;\n      const currentItemCount = Math.max(1, section.items.length);\n\n      if (key.ctrl && key.name === 'c') {\n        finish(null);\n        return;\n      }\n\n      if (key.name === 'q' || key.name === 'escape') {\n        finish(null);\n        return;\n      }\n\n      if (key.name === 'tab') {\n        activePane = activePane === 'sections' ? 'items' : 'sections';\n        renderFrame({ ...options, sections }, sectionIndex, itemIndexes, activePane);\n        return;\n      }\n\n      if (key.name === 'left') {\n        activePane = 'sections';\n        renderFrame({ ...options, sections }, sectionIndex, itemIndexes, activePane);\n        return;\n      }\n\n      if (key.name === 'right') {\n        activePane = 'items';\n        renderFrame({ ...options, sections }, sectionIndex, itemIndexes, activePane);\n        return;\n      }\n\n      if (key.name === 'up') {\n        if (activePane === 'sections') {\n          sectionIndex = moveIndex(sectionIndex, -1, sections.length, loop);\n        } else {\n          itemIndexes[sectionIndex] = moveIndex(itemIndexes[sectionIndex] ?? 0, -1, currentItemCount, loop);\n        }\n        renderFrame({ ...options, sections }, sectionIndex, itemIndexes, activePane);\n        return;\n      }\n\n      if (key.name === 'down') {\n        if (activePane === 'sections') {\n          sectionIndex = moveIndex(sectionIndex, 1, sections.length, loop);\n        } else {\n          itemIndexes[sectionIndex] = moveIndex(itemIndexes[sectionIndex] ?? 0, 1, currentItemCount, loop);\n        }\n        renderFrame({ ...options, sections }, sectionIndex, itemIndexes, activePane);\n        return;\n      }\n\n      if (key.name === 'return' || key.name === 'enter') {\n        if (activePane === 'sections') {\n          activePane = 'items';\n          renderFrame({ ...options, sections }, sectionIndex, itemIndexes, activePane);\n          return;\n        }\n        const itemIndex = itemIndexes[sectionIndex] ?? 0;\n        const item = sections[sectionIndex]!.items[itemIndex];\n        if (!item) return;\n        finish({\n          sectionId: sections[sectionIndex]!.id,\n          itemId: item.id,\n          sectionIndex,\n          itemIndex,\n        });\n      }\n    };\n\n    process.stdin.on('keypress', onKeypress);\n    renderFrame({ ...options, sections }, sectionIndex, itemIndexes, activePane);\n  });\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/ui/progress.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":108,"column":58,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":108,"endColumn":72}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import chalk from 'chalk';\n\nexport function renderPercentBar(percent: number, width = 20): string {\n  const clamped = Math.max(0, Math.min(100, Number.isFinite(percent) ? percent : 0));\n  const ratio = clamped / 100;\n  const filled = Math.round(ratio * width);\n  const empty = Math.max(0, width - filled);\n  const pctText = `${Math.round(clamped)}%`;\n  const filledBar = 'O'.repeat(filled);\n  const emptyBar = 'o'.repeat(empty);\n  return `${chalk.hex('#8b5cf6')(filledBar)}${chalk.hex('#312e81')(emptyBar)} ${chalk.hex('#22d3ee')(pctText)}`;\n}\n\nexport interface StepProgressTracker {\n  tick(message?: string): void;\n  set(current: number, message?: string): void;\n  done(message?: string): void;\n  fail(message?: string): void;\n}\n\nexport interface SegmentedStepProgressTracker {\n  tick(segment: string, message?: string): void;\n  set(segment: string, current: number, message?: string): void;\n  done(message?: string): void;\n  fail(message?: string): void;\n}\n\ninterface ProgressSegmentConfig {\n  key: string;\n  label: string;\n  totalSteps: number;\n}\n\ninterface ProgressSegmentState {\n  key: string;\n  label: string;\n  total: number;\n  current: number;\n  message?: string;\n}\n\nexport function createStepProgressTracker(\n  totalSteps: number,\n  title: string,\n  enabled = true,\n): StepProgressTracker {\n  const total = Math.max(1, totalSteps);\n  let current = 0;\n\n  const render = (symbol: string, message?: string): void => {\n    if (!enabled) return;\n    const percent = Math.round((Math.max(0, Math.min(total, current)) / total) * 100);\n    const line = `${symbol} ${chalk.bold(title)} ${renderPercentBar(percent, 24)}${message ? ` ${chalk.dim(message)}` : ''}`;\n    console.log(line);\n  };\n\n  const finishLine = (): void => {\n    // no-op: keep output append-only to avoid cursor-control ANSI sequences\n  };\n\n  return {\n    tick(message?: string): void {\n      current = Math.min(total, current + 1);\n      render(chalk.cyan(''), message);\n    },\n    set(next: number, message?: string): void {\n      current = Math.max(0, Math.min(total, next));\n      render(chalk.cyan(''), message);\n    },\n    done(message?: string): void {\n      current = total;\n      render(chalk.green(''), message ?? 'done');\n      finishLine();\n    },\n    fail(message?: string): void {\n      render(chalk.red(''), message ?? 'failed');\n      finishLine();\n    },\n  };\n}\n\nexport function createSegmentedStepProgressTracker(\n  segments: readonly ProgressSegmentConfig[],\n  title: string,\n  enabled = true,\n): SegmentedStepProgressTracker {\n  const states = segments\n    .map((segment) => ({\n      key: segment.key,\n      label: segment.label,\n      total: Math.max(1, segment.totalSteps),\n      current: 0,\n      message: undefined,\n    }))\n    .filter((segment) => segment.key.trim().length > 0);\n\n  const safeStates: ProgressSegmentState[] = states.length > 0\n    ? states\n    : [{ key: 'default', label: 'Progress', total: 1, current: 0 }];\n\n  const total = Math.max(\n    1,\n    safeStates.reduce((sum, segment) => sum + segment.total, 0),\n  );\n  const labelWidth = Math.max(...safeStates.map((segment) => segment.label.length), 7);\n\n  const findSegment = (key: string): ProgressSegmentState =>\n    safeStates.find((segment) => segment.key === key) ?? safeStates[0]!;\n\n  const render = (symbol: string, headline?: string): void => {\n    if (!enabled) return;\n\n    const completed = safeStates.reduce((sum, segment) => sum + segment.current, 0);\n    const percent = Math.round((Math.max(0, Math.min(total, completed)) / total) * 100);\n    const lines = [\n      `${symbol} ${chalk.bold(title)} ${renderPercentBar(percent, 24)}${headline ? ` ${chalk.dim(headline)}` : ''}`,\n      ...safeStates.map((segment) => {\n        const segmentPercent = Math.round((Math.max(0, Math.min(segment.total, segment.current)) / segment.total) * 100);\n        const label = segment.label.padEnd(labelWidth, ' ');\n        const detail = segment.message ? ` ${chalk.dim(segment.message)}` : '';\n        return `  ${chalk.bold(label)} ${renderPercentBar(segmentPercent, 24)}${detail}`;\n      }),\n    ];\n\n    console.log(lines.join('\\n'));\n  };\n\n  const finish = (): void => {\n    // no-op: append-only output, nothing to clean up\n  };\n\n  return {\n    tick(segmentKey: string, message?: string): void {\n      const segment = findSegment(segmentKey);\n      segment.current = Math.min(segment.total, segment.current + 1);\n      segment.message = message;\n      render(chalk.cyan(''), message);\n    },\n    set(segmentKey: string, current: number, message?: string): void {\n      const segment = findSegment(segmentKey);\n      segment.current = Math.max(0, Math.min(segment.total, current));\n      segment.message = message;\n      render(chalk.cyan(''), message);\n    },\n    done(message?: string): void {\n      for (const segment of safeStates) {\n        segment.current = segment.total;\n      }\n      render(chalk.green(''), message ?? 'done');\n      finish();\n    },\n    fail(message?: string): void {\n      render(chalk.red(''), message ?? 'failed');\n      finish();\n    },\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/ui/prompt-nav.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":59,"column":29,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":59,"endColumn":41,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[1812,1813],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, value is always falsy.","line":130,"column":9,"nodeType":"Identifier","messageId":"alwaysFalsy","endLine":130,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { emitKeypressEvents } from 'node:readline';\n\nexport type MenuPromptMode = 'select' | 'search';\n\ninterface KeypressLike {\n  name?: string;\n  ctrl?: boolean;\n  meta?: boolean;\n  shift?: boolean;\n}\n\ninterface BackKeyState {\n  mode: MenuPromptMode;\n  key?: KeypressLike;\n  input?: string;\n  searchTermLength: number;\n}\n\ninterface BackKeyDecision {\n  triggerBack: boolean;\n  nextSearchTermLength: number;\n}\n\nfunction isNonEmptyString(value: unknown): value is string {\n  return typeof value === 'string' && value.length > 0;\n}\n\nfunction isPrintableInput(input?: string): boolean {\n  return Boolean(input && input.length > 0 && !input.startsWith('\\u001b'));\n}\n\nfunction normalizeKeyName(key?: KeypressLike, input?: string): string | undefined {\n  const name = key?.name?.toLowerCase();\n  if (name) return name;\n  if (!input) return undefined;\n\n  // Some terminals emit raw escape sequences without key metadata.\n  if (input === '\\u001b[D') return 'left';\n  if (input === '\\u007f' || input === '\\u0008') return 'backspace';\n  if (input === '\\u001b[3~') return 'delete';\n  if (input === '\\u001b') return 'escape';\n  return undefined;\n}\n\n/**\n * Decide whether a keypress should move back to the previous menu and\n * update the tracked search-term length for search prompts.\n */\nexport function evaluateMenuBackKey(state: BackKeyState): BackKeyDecision {\n  const keyName = normalizeKeyName(state.key, state.input);\n  const hasModifier = Boolean(state.key?.ctrl || state.key?.meta);\n  let nextSearchTermLength = state.searchTermLength;\n\n  if (state.mode === 'search' && state.key?.ctrl && (keyName === 'u' || keyName === 'w')) {\n    return { triggerBack: false, nextSearchTermLength: 0 };\n  }\n\n  if (state.mode === 'search' && !hasModifier && isPrintableInput(state.input)) {\n    nextSearchTermLength += state.input!.length;\n  }\n\n  if (hasModifier) {\n    return { triggerBack: false, nextSearchTermLength };\n  }\n\n  if (keyName === 'escape') {\n    return { triggerBack: true, nextSearchTermLength: 0 };\n  }\n\n  if (keyName === 'left') {\n    return { triggerBack: true, nextSearchTermLength };\n  }\n\n  if (keyName === 'backspace' || keyName === 'delete') {\n    if (state.mode === 'search') {\n      if (state.searchTermLength <= 0) {\n        return { triggerBack: true, nextSearchTermLength: 0 };\n      }\n      return {\n        triggerBack: false,\n        nextSearchTermLength: Math.max(0, state.searchTermLength - 1),\n      };\n    }\n    return { triggerBack: true, nextSearchTermLength };\n  }\n\n  return { triggerBack: false, nextSearchTermLength };\n}\n\n/**\n * Run an inquirer menu prompt with keyboard back-navigation:\n * - escape: cancel current menu / go back\n * - left arrow: go back to previous menu\n * - backspace/delete: go back for select menus\n * - backspace/delete: go back for search menus when search box is empty\n */\nexport async function runMenuPrompt<T>(\n  runPrompt: (context: { signal: AbortSignal }) => Promise<T>,\n  mode: MenuPromptMode,\n): Promise<T | null> {\n  if (!process.stdin.isTTY) {\n    const controller = new AbortController();\n    return runPrompt({ signal: controller.signal });\n  }\n\n  const input = process.stdin;\n  const controller = new AbortController();\n  let searchTermLength = 0;\n  let abortedByBackKey = false;\n\n  const onKeypress = (data: unknown, key: unknown): void => {\n    const decision = evaluateMenuBackKey({\n      mode,\n      key: key as KeypressLike,\n      input: isNonEmptyString(data) ? data : undefined,\n      searchTermLength,\n    });\n    searchTermLength = decision.nextSearchTermLength;\n    if (decision.triggerBack) {\n      abortedByBackKey = true;\n      controller.abort();\n    }\n  };\n\n  emitKeypressEvents(input);\n  input.on('keypress', onKeypress);\n  try {\n    return await runPrompt({ signal: controller.signal });\n  } catch (err) {\n    if (abortedByBackKey) return null;\n    throw err;\n  } finally {\n    input.off('keypress', onKeypress);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/ui/spinner.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/ui/statusbar.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/ui/theme.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":105,"column":31,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":105,"endColumn":46}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import chalk, { type ChalkInstance } from 'chalk';\n\nexport interface ThemeColors {\n  primary: string;\n  secondary: string;\n  success: string;\n  error: string;\n  warning: string;\n  info: string;\n  muted: string;\n  text: string;\n  border: string;\n}\n\nexport interface Theme {\n  name: string;\n  description: string;\n  colors: ThemeColors;\n  primary: ChalkInstance;\n  secondary: ChalkInstance;\n  success: ChalkInstance;\n  error: ChalkInstance;\n  warning: ChalkInstance;\n  info: ChalkInstance;\n  muted: ChalkInstance;\n  dim: ChalkInstance;\n}\n\nconst THEMES: Record<string, { description: string; colors: ThemeColors }> = {\n  opta: {\n    description: 'Default Opta theme  Electric Violet accent',\n    colors: {\n      primary: '#8B5CF6',\n      secondary: '#3B82F6',\n      success: '#22C55E',\n      error: '#EF4444',\n      warning: '#F59E0B',\n      info: '#06B6D4',\n      muted: '#52525B',\n      text: '#FAFAFA',\n      border: '#3F3F46',\n    },\n  },\n  minimal: {\n    description: 'Minimal  muted grays, no color accents',\n    colors: {\n      primary: '#A1A1AA',\n      secondary: '#71717A',\n      success: '#A1A1AA',\n      error: '#F87171',\n      warning: '#FCD34D',\n      info: '#A1A1AA',\n      muted: '#52525B',\n      text: '#E4E4E7',\n      border: '#3F3F46',\n    },\n  },\n  solarized: {\n    description: 'Solarized Dark  warm tones',\n    colors: {\n      primary: '#268BD2',\n      secondary: '#2AA198',\n      success: '#859900',\n      error: '#DC322F',\n      warning: '#B58900',\n      info: '#6C71C4',\n      muted: '#586E75',\n      text: '#FDF6E3',\n      border: '#073642',\n    },\n  },\n  dracula: {\n    description: 'Dracula  purple and cyan',\n    colors: {\n      primary: '#BD93F9',\n      secondary: '#8BE9FD',\n      success: '#50FA7B',\n      error: '#FF5555',\n      warning: '#F1FA8C',\n      info: '#8BE9FD',\n      muted: '#6272A4',\n      text: '#F8F8F2',\n      border: '#44475A',\n    },\n  },\n  catppuccin: {\n    description: 'Catppuccin Mocha  pastel colors',\n    colors: {\n      primary: '#CBA6F7',\n      secondary: '#89B4FA',\n      success: '#A6E3A1',\n      error: '#F38BA8',\n      warning: '#F9E2AF',\n      info: '#74C7EC',\n      muted: '#585B70',\n      text: '#CDD6F4',\n      border: '#45475A',\n    },\n  },\n};\n\nlet currentThemeName = 'opta';\n\nfunction buildTheme(name: string): Theme {\n  const def = THEMES[name] ?? THEMES['opta']!;\n  const colors = def.colors;\n\n  return {\n    name,\n    description: def.description,\n    colors,\n    primary: chalk.hex(colors.primary),\n    secondary: chalk.hex(colors.secondary),\n    success: chalk.hex(colors.success),\n    error: chalk.hex(colors.error),\n    warning: chalk.hex(colors.warning),\n    info: chalk.hex(colors.info),\n    muted: chalk.hex(colors.muted),\n    dim: chalk.dim,\n  };\n}\n\nexport function getTheme(): Theme {\n  return buildTheme(currentThemeName);\n}\n\nexport function setTheme(name: string): void {\n  if (THEMES[name]) {\n    currentThemeName = name;\n  }\n}\n\nexport function listThemes(): Array<{ name: string; description: string }> {\n  return Object.entries(THEMES).map(([name, def]) => ({\n    name,\n    description: def.description,\n  }));\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/ui/thinking.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/ui/toolcards.ts","messages":[{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args.offset ?? 1' will use Object's default stringification format ('[object Object]') when stringified.","line":26,"column":59,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":26,"endColumn":75},{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":1,"message":"Invalid type \"{}\" of template literal expression.","line":26,"column":59,"nodeType":"LogicalExpression","messageId":"invalidType","endLine":26,"endColumn":75},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":26,"column":80,"nodeType":"TSAsExpression","messageId":"neverNullish","endLine":26,"endColumn":101},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":26,"column":111,"nodeType":"TSAsExpression","messageId":"neverNullish","endLine":26,"endColumn":131},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args.content ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":31,"column":30,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":31,"endColumn":48},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args.old_text' will use Object's default stringification format ('[object Object]') when stringified.","line":40,"column":32,"nodeType":"MemberExpression","messageId":"baseToString","endLine":40,"endColumn":45},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args.new_text' will use Object's default stringification format ('[object Object]') when stringified.","line":41,"column":32,"nodeType":"MemberExpression","messageId":"baseToString","endLine":41,"endColumn":45},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":49,"column":61,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":49,"endColumn":74,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[1882,1883],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":55,"column":63,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":55,"endColumn":76,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[2165,2166],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args.path' will use Object's default stringification format ('[object Object]') when stringified.","line":69,"column":69,"nodeType":"MemberExpression","messageId":"baseToString","endLine":69,"endColumn":78},{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":1,"message":"Invalid type \"{}\" of template literal expression.","line":69,"column":69,"nodeType":"MemberExpression","messageId":"invalidType","endLine":69,"endColumn":78},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args.path || '.'' will use Object's default stringification format ('[object Object]') when stringified.","line":73,"column":56,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":73,"endColumn":72},{"ruleId":"@typescript-eslint/no-base-to-string","severity":1,"message":"'args.question ?? ''' will use Object's default stringification format ('[object Object]') when stringified.","line":77,"column":58,"nodeType":"LogicalExpression","messageId":"baseToString","endLine":77,"endColumn":77}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import chalk from 'chalk';\nimport { getTheme } from './theme.js';\n\nconst TOOL_ICONS: Record<string, string> = {\n  read_file: '',\n  write_file: '',\n  edit_file: '',\n  list_dir: '',\n  search_files: '',\n  find_files: '',\n  run_command: '',\n  ask_user: '',\n};\n\nexport function formatToolCall(name: string, args: Record<string, unknown>): string {\n  const icon = TOOL_ICONS[name] || '';\n  const theme = getTheme();\n  const parts: string[] = [];\n\n  parts.push(chalk.dim('  ') + ` ${icon} ${theme.primary.bold(name)}`);\n\n  switch (name) {\n    case 'read_file':\n      parts.push(chalk.dim('   ') + theme.info(String(args.path)));\n      if (args.offset || args.limit) {\n        parts.push(chalk.dim('   ') + chalk.dim(`lines ${args.offset ?? 1}-${(args.offset as number ?? 0) + (args.limit as number ?? 0)}`));\n      }\n      break;\n\n    case 'write_file': {\n      const content = String(args.content ?? '');\n      const lineCount = content.split('\\n').length;\n      parts.push(chalk.dim('   ') + theme.info(String(args.path)) + chalk.dim(` (${lineCount} lines)`));\n      break;\n    }\n\n    case 'edit_file':\n      parts.push(chalk.dim('   ') + theme.info(String(args.path)));\n      if (args.old_text && args.new_text) {\n        const oldText = String(args.old_text);\n        const newText = String(args.new_text);\n        const oldLines = oldText.split('\\n');\n        const newLines = newText.split('\\n');\n        parts.push(chalk.dim('   ') + theme.error(`- ${oldLines.length} line${oldLines.length > 1 ? 's' : ''}`) +\n          chalk.dim('  ') + theme.success(`+ ${newLines.length} line${newLines.length > 1 ? 's' : ''}`));\n        // Show compact inline diff preview (max 6 lines)\n        const previewLimit = 3;\n        for (let li = 0; li < Math.min(oldLines.length, previewLimit); li++) {\n          parts.push(chalk.dim('   ') + theme.error('- ' + oldLines[li]!.slice(0, 60)));\n        }\n        if (oldLines.length > previewLimit) {\n          parts.push(chalk.dim('     ...'));\n        }\n        for (let li = 0; li < Math.min(newLines.length, previewLimit); li++) {\n          parts.push(chalk.dim('   ') + theme.success('+ ' + newLines[li]!.slice(0, 60)));\n        }\n        if (newLines.length > previewLimit) {\n          parts.push(chalk.dim('     ...'));\n        }\n      }\n      break;\n\n    case 'run_command':\n      parts.push(chalk.dim('   ') + theme.warning(`$ ${String(args.command)}`));\n      break;\n\n    case 'search_files':\n      parts.push(chalk.dim('   ') + theme.warning(`/${String(args.pattern)}/`));\n      if (args.path) parts.push(chalk.dim('   ') + chalk.dim(`in ${args.path}`));\n      break;\n\n    case 'list_dir':\n      parts.push(chalk.dim('   ') + theme.info(String(args.path || '.')));\n      break;\n\n    case 'ask_user':\n      parts.push(chalk.dim('   ') + chalk.italic(String(args.question ?? '').slice(0, 60)));\n      break;\n\n    default:\n      for (const [k, v] of Object.entries(args)) {\n        const val = String(v).slice(0, 50);\n        parts.push(chalk.dim('   ') + chalk.dim(`${k}: `) + val);\n      }\n  }\n\n  parts.push(chalk.dim('  '));\n  return parts.join('\\n');\n}\n\nexport function formatToolResult(name: string, result: string, maxLen = 300): string {\n  const trimmed = result.length > maxLen\n    ? result.slice(0, maxLen) + chalk.dim(`... (${result.length} chars total)`)\n    : result;\n\n  if (name === 'run_command') {\n    return chalk.dim('  ') + trimmed.split('\\n').map(l => chalk.dim('   ') + l).join('\\n');\n  }\n\n  return chalk.dim('  ') + trimmed.split('\\n').slice(0, 10).map(l => chalk.dim('   ') + l).join('\\n');\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/utils/common.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/utils/config-helpers.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":27,"column":12,"nodeType":"TSAsExpression","messageId":"neverNullish","endLine":27,"endColumn":55},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":1,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":34,"column":12,"nodeType":"TSAsExpression","messageId":"neverNullish","endLine":34,"endColumn":55}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Shared config override builder.\n *\n * Canonical function for constructing config overrides from CLI flags.\n * Imported by chat.ts and do.ts.\n */\n\nexport interface ConfigOverrideFlags {\n  model?: string;\n  commit?: boolean;\n  checkpoints?: boolean;\n  dangerous?: boolean;\n  yolo?: boolean;\n  auto?: boolean;\n  plan?: boolean;\n}\n\nexport function buildConfigOverrides(opts: ConfigOverrideFlags): Record<string, unknown> {\n  const overrides: Record<string, unknown> = {};\n\n  if (opts.model) {\n    overrides['model'] = { default: opts.model };\n  }\n\n  if (opts.commit === false) {\n    overrides['git'] = {\n      ...((overrides['git'] as Record<string, unknown>) ?? {}),\n      autoCommit: false,\n    };\n  }\n\n  if (opts.checkpoints === false) {\n    overrides['git'] = {\n      ...((overrides['git'] as Record<string, unknown>) ?? {}),\n      checkpoints: false,\n    };\n  }\n\n  if (opts.dangerous || opts.yolo) {\n    overrides['defaultMode'] = 'dangerous';\n  } else if (opts.auto) {\n    overrides['defaultMode'] = 'auto';\n  } else if (opts.plan) {\n    overrides['defaultMode'] = 'plan';\n  }\n\n  return overrides;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/utils/errors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/utils/ignore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/utils/json.ts","messages":[{"ruleId":"@typescript-eslint/no-redundant-type-constituents","severity":1,"message":"'unknown' overrides all other types in this union type.","line":11,"column":47,"nodeType":"TSUnknownKeyword","messageId":"overrides","endLine":11,"endColumn":54}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Safe JSON parsing utility.\n * Replaces 10+ scattered try/catch JSON.parse blocks with a single function.\n */\n\n/**\n * Parse a JSON string, returning the fallback on failure.\n * Avoids the need for a try/catch wrapper at every call site.\n */\nexport function safeParseJson<T = unknown>(input: string, fallback: T): T;\nexport function safeParseJson(input: string): unknown | undefined;\nexport function safeParseJson<T = unknown>(input: string, fallback?: T): T | undefined {\n  try {\n    return JSON.parse(input) as T;\n  } catch {\n    return fallback;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/utils/pricing.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/utils/terminal-layout.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/utils/text.ts","messages":[{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-control-regex').","line":1,"column":1,"severity":1,"nodeType":null,"fix":{"range":[0,44],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-control-regex').","line":28,"column":5,"severity":1,"nodeType":null,"fix":{"range":[958,1002],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-control-regex').","line":56,"column":5,"severity":1,"nodeType":null,"fix":{"range":[2169,2213],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-control-regex').","line":274,"column":5,"severity":1,"nodeType":null,"fix":{"range":[9448,9492],"text":" "}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"// eslint-disable-next-line no-control-regex\nconst ANSI_ESCAPE_RE = /\\x1B(?:\\[[0-?]*[ -/]*[@-~]|\\][^\\x07]*(?:\\x07|\\x1B\\\\))/g;\n\n/**\n * Strip ANSI escape codes while preserving textual content.\n */\nexport function stripAnsi(input: string): string {\n  if (!input) return '';\n  return input.replace(ANSI_ESCAPE_RE, '');\n}\n\n/**\n * Strip ANSI escape codes and non-printable control characters that can\n * corrupt Ink layout measurement.\n */\nexport function sanitizeTerminalText(input: string): string {\n  if (!input) return '';\n\n  return stripAnsi(input)\n    // Keep Windows CRLF as newline, but drop lone CR (commonly used for\n    // in-place progress updates) by converting to a space so tokens don't\n    // collapse into a single merged word.\n    .replace(/\\r\\n/g, '\\n')\n    .replace(/\\r/g, ' ')\n    // Normalize tabs to spaces so table/log output remains deterministic in Ink.\n    .replace(/\\t/g, '  ')\n    // Remove all remaining control chars except \\n.\n    // eslint-disable-next-line no-control-regex\n    .replace(/[\\u0000-\\u0008\\u000B-\\u001F\\u007F]/g, '')\n    // Remove zero-width formatting chars that can break width estimation.\n    .replace(/[\\u200B-\\u200D\\u2060\\uFEFF]/g, '')\n    // Normalize trailing line whitespace to prevent pathological line wrapping.\n    .replace(/[ \\t]+$/gm, '')\n    // Space-only lines are effectively blank lines in terminal rendering.\n    .replace(/^[ \\t]+$/gm, '')\n    // Keep user-visible spacing but cap runaway blank-line growth.\n    .replace(/\\n{5,}/g, '\\n\\n\\n\\n');\n}\n\n/**\n * Sanitize a streaming token chunk without trimming edge whitespace.\n *\n * Token streams can carry semantic spaces at either the beginning or end of\n * each chunk. Unlike `sanitizeTerminalText`, this keeps those spaces intact so\n * incrementally concatenated output does not collapse words together.\n */\nexport function sanitizeTerminalTokenChunk(input: string): string {\n  if (!input) return '';\n\n  return stripAnsi(input)\n    .replace(/\\r\\n/g, '\\n')\n    // Preserve token boundaries for chunked streams that emit lone CR.\n    .replace(/\\r/g, ' ')\n    .replace(/\\t/g, '  ')\n    // Remove control chars but preserve visible whitespace (\\n and spaces).\n    // eslint-disable-next-line no-control-regex\n    .replace(/[\\u0000-\\u0008\\u000B-\\u001F\\u007F]/g, '')\n    .replace(/[\\u200B-\\u200D\\u2060\\uFEFF]/g, '');\n}\n\nfunction normalizeInlineMarkdownHeadings(input: string): string {\n  return input\n    // Start headings on a fresh paragraph when models inline them.\n    .replace(/([^\\n])\\s+(#{1,6}\\s)/g, '$1\\n\\n$2')\n    // Avoid over-gapped heading stacks.\n    .replace(/\\n{3,}(#{1,6}\\s)/g, '\\n\\n$1');\n}\n\nfunction splitDenseDashLine(line: string): string {\n  const trimmed = line.trim();\n  if (!trimmed) return line;\n  if (trimmed.startsWith('#')) return line;\n  if (trimmed.startsWith('- ') || trimmed.startsWith('* ') || trimmed.startsWith(' ')) return line;\n  if (trimmed.startsWith('```')) return line;\n  if (trimmed.includes('http://') || trimmed.includes('https://')) return line;\n\n  const matchCount = (line.match(/\\s-\\s/g) ?? []).length;\n  if (matchCount < 2) return line;\n\n  const parts = line.split(/\\s-\\s+/).map((part) => part.trim()).filter(Boolean);\n  if (parts.length < 2) return line;\n\n  const first = parts[0] ?? '';\n  const rest = parts.slice(1);\n  const colonIdx = first.indexOf(':');\n  if (colonIdx > 0 && colonIdx < first.length - 1) {\n    const prefix = first.slice(0, colonIdx + 1).trim();\n    const firstItem = first.slice(colonIdx + 1).trim();\n    const items = [firstItem, ...rest].filter(Boolean);\n    if (items.length === 0) return line;\n    return `${prefix}\\n- ${items.join('\\n- ')}`;\n  }\n\n  return `${first}\\n- ${rest.join('\\n- ')}`;\n}\n\nfunction expandDenseLabels(line: string): string {\n  if (line.length < 120) return line;\n  const labelMatches = line.match(/\\b[a-z][a-z0-9_-]{1,20}:\\s/gi) ?? [];\n  if (labelMatches.length < 2) return line;\n  return line.replace(/\\s+([a-z][a-z0-9_-]{1,20}:\\s)/gi, '\\n$1');\n}\n\nfunction normalizeMissingInlineSpaces(line: string): string {\n  // Insert missing spaces after punctuation in dense prose (`foo,bar` -> `foo, bar`)\n  // and between collapsed camel boundaries in non-code prose (`toolStatus` -> `tool Status`).\n  return line\n    .replace(/([,:;.!?])(?=[A-Za-z])/g, '$1 ')\n    .replace(/([a-z])([A-Z])/g, '$1 $2');\n}\n\nconst HARD_TOKEN_WRAP_LIMIT = 48;\n\nfunction breakOverlongTokens(line: string): string {\n  if (line.length < HARD_TOKEN_WRAP_LIMIT * 2) return line;\n\n  return line\n    .split(/(\\s+)/)\n    .map((segment) => {\n      if (!segment || /^\\s+$/.test(segment)) return segment;\n      if (segment.length < HARD_TOKEN_WRAP_LIMIT * 2) return segment;\n      if (segment.includes('://')) return segment;\n      if (segment.includes('`')) return segment;\n      if (!/[A-Za-z0-9]/.test(segment)) return segment;\n      const chunks = segment.match(new RegExp(`.{1,${HARD_TOKEN_WRAP_LIMIT}}`, 'g'));\n      if (!chunks || chunks.length <= 1) return segment;\n      return chunks.join('\\n');\n    })\n    .join('');\n}\n\nfunction splitLongProseLine(line: string, streaming: boolean): string {\n  if (streaming) return breakOverlongTokens(line);\n  if (line.length < 140) return line;\n\n  const trimmed = line.trim();\n  if (!trimmed) return line;\n  if (trimmed.startsWith('#')) return line;\n  if (trimmed.startsWith('- ') || trimmed.startsWith('* ') || trimmed.startsWith(' ')) return line;\n  if (trimmed.startsWith('```')) return line;\n  if (trimmed.startsWith('|') || trimmed.includes('|')) return line;\n  if (trimmed.includes('http://') || trimmed.includes('https://')) return line;\n\n  let next = breakOverlongTokens(normalizeMissingInlineSpaces(line));\n  next = next.replace(/([.!?;])\\s+(?=[A-Z0-9#])/g, '$1\\n');\n  if (next.length >= 140) {\n    next = next.replace(/,\\s+(?=[A-Za-z0-9])/g, ',\\n');\n  }\n  if (next.length >= 140) {\n    next = next.replace(/\\)\\s+(?=[A-Za-z0-9])/g, ')\\n');\n  }\n  return next;\n}\n\nfunction formatDenseNonCodeSegment(segment: string, streaming: boolean): string {\n  let formatted = normalizeInlineMarkdownHeadings(segment)\n    // Start numbered list markers on new lines when inline-packed.\n    .replace(/([^\\n])\\s+(\\d{1,3}\\.\\s)/g, '$1\\n$2')\n    // Encourage clear bullets when models emit sentence-style \" - \" separators.\n    .replace(/([.!?;:])\\s+-\\s+/g, '$1\\n- ');\n\n  const lines = formatted\n    .split('\\n')\n    .map((line) => expandDenseLabels(line))\n    .map((line) => (streaming ? line : splitDenseDashLine(line)))\n    .map((line) => splitLongProseLine(line, streaming));\n\n  formatted = lines.join('\\n');\n\n  // Keep clear spacing, but avoid runaway blank vertical gaps.\n  formatted = formatted\n    .replace(/\\n{4,}/g, '\\n\\n\\n')\n    .replace(/[ \\t]+$/gm, '')\n    .trim();\n\n  return formatted;\n}\n\n/**\n * Premium display formatter for assistant responses.\n *\n * Preserves code-fence blocks verbatim while restructuring dense prose into\n * headings/lists with clearer spacing for terminal readability.\n */\nexport function formatAssistantDisplayText(\n  input: string,\n  options?: { streaming?: boolean },\n): string {\n  const base = sanitizeTerminalText(input);\n  if (!base) return '';\n\n  const streaming = Boolean(options?.streaming);\n  const lines = base.split('\\n');\n  const out: string[] = [];\n  const proseBuffer: string[] = [];\n  let inFence = false;\n\n  const flushProseBuffer = (): void => {\n    if (proseBuffer.length === 0) return;\n    const segment = proseBuffer.join('\\n');\n    proseBuffer.length = 0;\n    if (!segment.trim()) {\n      out.push(segment);\n      return;\n    }\n    out.push(formatDenseNonCodeSegment(segment, streaming));\n  };\n\n  for (const line of lines) {\n    const fenceToggle = line.trim().startsWith('```');\n    if (fenceToggle) {\n      flushProseBuffer();\n      out.push(line);\n      inFence = !inFence;\n      continue;\n    }\n\n    if (inFence) {\n      out.push(line);\n      continue;\n    }\n\n    proseBuffer.push(line);\n  }\n\n  flushProseBuffer();\n\n  return out.join('\\n').replace(/\\n{4,}/g, '\\n\\n\\n').trim();\n}\n\n/**\n * Keep leading indentation but drop trailing blank lines/whitespace.\n */\nexport function trimDisplayTail(input: string): string {\n  return input.replace(/[ \\t]+\\n/g, '\\n').replace(/\\s+$/, '');\n}\n\nfunction isZeroWidthCodePoint(cp: number): boolean {\n  return (\n    (cp >= 0x0300 && cp <= 0x036f) || // Combining Diacritical Marks\n    (cp >= 0x1ab0 && cp <= 0x1aff) || // Combining Diacritical Marks Extended\n    (cp >= 0x1dc0 && cp <= 0x1dff) || // Combining Diacritical Marks Supplement\n    (cp >= 0x20d0 && cp <= 0x20ff) || // Combining Diacritical Marks for Symbols\n    (cp >= 0xfe20 && cp <= 0xfe2f) || // Combining Half Marks\n    (cp >= 0xfe00 && cp <= 0xfe0f) || // Variation Selectors\n    cp === 0x200d // Zero-width joiner\n  );\n}\n\nfunction isWideCodePoint(cp: number): boolean {\n  return cp >= 0x1100 && (\n    cp <= 0x115f ||\n    cp === 0x2329 ||\n    cp === 0x232a ||\n    (cp >= 0x2e80 && cp <= 0xa4cf && cp !== 0x303f) ||\n    (cp >= 0xac00 && cp <= 0xd7a3) ||\n    (cp >= 0xf900 && cp <= 0xfaff) ||\n    (cp >= 0xfe10 && cp <= 0xfe19) ||\n    (cp >= 0xfe30 && cp <= 0xfe6f) ||\n    (cp >= 0xff00 && cp <= 0xff60) ||\n    (cp >= 0xffe0 && cp <= 0xffe6) ||\n    (cp >= 0x1f300 && cp <= 0x1f64f) ||\n    (cp >= 0x1f900 && cp <= 0x1f9ff) ||\n    (cp >= 0x20000 && cp <= 0x3fffd)\n  );\n}\n\nfunction normalizeForWidth(input: string): string {\n  if (!input) return '';\n  return stripAnsi(input)\n    .replace(/\\r\\n/g, '\\n')\n    .replace(/\\r/g, '')\n    // Keep tabs/newlines and spaces intact for layout math.\n    // eslint-disable-next-line no-control-regex\n    .replace(/[\\u0000-\\u0008\\u000B-\\u001F\\u007F]/g, '');\n}\n\n/**\n * Approximate terminal cell width for sanitized text.\n */\nexport function visibleTextWidth(input: string): number {\n  const text = normalizeForWidth(input);\n  let width = 0;\n\n  for (const ch of text) {\n    if (ch === '\\n' || ch === '\\r') continue;\n    if (ch === '\\t') {\n      width += 2;\n      continue;\n    }\n\n    const cp = ch.codePointAt(0);\n    if (!cp) continue;\n    if (cp < 32 || (cp >= 0x7f && cp <= 0x9f)) continue;\n    if (isZeroWidthCodePoint(cp)) continue;\n    width += isWideCodePoint(cp) ? 2 : 1;\n  }\n\n  return width;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthewbyrden/Synced/Opta/1-Apps/1D-Opta-CLI-TS/src/utils/tokens.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]