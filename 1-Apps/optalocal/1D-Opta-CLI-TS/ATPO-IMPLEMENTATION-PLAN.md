# Atpo (Optimiser) Implementation Plan

## 1. Overview and Core Identity
**Atpo** (Opta backwards) is the integrated "Optimiser" and autonomous supervisor for the Opta CLI. 
Rather than a simple fallback, Atpo acts as a parallel reasoning engine that monitors the primary local LLM during long-running or autonomous tasks.

### Core Responsibilities
- **Supervisor & Monitor:** Watches the primary local LLM's output and tool usage during complex, multi-step tasks based on defined thresholds.
- **Auto-Correction & Debugging:** Detects when the primary LLM is stuck in a loop, errors out, or hallucinates, and automatically reprompts or corrects it.
- **Fully Autonomous Mode:** When enabled, Atpo can take over the planning phase, directing the local LLM as a "worker" to execute tasks autonomously.
- **Intelligent Fallback:** Acts as the safety net. If the local LLM server (LMX) crashes or fails to respond, Atpo seamlessly takes over the primary workload.

## 2. Provider Agnosticism & Visuals (Smart Key Integration)
Atpo will not be hardcoded to Anthropic. It will leverage Opta CLI's existing Smart Key Detection system to automatically route to the correct provider based on the provided API key format.

### Supported Providers & Dynamic Theming
When a provider is detected, the TUI elements (The Cloud Element, menu badges, and intervention highlights) will dynamically adopt the provider's signature brand colors to improve visual clarity and immediate recognition:
- **Google Gemini:** `Gradient / Blue` (#4285F4)
- **Anthropic Claude:** `Peach / Orange` (#D97757)
- **OpenAI GPT:** `Green` (#10A37F)
- **OpenCode Zen / OpenRouter:** `Purple / Neutral` 

*Implementation Step:* Extend the current key-parsing logic in the CLI configuration to recognize keys and map them to Atpo's internal provider router, instantiating the correct client dynamically and updating the global TUI theme context for Atpo.

## 3. UI/UX Integration

### The Opta Menu (`Ctrl + S`)
- Add a dedicated **[ Atpo ]** tab in the main Opta configuration menu accessible via `Ctrl + S`.
- **Tab Features:**
  - **Status Indicator:** Shows if Atpo is currently Active, Standby, or Offline.
  - **Key, Model & Billing Management:** Input field for API keys, model selection, and detailed billing configuration (See Section 5).
  - **Configuration Dashboard:** Access to granular settings for triggers, budget, and proactivity.

### Terminal UI (TUI) Representation: "The Cloud Element"
- **Top-Right Positioning:** Instead of a full sidecar pane, Atpo will be represented by a minimalistic, cloud-themed UI element located in the currently empty space at the top right of the terminal.
- **Dynamic Coloring:** The cloud element's text and icon will be colored according to the active provider (e.g., Anthropic Orange, OpenAI Green).
- **Non-Interfering:** It must strictly avoid interfering with the main LLM conversation UI. 
- **Informative:** It will pulse or update its status (e.g., "Atpo: Reviewing Chunk...", "Atpo: Debugging") to keep the user informed without cluttering the screen.
- **Future-Proofing:** While designed with a "cloud" aesthetic, the system is built to support a secondary local model in the future if desired.

## 4. Architectural Implementation (Thresholds & Triggers)

### 4.1. Context Window Management & Chunk-Based Review
Atpo does not process every single token generated by the local LLM, which would be expensive and slow. Instead, it operates on a "Chunk-Based" review cycle:
1. **Anchor Context:** Atpo always retains the user's original prompt in its permanent context for the duration of the task.
2. **Chunk Evaluation:** Atpo waits for a defined "threshold of work" (a chunk) to be completed by the local LLM (e.g., a file written, a sub-task finished).
3. **Review & Intervene:** Atpo reviews the chunk. If needed, it debugs, makes direct changes, or reprompts the local LLM.
4. **Context Compaction:** Once the review cycle is complete, Atpo compacts/summarizes its recent context to save tokens and returns to a standby state, waiting for the next trigger.

### 4.2. Autonomous Atpo Triggers
To fully utilize Atpo without user intervention, the system will implement specific triggers that summon Atpo for optimized purposes:
- **Milestone Trigger:** Summoned when the local LLM completes a specific milestone or sub-task in its execution plan.
- **Stuck State / Error Trigger:** Automatically summoned if the local LLM repeats the same failing tool call (e.g., 3 consecutive failed grep searches) or encounters a severe runtime exception.
- **Complexity / Planning Trigger:** Triggered at the very beginning of a task if the user's prompt is deemed highly complex. Atpo is summoned to draft the initial architecture and plan, which is then handed off to the local LLM to execute.
- **Validation Trigger:** Summoned when the local LLM claims to have finished the entire task. Atpo acts as the final QA, reviewing the diffs and running tests before presenting the result to the user.

### 4.3. Core Orchestration (`src/core/agent.ts`)
- Modify the main `agentLoop` to emit lifecycle events corresponding to the triggers above.
- Create an `AtpoSupervisor` class that listens to these events, manages the chunk-based context compaction, and injects interventions into the primary LLM's context.

## 5. Granular Configuration & Dynamic Cost Management
Since Atpo utilizes the user's API keys (incurring potential costs), it requires fine-grained controls to balance optimization with budget. These settings are deeply integrated with the specific provider's billing structure.

### 5.1. Payment & Billing Configuration
Users can configure their specific billing structure in the Atpo Menu to accurately estimate and control costs:
- **Payment Method Toggle:** Users can specify if their key represents a **Subscription Plan** (e.g., ChatGPT Plus, Claude Pro - usually rate-limited by requests/time) or a **Pay-As-You-Go API** (billed per token).
- **Cost Estimation Engine:** Based on the selected payment method and model, Atpo calculates real-time cost estimates.
  - *For Subscriptions:* Atpo estimates usage as a "Percentage of Rate Limit" (e.g., "This task will use ~15% of your hourly Claude Pro limit").
  - *For Pay-As-You-Go:* Atpo estimates usage in fiat currency based on the specific model's pricing tiers (e.g., $3.00/1M input tokens for Claude 3 Sonnet).

### 5.2. Usage Limits & Failover Controls
The autonomy and frequency of Atpo's interventions are tied to overall usage limits, preventing runaway costs over time while allowing flexibility for significant tasks.
- **Auto-Pause Thresholds:** Set limits to pause Atpo operations once a certain usage amount is reached:
  - *Pay-As-You-Go:* "Pause Atpo after spending $5.00 this session/day."
  - *Subscription:* "Pause Atpo after consuming 50% of my current hourly plan rate limit."
- **Provider Failover / Switch:** Instead of pausing, users can configure Atpo to automatically switch to a cheaper or alternate provider (e.g., from Claude 3 Opus to a local secondary model, or to a cheaper Pay-As-You-Go API) once a usage threshold is hit.
- **Dynamic Threshold Scaling:** If Atpo is nearing its usage limit, it will automatically adjust its behavior to stretch the remaining budget. For example, it will switch from high-fidelity token reviews to aggressive context compaction, or drop from Autonomy Level 3 (Co-Pilot) down to Level 1 (Warn Only) to save money/limits.

### 5.3. Activation Triggers & Thresholds
Users can configure exactly *when* and *what* qualifies Atpo to wake up, balancing cost vs. reliability:
- **Error Thresholds:** Define how many consecutive local LLM errors (e.g., 1, 3, or 5) trigger an Atpo intervention.
- **Complexity Qualifier:** Toggle whether Atpo is allowed to auto-evaluate prompt complexity. If enabled, the user can set a "Token/Task Size" threshold (e.g., "Only invoke Atpo for tasks modifying >3 files").
- **Milestone Frequency:** Choose how often Atpo reviews chunks (e.g., "After every sub-task", "Only at the very end (Validation Only)", or "Every N tool calls").

### 5.4. Extent of Proactivity (Autonomy Levels)
Users can set how much control Atpo has when it is triggered:
- **Level 0 (Fallback Only):** Atpo only activates if the local model crashes or is unreachable.
- **Level 1 (Advisor/Warn):** Atpo monitors chunks and displays warnings/suggestions in the top-right Cloud Element but *does not* alter the local LLM's context or execute tools.
- **Level 2 (Auto-Debug/Steer):** Atpo can silently inject correction prompts (`<atpo_correction>`) into the local LLM's context window to get it unstuck.
- **Level 3 (Co-Pilot):** Atpo can actively take over tool execution to fix a stubborn bug, then hand control back to the local LLM.
- **Level 4 (Full Autonomy):** Atpo writes the master plan and acts as the "Manager," constantly orchestrating the local LLM "Worker" to complete large-scale project builds.
