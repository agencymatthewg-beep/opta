# Phase 1: TUI Markdown Rendering

## Objective

Render assistant markdown output (code blocks, headers, lists, bold/italic, links) in the Ink TUI with syntax highlighting and proper terminal formatting. Replace the current raw `<Text>` output with styled markdown that matches the REPL's quality.

## Research Summary

**Approach chosen:** Reuse existing `marked` + `marked-terminal` pipeline. These are already dependencies and `renderMarkdownToString()` in `src/ui/markdown.ts` produces ANSI-styled strings that Ink's `<Text>` can render directly.

**Rejected alternatives:**
- `ink-markdown` npm package — unmaintained (v1.0.4, 2 years stale), thin wrapper around marked-terminal. Adds dependency for no value.
- Custom AST-to-React renderer — too much work for Phase 1. Would require building React components for every markdown node type. Could revisit in Phase 10 polish if the ANSI approach has limitations.

**Streaming challenge:** Tokens arrive one character at a time and are accumulated into `msg.content`. Re-parsing the full accumulated text through marked on every token is expensive and causes visual flickering with partial/incomplete markdown. Solution: debounce markdown re-renders during streaming (every 150ms), show the latest rendered snapshot between debounces, and force a final render when the turn ends.

**Cache strategy:** Completed messages (not actively streaming) should cache their rendered output. Use a `Map<string, string>` keyed by content hash. React.memo the message components to prevent unnecessary re-renders of unchanged messages.

## Execution Context

**Key files to create:**
- `src/tui/MarkdownText.tsx` — New Ink component for markdown rendering
- `tests/tui/MarkdownText.test.tsx` — Tests for the component

**Key files to modify:**
- `src/tui/MessageList.tsx` — Replace raw `<Text>` with `<MarkdownText>`
- `src/tui/App.tsx` — Pass streaming state to MessageList
- `tests/tui/MessageList.test.tsx` — Update tests for markdown rendering

**Existing code to reuse:**
- `src/ui/markdown.ts` — `renderMarkdownToString()` function with marked-terminal config
- `src/tui/hooks/useTerminalSize.ts` — Terminal width for responsive rendering

## Tasks

### Task 1: Create MarkdownText Component

Create the core `<MarkdownText>` Ink component that renders markdown content using the existing marked-terminal pipeline.

**Files:**
- Create: `src/tui/MarkdownText.tsx`
- Create: `tests/tui/MarkdownText.test.tsx`
- Reference: `src/ui/markdown.ts` (reuse rendering pipeline)

**Step 1: Write failing tests for MarkdownText**

Create `tests/tui/MarkdownText.test.tsx`:

```tsx
import { describe, it, expect } from 'vitest';
import React from 'react';
import { render } from 'ink-testing-library';
import { MarkdownText } from '../../src/tui/MarkdownText.js';

describe('MarkdownText', () => {
  it('should render plain text unchanged', () => {
    const { lastFrame } = render(<MarkdownText text="Hello world" />);
    expect(lastFrame()).toContain('Hello world');
  });

  it('should render bold text with styling', () => {
    const { lastFrame } = render(<MarkdownText text="This is **bold** text" />);
    expect(lastFrame()).toContain('bold');
  });

  it('should render code blocks', () => {
    const md = '```javascript\nconst x = 1;\n```';
    const { lastFrame } = render(<MarkdownText text={md} />);
    expect(lastFrame()).toContain('const x = 1');
  });

  it('should render headers', () => {
    const { lastFrame } = render(<MarkdownText text="# Hello" />);
    expect(lastFrame()).toContain('Hello');
  });

  it('should handle empty text', () => {
    const { lastFrame } = render(<MarkdownText text="" />);
    expect(lastFrame()).toBe('');
  });

  it('should fall back to raw text when rendering fails', () => {
    // null/undefined edge case
    const { lastFrame } = render(<MarkdownText text="plain fallback" />);
    expect(lastFrame()).toContain('plain fallback');
  });
});
```

**Step 2: Run tests to verify they fail**

```bash
npx vitest run tests/tui/MarkdownText.test.tsx
```

Expected: FAIL — module not found.

**Step 3: Implement MarkdownText component**

Create `src/tui/MarkdownText.tsx`:

```tsx
import React, { useState, useEffect, useRef } from 'react';
import { Text } from 'ink';

// Lazy-loaded renderer (matches src/ui/markdown.ts pattern)
let cachedRenderer: ((md: string) => string) | null = null;

async function getMarkdownRenderer(): Promise<(md: string) => string> {
  if (cachedRenderer) return cachedRenderer;

  const chalk = (await import('chalk')).default;
  const { Marked } = await import('marked');
  const { default: TerminalRenderer } = await import('marked-terminal');

  const marked = new Marked(
    TerminalRenderer({
      code: chalk.hex('#F59E0B'),
      codespan: chalk.hex('#F59E0B').bold,
      firstHeading: chalk.hex('#8B5CF6').bold.underline,
      heading: chalk.hex('#3B82F6').bold,
      strong: chalk.bold,
      em: chalk.italic,
      del: chalk.dim.strikethrough,
      blockquote: chalk.hex('#71717A').italic,
      link: chalk.hex('#3B82F6').underline,
      href: chalk.hex('#3B82F6').underline,
      listitem: chalk.reset,
      table: chalk.reset,
      hr: chalk.dim,
      paragraph: chalk.reset,
      html: chalk.dim,
      width: 100,
      reflowText: false,
      showSectionPrefix: true,
      unescape: true,
      emoji: true,
      tab: 2,
    })
  );

  cachedRenderer = (md: string) => {
    const result = marked.parse(md, { async: false });
    return typeof result === 'string' ? result : String(result);
  };
  return cachedRenderer;
}

// Synchronous render using cached renderer, falls back to raw text
function renderSync(text: string): string {
  if (!text) return '';
  if (!cachedRenderer) return text;
  try {
    const result = cachedRenderer(text);
    // Strip trailing newlines that marked-terminal adds
    return result.replace(/\n+$/, '');
  } catch {
    return text;
  }
}

interface MarkdownTextProps {
  text: string;
  /** Width override for marked-terminal. Defaults to 100. */
  width?: number;
}

export function MarkdownText({ text, width }: MarkdownTextProps) {
  const [rendered, setRendered] = useState(() => renderSync(text));
  const prevText = useRef(text);

  // Initialize renderer on first mount
  useEffect(() => {
    let cancelled = false;
    getMarkdownRenderer().then(() => {
      if (!cancelled) {
        setRendered(renderSync(text));
      }
    });
    return () => { cancelled = true; };
  }, []);

  // Re-render when text changes (synchronous if renderer cached)
  useEffect(() => {
    if (text !== prevText.current) {
      prevText.current = text;
      setRendered(renderSync(text));
    }
  }, [text]);

  if (!text) return null;

  return <Text wrap="wrap">{rendered}</Text>;
}
```

**Step 4: Run tests to verify they pass**

```bash
npx vitest run tests/tui/MarkdownText.test.tsx
```

Expected: All tests PASS.

**Step 5: Commit**

```bash
git add src/tui/MarkdownText.tsx tests/tui/MarkdownText.test.tsx
git commit -m "feat(cli): add MarkdownText component for TUI markdown rendering"
```

---

### Task 2: Add Streaming Debounce

When tokens stream in, re-rendering markdown on every character is wasteful. Add debounced rendering so the display updates at most every 150ms during streaming, with a final render on stream completion.

**Files:**
- Modify: `src/tui/MarkdownText.tsx` — Add `isStreaming` prop with debounce logic
- Modify: `tests/tui/MarkdownText.test.tsx` — Add streaming tests

**Step 1: Write failing tests for streaming debounce**

Add to `tests/tui/MarkdownText.test.tsx`:

```tsx
describe('MarkdownText streaming', () => {
  it('should accept isStreaming prop', () => {
    const { lastFrame } = render(<MarkdownText text="Hello" isStreaming={true} />);
    expect(lastFrame()).toContain('Hello');
  });

  it('should render content while streaming', () => {
    const { lastFrame, rerender } = render(<MarkdownText text="Hel" isStreaming={true} />);
    expect(lastFrame()).toContain('Hel');

    rerender(<MarkdownText text="Hello world" isStreaming={true} />);
    expect(lastFrame()).toContain('Hello');
  });

  it('should force final render when streaming ends', () => {
    const { lastFrame, rerender } = render(
      <MarkdownText text="**bold text**" isStreaming={true} />
    );
    // During streaming, may show raw or partially rendered
    rerender(<MarkdownText text="**bold text**" isStreaming={false} />);
    // After streaming ends, should be fully rendered
    expect(lastFrame()).toContain('bold text');
  });
});
```

**Step 2: Run tests to verify the new tests fail**

```bash
npx vitest run tests/tui/MarkdownText.test.tsx
```

Expected: New streaming tests FAIL (isStreaming prop not implemented yet).

**Step 3: Implement streaming debounce**

Update `src/tui/MarkdownText.tsx` to add `isStreaming` prop:

- When `isStreaming` is true: debounce re-renders to every 150ms using `useRef` timer
- When `isStreaming` transitions from true to false: force immediate final render
- When `isStreaming` is false (default): render synchronously on every change

Key implementation:
```tsx
interface MarkdownTextProps {
  text: string;
  isStreaming?: boolean;
  width?: number;
}
```

Use `useRef` for the debounce timer and `useEffect` cleanup to cancel on unmount.

**Step 4: Run tests**

```bash
npx vitest run tests/tui/MarkdownText.test.tsx
```

Expected: All tests PASS.

**Step 5: Commit**

```bash
git add src/tui/MarkdownText.tsx tests/tui/MarkdownText.test.tsx
git commit -m "feat(cli): add streaming debounce to MarkdownText component"
```

---

### Task 3: Integrate MarkdownText into MessageList

Replace the raw `<Text wrap="wrap">{msg.content}</Text>` in MessageList with the new `<MarkdownText>` component. Pass streaming state from App.tsx so the active message gets debounced rendering.

**Files:**
- Modify: `src/tui/MessageList.tsx` — Use MarkdownText for assistant messages
- Modify: `src/tui/App.tsx` — Pass streaming index to MessageList
- Modify: `tests/tui/MessageList.test.tsx` — Update tests

**Step 1: Write failing tests for markdown in MessageList**

Update `tests/tui/MessageList.test.tsx`:

```tsx
it('should render assistant markdown content', () => {
  const messages = [
    { role: 'assistant', content: '**bold** and `code`' },
  ];
  const { lastFrame } = render(<MessageList messages={messages} />);
  // Should contain the text (with ANSI styling applied by marked-terminal)
  expect(lastFrame()).toContain('bold');
  expect(lastFrame()).toContain('code');
});

it('should render user messages as plain text', () => {
  const messages = [
    { role: 'user', content: '**not rendered as markdown**' },
  ];
  const { lastFrame } = render(<MessageList messages={messages} />);
  // User messages stay raw — no markdown processing
  expect(lastFrame()).toContain('**not rendered as markdown**');
});

it('should accept streamingIdx prop', () => {
  const messages = [
    { role: 'assistant', content: 'Hello' },
  ];
  const { lastFrame } = render(<MessageList messages={messages} streamingIdx={0} />);
  expect(lastFrame()).toContain('Hello');
});
```

**Step 2: Run tests to verify they fail**

```bash
npx vitest run tests/tui/MessageList.test.tsx
```

**Step 3: Update MessageList to use MarkdownText**

In `src/tui/MessageList.tsx`:

1. Import `MarkdownText` from `./MarkdownText.js`
2. Add `streamingIdx?: number | null` to `MessageListProps`
3. In `renderChatMessage()`:
   - For `role === 'assistant'`: render `<MarkdownText text={msg.content} isStreaming={i === streamingIdx} />`
   - For `role === 'user'`: keep raw `<Text wrap="wrap">{msg.content}</Text>`

**Step 4: Update App.tsx to pass streaming index**

In `src/tui/App.tsx`:

1. Pass `streamingIdx={streamingMsgIdx.current}` to `<MessageList>`
2. The existing `streamingMsgIdx` ref already tracks the active streaming message index

**Step 5: Run all tests**

```bash
npx vitest run tests/tui/MessageList.test.tsx tests/tui/MarkdownText.test.tsx tests/tui/App.test.tsx
```

Expected: All tests PASS.

**Step 6: Commit**

```bash
git add src/tui/MessageList.tsx src/tui/App.tsx tests/tui/MessageList.test.tsx
git commit -m "feat(cli): integrate markdown rendering into TUI message display"
```

---

### Task 4: Render Cache and Width Responsiveness

Add a render cache so completed messages don't re-parse on every React render. Make the markdown renderer width-aware so it adapts to terminal size.

**Files:**
- Modify: `src/tui/MarkdownText.tsx` — Add render cache, width-aware rendering
- Modify: `src/tui/MessageList.tsx` — React.memo message components, pass width
- Modify: `tests/tui/MarkdownText.test.tsx` — Cache and width tests

**Step 1: Write failing tests**

Add to `tests/tui/MarkdownText.test.tsx`:

```tsx
describe('MarkdownText caching', () => {
  it('should return same output for same input (cache hit)', () => {
    const { lastFrame: f1 } = render(<MarkdownText text="# Hello" />);
    const { lastFrame: f2 } = render(<MarkdownText text="# Hello" />);
    expect(f1()).toBe(f2());
  });
});

describe('MarkdownText width', () => {
  it('should accept width prop', () => {
    const { lastFrame } = render(<MarkdownText text="Hello world" width={40} />);
    expect(lastFrame()).toContain('Hello world');
  });
});
```

**Step 2: Run tests**

```bash
npx vitest run tests/tui/MarkdownText.test.tsx
```

**Step 3: Implement render cache**

In `src/tui/MarkdownText.tsx`:

1. Add module-level `Map<string, string>` cache (key = `${width}:${text}`, value = rendered ANSI)
2. Cap cache size at 200 entries (evict oldest)
3. Check cache before calling `renderSync()`
4. Store result in cache after rendering

**Step 4: Implement width-aware rendering**

1. Accept `width` prop in `MarkdownText`
2. Create a separate `getMarkdownRenderer(width)` that uses the provided width
3. In `MessageList`, get terminal width from `useTerminalSize()` and pass to `MarkdownText`
4. Account for padding (subtract left/right padding from available width)

**Step 5: React.memo message rows**

In `MessageList.tsx`:
1. Extract `renderChatMessage` into a `ChatMessage` component
2. Wrap with `React.memo` so unchanged messages don't re-render
3. Use stable keys based on message index

**Step 6: Run full test suite**

```bash
npx vitest run tests/tui/
```

Expected: All TUI tests PASS.

**Step 7: Run typecheck**

```bash
npm run typecheck
```

Expected: Clean.

**Step 8: Commit**

```bash
git add src/tui/MarkdownText.tsx src/tui/MessageList.tsx tests/tui/MarkdownText.test.tsx
git commit -m "feat(cli): add render cache and width-responsive markdown in TUI"
```

---

## Verification

After all tasks complete:

1. **Type check:** `npm run typecheck` — clean, no errors
2. **All tests pass:** `npx vitest run` — 735+ tests, 0 failures
3. **Manual smoke test:**
   - Run `npm run dev -- chat` (or `npx tsx src/index.ts chat --tui`)
   - Send a message that triggers markdown: "Write me a hello world in Python with a heading"
   - Verify: headings are colored, code blocks are highlighted, bold/italic work
   - Verify: streaming looks smooth (no flicker, debounced updates)
4. **No regressions:** REPL mode still works with its own markdown rendering

## Success Criteria

- [ ] Assistant messages in TUI display styled markdown (headings, bold, italic, links, lists)
- [ ] Code blocks render with syntax-highlighted colors (amber/yellow via marked-terminal)
- [ ] Streaming messages debounce re-renders (no flicker or parsing on every token)
- [ ] Completed messages are cached (no redundant re-parsing)
- [ ] Terminal width is respected (no horizontal overflow)
- [ ] User messages remain plain text (no markdown processing)
- [ ] All existing tests pass (zero regressions)
- [ ] New tests cover: basic rendering, streaming, caching, width
