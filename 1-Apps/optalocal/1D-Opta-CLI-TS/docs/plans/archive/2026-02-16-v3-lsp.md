---
status: archived
---

# V3 Phase 2: LSP Integration — Design & TDD Plan

> **Status:** Draft
> **Date:** 2026-02-16
> **Prerequisite:** None (standalone)
> **New dependency:** `vscode-languageserver-protocol` (~120KB)
> **Impact:** Search score 83 -> 95, Agent Depth 45 -> 60

---

## 1. Architecture Overview

```
┌─────────────────────────────────────┐
│          Agent Loop (agent.ts)       │
│   calls lsp_* tools via registry     │
└──────────┬──────────────────────────┘
           │
┌──────────▼──────────────────────────┐
│     Tool Registry (registry.ts)      │
│  routes lsp_* calls to LspManager    │
└──────────┬──────────────────────────┘
           │
┌──────────▼──────────────────────────┐
│      LspManager (lsp/manager.ts)     │
│  Pool of LspClient per language      │
│  Auto-detects servers                │
│  Manages lifecycle + doc sync        │
└───┬──────────┬──────────┬───────────┘
    │          │          │
┌───▼───┐ ┌───▼───┐ ┌───▼───┐
│tsserver│ │pyright│ │gopls  │  (stdio child processes)
└───────┘ └───────┘ └───────┘
```

**LspManager** is a singleton per session. It owns a `Map<language, LspClient>` and
handles lazy initialization: the first `lsp_definition` call for a `.ts` file spawns
tsserver if not already running. Servers persist across tool calls within the same
session and are shut down in `registry.close()`.

**LspClient** wraps a single LSP server process using stdio transport. It manages
the JSON-RPC connection, `initialize` handshake, `textDocument/didOpen` tracking,
and request routing. It uses the `vscode-languageserver-protocol` package for
type-safe message construction only (no VS Code runtime dependency).

---

## 2. New Files

| File | Purpose | Est. LOC |
|------|---------|----------|
| `src/lsp/client.ts` | LspClient class: spawn, initialize, request/response, shutdown | ~180 |
| `src/lsp/manager.ts` | LspManager: server pool, language detection, auto-discovery | ~120 |
| `src/lsp/servers.ts` | Per-language server configs (command, args, init options) | ~60 |
| `src/lsp/protocol.ts` | Type helpers: position from offset, URI conversion, result formatting | ~50 |
| `tests/lsp/client.test.ts` | LspClient unit tests with mocked child process | ~200 |
| `tests/lsp/manager.test.ts` | LspManager tests: pooling, detection, fallback | ~150 |
| `tests/lsp/protocol.test.ts` | Position/URI conversion tests | ~80 |

**Total new code:** ~840 LOC

---

## 3. Modified Files

### `src/core/tools.ts`

Add 6 LSP tool schemas to `TOOL_SCHEMAS` array (after `save_memory`).
Add 6 executor functions. Add LSP tool names to `DEFAULT_TOOL_PERMISSIONS`.

### `src/mcp/registry.ts`

Import `LspManager` and wire it into `buildToolRegistry()`. On tool execution,
route `lsp_*` tool calls through `LspManager.execute()`. Call `LspManager.shutdown()`
in `close()`.

### `src/core/config.ts`

Add `lsp` section to `OptaConfigSchema` with per-language server overrides and
a global enable/disable toggle.

### `tests/core/tools.test.ts`

Update tool count assertion from 14 to 20. Add `lsp_*` to expected tool names.

---

## 4. Tool Definitions (OpenAI Function Schemas)

### lsp_definition

```typescript
{
  type: 'function',
  function: {
    name: 'lsp_definition',
    description: 'Go to the definition of a symbol. Returns file path and line number.',
    parameters: {
      type: 'object',
      properties: {
        path: { type: 'string', description: 'File path (relative to cwd)' },
        line: { type: 'number', description: 'Line number (1-based)' },
        character: { type: 'number', description: 'Column number (0-based)' },
      },
      required: ['path', 'line', 'character'],
    },
  },
}
```

### lsp_references

```typescript
{
  type: 'function',
  function: {
    name: 'lsp_references',
    description: 'Find all references to a symbol across the workspace.',
    parameters: {
      type: 'object',
      properties: {
        path: { type: 'string', description: 'File path (relative to cwd)' },
        line: { type: 'number', description: 'Line number (1-based)' },
        character: { type: 'number', description: 'Column number (0-based)' },
        include_declaration: { type: 'boolean', description: 'Include the declaration itself (default: true)' },
      },
      required: ['path', 'line', 'character'],
    },
  },
}
```

### lsp_hover

```typescript
{
  type: 'function',
  function: {
    name: 'lsp_hover',
    description: 'Get type information and documentation for a symbol at a position.',
    parameters: {
      type: 'object',
      properties: {
        path: { type: 'string', description: 'File path (relative to cwd)' },
        line: { type: 'number', description: 'Line number (1-based)' },
        character: { type: 'number', description: 'Column number (0-based)' },
      },
      required: ['path', 'line', 'character'],
    },
  },
}
```

### lsp_symbols

```typescript
{
  type: 'function',
  function: {
    name: 'lsp_symbols',
    description: 'Search for symbols (functions, classes, variables) across the workspace by name.',
    parameters: {
      type: 'object',
      properties: {
        query: { type: 'string', description: 'Symbol name or partial name to search for' },
      },
      required: ['query'],
    },
  },
}
```

### lsp_document_symbols

```typescript
{
  type: 'function',
  function: {
    name: 'lsp_document_symbols',
    description: 'List all symbols (functions, classes, interfaces) defined in a file.',
    parameters: {
      type: 'object',
      properties: {
        path: { type: 'string', description: 'File path (relative to cwd)' },
      },
      required: ['path'],
    },
  },
}
```

### lsp_rename

```typescript
{
  type: 'function',
  function: {
    name: 'lsp_rename',
    description: 'Rename a symbol across all files in the workspace. Returns a list of edits to apply.',
    parameters: {
      type: 'object',
      properties: {
        path: { type: 'string', description: 'File path (relative to cwd)' },
        line: { type: 'number', description: 'Line number (1-based)' },
        character: { type: 'number', description: 'Column number (0-based)' },
        new_name: { type: 'string', description: 'New name for the symbol' },
      },
      required: ['path', 'line', 'character', 'new_name'],
    },
  },
}
```

---

## 5. Server Configuration

### Built-in Defaults (`src/lsp/servers.ts`)

```typescript
export interface LspServerConfig {
  command: string;
  args: string[];
  initializationOptions?: Record<string, unknown>;
  rootPatterns: string[];      // Files that indicate workspace root
  fileExtensions: string[];    // Which extensions this server handles
}

export const BUILTIN_SERVERS: Record<string, LspServerConfig> = {
  typescript: {
    command: 'typescript-language-server',
    args: ['--stdio'],
    initializationOptions: {
      preferences: { includeInlayParameterNameHints: 'none' },
    },
    rootPatterns: ['tsconfig.json', 'jsconfig.json', 'package.json'],
    fileExtensions: ['.ts', '.tsx', '.js', '.jsx', '.mjs', '.cjs'],
  },
  python: {
    command: 'pyright-langserver',
    args: ['--stdio'],
    initializationOptions: {},
    rootPatterns: ['pyproject.toml', 'setup.py', 'pyrightconfig.json'],
    fileExtensions: ['.py', '.pyi'],
  },
  go: {
    command: 'gopls',
    args: ['serve'],
    initializationOptions: {},
    rootPatterns: ['go.mod'],
    fileExtensions: ['.go'],
  },
  rust: {
    command: 'rust-analyzer',
    args: [],
    initializationOptions: {},
    rootPatterns: ['Cargo.toml'],
    fileExtensions: ['.rs'],
  },
};
```

### Auto-Detection Flow

```
1. Tool receives file path (e.g., src/core/agent.ts)
2. LspManager.getLanguage('.ts') -> 'typescript'
3. Check if LspClient for 'typescript' already running -> return it
4. Check if 'typescript-language-server' is on PATH (execa which)
5. If found: spawn, initialize, didOpen, return client
6. If not found: return fallback message
```

---

## 6. Config Schema Changes

Add to `OptaConfigSchema` in `src/core/config.ts`:

```typescript
lsp: z
  .object({
    enabled: z.boolean().default(true),
    servers: z
      .record(
        z.string(),
        z.object({
          command: z.string(),
          args: z.array(z.string()).default([]),
          initializationOptions: z.record(z.string(), z.unknown()).default({}),
        })
      )
      .default({}),
    timeout: z.number().default(10000),  // ms per request
  })
  .default({}),
```

Users can override a built-in server or add new ones:

```json
{
  "lsp": {
    "servers": {
      "typescript": {
        "command": "/usr/local/bin/tsserver-wrapper",
        "args": ["--stdio", "--log-level", "verbose"]
      }
    }
  }
}
```

Add LSP tools to default permissions (all `'allow'` since they are read-only,
except `lsp_rename` which is `'ask'`):

```typescript
lsp_definition: 'allow',
lsp_references: 'allow',
lsp_hover: 'allow',
lsp_symbols: 'allow',
lsp_document_symbols: 'allow',
lsp_rename: 'ask',
```

---

## 7. Implementation Tasks (TDD)

Each task follows red-green-refactor: write failing tests first, then implement.

### Task 1: Protocol Helpers (`src/lsp/protocol.ts`)

**Test file:** `tests/lsp/protocol.test.ts`

```typescript
import { describe, it, expect } from 'vitest';
import {
  filePathToUri,
  uriToFilePath,
  toPosition,
  formatLocation,
  formatLocations,
} from '../../src/lsp/protocol.js';

describe('filePathToUri', () => {
  it('converts absolute path to file URI', () => {
    expect(filePathToUri('/Users/matt/code/app.ts'))
      .toBe('file:///Users/matt/code/app.ts');
  });

  it('encodes spaces in path', () => {
    expect(filePathToUri('/Users/matt/my project/app.ts'))
      .toBe('file:///Users/matt/my%20project/app.ts');
  });
});

describe('uriToFilePath', () => {
  it('converts file URI back to path', () => {
    expect(uriToFilePath('file:///Users/matt/code/app.ts'))
      .toBe('/Users/matt/code/app.ts');
  });
});

describe('toPosition', () => {
  it('converts 1-based line to 0-based LSP position', () => {
    expect(toPosition(10, 5)).toEqual({ line: 9, character: 5 });
  });

  it('clamps line to minimum 0', () => {
    expect(toPosition(0, 0)).toEqual({ line: 0, character: 0 });
  });
});

describe('formatLocation', () => {
  it('formats a single location as path:line', () => {
    const loc = {
      uri: 'file:///Users/matt/code/app.ts',
      range: { start: { line: 9, character: 5 }, end: { line: 9, character: 15 } },
    };
    expect(formatLocation(loc, '/Users/matt/code')).toBe('app.ts:10:5');
  });
});

describe('formatLocations', () => {
  it('formats multiple locations with deduplication', () => {
    const locs = [
      { uri: 'file:///a/b.ts', range: { start: { line: 0, character: 0 }, end: { line: 0, character: 5 } } },
      { uri: 'file:///a/c.ts', range: { start: { line: 4, character: 2 }, end: { line: 4, character: 8 } } },
    ];
    const result = formatLocations(locs, '/a');
    expect(result).toContain('b.ts:1:0');
    expect(result).toContain('c.ts:5:2');
  });

  it('returns "No results found." for empty array', () => {
    expect(formatLocations([], '/a')).toBe('No results found.');
  });
});
```

**Implementation:** Pure functions, no I/O. ~50 LOC.

---

### Task 2: LspClient Core (`src/lsp/client.ts`)

**Test file:** `tests/lsp/client.test.ts`

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { EventEmitter } from 'node:events';
import { LspClient } from '../../src/lsp/client.js';

// Mock child_process.spawn
const mockProcess = () => {
  const proc = new EventEmitter() as any;
  proc.stdin = { write: vi.fn(), end: vi.fn() };
  proc.stdout = new EventEmitter();
  proc.stderr = new EventEmitter();
  proc.kill = vi.fn();
  proc.pid = 12345;
  return proc;
};

vi.mock('node:child_process', () => ({
  spawn: vi.fn(() => mockProcess()),
}));

describe('LspClient', () => {
  let client: LspClient;

  beforeEach(() => {
    client = new LspClient({
      command: 'typescript-language-server',
      args: ['--stdio'],
      rootUri: 'file:///project',
      language: 'typescript',
    });
  });

  afterEach(async () => {
    await client.shutdown().catch(() => {});
  });

  it('spawns the server process on initialize', async () => {
    const { spawn } = await import('node:child_process');
    // Simulate server responding to initialize
    setTimeout(() => {
      const proc = vi.mocked(spawn).mock.results[0]?.value;
      if (proc) {
        const response = JSON.stringify({
          jsonrpc: '2.0',
          id: 1,
          result: { capabilities: { definitionProvider: true } },
        });
        proc.stdout.emit('data', Buffer.from(
          `Content-Length: ${Buffer.byteLength(response)}\r\n\r\n${response}`
        ));
      }
    }, 10);

    await client.initialize();
    expect(spawn).toHaveBeenCalledWith(
      'typescript-language-server',
      ['--stdio'],
      expect.any(Object)
    );
  });

  it('tracks opened documents', async () => {
    // After initialize, opening a file should be tracked
    expect(client.isDocumentOpen('file:///project/src/app.ts')).toBe(false);
  });

  it('throws on request before initialize', async () => {
    await expect(
      client.definition('file:///test.ts', { line: 0, character: 0 })
    ).rejects.toThrow('not initialized');
  });

  it('rejects with timeout when server does not respond', async () => {
    // Don't simulate a response -> should timeout
    await expect(client.initialize({ timeout: 50 })).rejects.toThrow();
  }, 5000);
});
```

**Implementation:** ~180 LOC. Key methods:

```typescript
export class LspClient {
  private process: ChildProcess | null = null;
  private nextId = 1;
  private pending = new Map<number, { resolve: Function; reject: Function }>();
  private openDocs = new Set<string>();
  private buffer = Buffer.alloc(0);
  private initialized = false;

  constructor(private opts: LspClientOptions) {}

  async initialize(options?: { timeout?: number }): Promise<void>;
  async shutdown(): Promise<void>;

  // Document sync
  async openDocument(uri: string, text: string): Promise<void>;
  async closeDocument(uri: string): Promise<void>;
  isDocumentOpen(uri: string): boolean;

  // LSP requests
  async definition(uri: string, position: Position): Promise<Location[]>;
  async references(uri: string, position: Position, includeDecl?: boolean): Promise<Location[]>;
  async hover(uri: string, position: Position): Promise<string>;
  async workspaceSymbols(query: string): Promise<SymbolInformation[]>;
  async documentSymbols(uri: string): Promise<DocumentSymbol[]>;
  async rename(uri: string, position: Position, newName: string): Promise<WorkspaceEdit>;

  // Internal JSON-RPC
  private sendRequest(method: string, params: unknown): Promise<unknown>;
  private sendNotification(method: string, params: unknown): void;
  private handleData(data: Buffer): void;
}
```

---

### Task 3: LspManager (`src/lsp/manager.ts`)

**Test file:** `tests/lsp/manager.test.ts`

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { LspManager } from '../../src/lsp/manager.js';

// Mock execa for which-style checks
vi.mock('execa', () => ({
  execa: vi.fn().mockRejectedValue(new Error('not found')),
}));

// Mock LspClient
vi.mock('../../src/lsp/client.js', () => ({
  LspClient: vi.fn().mockImplementation(() => ({
    initialize: vi.fn(),
    shutdown: vi.fn(),
    openDocument: vi.fn(),
    closeDocument: vi.fn(),
    isDocumentOpen: vi.fn().mockReturnValue(false),
    definition: vi.fn().mockResolvedValue([]),
    references: vi.fn().mockResolvedValue([]),
    hover: vi.fn().mockResolvedValue(''),
    workspaceSymbols: vi.fn().mockResolvedValue([]),
    documentSymbols: vi.fn().mockResolvedValue([]),
    rename: vi.fn().mockResolvedValue({ changes: {} }),
  })),
}));

describe('LspManager', () => {
  let manager: LspManager;

  beforeEach(() => {
    manager = new LspManager({ cwd: '/project', config: {} });
  });

  afterEach(async () => {
    await manager.shutdownAll();
  });

  describe('language detection', () => {
    it('detects TypeScript from .ts extension', () => {
      expect(manager.getLanguage('src/app.ts')).toBe('typescript');
    });

    it('detects TypeScript from .tsx extension', () => {
      expect(manager.getLanguage('src/App.tsx')).toBe('typescript');
    });

    it('detects Python from .py extension', () => {
      expect(manager.getLanguage('main.py')).toBe('python');
    });

    it('detects Go from .go extension', () => {
      expect(manager.getLanguage('main.go')).toBe('go');
    });

    it('detects Rust from .rs extension', () => {
      expect(manager.getLanguage('src/lib.rs')).toBe('rust');
    });

    it('returns null for unknown extensions', () => {
      expect(manager.getLanguage('readme.md')).toBeNull();
    });
  });

  describe('server availability', () => {
    it('returns fallback message when server binary not found', async () => {
      const result = await manager.execute('lsp_definition', {
        path: 'src/app.ts',
        line: 1,
        character: 0,
      });
      expect(result).toContain('not available');
      expect(result).toContain('search_files');
    });

    it('returns fallback for unsupported file types', async () => {
      const result = await manager.execute('lsp_definition', {
        path: 'data.csv',
        line: 1,
        character: 0,
      });
      expect(result).toContain('No LSP server');
    });
  });

  describe('server pooling', () => {
    it('reuses existing client for same language', async () => {
      const { execa } = await import('execa');
      vi.mocked(execa).mockResolvedValue({ stdout: '/usr/bin/tls' } as any);

      await manager.execute('lsp_definition', { path: 'a.ts', line: 1, character: 0 });
      await manager.execute('lsp_definition', { path: 'b.ts', line: 1, character: 0 });

      const { LspClient } = await import('../../src/lsp/client.js');
      // Should only construct one client for typescript
      expect(LspClient).toHaveBeenCalledTimes(1);
    });
  });

  describe('shutdownAll', () => {
    it('shuts down all running servers', async () => {
      const { execa } = await import('execa');
      vi.mocked(execa).mockResolvedValue({ stdout: '/usr/bin/tls' } as any);

      await manager.execute('lsp_hover', { path: 'a.ts', line: 1, character: 0 });
      await manager.shutdownAll();
      // Should not throw
    });
  });
});
```

**Implementation:** ~120 LOC. Core structure:

```typescript
export class LspManager {
  private clients = new Map<string, LspClient>();
  private serverChecked = new Map<string, boolean>();

  constructor(private opts: { cwd: string; config: LspConfig }) {}

  getLanguage(filePath: string): string | null;
  async getClient(language: string): Promise<LspClient | null>;
  async execute(toolName: string, args: Record<string, unknown>): Promise<string>;
  async shutdownAll(): Promise<void>;
}
```

---

### Task 4: Tool Executors in tools.ts

**Test additions to** `tests/core/tools.test.ts`:

```typescript
describe('LSP tool schemas', () => {
  it('defines 20 tools total', () => {
    expect(TOOL_SCHEMAS).toHaveLength(20);
  });

  it('has all 6 LSP tool names', () => {
    const names = getToolNames();
    expect(names).toContain('lsp_definition');
    expect(names).toContain('lsp_references');
    expect(names).toContain('lsp_hover');
    expect(names).toContain('lsp_symbols');
    expect(names).toContain('lsp_document_symbols');
    expect(names).toContain('lsp_rename');
  });

  it('LSP read tools have allow permission by default', () => {
    expect(resolvePermission('lsp_definition', DEFAULT_CONFIG)).toBe('allow');
    expect(resolvePermission('lsp_references', DEFAULT_CONFIG)).toBe('allow');
    expect(resolvePermission('lsp_hover', DEFAULT_CONFIG)).toBe('allow');
    expect(resolvePermission('lsp_symbols', DEFAULT_CONFIG)).toBe('allow');
    expect(resolvePermission('lsp_document_symbols', DEFAULT_CONFIG)).toBe('allow');
  });

  it('lsp_rename requires ask permission', () => {
    expect(resolvePermission('lsp_rename', DEFAULT_CONFIG)).toBe('ask');
  });
});
```

---

### Task 5: Registry Integration

**Test additions to** `tests/mcp/registry.test.ts`:

```typescript
describe('LSP tool routing', () => {
  it('includes LSP tool schemas when LSP is enabled', async () => {
    const config = { ...DEFAULT_CONFIG, lsp: { enabled: true, servers: {}, timeout: 10000 } };
    const registry = await buildToolRegistry(config);
    const names = registry.schemas.map(s => s.function.name);
    expect(names).toContain('lsp_definition');
    expect(names).toContain('lsp_references');
  });

  it('excludes LSP tool schemas when LSP is disabled', async () => {
    const config = { ...DEFAULT_CONFIG, lsp: { enabled: false, servers: {}, timeout: 10000 } };
    const registry = await buildToolRegistry(config);
    const names = registry.schemas.map(s => s.function.name);
    expect(names).not.toContain('lsp_definition');
  });

  it('routes lsp_* calls through LspManager.execute', async () => {
    const config = { ...DEFAULT_CONFIG, lsp: { enabled: true, servers: {}, timeout: 10000 } };
    const registry = await buildToolRegistry(config);
    const result = await registry.execute('lsp_definition', JSON.stringify({
      path: 'src/app.ts', line: 1, character: 0,
    }));
    // Should return fallback (no real server) instead of "Unknown tool"
    expect(result).not.toContain('Unknown tool');
  });
});
```

---

### Task 6: Document Synchronization

**Test additions to** `tests/lsp/client.test.ts`:

```typescript
describe('document sync', () => {
  it('sends didOpen when opening a new document', async () => {
    // After initialize, openDocument should send notification
    // Verify via spy on sendNotification
  });

  it('does not re-open already opened documents', async () => {
    // Second call to openDocument for same URI should be a no-op
  });

  it('sends didClose when closing a document', async () => {
    // After close, isDocumentOpen returns false
  });

  it('auto-opens documents on first LSP request', async () => {
    // definition() on unopened file should read it and send didOpen first
  });
});
```

**Implementation in LspClient:** Before each LSP request, check if the document
is open. If not, read the file, call `textDocument/didOpen`, then proceed with the
request.

```typescript
private async ensureDocumentOpen(uri: string): Promise<void> {
  if (this.openDocs.has(uri)) return;
  const filePath = uriToFilePath(uri);
  const text = await readFile(filePath, 'utf-8');
  this.sendNotification('textDocument/didOpen', {
    textDocument: {
      uri,
      languageId: this.opts.language,
      version: 1,
      text,
    },
  });
  this.openDocs.add(uri);
}
```

---

### Task 7: Notify on File Edit (Agent Loop Integration)

When the agent edits a file via `edit_file` or `write_file`, the LSP server needs
to know. This is handled in the registry, not in tools.ts.

**Implementation in registry.ts:**

```typescript
async execute(name: string, argsJson: string): Promise<string> {
  const result = await this.executeInner(name, argsJson);

  // Notify LSP of file changes after write operations
  if (this.lspManager && (name === 'edit_file' || name === 'write_file' || name === 'multi_edit')) {
    const args = JSON.parse(argsJson);
    if (args.path) {
      await this.lspManager.notifyFileChanged(resolve(args.path));
    }
  }

  return result;
}
```

This sends a `textDocument/didChange` (full sync) or `textDocument/didClose` +
`textDocument/didOpen` cycle to refresh the server's view of the file.

---

## 8. Performance Considerations

### Cold Start Latency

| Server | Typical Init Time | Mitigation |
|--------|-------------------|------------|
| typescript-language-server | 1-2s | Lazy init on first LSP tool call |
| pyright-langserver | 0.5-1s | Same |
| gopls | 0.3-0.5s | Same |
| rust-analyzer | 2-5s | Same (warn user) |

The first LSP tool call in a session will feel slow. Subsequent calls reuse the
running server and return in <100ms. This is acceptable because:

1. Agent workflows are not latency-sensitive (model inference is 2-10s anyway)
2. The agent can use `search_files` while waiting for LSP if needed
3. Cold start happens at most once per language per session

### Caching

No explicit response cache. LSP servers maintain their own internal index and
respond quickly after initialization. Re-reading a file for didOpen is the main
overhead (~1ms for typical source files).

### Keepalive

Servers stay alive for the entire session. Shutdown happens in `registry.close()`,
which the agent loop already calls at the end of every run. For `chat` sessions,
servers persist across multiple turns (desirable).

### Token Budget

6 LSP tool schemas add ~900 tokens to the tool definitions. Combined with the
existing 14 tools (~2,100 tokens), total tool overhead is ~3,000 tokens. This is
manageable for 32K context models. If the tool count warning threshold (20) is hit,
the console already warns the user.

---

## 9. Fallback Behavior

When an LSP server is not available (binary not found, crash, timeout):

```
Tool: lsp_definition
File: src/core/agent.ts
Line: 42, Character: 15

LSP server "typescript-language-server" is not available.
Install it with: npm install -g typescript-language-server typescript

Suggested alternative: Use search_files to find definitions:
  search_files({ pattern: "function agentLoop|export.*agentLoop", glob: "*.ts" })
```

The fallback message includes:

1. Which server was expected
2. Installation command
3. A concrete `search_files` call the model can copy

This means the agent can degrade gracefully -- the model sees the suggestion
and can immediately call `search_files` instead. No hard failure.

### Fallback Hierarchy

```
1. LSP server running -> use it (fast, precise)
2. LSP server binary on PATH but not running -> spawn it (1-2s delay)
3. LSP server not installed -> return fallback with install hint
4. LSP disabled in config -> tool schemas not included at all
5. File type unsupported -> return "No LSP server configured for .xyz files"
```

---

## 10. Implementation Order

| # | Task | Depends On | Est. Time |
|---|------|-----------|-----------|
| 1 | `src/lsp/protocol.ts` + tests | Nothing | 30 min |
| 2 | `src/lsp/servers.ts` | Nothing | 15 min |
| 3 | `src/lsp/client.ts` + tests | Tasks 1-2 | 2 hr |
| 4 | `src/lsp/manager.ts` + tests | Task 3 | 1 hr |
| 5 | Tool schemas in `tools.ts` + tests | Nothing | 30 min |
| 6 | Config schema in `config.ts` | Nothing | 15 min |
| 7 | Registry integration in `registry.ts` | Tasks 4-6 | 45 min |
| 8 | File change notifications | Task 7 | 30 min |
| 9 | Manual testing with real tsserver | All | 1 hr |

**Total estimated:** ~7 hours

---

## 11. Open Questions

1. **Should `lsp_rename` actually apply edits, or just return the workspace edit?**
   Current design: returns the list of edits as text. The model can then use
   `multi_edit` to apply them, which goes through permission checks. This keeps
   `lsp_rename` as a "preview" and `multi_edit` as the "apply" step.

2. **Should we support `textDocument/didChange` incremental sync?**
   No for V1. Full document sync (mode 1) is simpler and sufficient. Incremental
   sync can be added later if performance requires it.

3. **Should LSP servers auto-start when the session begins?**
   No. Lazy initialization is better: many sessions only use file tools and never
   need LSP. Spawning 4 server processes eagerly would waste resources.
