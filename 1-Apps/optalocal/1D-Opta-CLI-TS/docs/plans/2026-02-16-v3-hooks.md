# V3 Hook System — Lifecycle Events for Opta CLI

**Date:** 2026-02-16  |  **Effort:** ~250 lines new, ~34 lines modified  |  **Est:** 3 hours
**Dependencies:** execa (installed), zod (installed)  |  **No new deps**

---

## 1. Architecture Overview

Users run shell commands at lifecycle points in the agent loop. Configured in
`.opta/config.json` (project) or `~/.config/opta/config.json` (user).
Zero hooks configured = zero cost (no-op singleton).

```
Session starts -> fire("session.start")
  Agent loop:
    Model returns tool calls
      -> fire("tool.pre", { tool, args })
         Non-zero exit? -> skip tool, feed stderr to model
      -> executeTool()
      -> fire("tool.post", { tool, args, result })
    Context compaction -> fire("compact")
  Loop ends -> fire("session.end")
  Error -> fire("error", { message })
```

**Core class:** `HookManager` with `fire(event, context)` and `static create(defs?)`.
Factory returns shared `NoOpHookManager` when no hooks configured.

---

## 2. New Files

### `src/hooks/manager.ts` (~120 lines)

**Types:**

```typescript
export type HookEvent =
  | 'session.start' | 'session.end'
  | 'tool.pre' | 'tool.post'
  | 'compact' | 'error';

export interface HookDefinition {
  event: HookEvent;
  command: string;
  matcher?: string;     // Regex against tool name (tool.pre/tool.post only)
  timeout?: number;     // ms, default 10000
  background?: boolean; // fire-and-forget, default false
}

export interface HookContext {
  event: HookEvent;
  session_id: string;
  cwd: string;
  tool_name?: string;
  tool_args?: string;       // JSON string
  tool_result?: string;     // tool.post only
  error_message?: string;   // error event only
  model?: string;
}

export interface HookResult {
  cancelled: boolean;
  reason?: string;          // stderr from cancelling hook
}
```

**Key implementation details:**

- Constructor compiles `matcher` strings into `RegExp` objects once
- `fire()` filters hooks by event + matcher, builds env vars, runs via execa
- `tool.pre` only: non-zero exit returns `{ cancelled: true, reason: stderr }`
- Background hooks: `.catch()` swallows errors, does not await
- `runHook()` calls `execa('sh', ['-c', command])` with timeout + env
- `NoOpHookManager` extends `HookManager`, overrides `fire()` to return `NOOP_RESULT`

### `src/hooks/__tests__/manager.test.ts` (~100 lines)

Test suite covering all 8 tasks below.

---

## 3. Modified Files

### `src/core/config.ts` — Add hooks to Zod schema (+12 lines)

```typescript
const HookDefinitionSchema = z.object({
  event: z.enum(['session.start','session.end','tool.pre','tool.post','compact','error']),
  command: z.string(),
  matcher: z.string().optional(),
  timeout: z.number().min(100).max(60000).optional(),
  background: z.boolean().optional(),
});

// Add to OptaConfigSchema after `search`:
hooks: z.array(HookDefinitionSchema).default([]),
```

### `src/core/agent.ts` — Wire hooks into agent loop (+34 lines)

| Location | Change |
|----------|--------|
| Top | Import `HookManager`, `HookContext` |
| Before while loop | `const hooks = HookManager.create(config.hooks)` + fire session.start |
| Before `registry.execute()` | fire tool.pre, check `preResult.cancelled`, push blocked message + continue |
| After `registry.execute()` | fire tool.post with result (capped at 2KB) |
| After `compactHistory()` | fire compact |
| After while loop | fire session.end |
| New try/catch wrapper | fire error with `err.message` |

---

## 4. Config Schema & Env Vars

```json
{
  "hooks": [
    { "event": "tool.pre", "matcher": "run_command", "command": ".opta/hooks/block-rm.sh" },
    { "event": "tool.post", "matcher": "edit_file|write_file", "command": ".opta/hooks/auto-lint.sh", "timeout": 15000 },
    { "event": "session.end", "command": "git add -A && git commit -m 'opta: done'", "background": true }
  ]
}
```

| Env Variable | When Set | Description |
|-------------|----------|-------------|
| `OPTA_EVENT` | Always | Event name |
| `OPTA_SESSION_ID` | Always | Session ID |
| `OPTA_CWD` | Always | Working directory |
| `OPTA_MODEL` | Always | Active model name |
| `OPTA_TOOL_NAME` | tool.* | Tool name (e.g., `edit_file`) |
| `OPTA_TOOL_ARGS` | tool.* | JSON tool arguments |
| `OPTA_TOOL_RESULT` | tool.post | Result text (first 2KB) |
| `OPTA_ERROR` | error | Error message |

---

## 5. Claude Code Parity

| Feature | CC | Opta V3 | Notes |
|---------|:--:|:-------:|-------|
| PreToolUse / tool.pre | Y | Y | Regex matcher + exit-code cancellation |
| PostToolUse / tool.post | Y | Y | Result via env var |
| SessionStart/End | Y | Y | |
| PreCompact / compact | Y | Y | |
| Error event | N | Y | Opta-specific addition |
| Matcher patterns (regex) | Y | Y | On tool name |
| Timeout protection | Y | Y | 10s default (CC: 600s) |
| Background/async hooks | Y | Y | `background: true` |
| MCP tool matching | Y | Y | `mcp__server__tool` names |
| JSON stdin/stdout protocol | Y | N | V4: env vars simpler for V3 |
| Prompt/Agent-based hooks | Y | N | V4: requires capable LLM |
| Plugin hooks | Y | N | V4: 2 locations for now |
| Stop event (force continue) | Y | N | V4: add as separate event |
| UserPromptSubmit | Y | N | V4: add as `prompt.pre` |
| `/hooks` interactive menu | Y | N | V4: use `opta config` for now |

**V3 covers 9/14 applicable features. 5 deferred to V4.**

---

## 6. Implementation Tasks (TDD)

### Task 1: No-op path (30 min)

```typescript
it('returns non-cancelled when no hooks configured', async () => {
  const mgr = HookManager.create();
  const r = await mgr.fire('session.start', { event:'session.start', session_id:'t', cwd:'/tmp' });
  expect(r.cancelled).toBe(false);
});
it('create([]) returns no-op manager', async () => {
  const mgr = HookManager.create([]);
  const r = await mgr.fire('tool.pre', { event:'tool.pre', session_id:'t', cwd:'/tmp', tool_name:'x' });
  expect(r.cancelled).toBe(false);
});
```

Implement: `HookManager`, `NoOpHookManager`, `create()` factory.

### Task 2: Execution + env vars (30 min)

```typescript
it('fires hook and passes env vars', async () => {
  const mgr = HookManager.create([{ event:'session.start', command:'echo "$OPTA_EVENT"' }]);
  const r = await mgr.fire('session.start', { event:'session.start', session_id:'s42', cwd:'/tmp' });
  expect(r.cancelled).toBe(false);
});
it('skips hooks for non-matching events', async () => {
  const mgr = HookManager.create([{ event:'session.end', command:'exit 1' }]);
  const r = await mgr.fire('session.start', { event:'session.start', session_id:'t', cwd:'/tmp' });
  expect(r.cancelled).toBe(false);
});
```

Implement: `fire()`, `runHook()`, `buildEnv()`.

### Task 3: Matcher patterns (20 min)

```typescript
it('matcher regex filters by tool name', async () => {
  const mgr = HookManager.create([{ event:'tool.pre', matcher:'edit_file|write_file', command:'exit 1' }]);
  expect((await mgr.fire('tool.pre', { event:'tool.pre', session_id:'t', cwd:'/tmp', tool_name:'edit_file' })).cancelled).toBe(true);
  expect((await mgr.fire('tool.pre', { event:'tool.pre', session_id:'t', cwd:'/tmp', tool_name:'read_file' })).cancelled).toBe(false);
});
it('matches MCP tool names with mcp__.*', async () => {
  const mgr = HookManager.create([{ event:'tool.pre', matcher:'mcp__.*', command:'exit 1' }]);
  const r = await mgr.fire('tool.pre', { event:'tool.pre', session_id:'t', cwd:'/tmp', tool_name:'mcp__mem__save' });
  expect(r.cancelled).toBe(true);
});
```

Implement: RegExp compilation in constructor, filter in `fire()`.

### Task 4: tool.pre cancellation (20 min)

```typescript
it('non-zero exit on tool.pre cancels with stderr reason', async () => {
  const mgr = HookManager.create([{ event:'tool.pre', command:'echo "Blocked" >&2 && exit 1' }]);
  const r = await mgr.fire('tool.pre', { event:'tool.pre', session_id:'t', cwd:'/tmp', tool_name:'run_command' });
  expect(r.cancelled).toBe(true);
  expect(r.reason).toContain('Blocked');
});
it('non-zero exit on tool.post does NOT cancel', async () => {
  const mgr = HookManager.create([{ event:'tool.post', command:'exit 1' }]);
  const r = await mgr.fire('tool.post', { event:'tool.post', session_id:'t', cwd:'/tmp', tool_name:'edit_file' });
  expect(r.cancelled).toBe(false);
});
```

Implement: Cancellation guard `if (event === 'tool.pre' && exitCode !== 0)`.

### Task 5: Timeout (15 min)

```typescript
it('kills hooks exceeding timeout', async () => {
  const mgr = HookManager.create([{ event:'session.start', command:'sleep 60', timeout:200 }]);
  const start = Date.now();
  await mgr.fire('session.start', { event:'session.start', session_id:'t', cwd:'/tmp' });
  expect(Date.now() - start).toBeLessThan(2000);
});
```

Implement: Already handled by `execa({ timeout })`.

### Task 6: Background hooks (15 min)

```typescript
it('background hooks do not block', async () => {
  const mgr = HookManager.create([{ event:'session.end', command:'sleep 5', background:true }]);
  const start = Date.now();
  await mgr.fire('session.end', { event:'session.end', session_id:'t', cwd:'/tmp' });
  expect(Date.now() - start).toBeLessThan(1000);
});
```

Implement: `if (hook.background)` branch with fire-and-forget.

### Task 7: Config schema (15 min)

```typescript
it('parses hooks from config', () => {
  const c = OptaConfigSchema.parse({ hooks:[{ event:'tool.pre', command:'echo hi', matcher:'edit_file' }] });
  expect(c.hooks).toHaveLength(1);
});
it('rejects invalid event name', () => {
  expect(() => OptaConfigSchema.parse({ hooks:[{ event:'invalid', command:'x' }] })).toThrow();
});
it('defaults to empty array', () => {
  expect(OptaConfigSchema.parse({}).hooks).toEqual([]);
});
```

Implement: `HookDefinitionSchema` + `hooks` field in `OptaConfigSchema`.

### Task 8: Wire into agent.ts (20 min)

Integration: add 7 `hooks.fire()` call sites as described in Section 3.

---

## 7. Built-in Hook Scripts

Ship as examples in `.opta/hooks/`:

**`block-rm.sh`** (tool.pre, matcher: `run_command`) — Blocks `rm -rf` commands:
```bash
#!/bin/bash
CMD=$(echo "$OPTA_TOOL_ARGS" | jq -r '.command // empty' 2>/dev/null)
echo "$CMD" | grep -qE 'rm\s+(-rf?|--recursive)' && echo "Blocked: destructive rm" >&2 && exit 1
exit 0
```

**`auto-lint.sh`** (tool.post, matcher: `edit_file|write_file|multi_edit`) — Auto-lint:
```bash
#!/bin/bash
FILE=$(echo "$OPTA_TOOL_ARGS" | jq -r '.path // empty' 2>/dev/null)
[ -z "$FILE" ] && exit 0
case "${FILE##*.}" in
  ts|tsx|js|jsx) npx eslint --fix "$FILE" 2>/dev/null ;; py) ruff check --fix "$FILE" 2>/dev/null ;;
esac; exit 0
```

**`auto-test.sh`** (tool.post, matcher: `edit_file|write_file`, background: true) — Run tests:
```bash
#!/bin/bash
FILE=$(echo "$OPTA_TOOL_ARGS" | jq -r '.path // empty' 2>/dev/null)
[ -z "$FILE" ] && exit 0
case "${FILE##*.}" in ts|tsx) npm test -- --run --reporter=dot 2>&1 | tail -5 ;; esac; exit 0
```

---

## 8. Implementation Order

| # | Task | Time | Depends |
|---|------|------|---------|
| 1 | Config schema (Task 7) | 15m | -- |
| 2 | HookManager core + no-op (Task 1) | 30m | -- |
| 3 | Execution + env vars (Task 2) | 30m | 2 |
| 4 | Matcher patterns (Task 3) | 20m | 3 |
| 5 | tool.pre cancellation (Task 4) | 20m | 4 |
| 6 | Timeout protection (Task 5) | 15m | 3 |
| 7 | Background hooks (Task 6) | 15m | 3 |
| 8 | Wire into agent.ts (Task 8) | 20m | 1-7 |
| 9 | Built-in hook scripts | 15m | -- |
| | **Total** | **3h** | |

---

## 9. V4 Upgrade Path

1. **JSON stdin/stdout protocol** — Full context via stdin, structured JSON responses for
   allow/deny/ask decisions and `updatedInput` to modify tool args before execution
2. **`prompt.pre` event** — Hook before user prompt processed (Claude Code's `UserPromptSubmit`)
3. **`stop` event** — Force agent to continue (separate from session.end)
4. **Prompt-based hooks** — LLM evaluation instead of shell commands
5. **Plugin hooks** — Auto-loaded from MCP plugins
6. **`/hooks` interactive menu** — TUI for managing hooks
7. **Hook deduplication** — Across user/project config
8. **`statusMessage` field** — Custom spinner text while hook runs
