'use client';

/**
 * Dashboard -- Root page (/).
 *
 * Connects to LMX /admin/events via SSE, displays live VRAM gauge,
 * loaded models list, throughput chart, and server stats. Uses global
 * ConnectionProvider for dynamic base URL (LAN/WAN auto-failover).
 *
 * Throughput data uses a CircularBuffer (capacity 300 = 5 min at 1/sec)
 * flushed to React state on a 1-second interval -- separate from the
 * 500ms VRAM/status flush to avoid coupling chart redraws to gauge updates.
 *
 * Responsive CSS Grid layout:
 * 3 columns (desktop) -> 2 columns (tablet) -> 1 column (mobile).
 */

import { useState, useCallback, useEffect, useMemo, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { RefreshCw, Plus, AlertCircle, WifiOff, AlertTriangle, Cloud } from 'lucide-react';
import { Button } from '@opta/ui';

import { useSSE } from '@/hooks/useSSE';
import { useBufferedState } from '@/hooks/useBufferedState';
import { useHeartbeat } from '@/hooks/useHeartbeat';
import { useConnectionContextSafe } from '@/components/shared/ConnectionProvider';
import { useAuthSafe } from '@/components/shared/AuthProvider';
import type { ServerStatus } from '@/types/lmx';
import { CircularBuffer } from '@/lib/circular-buffer';
import type { ThroughputPoint } from '@/lib/circular-buffer';

import { VRAMGauge } from '@/components/dashboard/VRAMGauge';
import { ModelList } from '@/components/dashboard/ModelList';
import { ThroughputChart } from '@/components/dashboard/ThroughputChart';
import { ModelLoadDialog } from '@/components/dashboard/ModelLoadDialog';
import { HeartbeatIndicator } from '@/components/dashboard/HeartbeatIndicator';

// ---------------------------------------------------------------------------
// SSE event shape
// ---------------------------------------------------------------------------

interface SSEEvent {
  type: 'status' | 'model_change' | 'throughput';
  data: ServerStatus | ThroughputPoint;
}

// ---------------------------------------------------------------------------
// Constants
// ---------------------------------------------------------------------------

/** 300 data points = 5 minutes at 1 data point per second */
const THROUGHPUT_BUFFER_CAPACITY = 300;

/** Flush chart data to React state every 1 second */
const CHART_FLUSH_INTERVAL_MS = 1000;

// ---------------------------------------------------------------------------
// Dashboard page
// ---------------------------------------------------------------------------

export default function DashboardPage() {
  // ---- Auth context (optional — only present in cloud mode) ----
  const auth = useAuthSafe();

  // ---- Connection from global provider (null while settings load) ----
  const connection = useConnectionContextSafe();
  const baseUrl = connection?.baseUrl ?? '';
  const isConnected = connection?.isConnected ?? false;
  const client = connection?.client ?? null;
  const connectionType = connection?.connectionType ?? 'probing';
  const adminKey = connection?.adminKey ?? '';
  const recheckConnection = connection?.recheckNow;

  // ---- Derived SSE URL (reacts to LAN/WAN changes) ----
  const sseUrl = useMemo(() => {
    if (!isConnected) return '';
    return `${baseUrl}/admin/events`;
  }, [baseUrl, isConnected]);

  // ---- Admin key header for SSE ----
  const sseHeaders = useMemo(() => {
    if (!adminKey) return undefined;
    return { 'X-Admin-Key': adminKey };
  }, [adminKey]);

  // ---- Buffered server status (500ms flush) ----
  const [status, pushStatus] = useBufferedState<ServerStatus | null>(
    null,
    500,
  );

  // ---- Throughput circular buffer + state (1s flush) ----
  const throughputBufferRef = useRef(
    new CircularBuffer<ThroughputPoint>(THROUGHPUT_BUFFER_CAPACITY),
  );
  const [chartData, setChartData] = useState<ThroughputPoint[]>([]);

  // Flush throughput buffer to React state on 1-second interval
  useEffect(() => {
    const id = setInterval(() => {
      setChartData(throughputBufferRef.current.toArray());
    }, CHART_FLUSH_INTERVAL_MS);
    return () => clearInterval(id);
  }, []);

  // Compute average TPS from chart data
  const averageTps = useMemo(() => {
    if (chartData.length === 0) return undefined;
    const sum = chartData.reduce((acc, p) => acc + p.tokensPerSecond, 0);
    return sum / chartData.length;
  }, [chartData]);

  // ---- SSE message handler ----
  const handleMessage = useCallback(
    (event: SSEEvent) => {
      switch (event.type) {
        case 'status':
        case 'model_change':
          pushStatus(() => event.data as ServerStatus);
          break;
        case 'throughput':
          throughputBufferRef.current.push(event.data as ThroughputPoint);
          break;
      }
    },
    [pushStatus],
  );

  // ---- SSE connection ----
  const { connectionState, reconnect } = useSSE<SSEEvent>({
    url: sseUrl,
    headers: sseHeaders,
    onMessage: handleMessage,
    enabled: isConnected && sseUrl !== '',
  });

  // ---- Heartbeat health monitor ----
  const { isHealthy, consecutiveFailures, lastPingMs } = useHeartbeat({
    baseUrl,
    adminKey,
    enabled: isConnected,
  });

  // ---- Synthesize throughput from status TPS ----
  // If the server sends status events with tokens_per_second but no
  // dedicated throughput events, create synthetic throughput points.
  const lastStatusTpsRef = useRef<number | null>(null);
  useEffect(() => {
    if (status?.tokens_per_second != null) {
      const tps = status.tokens_per_second;
      if (lastStatusTpsRef.current !== tps) {
        lastStatusTpsRef.current = tps;
        throughputBufferRef.current.push({
          timestamp: Date.now(),
          tokensPerSecond: tps,
        });
      }
    }
  }, [status]);

  // ---- Model unload handler (uses connection-aware client) ----
  const [unloadingId, setUnloadingId] = useState<string | null>(null);

  const [actionError, setActionError] = useState<string | null>(null);

  const handleUnload = useCallback(
    async (modelId: string) => {
      if (!client) return;
      setUnloadingId(modelId);
      setActionError(null);
      try {
        await client.unloadModel(modelId);
      } catch (err) {
        setActionError(
          err instanceof Error ? err.message : 'Failed to unload model',
        );
      } finally {
        setUnloadingId(null);
      }
    },
    [client],
  );

  // ---- Model load handler ----
  const [isLoadOpen, setIsLoadOpen] = useState(false);
  const [isLoadingModel, setIsLoadingModel] = useState(false);

  const handleLoadModel = useCallback(
    async (modelPath: string, quantization?: string) => {
      if (!client) return;
      setIsLoadingModel(true);
      setActionError(null);
      try {
        await client.loadModel({
          model_path: modelPath,
          quantization,
        });
        setIsLoadOpen(false);
      } catch (err) {
        setActionError(
          err instanceof Error ? err.message : 'Failed to load model',
        );
      } finally {
        setIsLoadingModel(false);
      }
    },
    [client],
  );

  // ---- Dashboard render ----
  return (
    <main className="min-h-screen p-6">
      {/* Page title row */}
      <div className="mb-5">
        <div className="opta-section-header mb-1">
          <h1 className="opta-section-title">Dashboard</h1>
          <div className="opta-section-line" />
        </div>
        {/* User context strip — shown when signed in */}
        {auth?.user && (
          <p className="text-xs text-text-muted flex items-center gap-1.5 mt-1">
            <Cloud className="h-3 w-3" />
            <span>
              Signed in as{' '}
              <span className="text-text-secondary">
                {auth.user.user_metadata?.full_name ?? auth.user.email ?? 'unknown'}
              </span>
            </span>
          </p>
        )}
      </div>

      {/* Page header actions */}
      <header className="mb-6 flex items-center justify-end gap-3">
        {/* Heartbeat health indicator */}
        {isConnected && (
          <HeartbeatIndicator
            isHealthy={isHealthy}
            consecutiveFailures={consecutiveFailures}
            lastPingMs={lastPingMs}
          />
        )}
        {/* SSE error badge */}
        {connectionType !== 'offline' && connectionState === 'error' && (
          <span className="inline-flex items-center rounded-full border border-neon-red/30 bg-neon-red/10 px-2 py-0.5 text-[10px] font-semibold uppercase tracking-widest text-neon-red">
            SSE off
          </span>
        )}
        <div className="flex shrink-0 items-center gap-2">
          <Button
            variant="glass"
            size="sm"
            onClick={() => setIsLoadOpen((prev) => !prev)}
            aria-label="Load a model"
          >
            <Plus className="mr-1.5 h-4 w-4" />
            Load Model
          </Button>
          <Button
            variant="ghost"
            size="sm"
            onClick={reconnect}
            aria-label="Reconnect SSE"
          >
            <RefreshCw className="h-4 w-4" />
          </Button>
        </div>
      </header>

      {/* Offline state */}
      {connectionType === 'offline' && (
        <div className="mb-4 glass-subtle rounded-xl p-6 text-center">
          <WifiOff className="mx-auto h-8 w-8 text-neon-red mb-3" />
          <p className="text-sm font-medium text-text-primary mb-1">
            Server unreachable
          </p>
          <p className="text-xs text-text-muted mb-4">
            {connection?.error ?? 'Could not connect via LAN or WAN'}
          </p>
          <Button
            variant="glass"
            size="sm"
            onClick={recheckConnection}
          >
            <RefreshCw className="mr-1.5 h-3.5 w-3.5" />
            Retry Connection
          </Button>
        </div>
      )}

      {/* Heartbeat reconnection banner */}
      <AnimatePresence>
        {!isHealthy && connectionType !== 'offline' && (
          <motion.div
            initial={{ opacity: 0, y: -8, height: 0 }}
            animate={{ opacity: 1, y: 0, height: 'auto' }}
            exit={{ opacity: 0, y: -8, height: 0 }}
            transition={{ type: 'spring', stiffness: 300, damping: 30 }}
            className="mb-4 flex items-center gap-2 rounded-lg glass-subtle border border-neon-amber/30 px-4 py-3"
          >
            <AlertTriangle className="h-4 w-4 shrink-0 text-neon-amber" />
            <p className="flex-1 text-sm text-neon-amber">
              Connection unstable — reconnecting...
            </p>
            <Button
              variant="ghost"
              size="sm"
              onClick={() => {
                reconnect();
                recheckConnection?.();
              }}
              className="text-xs text-neon-amber hover:text-neon-amber/80"
            >
              <RefreshCw className="mr-1 h-3 w-3" />
              Retry
            </Button>
          </motion.div>
        )}
      </AnimatePresence>

      {/* Action error banner */}
      <AnimatePresence>
        {actionError && (
          <motion.div
            initial={{ opacity: 0, y: -8, height: 0 }}
            animate={{ opacity: 1, y: 0, height: 'auto' }}
            exit={{ opacity: 0, y: -8, height: 0 }}
            transition={{ type: 'spring', stiffness: 300, damping: 30 }}
            className="mb-4 flex items-center gap-2 rounded-lg border border-neon-red/20 bg-neon-red/10 px-4 py-3"
          >
            <AlertCircle className="h-4 w-4 shrink-0 text-neon-red" />
            <p className="flex-1 text-sm text-neon-red">{actionError}</p>
            <button
              onClick={() => setActionError(null)}
              className="text-xs text-neon-red/60 hover:text-neon-red"
              aria-label="Dismiss error"
            >
              Dismiss
            </button>
          </motion.div>
        )}
      </AnimatePresence>

      {/* Model Load Dialog (collapsible panel) */}
      <div className="mb-4">
        <ModelLoadDialog
          onLoad={handleLoadModel}
          isLoading={isLoadingModel}
          isOpen={isLoadOpen}
          onClose={() => setIsLoadOpen(false)}
        />
      </div>

      {/* Dashboard grid: 3 -> 2 -> 1 columns */}
      <div className="grid grid-cols-1 gap-5 md:grid-cols-2 xl:grid-cols-3">
        {/* VRAM Gauge */}
        <VRAMGauge
          usedGB={status?.vram_used_gb ?? 0}
          totalGB={status?.vram_total_gb ?? 0}
        />

        {/* Loaded Models */}
        <div className="md:col-span-1 xl:col-span-2">
          <ModelList
            models={status?.loaded_models ?? []}
            onUnload={handleUnload}
            isUnloading={unloadingId}
            onLoad={() => setIsLoadOpen(true)}
          />
        </div>

        {/* Throughput Chart -- full width */}
        <div className="col-span-full">
          <ThroughputChart data={chartData} averageTps={averageTps} />
        </div>

        {/* Server Stats */}
        <div className="glass-subtle col-span-full rounded-xl p-6">
          <div className="opta-section-header mb-5">
            <h2 className="shrink-0 text-xs font-semibold uppercase tracking-[0.2em] text-text-muted">
              Server Info
            </h2>
            <div className="opta-section-line opacity-30" />
          </div>
          <div className="grid grid-cols-2 gap-6 sm:grid-cols-3 lg:grid-cols-5">
            <StatItem
              label="Active Requests"
              value={status?.active_requests ?? 0}
              accent={(status?.active_requests ?? 0) > 0 ? 'var(--color-neon-cyan)' : undefined}
            />
            <StatItem
              label="Tokens/sec"
              value={status?.tokens_per_second != null ? status.tokens_per_second.toFixed(1) : '0.0'}
            />
            <StatItem
              label="Temperature"
              value={status?.temperature_celsius != null ? `${status.temperature_celsius.toFixed(0)}\u00B0C` : '\u2014'}
              accent={getTempAccent(status?.temperature_celsius ?? null)}
            />
            <StatItem
              label="Uptime"
              value={formatUptime(status?.uptime_seconds ?? 0)}
            />
            <StatItem
              label="Ping"
              value={lastPingMs !== null ? `${lastPingMs}ms` : '\u2014'}
              accent={getPingAccent(lastPingMs)}
            />
          </div>
        </div>
      </div>
    </main>
  );
}

// ---------------------------------------------------------------------------
// Sub-components
// ---------------------------------------------------------------------------

function StatItem({
  label,
  value,
  accent,
}: {
  label: string;
  value: string | number;
  /** Optional CSS color string — overrides default text-primary */
  accent?: string;
}) {
  return (
    <div className="space-y-2">
      <p className="text-[11px] font-medium uppercase tracking-[0.15em] text-text-muted">
        {label}
      </p>
      <p
        className="text-2xl font-bold leading-none tabular-nums"
        style={{ color: accent ?? 'var(--color-text-primary)' }}
      >
        {value}
      </p>
    </div>
  );
}

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

/** Returns a CSS color accent for temperature (amber >70°C, red >85°C). */
function getTempAccent(celsius: number | null): string | undefined {
  if (celsius == null) return undefined;
  if (celsius >= 85) return 'var(--color-neon-red)';
  if (celsius >= 70) return 'var(--color-neon-amber)';
  return undefined;
}

/** Returns a CSS color accent for ping latency (green <10ms, amber >50ms). */
function getPingAccent(ms: number | null): string | undefined {
  if (ms == null) return undefined;
  if (ms < 10) return 'var(--color-neon-green)';
  if (ms > 50) return 'var(--color-neon-amber)';
  return undefined;
}

function formatUptime(seconds: number): string {
  if (seconds <= 0) return '\u2014';
  const h = Math.floor(seconds / 3600);
  const m = Math.floor((seconds % 3600) / 60);
  if (h > 0) return `${h}h ${m}m`;
  return `${m}m`;
}
