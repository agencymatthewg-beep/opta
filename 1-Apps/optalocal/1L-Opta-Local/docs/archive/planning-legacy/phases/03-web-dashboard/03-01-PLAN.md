---
phase: 03-web-dashboard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - 1-Apps/1L-Opta-Local/web/package.json
  - 1-Apps/1L-Opta-Local/web/src/hooks/useSSE.ts
  - 1-Apps/1L-Opta-Local/web/src/hooks/useBufferedState.ts
  - 1-Apps/1L-Opta-Local/web/src/lib/circular-buffer.ts
autonomous: true
status: review
---

<objective>
Create the SSE connection infrastructure for real-time server monitoring.

Purpose: Build the foundational hooks and utilities that all dashboard components depend on — SSE with auto-reconnect, buffered state updates for high-frequency data, and a circular buffer for time-series chart data.
Output: useSSE hook with @microsoft/fetch-event-source, useBufferedState hook for batched renders, and CircularBuffer utility for time-windowed data.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-web-dashboard/03-RESEARCH.md
@.planning/phases/01-web-project-setup/01-02-SUMMARY.md

# Phase 1 source files:
@1-Apps/1L-Opta-Local/web/src/lib/lmx-client.ts
@1-Apps/1L-Opta-Local/web/src/lib/connection.ts
@1-Apps/1L-Opta-Local/web/src/types/lmx.ts

# Design rules:
@1-Apps/1L-Opta-Local/web/CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dashboard dependencies and create SSE hook</name>
  <files>
    1-Apps/1L-Opta-Local/web/package.json,
    1-Apps/1L-Opta-Local/web/src/hooks/useSSE.ts
  </files>
  <action>
    1. Install dashboard dependencies:
       ```bash
       cd 1-Apps/1L-Opta-Local/web && pnpm add @microsoft/fetch-event-source recharts
       ```

    2. Create `src/hooks/useSSE.ts` ('use client') wrapping @microsoft/fetch-event-source:
       - Generic hook: useSSE<T>(options: UseSSEOptions<T>)
       - Options: url, headers (for X-Admin-Key), onMessage callback, onError callback, enabled flag, retryInterval (default 3000), maxRetries (default 10)
       - Connection state: 'connecting' | 'open' | 'closed' | 'error'
       - AbortController in useRef (survives re-renders without triggering them)
       - Retry counter in useRef (mutations don't cause re-renders)
       - Exponential backoff with jitter: delay * 2^retries * (1 + Math.random() * 0.5), capped at 30s
       - fetchEventSource handles Page Visibility API automatically (pauses on tab hide, reconnects on show)
       - Cleanup: abort controller in useEffect cleanup function
       - Return { connectionState, disconnect, reconnect }
       - See 03-RESEARCH.md Pattern 1 for the exact implementation
       - IMPORTANT: Do NOT use native EventSource — it cannot send custom headers (X-Admin-Key would be exposed in URL query params)
  </action>
  <verify>pnpm run build passes; @microsoft/fetch-event-source and recharts resolve correctly</verify>
  <done>useSSE hook created with auto-reconnect, exponential backoff with jitter, and Page Visibility support</done>
</task>

<task type="auto">
  <name>Task 2: Create buffered state hook and circular buffer utility</name>
  <files>
    1-Apps/1L-Opta-Local/web/src/hooks/useBufferedState.ts,
    1-Apps/1L-Opta-Local/web/src/lib/circular-buffer.ts
  </files>
  <action>
    1. Create `src/hooks/useBufferedState.ts` ('use client'):
       - Generic hook: useBufferedState<T>(initialState: T, intervalMs?: number)
       - Stores latest value in useRef (buffer) — updates to ref do NOT trigger re-renders
       - Flushes buffer to useState on a setInterval (default 500ms)
       - Returns [state, push] where push accepts an updater function: (prev: T) => T
       - This prevents re-render storms from high-frequency SSE events (10-50Hz throughput metrics)
       - See 03-RESEARCH.md Pattern 2 for the exact implementation

    2. Create `src/lib/circular-buffer.ts`:
       - Class: CircularBuffer<T> with constructor(capacity: number)
       - push(item: T): adds item, overwrites oldest when full
       - toArray(): returns items in chronological order (unwraps circular structure)
       - length getter: current item count
       - isFull getter: whether buffer has reached capacity
       - clear(): resets buffer
       - Use case: new CircularBuffer<ThroughputPoint>(300) keeps 5 minutes of data at 1s granularity
       - See 03-RESEARCH.md Pattern 3 for the exact implementation
       - Export both the class and a ThroughputPoint type: { timestamp: number, tokensPerSecond: number }
  </action>
  <verify>pnpm run build passes; no TypeScript errors in hooks or utility files</verify>
  <done>useBufferedState batches renders at configurable intervals; CircularBuffer maintains fixed-size sliding window with chronological toArray()</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd 1-Apps/1L-Opta-Local/web && pnpm run build` succeeds without errors
- [ ] useSSE hook compiles with generic type parameter
- [ ] useBufferedState compiles with generic type parameter
- [ ] CircularBuffer toArray returns chronological order
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- SSE hook supports custom headers for admin key authentication
- Buffer and circular buffer utilities are generic and reusable
</success_criteria>

<output>
After completion, create `.planning/phases/03-web-dashboard/03-01-SUMMARY.md`
</output>
