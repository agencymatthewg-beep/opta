# Plan 61-03: Effects Shaders

## Wave: 2 (Depends on 61-01)

## Objective

Create WGSL effect shaders for plasma/noise generation and bloom post-processing.

## Execution Context

**Reference Documents:**
- `Gemini Deep Research/Hardware & Platform Knowledge/wgpu-SwiftUI-iOS-macOS-Integration.md`
- Shader toy noise/plasma references

**Key Insights:**
- Noise functions essential for organic effects
- Bloom requires multi-pass (threshold -> blur -> composite)
- Apple GPUs optimize texture sampling well

## Context

**Depends on:**
- Plan 61-01 (ShaderLibrary infrastructure)
- Plan 61-02 (math/color utilities)

**Builds foundation for:**
- Plan 62 (SwiftUI visual effects)
- Background animations and UI feedback

## Tasks

### Task 1: Create noise shader include

**File:** `opta-native/opta-render/shaders/includes/noise.wgsl`

```wgsl
// Noise functions for procedural effects

#include "math.wgsl"

/// Hash function for pseudo-random numbers.
fn hash21(p: vec2<f32>) -> f32 {
    var p3 = fract(vec3<f32>(p.x, p.y, p.x) * 0.1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

fn hash22(p: vec2<f32>) -> vec2<f32> {
    var p3 = fract(vec3<f32>(p.x, p.y, p.x) * vec3<f32>(0.1031, 0.1030, 0.0973));
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.xx + p3.yz) * p3.zy);
}

fn hash31(p: vec3<f32>) -> f32 {
    var p3 = fract(p * 0.1031);
    p3 += dot(p3, p3.zyx + 31.32);
    return fract((p3.x + p3.y) * p3.z);
}

/// Value noise 2D.
fn value_noise(p: vec2<f32>) -> f32 {
    let i = floor(p);
    let f = fract(p);

    // Cubic interpolation
    let u = f * f * (3.0 - 2.0 * f);

    return mix(
        mix(hash21(i + vec2<f32>(0.0, 0.0)), hash21(i + vec2<f32>(1.0, 0.0)), u.x),
        mix(hash21(i + vec2<f32>(0.0, 1.0)), hash21(i + vec2<f32>(1.0, 1.0)), u.x),
        u.y
    );
}

/// Gradient for Perlin noise.
fn gradient(hash: f32, x: f32, y: f32) -> f32 {
    let h = u32(hash * 16.0) & 15u;
    let u = select(y, x, h < 8u);
    let v = select(select(x, y, h == 12u || h == 14u), y, h < 4u);
    return select(-u, u, (h & 1u) == 0u) + select(-v, v, (h & 2u) == 0u);
}

/// Perlin noise 2D.
fn perlin_noise(p: vec2<f32>) -> f32 {
    let i = floor(p);
    let f = fract(p);

    // Quintic interpolation
    let u = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);

    let n00 = gradient(hash21(i + vec2<f32>(0.0, 0.0)), f.x, f.y);
    let n10 = gradient(hash21(i + vec2<f32>(1.0, 0.0)), f.x - 1.0, f.y);
    let n01 = gradient(hash21(i + vec2<f32>(0.0, 1.0)), f.x, f.y - 1.0);
    let n11 = gradient(hash21(i + vec2<f32>(1.0, 1.0)), f.x - 1.0, f.y - 1.0);

    return mix(mix(n00, n10, u.x), mix(n01, n11, u.x), u.y);
}

/// Fractal Brownian Motion (multi-octave noise).
fn fbm(p: vec2<f32>, octaves: i32) -> f32 {
    var value = 0.0;
    var amplitude = 0.5;
    var frequency = 1.0;
    var pos = p;

    for (var i = 0; i < octaves; i++) {
        value += amplitude * perlin_noise(pos * frequency);
        amplitude *= 0.5;
        frequency *= 2.0;
        // Rotate to reduce axis-aligned artifacts
        pos = vec2<f32>(pos.x * 0.8 - pos.y * 0.6, pos.x * 0.6 + pos.y * 0.8);
    }

    return value;
}

/// Simplex noise 2D (faster than Perlin).
fn simplex_noise(p: vec2<f32>) -> f32 {
    let K1 = 0.366025404; // (sqrt(3)-1)/2
    let K2 = 0.211324865; // (3-sqrt(3))/6

    let i = floor(p + (p.x + p.y) * K1);
    let a = p - i + (i.x + i.y) * K2;
    let o = select(vec2<f32>(0.0, 1.0), vec2<f32>(1.0, 0.0), a.x > a.y);
    let b = a - o + K2;
    let c = a - 1.0 + 2.0 * K2;

    let h = max(0.5 - vec3<f32>(dot(a, a), dot(b, b), dot(c, c)), vec3<f32>(0.0));
    let n = h * h * h * h * vec3<f32>(
        dot(a, hash22(i) - 0.5),
        dot(b, hash22(i + o) - 0.5),
        dot(c, hash22(i + 1.0) - 0.5)
    );

    return dot(n, vec3<f32>(70.0));
}

/// Worley/cellular noise 2D.
fn worley_noise(p: vec2<f32>) -> f32 {
    let i = floor(p);
    let f = fract(p);

    var min_dist = 1.0;

    for (var y = -1; y <= 1; y++) {
        for (var x = -1; x <= 1; x++) {
            let neighbor = vec2<f32>(f32(x), f32(y));
            let point = hash22(i + neighbor);
            let diff = neighbor + point - f;
            let dist = length(diff);
            min_dist = min(min_dist, dist);
        }
    }

    return min_dist;
}
```

### Task 2: Create plasma shader

**File:** `opta-native/opta-render/shaders/plasma.wgsl`

```wgsl
// Plasma effect shader

#include "noise.wgsl"
#include "color.wgsl"

struct Uniforms {
    resolution: vec2<f32>,
    time: f32,
    speed: f32,
    scale: f32,
    color_shift: f32,
    _padding: vec2<f32>,
}

@group(0) @binding(0)
var<uniform> uniforms: Uniforms;

struct VertexOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv: vec2<f32>,
}

@vertex
fn vs_main(@builtin(vertex_index) vertex_index: u32) -> VertexOutput {
    var positions = array<vec2<f32>, 3>(
        vec2<f32>(-1.0, -1.0),
        vec2<f32>(3.0, -1.0),
        vec2<f32>(-1.0, 3.0)
    );

    var output: VertexOutput;
    output.position = vec4<f32>(positions[vertex_index], 0.0, 1.0);
    output.uv = positions[vertex_index] * 0.5 + 0.5;
    return output;
}

@fragment
fn fs_main(input: VertexOutput) -> @location(0) vec4<f32> {
    let t = uniforms.time * uniforms.speed;
    let uv = input.uv * uniforms.scale;

    // Multiple sine waves for plasma effect
    var value = 0.0;
    value += sin(uv.x * 10.0 + t);
    value += sin(uv.y * 10.0 + t * 1.1);
    value += sin((uv.x + uv.y) * 10.0 + t * 0.9);
    value += sin(sqrt(uv.x * uv.x + uv.y * uv.y) * 20.0 - t * 2.0);

    // Add noise for organic feel
    value += fbm(uv * 3.0 + t * 0.2, 4) * 2.0;

    // Normalize to 0-1
    value = value * 0.1 + 0.5;

    // Color palette using HSL
    let hue = fract(value + uniforms.color_shift);
    let saturation = 0.8;
    let lightness = 0.5 + value * 0.2;

    let rgb = hsl_to_rgb(vec3<f32>(hue, saturation, lightness));
    return vec4<f32>(linear_to_srgb(rgb), 1.0);
}
```

### Task 3: Create bloom threshold shader

**File:** `opta-native/opta-render/shaders/bloom_threshold.wgsl`

```wgsl
// Bloom effect - threshold pass
// Extracts bright areas for blurring

#include "color.wgsl"

struct Uniforms {
    threshold: f32,
    soft_threshold: f32,
    _padding: vec2<f32>,
}

@group(0) @binding(0)
var<uniform> uniforms: Uniforms;

@group(0) @binding(1)
var input_texture: texture_2d<f32>;

@group(0) @binding(2)
var input_sampler: sampler;

struct VertexOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv: vec2<f32>,
}

@vertex
fn vs_main(@builtin(vertex_index) vertex_index: u32) -> VertexOutput {
    var positions = array<vec2<f32>, 3>(
        vec2<f32>(-1.0, -1.0),
        vec2<f32>(3.0, -1.0),
        vec2<f32>(-1.0, 3.0)
    );

    var output: VertexOutput;
    output.position = vec4<f32>(positions[vertex_index], 0.0, 1.0);
    output.uv = positions[vertex_index] * 0.5 + 0.5;
    output.uv.y = 1.0 - output.uv.y; // Flip Y for texture coords
    return output;
}

@fragment
fn fs_main(input: VertexOutput) -> @location(0) vec4<f32> {
    let color = textureSample(input_texture, input_sampler, input.uv);

    // Calculate luminance
    let luminance = dot(color.rgb, vec3<f32>(0.2126, 0.7152, 0.0722));

    // Soft threshold (knee curve)
    let soft = luminance - uniforms.threshold + uniforms.soft_threshold;
    let soft_clamped = clamp(soft, 0.0, 2.0 * uniforms.soft_threshold);
    let soft_weight = soft_clamped * soft_clamped / (4.0 * uniforms.soft_threshold + 0.0001);

    // Combine hard and soft threshold
    let contribution = max(soft_weight, luminance - uniforms.threshold);
    let weight = contribution / (luminance + 0.0001);

    return vec4<f32>(color.rgb * weight, 1.0);
}
```

### Task 4: Create gaussian blur shader

**File:** `opta-native/opta-render/shaders/blur.wgsl`

```wgsl
// Gaussian blur shader (separable - run twice for H and V)

struct Uniforms {
    direction: vec2<f32>,  // (1,0) for horizontal, (0,1) for vertical
    texel_size: vec2<f32>, // 1.0 / texture_size
}

@group(0) @binding(0)
var<uniform> uniforms: Uniforms;

@group(0) @binding(1)
var input_texture: texture_2d<f32>;

@group(0) @binding(2)
var input_sampler: sampler;

struct VertexOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv: vec2<f32>,
}

@vertex
fn vs_main(@builtin(vertex_index) vertex_index: u32) -> VertexOutput {
    var positions = array<vec2<f32>, 3>(
        vec2<f32>(-1.0, -1.0),
        vec2<f32>(3.0, -1.0),
        vec2<f32>(-1.0, 3.0)
    );

    var output: VertexOutput;
    output.position = vec4<f32>(positions[vertex_index], 0.0, 1.0);
    output.uv = positions[vertex_index] * 0.5 + 0.5;
    output.uv.y = 1.0 - output.uv.y;
    return output;
}

// 9-tap Gaussian kernel (sigma ~= 2)
const KERNEL_SIZE: i32 = 9;
const OFFSETS: array<f32, 9> = array<f32, 9>(-4.0, -3.0, -2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0);
const WEIGHTS: array<f32, 9> = array<f32, 9>(
    0.0162, 0.0540, 0.1216, 0.1945,
    0.2270,
    0.1945, 0.1216, 0.0540, 0.0162
);

@fragment
fn fs_main(input: VertexOutput) -> @location(0) vec4<f32> {
    var color = vec4<f32>(0.0);
    let step = uniforms.direction * uniforms.texel_size;

    for (var i = 0; i < KERNEL_SIZE; i++) {
        let offset = step * OFFSETS[i];
        color += textureSample(input_texture, input_sampler, input.uv + offset) * WEIGHTS[i];
    }

    return color;
}
```

### Task 5: Create bloom composite shader

**File:** `opta-native/opta-render/shaders/bloom_composite.wgsl`

```wgsl
// Bloom effect - composite pass
// Combines original image with blurred bloom

struct Uniforms {
    intensity: f32,
    _padding: vec3<f32>,
}

@group(0) @binding(0)
var<uniform> uniforms: Uniforms;

@group(0) @binding(1)
var original_texture: texture_2d<f32>;

@group(0) @binding(2)
var bloom_texture: texture_2d<f32>;

@group(0) @binding(3)
var tex_sampler: sampler;

struct VertexOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv: vec2<f32>,
}

@vertex
fn vs_main(@builtin(vertex_index) vertex_index: u32) -> VertexOutput {
    var positions = array<vec2<f32>, 3>(
        vec2<f32>(-1.0, -1.0),
        vec2<f32>(3.0, -1.0),
        vec2<f32>(-1.0, 3.0)
    );

    var output: VertexOutput;
    output.position = vec4<f32>(positions[vertex_index], 0.0, 1.0);
    output.uv = positions[vertex_index] * 0.5 + 0.5;
    output.uv.y = 1.0 - output.uv.y;
    return output;
}

@fragment
fn fs_main(input: VertexOutput) -> @location(0) vec4<f32> {
    let original = textureSample(original_texture, tex_sampler, input.uv);
    let bloom = textureSample(bloom_texture, tex_sampler, input.uv);

    // Additive blend
    let result = original.rgb + bloom.rgb * uniforms.intensity;

    return vec4<f32>(result, original.a);
}
```

### Task 6: Create effect shader Rust bindings

**File:** `opta-native/opta-render/src/effects/mod.rs`

```rust
//! GPU effect shaders for visual effects.

mod plasma;
mod bloom;

pub use plasma::{PlasmaEffect, PlasmaConfig};
pub use bloom::{BloomEffect, BloomConfig};
```

**File:** `opta-native/opta-render/src/effects/plasma.rs`

```rust
use wgpu::{Device, Queue, ShaderModule, RenderPipeline, Buffer, BindGroup};
use bytemuck::{Pod, Zeroable};

/// Plasma effect configuration.
#[derive(Debug, Clone, Copy)]
pub struct PlasmaConfig {
    pub speed: f32,
    pub scale: f32,
    pub color_shift: f32,
}

impl Default for PlasmaConfig {
    fn default() -> Self {
        Self {
            speed: 1.0,
            scale: 1.0,
            color_shift: 0.0,
        }
    }
}

#[repr(C)]
#[derive(Debug, Clone, Copy, Pod, Zeroable)]
struct PlasmaUniforms {
    resolution: [f32; 2],
    time: f32,
    speed: f32,
    scale: f32,
    color_shift: f32,
    _padding: [f32; 2],
}

/// Plasma effect renderer.
pub struct PlasmaEffect {
    pipeline: RenderPipeline,
    uniform_buffer: Buffer,
    bind_group: BindGroup,
    config: PlasmaConfig,
}

impl PlasmaEffect {
    /// Create a new plasma effect.
    pub fn new(device: &Device, format: wgpu::TextureFormat) -> Self {
        // Implementation would create shader module, pipeline, buffers
        todo!("Implement plasma effect creation")
    }

    /// Update configuration.
    pub fn set_config(&mut self, config: PlasmaConfig) {
        self.config = config;
    }

    /// Render the plasma effect.
    pub fn render(
        &self,
        encoder: &mut wgpu::CommandEncoder,
        target: &wgpu::TextureView,
        queue: &Queue,
        time: f32,
        width: u32,
        height: u32,
    ) {
        // Update uniforms
        let uniforms = PlasmaUniforms {
            resolution: [width as f32, height as f32],
            time,
            speed: self.config.speed,
            scale: self.config.scale,
            color_shift: self.config.color_shift,
            _padding: [0.0; 2],
        };
        queue.write_buffer(&self.uniform_buffer, 0, bytemuck::bytes_of(&uniforms));

        // Render pass
        let mut pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
            label: Some("Plasma Effect"),
            color_attachments: &[Some(wgpu::RenderPassColorAttachment {
                view: target,
                resolve_target: None,
                ops: wgpu::Operations {
                    load: wgpu::LoadOp::Clear(wgpu::Color::BLACK),
                    store: wgpu::StoreOp::Store,
                },
            })],
            depth_stencil_attachment: None,
            timestamp_writes: None,
            occlusion_query_set: None,
        });

        pass.set_pipeline(&self.pipeline);
        pass.set_bind_group(0, &self.bind_group, &[]);
        pass.draw(0..3, 0..1); // Fullscreen triangle
    }
}
```

**File:** `opta-native/opta-render/src/effects/bloom.rs`

```rust
use wgpu::{Device, Queue, TextureFormat};

/// Bloom effect configuration.
#[derive(Debug, Clone, Copy)]
pub struct BloomConfig {
    /// Brightness threshold for bloom extraction.
    pub threshold: f32,
    /// Soft threshold knee (smooths the cutoff).
    pub soft_threshold: f32,
    /// Bloom intensity in final composite.
    pub intensity: f32,
    /// Number of blur passes (more = wider bloom).
    pub blur_passes: u32,
}

impl Default for BloomConfig {
    fn default() -> Self {
        Self {
            threshold: 0.8,
            soft_threshold: 0.5,
            intensity: 1.0,
            blur_passes: 5,
        }
    }
}

/// Multi-pass bloom post-processing effect.
pub struct BloomEffect {
    threshold_pipeline: wgpu::RenderPipeline,
    blur_pipeline: wgpu::RenderPipeline,
    composite_pipeline: wgpu::RenderPipeline,
    // Intermediate textures for ping-pong blurring
    bloom_textures: [wgpu::Texture; 2],
    bloom_views: [wgpu::TextureView; 2],
    config: BloomConfig,
}

impl BloomEffect {
    /// Create a new bloom effect.
    pub fn new(device: &Device, format: TextureFormat, width: u32, height: u32) -> Self {
        // Implementation would create pipelines and textures
        todo!("Implement bloom effect creation")
    }

    /// Resize internal textures.
    pub fn resize(&mut self, device: &Device, width: u32, height: u32) {
        // Recreate bloom textures at new size
        todo!("Implement bloom resize")
    }

    /// Apply bloom to an input texture.
    pub fn apply(
        &self,
        encoder: &mut wgpu::CommandEncoder,
        input: &wgpu::TextureView,
        output: &wgpu::TextureView,
        queue: &Queue,
    ) {
        // 1. Threshold pass - extract bright areas
        // 2. Blur passes - ping-pong between bloom textures
        // 3. Composite pass - add bloom to original
        todo!("Implement bloom apply")
    }
}
```

### Task 7: Update lib.rs exports

**Update:** `opta-native/opta-render/src/lib.rs`

```rust
pub mod effects;

pub use effects::{PlasmaEffect, PlasmaConfig, BloomEffect, BloomConfig};
```

### Task 8: Add effect tests

**File:** `opta-native/opta-render/tests/effects_test.rs`

```rust
//! Tests for effect shaders.

use opta_render::effects::{PlasmaConfig, BloomConfig};

#[test]
fn test_plasma_config_default() {
    let config = PlasmaConfig::default();
    assert_eq!(config.speed, 1.0);
    assert_eq!(config.scale, 1.0);
    assert_eq!(config.color_shift, 0.0);
}

#[test]
fn test_bloom_config_default() {
    let config = BloomConfig::default();
    assert_eq!(config.threshold, 0.8);
    assert_eq!(config.soft_threshold, 0.5);
    assert_eq!(config.intensity, 1.0);
    assert_eq!(config.blur_passes, 5);
}

#[test]
fn test_noise_shader_compiles() {
    let mut preprocessor = opta_render::shader::ShaderPreprocessor::new();
    preprocessor.register_include("math.wgsl", include_str!("../shaders/includes/math.wgsl"));
    preprocessor.register_include("noise.wgsl", include_str!("../shaders/includes/noise.wgsl"));

    let source = r#"
#include "noise.wgsl"

fn main() {
    let n = fbm(vec2<f32>(0.0), 4);
}
"#;

    let result = preprocessor.process(source);
    assert!(result.is_ok());
}
```

## Verification

```bash
cd opta-native
cargo check -p opta-render
cargo clippy -p opta-render -- -D warnings
cargo test -p opta-render
```

## Success Criteria

- [ ] Noise shader include with value, perlin, simplex, worley noise
- [ ] Plasma effect shader with configurable parameters
- [ ] Bloom effect with threshold, blur, composite passes
- [ ] Rust bindings for plasma and bloom effects
- [ ] All tests pass

## Output

- Complete noise library for procedural generation
- Plasma effect for animated backgrounds
- Bloom post-processing for glow effects
