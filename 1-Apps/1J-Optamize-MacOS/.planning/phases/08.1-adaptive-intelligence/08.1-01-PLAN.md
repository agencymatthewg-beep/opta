---
phase: 08.1-adaptive-intelligence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/types/profile.ts, mcp-server/src/opta_mcp/profile.py, src-tauri/src/profile.rs, src-tauri/src/lib.rs, mcp-server/src/opta_mcp/server.py, src/hooks/useUserProfile.ts]
autonomous: true
---

<objective>
Create the foundational user profile storage system for Opta's adaptive intelligence.

Purpose: Establish persistent storage for user preferences (mode, depth, style), hardware signature, and learned patterns. This enables all subsequent personalization features.

Output: Complete profile CRUD system spanning TypeScript types, Python storage module, Tauri commands, and React hook.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/MUST_HAVE.md

# Existing patterns to follow:
@src/hooks/useOptimizer.ts
@src/types/optimizer.ts
@mcp-server/src/opta_mcp/optimizer.py
@src-tauri/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TypeScript profile types</name>
  <files>src/types/profile.ts</files>
  <action>
Create comprehensive TypeScript types for the user profile domain:

```typescript
// User preference enums matching MUST_HAVE.md
export type UserMode = 'simple' | 'standard' | 'power';
export type OptimizationDepth = 'efficient' | 'thorough' | 'optimised';
export type CommunicationStyle = 'informative' | 'concise';

// Hardware identification
export interface HardwareSignature {
  cpu: string;
  gpu: string | null;
  ramGb: number;
  platform: 'windows' | 'macos' | 'linux';
}

// Learned pattern from optimization history
export interface OptimizationPattern {
  patternType: 'preference' | 'aversion' | 'timing';
  settingCategory: 'graphics' | 'launch_options' | 'priority';
  settingKey: string;
  confidence: number;  // 0-1
  sampleCount: number;
  description: string;  // Human-readable, e.g., "You typically prefer higher FPS over visual quality"
  lastUpdated: number;
}

// Main user profile
export interface UserProfile {
  id: string;
  createdAt: number;
  updatedAt: number;

  // User preferences (from MUST_HAVE)
  userMode: UserMode;
  optimizationDepth: OptimizationDepth;
  communicationStyle: CommunicationStyle;

  // Hardware identification
  hardwareSignature: HardwareSignature;

  // Learned patterns (populated by pattern learning engine)
  patterns: OptimizationPattern[];

  // Statistics
  totalOptimizations: number;
  totalGamesOptimized: number;
  optimizationsAccepted: number;
  optimizationsReverted: number;
}

// Profile update payload (partial updates)
export interface ProfileUpdate {
  userMode?: UserMode;
  optimizationDepth?: OptimizationDepth;
  communicationStyle?: CommunicationStyle;
}

// Default profile for new users
export const DEFAULT_PROFILE: Omit<UserProfile, 'id' | 'createdAt' | 'updatedAt' | 'hardwareSignature'> = {
  userMode: 'standard',
  optimizationDepth: 'thorough',
  communicationStyle: 'informative',
  patterns: [],
  totalOptimizations: 0,
  totalGamesOptimized: 0,
  optimizationsAccepted: 0,
  optimizationsReverted: 0,
};
```

Include JSDoc comments for each type explaining its purpose.
  </action>
  <verify>npm run build passes with no TypeScript errors</verify>
  <done>All profile types defined and exported, DEFAULT_PROFILE constant available</done>
</task>

<task type="auto">
  <name>Task 2: Create Python profile module</name>
  <files>mcp-server/src/opta_mcp/profile.py</files>
  <action>
Create profile.py following the pattern from optimizer.py. Storage location: `~/.opta/profiles/main_profile.json`

Key functions:
1. `get_or_create_profile()` - Returns existing profile or creates default
2. `save_profile(profile: dict)` - Saves profile to disk
3. `update_profile(updates: dict)` - Partial updates, merges with existing
4. `delete_profile()` - Removes all profile data
5. `get_hardware_signature()` - Detects current hardware using psutil/GPUtil

Profile structure mirrors TypeScript types. Use `dataclasses` for internal representation, convert to dict for JSON storage.

Hardware detection:
- CPU: `platform.processor()` or `psutil.cpu_freq()`
- GPU: Use existing GPUtil pattern from telemetry
- RAM: `psutil.virtual_memory().total / (1024**3)`
- Platform: `sys.platform`

Create `.opta/profiles/` directory if it doesn't exist. Use atomic writes (write to temp file, then rename) to prevent corruption.

Add to server.py tool list:
- `get_user_profile` - Returns current profile
- `update_user_profile` - Updates preferences
- `delete_user_profile` - Deletes all data
  </action>
  <verify>Python imports work: `python -c "from opta_mcp.profile import get_or_create_profile; print(get_or_create_profile())"`</verify>
  <done>Profile CRUD operations work, hardware detection populates signature, JSON file persists correctly</done>
</task>

<task type="auto">
  <name>Task 3: Add Tauri commands and React hook</name>
  <files>src-tauri/src/profile.rs, src-tauri/src/lib.rs, src/hooks/useUserProfile.ts</files>
  <action>
1. Create `src-tauri/src/profile.rs`:
```rust
use serde::{Deserialize, Serialize};
use std::process::Command;

#[derive(Debug, Serialize, Deserialize)]
pub struct UserProfile {
    pub id: String,
    pub created_at: f64,
    pub updated_at: f64,
    pub user_mode: String,
    pub optimization_depth: String,
    pub communication_style: String,
    // ... other fields matching TypeScript types
}

#[tauri::command]
pub async fn load_user_profile() -> Result<UserProfile, String> {
    // Call Python via subprocess (following existing patterns in lib.rs)
}

#[tauri::command]
pub async fn update_user_profile(updates: serde_json::Value) -> Result<UserProfile, String> {
    // Call Python via subprocess
}

#[tauri::command]
pub async fn delete_user_profile() -> Result<bool, String> {
    // Call Python via subprocess
}
```

2. In `lib.rs`:
- Add `mod profile;`
- Register commands: `load_user_profile`, `update_user_profile`, `delete_user_profile`

3. Create `src/hooks/useUserProfile.ts` following useOptimizer.ts pattern:
- State: `profile`, `loading`, `error`
- Methods: `loadProfile()`, `updateProfile(updates)`, `deleteProfile()`
- Auto-load on mount with useEffect
- Return type: `UseUserProfileResult`
  </action>
  <verify>cargo build passes, npm run build passes</verify>
  <done>Tauri commands registered and callable from React, hook follows established patterns</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `cargo build` succeeds without errors
- [ ] Profile types are importable: `import { UserProfile } from '@/types/profile'`
- [ ] Profile persists to `~/.opta/profiles/main_profile.json`
- [ ] Hook can load/update/delete profile
</verification>

<success_criteria>
- All tasks completed
- TypeScript types match Python dataclass structure
- Profile persists across app restarts
- Hardware signature auto-detected on first run
- Default values set for new users (standard mode, thorough depth, informative style)
</success_criteria>

<output>
After completion, create `.planning/phases/08.1-adaptive-intelligence/08.1-01-SUMMARY.md`
</output>
