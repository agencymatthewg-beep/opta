# Plan 60-03: Frame Timing and Quality

## Wave: 2 (Depends on 60-01 and 60-02)

## Objective

Implement frame timing infrastructure with CADisplayLink support, 120Hz ProMotion, and GPU capability detection.

## Execution Context

**Reference Documents:**
- `Gemini Deep Research/Hardware & Platform Knowledge/wgpu-SwiftUI-iOS-macOS-Integration.md`
- Apple Developer: CADisplayLink, CVDisplayLink

**Key Insights from Research:**
- iOS: CADisplayLink with RunLoop.Mode.common (not default!)
- macOS: CVDisplayLink runs on background thread (thread safety critical)
- 120Hz: Use preferredFrameRateRange (iOS 15+)
- PresentMode::Fifo for VSync, avoid Mailbox on mobile

## Context

**Depends on:**
- Plan 60-01 (GpuContext, RenderSurface)
- Plan 60-02 (RenderPipeline2D, FrameEncoder)

**Threading Model:**
- macOS: CVDisplayLink callback on render thread
- iOS: CADisplayLink callback on main thread

## Tasks

### Task 1: Create frame timing abstraction

**File:** `opta-native/opta-render/src/timing.rs`

```rust
pub struct FrameTiming {
    last_frame_time: std::time::Instant,
    frame_count: u64,
    fps_samples: Vec<f64>,
    target_fps: u32,
}

impl FrameTiming {
    pub fn new(target_fps: u32) -> Self;

    /// Call at start of each frame
    pub fn begin_frame(&mut self) -> FrameInfo;

    /// Get rolling average FPS
    pub fn average_fps(&self) -> f64;

    /// Check if we should skip frame (frame limiting)
    pub fn should_render(&self) -> bool;
}

pub struct FrameInfo {
    pub delta_time: f64,
    pub frame_number: u64,
    pub target_fps: u32,
    pub estimated_fps: f64,
}
```

### Task 2: Create quality settings

**File:** `opta-native/opta-render/src/quality.rs`

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum QualityLevel {
    Low,
    Medium,
    High,
    Ultra,
}

pub struct QualitySettings {
    pub level: QualityLevel,
    pub target_fps: u32,
    pub msaa_samples: u32,
    pub texture_quality: f32,
    pub particle_count_multiplier: f32,
    pub shadow_quality: ShadowQuality,
}

impl QualitySettings {
    pub fn auto_detect(capabilities: &GpuCapabilities) -> Self;

    pub fn for_level(level: QualityLevel) -> Self;
}

#[derive(Debug, Clone, Copy)]
pub enum ShadowQuality {
    Off,
    Low,    // 512x512
    Medium, // 1024x1024
    High,   // 2048x2048
}
```

### Task 3: Create render state manager

**File:** `opta-native/opta-render/src/state.rs`

```rust
use std::sync::{Arc, RwLock};

/// Thread-safe render state for CVDisplayLink callback
pub struct RenderState {
    inner: Arc<RwLock<RenderStateInner>>,
}

struct RenderStateInner {
    gpu: GpuContext,
    surface: RenderSurface,
    pipeline: RenderPipeline2D,
    timing: FrameTiming,
    quality: QualitySettings,
    pending_resize: Option<(u32, u32)>,
    is_paused: bool,
}

impl RenderState {
    pub fn new(
        gpu: GpuContext,
        surface: RenderSurface,
        quality: QualitySettings,
    ) -> Self;

    /// Called from main thread to request resize
    pub fn request_resize(&self, width: u32, height: u32);

    /// Called from render thread to perform frame
    pub fn render_frame(&self) -> Result<(), RenderError>;

    /// Pause/resume rendering
    pub fn set_paused(&self, paused: bool);
}
```

### Task 4: Implement autorelease pool wrapper

**File:** `opta-native/opta-render/src/autorelease.rs`

Critical for preventing Metal memory leaks:

```rust
#[cfg(target_os = "macos")]
pub fn with_autorelease_pool<F, R>(f: F) -> R
where
    F: FnOnce() -> R,
{
    use objc2::rc::AutoreleasePool;
    let pool = AutoreleasePool::new();
    let result = f();
    drop(pool);
    result
}

#[cfg(not(target_os = "macos"))]
pub fn with_autorelease_pool<F, R>(f: F) -> R
where
    F: FnOnce() -> R,
{
    f()
}
```

### Task 5: Create SwiftUI bridge types

**File:** `opta-native/opta-render/src/bridge.rs`

Types for Swift integration:

```rust
/// Configuration passed from Swift to Rust
#[repr(C)]
pub struct RenderConfig {
    pub physical_width: u32,
    pub physical_height: u32,
    pub scale_factor: f64,
    pub target_fps: u32,
    pub quality_level: u32, // 0=Low, 1=Medium, 2=High, 3=Ultra
}

/// Status returned from Rust to Swift
#[repr(C)]
pub struct RenderStatus {
    pub is_ready: bool,
    pub current_fps: f32,
    pub gpu_memory_used: u64,
    pub frame_time_ms: f32,
}
```

### Task 6: Implement FFI for frame loop

**File:** `opta-native/opta-render/src/ffi.rs` (extend)

```rust
#[no_mangle]
pub extern "C" fn opta_render_frame(state: *mut RenderState) -> RenderStatus;

#[no_mangle]
pub extern "C" fn opta_render_set_quality(
    state: *mut RenderState,
    level: u32,
);

#[no_mangle]
pub extern "C" fn opta_render_set_paused(
    state: *mut RenderState,
    paused: bool,
);

#[no_mangle]
pub extern "C" fn opta_render_get_capabilities(
    state: *const RenderState,
) -> *const GpuCapabilities;
```

### Task 7: Create integration test

**File:** `opta-native/opta-render/tests/render_test.rs`

```rust
#[test]
fn test_quality_auto_detect() {
    // Test quality level detection based on GPU capabilities
}

#[test]
fn test_frame_timing() {
    let mut timing = FrameTiming::new(60);
    let info = timing.begin_frame();
    assert_eq!(info.target_fps, 60);
}

#[test]
fn test_render_state_thread_safety() {
    // Verify RenderState is Send + Sync
    fn assert_send_sync<T: Send + Sync>() {}
    assert_send_sync::<RenderState>();
}
```

## Verification

```bash
cd opta-native
cargo check -p opta-render
cargo clippy -p opta-render -- -D warnings
cargo test -p opta-render

# Verify thread safety
cargo test -p opta-render -- --test-threads=4
```

## Success Criteria

- [ ] FrameTiming correctly tracks frame deltas and FPS
- [ ] QualitySettings auto-detects appropriate level for hardware
- [ ] RenderState is thread-safe (Send + Sync)
- [ ] Autorelease pool prevents Metal memory leaks
- [ ] FFI exports complete for Swift integration
- [ ] All tests pass

## Output

- Complete frame timing infrastructure
- Quality settings with auto-detection
- Thread-safe render state for CVDisplayLink
- Ready for SwiftUI shell integration (Phase 62)
