---
phase: 08.1-adaptive-intelligence
plan: 03
type: execute
wave: 3
depends_on: ["08.1-02"]
files_modified: [mcp-server/src/opta_mcp/patterns.py, mcp-server/src/opta_mcp/server.py, src/components/PersonalizedRecommendations.tsx, src/pages/Games.tsx, src/hooks/useUserProfile.ts, src/types/profile.ts]
autonomous: true
---

<objective>
Implement personalized recommendation engine that suggests optimizations based on learned patterns.

Purpose: Use detected patterns to generate contextual recommendations like "Based on your preference for FPS, I recommend these settings for Valorant." Show recommendations in the Games page to guide users toward optimizations they're likely to accept.

Output: Recommendation generation logic, PersonalizedRecommendations component, and Games page integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/MUST_HAVE.md
@.planning/phases/08.1-adaptive-intelligence/08.1-01-SUMMARY.md
@.planning/phases/08.1-adaptive-intelligence/08.1-02-SUMMARY.md

# UI patterns to follow:
@src/pages/Games.tsx
@src/components/GameCard.tsx
@src/components/GameOptimizationPreview.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add recommendation types and generation logic</name>
  <files>src/types/profile.ts, mcp-server/src/opta_mcp/patterns.py, mcp-server/src/opta_mcp/server.py</files>
  <action>
1. Add recommendation types to src/types/profile.ts:
```typescript
export interface Recommendation {
  id: string;
  gameId: string;
  gameName: string;
  settingCategory: 'graphics' | 'launch_options' | 'priority';
  settingKey: string;
  suggestedValue: unknown;
  reason: string;  // "Based on your FPS preference..."
  expectedImpact: string;  // "+15 FPS estimated"
  confidence: 'high' | 'medium' | 'low';
  basedOnPattern: string;  // Pattern ID that triggered this
}

export interface RecommendationResponse {
  recommendations: Recommendation[];
  generatedAt: number;
  patternCount: number;  // How many patterns were used
}
```

2. Add recommendation generation to patterns.py:
```python
def generate_recommendations(
    game_id: str,
    game_name: str,
    available_settings: dict,  # From game_settings database
    patterns: List[DetectedPattern]
) -> List[dict]:
    """Generate personalized recommendations for a game based on patterns."""
    recommendations = []

    for pattern in patterns:
        if pattern.pattern_type == 'preference':
            # Find settings in available_settings that match this preference
            # e.g., if pattern shows FPS preference, recommend FPS-boosting settings
            # Generate recommendation with reason based on pattern.description
            pass
        elif pattern.pattern_type == 'aversion':
            # Exclude or deprioritize settings user typically reverts
            pass

    # Score and sort recommendations by confidence
    # Limit to top 5 recommendations per game
    return recommendations

def get_recommendations_for_game(game_id: str, game_name: str) -> dict:
    """Get personalized recommendations for a specific game."""
    # Load user patterns
    # Load available settings for game from game_settings database
    # Generate and return recommendations
```

3. Add MCP tool in server.py:
```python
Tool(
    name="get_recommendations",
    description="Get personalized optimization recommendations for a game",
    inputSchema={
        "type": "object",
        "properties": {
            "game_id": {"type": "string"},
            "game_name": {"type": "string"}
        },
        "required": ["game_id", "game_name"]
    }
)
```

Recommendation reasons should be user-friendly based on MUST_HAVE.md:
- "Based on your history, I'm prioritizing FPS over quality. Change this?"
- "You typically accept these settings - high confidence they'll work for you"
  </action>
  <verify>Python: `python -c "from opta_mcp.patterns import get_recommendations_for_game"`</verify>
  <done>Recommendation types defined, generation logic implemented, MCP tool available</done>
</task>

<task type="auto">
  <name>Task 2: Create PersonalizedRecommendations component</name>
  <files>src/components/PersonalizedRecommendations.tsx</files>
  <action>
Create a component that displays personalized recommendations following the glass design system:

```typescript
import { motion } from 'framer-motion';
import { Sparkles, TrendingUp, Info } from 'lucide-react';
import { cn } from '@/lib/utils';
import { Recommendation } from '@/types/profile';

interface PersonalizedRecommendationsProps {
  recommendations: Recommendation[];
  onApply: (recommendation: Recommendation) => void;
  onDismiss: (recommendationId: string) => void;
  loading?: boolean;
}

export function PersonalizedRecommendations({
  recommendations,
  onApply,
  onDismiss,
  loading
}: PersonalizedRecommendationsProps) {
  if (loading) {
    return <LoadingSkeleton />;
  }

  if (recommendations.length === 0) {
    return null;  // Don't show section if no recommendations
  }

  return (
    <motion.div
      initial={{ opacity: 0, y: 12 }}
      animate={{ opacity: 1, y: 0 }}
      className="glass rounded-xl p-4 border border-border/30"
    >
      <div className="flex items-center gap-2 mb-3">
        <Sparkles className="w-5 h-5 text-primary" />
        <h3 className="text-sm font-medium">Recommended for You</h3>
      </div>

      <div className="space-y-2">
        {recommendations.map((rec) => (
          <RecommendationCard
            key={rec.id}
            recommendation={rec}
            onApply={() => onApply(rec)}
            onDismiss={() => onDismiss(rec.id)}
          />
        ))}
      </div>
    </motion.div>
  );
}

function RecommendationCard({ recommendation, onApply, onDismiss }) {
  // Show: reason, expected impact, confidence indicator
  // Buttons: Apply, Dismiss
  // Use Badge for confidence level
}
```

Follow DESIGN_SYSTEM.md:
- Glass effect for container
- Framer Motion animations
- Lucide icons only
- Color-coded confidence (high=green, medium=yellow, low=gray)
  </action>
  <verify>npm run build passes, component renders without errors</verify>
  <done>PersonalizedRecommendations component created with proper styling and interactions</done>
</task>

<task type="auto">
  <name>Task 3: Integrate recommendations into Games page and hook</name>
  <files>src/pages/Games.tsx, src/hooks/useUserProfile.ts</files>
  <action>
1. Add getRecommendations to useUserProfile hook:
```typescript
const getRecommendations = useCallback(async (gameId: string, gameName: string) => {
  try {
    const result = await invoke<RecommendationResponse>('get_recommendations', {
      gameId,
      gameName
    });
    return result;
  } catch (e) {
    console.error('Failed to get recommendations:', e);
    return { recommendations: [], generatedAt: Date.now(), patternCount: 0 };
  }
}, []);
```

2. Integrate into Games.tsx:
- When a game is selected, fetch recommendations for that game
- Show PersonalizedRecommendations component above GameOptimizationPreview
- Only show if user has patterns (patternCount > 0)
- Handle apply: pre-fill optimization settings with recommendation
- Handle dismiss: hide that recommendation for this session

3. Add Tauri command for get_recommendations in lib.rs/profile.rs

Layout in Games page when game selected:
```
[Game Card - Selected]
[PersonalizedRecommendations - if any]
[GameOptimizationPreview]
```

Recommendations should feel like helpful suggestions, not pushy upsells. Match the "understated confidence" personality from MUST_HAVE.md.
  </action>
  <verify>npm run build passes, recommendations appear when viewing a game (after sufficient pattern data exists)</verify>
  <done>Recommendations integrated into Games page, shown contextually when patterns exist</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `cargo build` succeeds without errors
- [ ] Recommendation types properly defined
- [ ] PersonalizedRecommendations component follows design system
- [ ] Recommendations appear in Games page when viewing a game
- [ ] Recommendations show user-friendly reasons
- [ ] Apply/dismiss actions work correctly
</verification>

<success_criteria>
- All tasks completed
- Recommendations generated based on detected patterns
- UI shows recommendations with confidence indicators
- Reasons are human-readable ("Based on your FPS preference...")
- Graceful handling when no patterns exist (hide section)
- Non-intrusive: recommendations feel helpful, not pushy
</success_criteria>

<output>
After completion, create `.planning/phases/08.1-adaptive-intelligence/08.1-03-SUMMARY.md`
</output>
