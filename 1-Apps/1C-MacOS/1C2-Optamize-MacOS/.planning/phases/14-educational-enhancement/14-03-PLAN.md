# Plan 14-03: Smart Error Recovery (Rollback)

wave: 2
autonomous: true

## Overview

Implement rollback system with one-click undo, auto-detection of performance drops, and learning feedback.

## Tasks

### 1. Create Rollback Manager
**File**: `src/components/RollbackManager.tsx` (new)

```tsx
interface RollbackState {
  id: string;
  timestamp: number;
  optimizations: AppliedOptimization[];
  previousSettings: Record<string, any>;
  game?: Game;
}

export function useRollback() {
  const [rollbackStates, setRollbackStates] = useState<RollbackState[]>(() => {
    const saved = localStorage.getItem('opta-rollback-states');
    return saved ? JSON.parse(saved) : [];
  });

  const createRollbackPoint = (optimizations: AppliedOptimization[], game?: Game) => {
    const state: RollbackState = {
      id: `rb-${Date.now()}`,
      timestamp: Date.now(),
      optimizations,
      previousSettings: captureCurrentSettings(optimizations),
      game,
    };

    const updated = [state, ...rollbackStates].slice(0, 10);  // Keep last 10
    setRollbackStates(updated);
    localStorage.setItem('opta-rollback-states', JSON.stringify(updated));

    return state.id;
  };

  const rollback = async (stateId: string) => {
    const state = rollbackStates.find(s => s.id === stateId);
    if (!state) throw new Error('Rollback state not found');

    // Restore previous settings
    await restoreSettings(state.previousSettings);

    // Remove this and newer states
    const index = rollbackStates.findIndex(s => s.id === stateId);
    const updated = rollbackStates.slice(index + 1);
    setRollbackStates(updated);
    localStorage.setItem('opta-rollback-states', JSON.stringify(updated));
  };

  return { rollbackStates, createRollbackPoint, rollback };
}
```

### 2. Create One-Click Rollback UI
**File**: `src/components/RollbackBanner.tsx` (new)

Show banner after optimization with quick rollback option:

```tsx
export function RollbackBanner({ rollbackId, optimizations, onRollback }) {
  const [timeLeft, setTimeLeft] = useState(60);

  useEffect(() => {
    const timer = setInterval(() => {
      setTimeLeft(t => {
        if (t <= 1) {
          clearInterval(timer);
          return 0;
        }
        return t - 1;
      });
    }, 1000);
    return () => clearInterval(timer);
  }, []);

  if (timeLeft === 0) return null;

  return (
    <motion.div
      initial={{ opacity: 0, y: -20 }}
      animate={{ opacity: 1, y: 0 }}
      exit={{ opacity: 0, y: -20 }}
      className="fixed top-4 right-4 glass rounded-lg p-4 max-w-sm shadow-lg"
    >
      <div className="flex items-start gap-3">
        <Undo2 className="w-5 h-5 text-primary" />
        <div className="flex-1">
          <p className="font-medium">Optimizations Applied</p>
          <p className="text-sm text-muted-foreground">
            {optimizations.length} changes made. Not working as expected?
          </p>
          <div className="flex items-center gap-3 mt-2">
            <Button
              size="sm"
              variant="outline"
              onClick={onRollback}
            >
              Undo All ({timeLeft}s)
            </Button>
            <button className="text-xs text-muted-foreground hover:underline">
              Dismiss
            </button>
          </div>
        </div>
      </div>
    </motion.div>
  );
}
```

### 3. Auto-Detect Performance Drops
**File**: `src/hooks/usePerformanceMonitor.ts` (new)

```tsx
export function usePerformanceMonitor() {
  const [baseline, setBaseline] = useState<PerformanceMetrics | null>(null);
  const [current, setCurrent] = useState<PerformanceMetrics | null>(null);
  const [degradationDetected, setDegradationDetected] = useState(false);

  const startMonitoring = (baselineMetrics: PerformanceMetrics) => {
    setBaseline(baselineMetrics);
    setDegradationDetected(false);
  };

  // Poll current performance every 5 seconds
  useEffect(() => {
    if (!baseline) return;

    const interval = setInterval(async () => {
      const currentMetrics = await getCurrentPerformance();
      setCurrent(currentMetrics);

      // Detect significant degradation (>20% worse)
      if (currentMetrics.fps < baseline.fps * 0.8) {
        setDegradationDetected(true);
      }
    }, 5000);

    return () => clearInterval(interval);
  }, [baseline]);

  return { baseline, current, degradationDetected, startMonitoring };
}
```

### 4. Create Performance Drop Alert
**File**: `src/components/PerformanceDropAlert.tsx` (new)

```tsx
export function PerformanceDropAlert({ baseline, current, onRollback, onDismiss }) {
  const dropPercent = Math.round((1 - current.fps / baseline.fps) * 100);

  return (
    <motion.div
      initial={{ opacity: 0, scale: 0.95 }}
      animate={{ opacity: 1, scale: 1 }}
      className="fixed inset-0 bg-black/50 flex items-center justify-center z-50"
    >
      <div className="glass rounded-xl p-6 max-w-md mx-4">
        <div className="flex items-center gap-3 mb-4">
          <AlertTriangle className="w-8 h-8 text-warning" />
          <div>
            <h3 className="font-semibold text-lg">Performance Drop Detected</h3>
            <p className="text-sm text-muted-foreground">
              FPS decreased by {dropPercent}% after optimization
            </p>
          </div>
        </div>

        <div className="grid grid-cols-2 gap-4 mb-6">
          <div className="glass-subtle rounded p-3 text-center">
            <p className="text-xs text-muted-foreground">Before</p>
            <p className="text-2xl font-bold text-success">{baseline.fps} FPS</p>
          </div>
          <div className="glass-subtle rounded p-3 text-center">
            <p className="text-xs text-muted-foreground">After</p>
            <p className="text-2xl font-bold text-danger">{current.fps} FPS</p>
          </div>
        </div>

        <div className="flex gap-3">
          <Button variant="outline" className="flex-1" onClick={onDismiss}>
            Keep Changes
          </Button>
          <Button className="flex-1" onClick={onRollback}>
            <Undo2 className="w-4 h-4 mr-2" />
            Undo Changes
          </Button>
        </div>
      </div>
    </motion.div>
  );
}
```

### 5. Add "This Didn't Work" Feedback Button
**File**: `src/components/OptimizationFeedback.tsx` (new)

```tsx
export function OptimizationFeedback({ optimization, onFeedback }) {
  const [submitted, setSubmitted] = useState(false);

  const handleNegativeFeedback = async () => {
    await recordFeedback({
      optimizationId: optimization.id,
      type: 'negative',
      context: {
        game: optimization.game,
        hardware: await getHardwareInfo(),
      },
    });
    setSubmitted(true);
    onFeedback?.('negative');
  };

  if (submitted) {
    return (
      <p className="text-xs text-muted-foreground">
        Thanks! Opta will learn from this.
      </p>
    );
  }

  return (
    <button
      onClick={handleNegativeFeedback}
      className="text-xs text-muted-foreground hover:text-foreground flex items-center gap-1"
    >
      <ThumbsDown className="w-3 h-3" />
      This didn't work for me
    </button>
  );
}
```

## Verification

1. Apply optimizations → See rollback banner with countdown
2. Click "Undo All" → Settings restored to previous state
3. Play game after optimization → If FPS drops >20%, see alert
4. Click "This didn't work" → Feedback recorded, learning updated
5. View rollback history → See last 10 rollback points

## Files Modified

- `src/components/RollbackManager.tsx` (new)
- `src/components/RollbackBanner.tsx` (new)
- `src/hooks/usePerformanceMonitor.ts` (new)
- `src/components/PerformanceDropAlert.tsx` (new)
- `src/components/OptimizationFeedback.tsx` (new)
- `src/pages/Games.tsx` (integrate rollback)
- `src/components/OptimizationResultModal.tsx` (add feedback)

## Estimated Duration

30-35 minutes
