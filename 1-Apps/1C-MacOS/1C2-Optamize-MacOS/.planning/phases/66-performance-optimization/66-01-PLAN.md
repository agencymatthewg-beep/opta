# Plan 66-01: Binary Size & LTO Optimization

## Wave: 1 (Independent)

## Objective

Optimize Rust binary size through LTO, dead code elimination, and compile-time configuration for a minimal deployment size.

## Execution Context

**Reference Documents:**
- Rust min-sized-rust guide
- wgpu binary optimization docs

**Key Insights:**
- LTO (Link-Time Optimization) significantly reduces binary size
- panic=abort saves ~10% on embedded
- strip symbols in release builds
- Target binary size < 15MB

## Context

**Depends on:**
- All previous phases (optimization applied last)

**Builds foundation for:**
- App Store submission
- Fast downloads and updates

## Tasks

### Task 1: Configure Cargo profile for release

**Update:** `opta-native/Cargo.toml`

```toml
[profile.release]
# Enable LTO for maximum optimization
lto = "fat"
# Single codegen unit for better optimization
codegen-units = 1
# Optimize for size with loop unrolling
opt-level = "z"
# Strip debug symbols
strip = true
# Use abort on panic (smaller binaries)
panic = "abort"

[profile.release-with-debug]
inherits = "release"
debug = true
strip = false

[profile.bench]
inherits = "release"
debug = true
strip = false
```

### Task 2: Create feature flags for optional components

**Update:** `opta-native/opta-render/Cargo.toml`

```toml
[features]
default = ["metal"]
metal = ["wgpu/metal"]
vulkan = ["wgpu/vulkan"]
dx12 = ["wgpu/dx12"]

# Development features
shader-hot-reload = ["notify"]

# Optional components (exclude to reduce size)
particles = []
bloom = []
full-effects = ["particles", "bloom"]
```

### Task 3: Create build script for size analysis

**File:** `opta-native/scripts/analyze-size.sh`

```bash
#!/bin/bash
# Analyze binary size and component breakdown

set -e

cd "$(dirname "$0")/.."

echo "Building release binary..."
cargo build --release --package opta-macos

BINARY="target/release/opta-macos"

echo ""
echo "=== Binary Size Analysis ==="
echo ""

# Total size
SIZE=$(ls -la "$BINARY" | awk '{print $5}')
SIZE_MB=$(echo "scale=2; $SIZE / 1048576" | bc)
echo "Total binary size: ${SIZE_MB} MB ($SIZE bytes)"

# Size with different strip levels
echo ""
echo "Strip analysis:"
cp "$BINARY" /tmp/opta-stripped
strip /tmp/opta-stripped
STRIPPED_SIZE=$(ls -la /tmp/opta-stripped | awk '{print $5}')
STRIPPED_MB=$(echo "scale=2; $STRIPPED_SIZE / 1048576" | bc)
echo "  After strip: ${STRIPPED_MB} MB"

# Object file analysis if bloat is installed
if command -v cargo-bloat &> /dev/null; then
    echo ""
    echo "=== Largest Functions ==="
    cargo bloat --release --package opta-macos -n 20

    echo ""
    echo "=== Largest Crates ==="
    cargo bloat --release --package opta-macos --crates
fi

# Check against target
TARGET_MB=15
if (( $(echo "$SIZE_MB > $TARGET_MB" | bc -l) )); then
    echo ""
    echo "⚠️  WARNING: Binary size exceeds target of ${TARGET_MB} MB"
    exit 1
else
    echo ""
    echo "✅ Binary size within target (< ${TARGET_MB} MB)"
fi
```

### Task 4: Configure wgpu for minimal features

**Update:** `opta-native/opta-render/Cargo.toml`

```toml
[dependencies]
# Use wgpu with only needed backends
wgpu = { version = "24.0", default-features = false, features = [
    "wgsl",
    # Platform-specific backends enabled via features
] }

[target.'cfg(target_os = "macos")'.dependencies]
wgpu = { version = "24.0", default-features = false, features = [
    "wgsl",
    "metal",
] }

[target.'cfg(target_os = "windows")'.dependencies]
wgpu = { version = "24.0", default-features = false, features = [
    "wgsl",
    "dx12",
] }

[target.'cfg(target_os = "linux")'.dependencies]
wgpu = { version = "24.0", default-features = false, features = [
    "wgsl",
    "vulkan",
] }
```

### Task 5: Create conditional compilation for debug features

**File:** `opta-native/opta-render/src/debug.rs`

```rust
//! Debug utilities (compiled out in release).

/// Debug overlay showing FPS, memory, etc.
#[cfg(debug_assertions)]
pub struct DebugOverlay {
    fps_history: Vec<f32>,
    frame_times: Vec<f32>,
}

#[cfg(debug_assertions)]
impl DebugOverlay {
    pub fn new() -> Self {
        Self {
            fps_history: Vec::with_capacity(120),
            frame_times: Vec::with_capacity(120),
        }
    }

    pub fn record_frame(&mut self, delta: f32) {
        let fps = 1.0 / delta;
        self.fps_history.push(fps);
        self.frame_times.push(delta * 1000.0);

        if self.fps_history.len() > 120 {
            self.fps_history.remove(0);
            self.frame_times.remove(0);
        }
    }

    pub fn average_fps(&self) -> f32 {
        if self.fps_history.is_empty() {
            return 0.0;
        }
        self.fps_history.iter().sum::<f32>() / self.fps_history.len() as f32
    }
}

/// No-op in release builds.
#[cfg(not(debug_assertions))]
pub struct DebugOverlay;

#[cfg(not(debug_assertions))]
impl DebugOverlay {
    pub fn new() -> Self { Self }
    pub fn record_frame(&mut self, _delta: f32) {}
    pub fn average_fps(&self) -> f32 { 0.0 }
}

/// Debug print macro (no-op in release).
#[cfg(debug_assertions)]
macro_rules! debug_log {
    ($($arg:tt)*) => {
        eprintln!("[DEBUG] {}", format!($($arg)*));
    };
}

#[cfg(not(debug_assertions))]
macro_rules! debug_log {
    ($($arg:tt)*) => {};
}

pub(crate) use debug_log;
```

## Verification

```bash
cd opta-native
./scripts/analyze-size.sh

# Check specific optimizations
cargo build --release -p opta-render
ls -la target/release/libopta_render.a
```

## Success Criteria

- [ ] Release binary < 15MB
- [ ] LTO enabled and working
- [ ] Debug symbols stripped in release
- [ ] Feature flags reduce size when disabled
- [ ] Size analysis script works

## Output

- Optimized Cargo profiles
- Binary size analysis tooling
- Feature flags for optional components
- Conditional compilation patterns
