---
phase: 03-process-management
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified: [mcp-server/src/opta_mcp/processes.py, mcp-server/src/opta_mcp/server.py, src-tauri/src/processes.rs, src/components/StealthMode.tsx, src/components/StealthMode.css, src/pages/Dashboard.tsx, src/pages/Dashboard.css]
autonomous: true
---

<objective>
Implement Stealth Mode - one-click termination of safe-to-kill background processes.

Purpose: Allow users to free up system resources before gaming by killing unnecessary background processes with a single click.
Output: Stealth Mode button with confirmation dialog, batch process termination, and results feedback.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Prior plan context (depends on process listing):
@.planning/phases/03-process-management/03-01-PLAN.md

Source files to extend:
@mcp-server/src/opta_mcp/processes.py
@src-tauri/src/processes.rs
@src/components/ProcessList.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add process termination functions to Python MCP server</name>
  <files>mcp-server/src/opta_mcp/processes.py, mcp-server/src/opta_mcp/server.py</files>
  <action>
Add to `processes.py`:

1. `terminate_process(pid: int) -> dict`:
   - Use `psutil.Process(pid).terminate()` with graceful fallback to `.kill()`
   - Return {"success": True, "pid": pid, "name": name} on success
   - Return {"success": False, "pid": pid, "error": str} on failure
   - Never raise exceptions - always return result dict

2. `stealth_mode() -> dict`:
   - Get all processes with `get_process_list()`
   - Filter to only "safe-to-kill" category
   - Terminate each, collecting results
   - Return {"terminated": [...], "failed": [...], "freed_memory_mb": estimated}
   - Estimate freed memory from memory_percent * total_memory before killing

3. Register tools in server.py:
   - `terminate_process` tool with pid input parameter
   - `stealth_mode` tool with no parameters

SAFETY:
- Never terminate processes with category != "safe-to-kill" in stealth_mode
- Add 0.5s timeout to terminate operations
- Log all terminations for debugging
  </action>
  <verify>
cd mcp-server && uv run python -c "from opta_mcp.processes import get_process_list; safe = [p for p in get_process_list() if p['category'] == 'safe-to-kill']; print(f'{len(safe)} safe-to-kill processes found')"
  </verify>
  <done>terminate_process and stealth_mode functions work correctly, only targeting safe-to-kill processes</done>
</task>

<task type="auto">
  <name>Task 2: Add Rust commands for process termination</name>
  <files>src-tauri/src/processes.rs</files>
  <action>
Add to `processes.rs`:

1. `TerminateResult` struct:
   - success: bool
   - pid: u32
   - name: Option<String>
   - error: Option<String>

2. `StealthModeResult` struct:
   - terminated: Vec<TerminateResult>
   - failed: Vec<TerminateResult>
   - freed_memory_mb: f32

3. `#[tauri::command] async fn terminate_process(pid: u32) -> Result<TerminateResult, String>`:
   - Invoke Python MCP terminate_process tool
   - Parse and return result

4. `#[tauri::command] async fn stealth_mode() -> Result<StealthModeResult, String>`:
   - Invoke Python MCP stealth_mode tool
   - Parse and return result

5. Register both commands in lib.rs invoke_handler

Follow subprocess pattern from existing commands.
  </action>
  <verify>
cd src-tauri && cargo check
  </verify>
  <done>Rust commands compile and are registered in invoke_handler</done>
</task>

<task type="auto">
  <name>Task 3: Create StealthMode component with confirmation and results</name>
  <files>src/components/StealthMode.tsx, src/components/StealthMode.css, src/pages/Dashboard.tsx, src/pages/Dashboard.css</files>
  <action>
1. Create `StealthMode.tsx` component:
   - Large "STEALTH MODE" button with power/stealth icon
   - On click: show confirmation modal listing safe-to-kill processes
   - Modal shows: "X processes will be terminated. Estimated memory freed: Y MB"
   - "Cancel" and "Activate" buttons in modal
   - On confirm: invoke stealth_mode command, show loading spinner
   - On complete: show results (X terminated, Y failed, Z MB freed)
   - Results dismiss after 5 seconds or on click

2. Create `StealthMode.css`:
   - Gaming aesthetic - prominent button with glow effect
   - Pulsing animation when active
   - Neon green (#00ff88) accent on hover/active
   - Modal with dark overlay
   - Results panel with success/error counts

3. Add StealthMode to Dashboard.tsx:
   - Place prominently above ProcessList
   - Button should be visually distinct - this is a key feature

4. Add TypeScript types to processes.ts:
   - TerminateResult interface
   - StealthModeResult interface

UI inspiration: Think gaming "boost" button - prominent, satisfying to click, clear feedback.
  </action>
  <verify>
npm run build && npm run dev
  </verify>
  <done>StealthMode button visible on Dashboard, confirmation modal works, results display after execution</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd src-tauri && cargo check` passes
- [ ] `npm run build` succeeds
- [ ] StealthMode button visible on Dashboard
- [ ] Clicking button shows confirmation with process list
- [ ] Canceling closes modal without action
- [ ] Confirming terminates safe-to-kill processes and shows results
- [ ] Results show terminated count, failed count, and freed memory
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Stealth Mode only terminates "safe-to-kill" processes (NEVER system processes)
- Clear feedback on what was terminated
- Human-in-the-loop: always shows confirmation before action
</success_criteria>

<output>
After completion, create `.planning/phases/03-process-management/03-02-SUMMARY.md`
</output>
