# Plan 65-01: Crux State Management

## Wave: 1 (Independent)

## Objective

Migrate application state to Crux framework for unified state management across all platforms.

## Execution Context

**Reference Documents:**
- Crux framework documentation
- Phase 59 Crux core setup

**Key Insights:**
- Crux uses Model-View-Update pattern
- Effects handle side effects (HTTP, storage)
- Events flow from UI to core, Capabilities flow from core to shell

## Context

**Depends on:**
- Phase 59 (Crux foundation)

**Builds foundation for:**
- Cross-platform state sync
- SQLite persistence
- Offline-first architecture

## Tasks

### Task 1: Create application model

**File:** `opta-native/opta-core/src/model.rs`

```rust
//! Application state model for Opta.

use serde::{Deserialize, Serialize};

/// Root application state.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct AppModel {
    /// Current page/view.
    pub current_view: View,
    /// User settings.
    pub settings: Settings,
    /// Ring animation state.
    pub ring_state: RingState,
    /// Telemetry data.
    pub telemetry: TelemetryState,
    /// User profile.
    pub profile: UserProfile,
}

/// Application views/pages.
#[derive(Debug, Clone, Default, Serialize, Deserialize, PartialEq)]
pub enum View {
    #[default]
    Dashboard,
    Optimization,
    Chess,
    Settings,
    KnowledgeGraph,
}

/// User settings.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Settings {
    pub haptics_enabled: bool,
    pub sound_enabled: bool,
    pub quality_level: QualityLevel,
    pub theme: Theme,
    pub launch_at_login: bool,
    pub show_menu_bar: bool,
}

impl Default for Settings {
    fn default() -> Self {
        Self {
            haptics_enabled: true,
            sound_enabled: false,
            quality_level: QualityLevel::High,
            theme: Theme::Dark,
            launch_at_login: false,
            show_menu_bar: true,
        }
    }
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq)]
pub enum QualityLevel {
    Low,
    Medium,
    High,
    Ultra,
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq)]
pub enum Theme {
    Dark,
    Light,
    System,
}

/// Ring animation state (synced with renderer).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RingState {
    pub state: RingAnimationState,
    pub energy: f32,
    pub last_interaction: Option<u64>,
}

impl Default for RingState {
    fn default() -> Self {
        Self {
            state: RingAnimationState::Dormant,
            energy: 0.0,
            last_interaction: None,
        }
    }
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq)]
pub enum RingAnimationState {
    Dormant,
    Waking,
    Active,
    Processing,
    Exploding,
    Recovering,
}

/// Telemetry snapshot.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct TelemetryState {
    pub cpu_usage: f32,
    pub memory_usage: f32,
    pub gpu_usage: f32,
    pub temperature: f32,
}

/// User profile for personalization.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct UserProfile {
    pub expertise_level: ExpertiseLevel,
    pub communication_style: CommunicationStyle,
    pub optimization_preferences: OptimizationPreferences,
}

#[derive(Debug, Clone, Copy, Default, Serialize, Deserialize, PartialEq)]
pub enum ExpertiseLevel {
    Beginner,
    #[default]
    Intermediate,
    Expert,
}

#[derive(Debug, Clone, Copy, Default, Serialize, Deserialize, PartialEq)]
pub enum CommunicationStyle {
    #[default]
    Balanced,
    Concise,
    Detailed,
    Technical,
}

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct OptimizationPreferences {
    pub prioritize_performance: bool,
    pub prioritize_efficiency: bool,
    pub auto_apply: bool,
}
```

### Task 2: Create Crux events

**File:** `opta-native/opta-core/src/events.rs`

```rust
//! Application events for Crux.

use serde::{Deserialize, Serialize};
use super::model::*;

/// Events that can be sent to the Crux core.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Event {
    // Navigation
    NavigateTo(View),

    // Ring interactions
    RingHover,
    RingClick,
    RingIdle,

    // Settings
    UpdateSettings(Settings),
    ToggleHaptics,
    ToggleSound,
    SetQuality(QualityLevel),

    // Telemetry
    TelemetryUpdate(TelemetryState),

    // Profile
    SetExpertise(ExpertiseLevel),
    SetCommunicationStyle(CommunicationStyle),

    // Persistence
    LoadState,
    SaveState,
    StateLoaded(Box<AppModel>),

    // Optimization
    RunOptimization,
    OptimizationComplete(OptimizationResult),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OptimizationResult {
    pub improvements: Vec<String>,
    pub score_change: i32,
}
```

### Task 3: Create Crux app implementation

**File:** `opta-native/opta-core/src/app.rs`

```rust
//! Crux application implementation.

use crux_core::{App, render::Render};
use super::{model::*, events::Event, capabilities::*};

/// Opta Crux application.
#[derive(Default)]
pub struct OptaApp;

/// View model for the shell.
#[derive(Debug, Clone, Default)]
pub struct ViewModel {
    pub view: View,
    pub ring_state: RingAnimationState,
    pub ring_energy: f32,
    pub telemetry: TelemetryState,
    pub settings: Settings,
}

impl App for OptaApp {
    type Event = Event;
    type Model = AppModel;
    type ViewModel = ViewModel;
    type Capabilities = Capabilities;

    fn update(&self, event: Self::Event, model: &mut Self::Model, caps: &Self::Capabilities) {
        match event {
            Event::NavigateTo(view) => {
                model.current_view = view;
            }

            Event::RingHover => {
                if model.ring_state.state == RingAnimationState::Dormant {
                    model.ring_state.state = RingAnimationState::Waking;
                    caps.haptics.play(HapticType::WakeUp);
                }
            }

            Event::RingClick => {
                model.ring_state.state = RingAnimationState::Exploding;
                caps.haptics.play(HapticType::Explosion);
            }

            Event::RingIdle => {
                if model.ring_state.state == RingAnimationState::Active {
                    model.ring_state.state = RingAnimationState::Dormant;
                }
            }

            Event::UpdateSettings(settings) => {
                model.settings = settings;
                caps.storage.save("settings", &model.settings);
            }

            Event::ToggleHaptics => {
                model.settings.haptics_enabled = !model.settings.haptics_enabled;
            }

            Event::ToggleSound => {
                model.settings.sound_enabled = !model.settings.sound_enabled;
            }

            Event::SetQuality(level) => {
                model.settings.quality_level = level;
            }

            Event::TelemetryUpdate(telemetry) => {
                model.telemetry = telemetry;
            }

            Event::SetExpertise(level) => {
                model.profile.expertise_level = level;
            }

            Event::SetCommunicationStyle(style) => {
                model.profile.communication_style = style;
            }

            Event::LoadState => {
                caps.storage.load("app_state");
            }

            Event::SaveState => {
                caps.storage.save("app_state", model);
            }

            Event::StateLoaded(state) => {
                *model = *state;
            }

            Event::RunOptimization => {
                model.ring_state.state = RingAnimationState::Processing;
                caps.optimization.run();
            }

            Event::OptimizationComplete(result) => {
                model.ring_state.state = RingAnimationState::Exploding;
                caps.haptics.play(HapticType::Explosion);
            }
        }
    }

    fn view(&self, model: &Self::Model) -> Self::ViewModel {
        ViewModel {
            view: model.current_view.clone(),
            ring_state: model.ring_state.state,
            ring_energy: model.ring_state.energy,
            telemetry: model.telemetry.clone(),
            settings: model.settings.clone(),
        }
    }
}
```

### Task 4: Create capabilities

**File:** `opta-native/opta-core/src/capabilities.rs`

```rust
//! Crux capabilities for Opta.

use crux_core::macros::Capability;
use serde::{Deserialize, Serialize};

/// Haptic feedback capability.
#[derive(Capability)]
pub struct Haptics<Ev> {
    context: crux_core::capability::CapabilityContext<HapticOp, Ev>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum HapticOp {
    Play(HapticType),
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum HapticType {
    Tap,
    Explosion,
    WakeUp,
    Pulse,
    Warning,
}

impl<Ev> Haptics<Ev> {
    pub fn play(&self, haptic_type: HapticType) {
        self.context.spawn(HapticOp::Play(haptic_type));
    }
}

/// Storage capability.
#[derive(Capability)]
pub struct Storage<Ev> {
    context: crux_core::capability::CapabilityContext<StorageOp, Ev>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum StorageOp {
    Save { key: String, data: Vec<u8> },
    Load { key: String },
}

impl<Ev> Storage<Ev> {
    pub fn save<T: Serialize>(&self, key: &str, data: &T) {
        if let Ok(bytes) = bincode::serialize(data) {
            self.context.spawn(StorageOp::Save {
                key: key.to_string(),
                data: bytes,
            });
        }
    }

    pub fn load(&self, key: &str) {
        self.context.spawn(StorageOp::Load {
            key: key.to_string(),
        });
    }
}

/// Optimization capability.
#[derive(Capability)]
pub struct Optimization<Ev> {
    context: crux_core::capability::CapabilityContext<OptimizationOp, Ev>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OptimizationOp {
    Run,
    Cancel,
}

impl<Ev> Optimization<Ev> {
    pub fn run(&self) {
        self.context.spawn(OptimizationOp::Run);
    }
}

/// Combined capabilities.
#[derive(crux_core::macros::Effect)]
pub struct Capabilities {
    pub render: crux_core::render::Render<super::events::Event>,
    pub haptics: Haptics<super::events::Event>,
    pub storage: Storage<super::events::Event>,
    pub optimization: Optimization<super::events::Event>,
}
```

## Verification

```bash
cd opta-native
cargo check -p opta-core
cargo test -p opta-core
```

## Success Criteria

- [ ] AppModel contains all application state
- [ ] Events handle all user interactions
- [ ] Capabilities abstract platform operations
- [ ] View model is pure data for rendering

## Output

- Crux-based state management
- Type-safe events and capabilities
- Platform-agnostic application logic
