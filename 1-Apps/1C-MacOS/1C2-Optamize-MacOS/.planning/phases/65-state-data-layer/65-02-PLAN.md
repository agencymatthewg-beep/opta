# Plan 65-02: SQLite Persistence

## Wave: 2 (Depends on 65-01)

## Objective

Implement SQLite database via rusqlite for persistent storage of user data, settings, and optimization history.

## Execution Context

**Reference Documents:**
- rusqlite documentation
- Existing React SQLite patterns

**Key Insights:**
- rusqlite provides safe SQLite bindings
- Use migrations for schema versioning
- Store blobs for complex data (profiles, presets)

## Context

**Depends on:**
- Phase 65-01 (Crux state management)

**Builds foundation for:**
- User profile persistence
- Optimization history
- Cross-device sync

## Tasks

### Task 1: Create database schema and migrations

**File:** `opta-native/opta-core/src/storage/schema.sql`

```sql
-- Opta SQLite Schema v1

-- User settings
CREATE TABLE IF NOT EXISTS settings (
    key TEXT PRIMARY KEY,
    value BLOB NOT NULL,
    updated_at INTEGER NOT NULL
);

-- User profile
CREATE TABLE IF NOT EXISTS profile (
    id INTEGER PRIMARY KEY CHECK (id = 1),
    expertise_level TEXT NOT NULL DEFAULT 'intermediate',
    communication_style TEXT NOT NULL DEFAULT 'balanced',
    preferences BLOB,
    created_at INTEGER NOT NULL,
    updated_at INTEGER NOT NULL
);

-- Optimization history
CREATE TABLE IF NOT EXISTS optimizations (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    timestamp INTEGER NOT NULL,
    score_before INTEGER NOT NULL,
    score_after INTEGER NOT NULL,
    actions BLOB NOT NULL,
    result TEXT NOT NULL
);

-- Telemetry snapshots (for trends)
CREATE TABLE IF NOT EXISTS telemetry_history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    timestamp INTEGER NOT NULL,
    cpu_usage REAL NOT NULL,
    memory_usage REAL NOT NULL,
    gpu_usage REAL,
    temperature REAL
);

-- Create indexes
CREATE INDEX IF NOT EXISTS idx_telemetry_timestamp ON telemetry_history(timestamp);
CREATE INDEX IF NOT EXISTS idx_optimizations_timestamp ON optimizations(timestamp);
```

### Task 2: Create database manager

**File:** `opta-native/opta-core/src/storage/database.rs`

```rust
//! SQLite database manager.

use rusqlite::{Connection, params, Result as SqlResult};
use std::path::Path;

/// Database manager for Opta.
pub struct Database {
    conn: Connection,
}

impl Database {
    /// Open or create database at the given path.
    pub fn open(path: impl AsRef<Path>) -> SqlResult<Self> {
        let conn = Connection::open(path)?;

        // Enable foreign keys and WAL mode
        conn.execute_batch(
            "PRAGMA foreign_keys = ON;
             PRAGMA journal_mode = WAL;
             PRAGMA synchronous = NORMAL;"
        )?;

        let db = Self { conn };
        db.migrate()?;
        Ok(db)
    }

    /// Open in-memory database (for testing).
    pub fn open_in_memory() -> SqlResult<Self> {
        let conn = Connection::open_in_memory()?;
        let db = Self { conn };
        db.migrate()?;
        Ok(db)
    }

    /// Run migrations.
    fn migrate(&self) -> SqlResult<()> {
        self.conn.execute_batch(include_str!("schema.sql"))
    }

    /// Save a setting.
    pub fn save_setting(&self, key: &str, value: &[u8]) -> SqlResult<()> {
        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs() as i64;

        self.conn.execute(
            "INSERT OR REPLACE INTO settings (key, value, updated_at) VALUES (?1, ?2, ?3)",
            params![key, value, now],
        )?;
        Ok(())
    }

    /// Load a setting.
    pub fn load_setting(&self, key: &str) -> SqlResult<Option<Vec<u8>>> {
        let mut stmt = self.conn.prepare(
            "SELECT value FROM settings WHERE key = ?1"
        )?;

        let result = stmt.query_row(params![key], |row| row.get(0));
        match result {
            Ok(value) => Ok(Some(value)),
            Err(rusqlite::Error::QueryReturnedNoRows) => Ok(None),
            Err(e) => Err(e),
        }
    }

    /// Record optimization result.
    pub fn record_optimization(
        &self,
        score_before: i32,
        score_after: i32,
        actions: &[u8],
        result: &str,
    ) -> SqlResult<i64> {
        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs() as i64;

        self.conn.execute(
            "INSERT INTO optimizations (timestamp, score_before, score_after, actions, result)
             VALUES (?1, ?2, ?3, ?4, ?5)",
            params![now, score_before, score_after, actions, result],
        )?;

        Ok(self.conn.last_insert_rowid())
    }

    /// Record telemetry snapshot.
    pub fn record_telemetry(
        &self,
        cpu_usage: f32,
        memory_usage: f32,
        gpu_usage: Option<f32>,
        temperature: Option<f32>,
    ) -> SqlResult<()> {
        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs() as i64;

        self.conn.execute(
            "INSERT INTO telemetry_history (timestamp, cpu_usage, memory_usage, gpu_usage, temperature)
             VALUES (?1, ?2, ?3, ?4, ?5)",
            params![now, cpu_usage, memory_usage, gpu_usage, temperature],
        )?;
        Ok(())
    }

    /// Get recent telemetry history.
    pub fn get_telemetry_history(&self, limit: usize) -> SqlResult<Vec<TelemetryRecord>> {
        let mut stmt = self.conn.prepare(
            "SELECT timestamp, cpu_usage, memory_usage, gpu_usage, temperature
             FROM telemetry_history
             ORDER BY timestamp DESC
             LIMIT ?1"
        )?;

        let records = stmt.query_map(params![limit as i64], |row| {
            Ok(TelemetryRecord {
                timestamp: row.get(0)?,
                cpu_usage: row.get(1)?,
                memory_usage: row.get(2)?,
                gpu_usage: row.get(3)?,
                temperature: row.get(4)?,
            })
        })?;

        records.collect()
    }

    /// Prune old telemetry data.
    pub fn prune_telemetry(&self, days_to_keep: u32) -> SqlResult<usize> {
        let cutoff = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs() as i64 - (days_to_keep as i64 * 86400);

        self.conn.execute(
            "DELETE FROM telemetry_history WHERE timestamp < ?1",
            params![cutoff],
        )
    }
}

/// Telemetry record from database.
#[derive(Debug, Clone)]
pub struct TelemetryRecord {
    pub timestamp: i64,
    pub cpu_usage: f32,
    pub memory_usage: f32,
    pub gpu_usage: Option<f32>,
    pub temperature: Option<f32>,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_database_open() {
        let db = Database::open_in_memory().unwrap();
        assert!(db.load_setting("test").unwrap().is_none());
    }

    #[test]
    fn test_settings() {
        let db = Database::open_in_memory().unwrap();

        db.save_setting("key1", b"value1").unwrap();
        let loaded = db.load_setting("key1").unwrap();
        assert_eq!(loaded, Some(b"value1".to_vec()));
    }

    #[test]
    fn test_telemetry() {
        let db = Database::open_in_memory().unwrap();

        db.record_telemetry(50.0, 60.0, Some(30.0), Some(65.0)).unwrap();
        let history = db.get_telemetry_history(10).unwrap();
        assert_eq!(history.len(), 1);
        assert_eq!(history[0].cpu_usage, 50.0);
    }
}
```

### Task 3: Create storage module

**File:** `opta-native/opta-core/src/storage/mod.rs`

```rust
//! Persistent storage for Opta.

mod database;

pub use database::{Database, TelemetryRecord};
```

## Verification

```bash
cd opta-native
cargo test -p opta-core -- storage
cargo check -p opta-core
```

## Success Criteria

- [ ] Database opens and migrates schema
- [ ] Settings save and load correctly
- [ ] Telemetry history records and retrieves
- [ ] Pruning removes old data
- [ ] Tests pass

## Output

- SQLite persistence layer
- Schema with settings, profiles, history
- Database manager with CRUD operations
