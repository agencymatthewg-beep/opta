---
phase: 03-process-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [mcp-server/src/opta_mcp/processes.py, mcp-server/src/opta_mcp/server.py, src-tauri/src/processes.rs, src-tauri/src/lib.rs, src/types/processes.ts, src/hooks/useProcesses.ts, src/components/ProcessList.tsx, src/components/ProcessList.css, src/pages/Dashboard.tsx]
autonomous: true
---

<objective>
Implement process listing and categorization for real-time process monitoring.

Purpose: Enable users to see all running processes with resource usage and categorization (system-critical, user app, safe-to-kill) - the foundation for Stealth Mode.
Output: Process listing in MCP server, Tauri integration, and ProcessList UI component on Dashboard.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Prior phase context (extends existing MCP server):
@.planning/phases/02-hardware-telemetry/02-01-SUMMARY.md
@.planning/phases/02-hardware-telemetry/02-02-SUMMARY.md

Source files to extend:
@mcp-server/src/opta_mcp/telemetry.py
@mcp-server/src/opta_mcp/server.py
@src-tauri/src/telemetry.rs
@src-tauri/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add process listing and categorization to Python MCP server</name>
  <files>mcp-server/src/opta_mcp/processes.py, mcp-server/src/opta_mcp/server.py</files>
  <action>
Create new `processes.py` module with:

1. `get_process_list()` function using `psutil.process_iter()`:
   - Return list of dicts with: pid, name, cpu_percent, memory_percent, status, username, create_time
   - Use `proc.info` dict approach for efficiency (avoid per-process exceptions)
   - Sort by CPU usage descending
   - Limit to top 100 processes to keep payload manageable

2. `categorize_process(name: str, username: str) -> str` function:
   - Return "system" for: kernel, init, systemd, launchd, csrss, smss, svchost, System Idle Process, WindowServer
   - Return "safe-to-kill" for known bloatware: Adobe updaters, Spotify helper, Discord helper, Steam client bootstrapper, OneDrive, Google Update, Microsoft Edge Update, Razer services, OMEN Hub services
   - Return "user" for everything else
   - Use lowercase matching for cross-platform compatibility

3. Register `get_processes` tool in server.py following existing pattern (see get_system_snapshot)

AVOID: Don't iterate processes twice. Don't block on cpu_percent with interval (use 0).
  </action>
  <verify>
cd mcp-server && uv run python -c "from opta_mcp.processes import get_process_list; import json; print(json.dumps(get_process_list()[:3], indent=2))"
  </verify>
  <done>get_processes MCP tool returns list of categorized processes with CPU/memory stats</done>
</task>

<task type="auto">
  <name>Task 2: Create Rust command and TypeScript types for process data</name>
  <files>src-tauri/src/processes.rs, src-tauri/src/lib.rs, src/types/processes.ts</files>
  <action>
1. Create `processes.rs` module with:
   - `ProcessInfo` struct: pid (u32), name (String), cpu_percent (f32), memory_percent (f32), status (String), category (String), username (Option<String>)
   - `#[tauri::command] async fn get_processes()` that invokes Python MCP server (follow telemetry.rs pattern)
   - Parse JSON output into Vec<ProcessInfo>

2. Register in `lib.rs`:
   - Add `mod processes;`
   - Add `processes::get_processes` to `.invoke_handler(tauri::generate_handler![...])`

3. Create `src/types/processes.ts` with:
   - `ProcessInfo` interface matching Rust struct
   - Export for use in hooks/components

Follow established patterns from telemetry.rs - subprocess per-request, nullable fields for error handling.
  </action>
  <verify>
cd src-tauri && cargo check
  </verify>
  <done>Rust command compiles and TypeScript types match struct</done>
</task>

<task type="auto">
  <name>Task 3: Create ProcessList component and integrate with Dashboard</name>
  <files>src/hooks/useProcesses.ts, src/components/ProcessList.tsx, src/components/ProcessList.css, src/pages/Dashboard.tsx</files>
  <action>
1. Create `useProcesses.ts` hook:
   - Follow useTelemetry.ts pattern
   - Poll every 3 seconds (processes change less frequently than telemetry)
   - Return { processes, loading, error, refresh }

2. Create `ProcessList.tsx` component:
   - Scrollable table showing: Name, CPU%, Memory%, Category, PID
   - Category badges with colors: "system" (gray), "user" (blue), "safe-to-kill" (yellow)
   - Click row to select (for future Stealth Mode integration)
   - Sort by CPU% descending by default
   - Loading skeleton while fetching
   - Max height with overflow-y scroll

3. Create `ProcessList.css`:
   - Gaming aesthetic matching existing components (dark theme, neon accents)
   - Table with hover states
   - Category badges with appropriate colors
   - Sticky header

4. Add ProcessList to Dashboard.tsx:
   - Place below telemetry meters in a new section
   - Title: "Running Processes"
   - Show process count in header

Follow gaming aesthetic from TelemetryCard - dark backgrounds, neon green accents, subtle glow effects.
  </action>
  <verify>
npm run build && npm run dev
  </verify>
  <done>ProcessList renders on Dashboard with real process data, sorted by CPU usage</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd mcp-server && uv run python -c "from opta_mcp.processes import get_process_list; print(len(get_process_list()))"` returns process count
- [ ] `cd src-tauri && cargo check` passes without errors
- [ ] `npm run build` succeeds
- [ ] Dashboard shows ProcessList with real processes
- [ ] Processes are categorized correctly (system/user/safe-to-kill)
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Process list displays real data from system
- Categories correctly identify system processes vs safe-to-kill
</success_criteria>

<output>
After completion, create `.planning/phases/03-process-management/03-01-SUMMARY.md`
</output>
