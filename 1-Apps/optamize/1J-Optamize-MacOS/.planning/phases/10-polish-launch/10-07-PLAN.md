---
phase: 10-polish-launch
plan: 07
type: execute
wave: 3
depends_on: [10-04, 10-06]
files_modified: [src/components/ExpertiseDetection.tsx, src/hooks/useExpertise.ts, mcp-server/src/opta_mcp/expertise.py, mcp-server/src/opta_mcp/server.py]
autonomous: true
---

<objective>
Implement expertise-level detection to automatically adjust explanation complexity.

Purpose: Fulfill MUST_HAVE requirement for Adaptive User Modes. The app detects user expertise from behavior patterns and adjusts explanations accordingly - simple for beginners, detailed for power users. Users can also manually set their level.

Output: Expertise detection system that adapts UI complexity dynamically.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/MUST_HAVE.md
@.planning/phases/10-polish-launch/10-CONTEXT.md
@src/components/LearnModeContext.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define expertise types and detection logic</name>
  <files>src/types/expertise.ts, mcp-server/src/opta_mcp/expertise.py</files>
  <action>
Create expertise types and detection algorithm:

```typescript
// src/types/expertise.ts

export type ExpertiseLevel = 'simple' | 'standard' | 'power';

export interface ExpertiseSignals {
  // Behavioral signals
  usesTechnicalFeatures: number;  // 0-100
  readsDocumentation: number;  // 0-100
  usesShortcuts: number;  // 0-100
  expandsTechnicalDetails: number;  // 0-100
  usesInvestigationMode: number;  // 0-100

  // Time-based signals
  timeInApp: number;  // minutes
  sessionsCount: number;
  optimizationsApplied: number;

  // Explicit preference
  manualOverride: ExpertiseLevel | null;
}

export interface ExpertiseProfile {
  currentLevel: ExpertiseLevel;
  confidence: number;  // 0-100
  signals: ExpertiseSignals;
  history: ExpertiseLevelChange[];
  manualOverride: ExpertiseLevel | null;
}

export interface ExpertiseLevelChange {
  timestamp: number;
  from: ExpertiseLevel;
  to: ExpertiseLevel;
  reason: string;
}
```

```python
# mcp-server/src/opta_mcp/expertise.py
"""Expertise detection and adaptation."""

import json
import time
from pathlib import Path
from dataclasses import dataclass, asdict
from typing import Optional

OPTA_DIR = Path.home() / ".opta"
EXPERTISE_FILE = OPTA_DIR / "expertise.json"

@dataclass
class ExpertiseSignals:
    uses_technical_features: int = 0  # 0-100
    reads_documentation: int = 0
    uses_shortcuts: int = 0
    expands_technical_details: int = 0
    uses_investigation_mode: int = 0
    time_in_app: int = 0  # minutes
    sessions_count: int = 0
    optimizations_applied: int = 0


def detect_expertise_level(signals: dict) -> dict:
    """
    Detect expertise level from behavioral signals.

    Algorithm:
    - Simple: New users, < 5 sessions, rarely uses technical features
    - Standard: Regular users, 5-20 sessions, moderate technical usage
    - Power: Advanced users, > 20 sessions, frequently uses technical features
    """
    s = ExpertiseSignals(**signals) if isinstance(signals, dict) else signals

    # Calculate composite score (0-100)
    technical_score = (
        s.uses_technical_features * 0.25 +
        s.expands_technical_details * 0.2 +
        s.uses_investigation_mode * 0.25 +
        s.uses_shortcuts * 0.15 +
        s.reads_documentation * 0.15
    )

    # Time/usage factor
    usage_factor = min(
        (s.sessions_count / 20) * 50 +
        (s.optimizations_applied / 10) * 50,
        100
    )

    # Combined score
    composite = (technical_score * 0.7 + usage_factor * 0.3)

    # Determine level
    if composite < 30:
        level = "simple"
        confidence = 100 - composite  # More confident at lower scores
    elif composite < 65:
        level = "standard"
        confidence = 100 - abs(composite - 47.5) * 2  # Most confident at middle
    else:
        level = "power"
        confidence = min(composite, 100)  # More confident at higher scores

    return {
        "currentLevel": level,
        "confidence": int(confidence),
        "compositeScore": int(composite),
        "signals": asdict(s) if isinstance(s, ExpertiseSignals) else s
    }


def record_signal(signal_name: str, value: int) -> dict:
    """Record a behavioral signal and recalculate expertise."""
    profile = load_expertise_profile()

    # Update signal (weighted average with previous)
    current = profile.get("signals", {}).get(signal_name, 0)
    profile["signals"][signal_name] = int(current * 0.7 + value * 0.3)

    # Recalculate level
    detection = detect_expertise_level(profile["signals"])
    profile.update(detection)

    save_expertise_profile(profile)
    return profile


def set_manual_override(level: Optional[str]) -> dict:
    """Set or clear manual expertise override."""
    profile = load_expertise_profile()
    profile["manualOverride"] = level

    if level:
        profile["currentLevel"] = level
        profile["confidence"] = 100
    else:
        # Recalculate from signals
        detection = detect_expertise_level(profile.get("signals", {}))
        profile.update(detection)

    save_expertise_profile(profile)
    return profile


def load_expertise_profile() -> dict:
    """Load expertise profile from disk."""
    if EXPERTISE_FILE.exists():
        return json.loads(EXPERTISE_FILE.read_text())
    return {
        "currentLevel": "standard",
        "confidence": 50,
        "signals": asdict(ExpertiseSignals()),
        "history": [],
        "manualOverride": None
    }


def save_expertise_profile(profile: dict) -> None:
    """Save expertise profile to disk."""
    OPTA_DIR.mkdir(parents=True, exist_ok=True)
    EXPERTISE_FILE.write_text(json.dumps(profile, indent=2))


def get_expertise_profile() -> dict:
    """Get current expertise profile."""
    return load_expertise_profile()
```
  </action>
  <verify>Python module imports correctly</verify>
  <done>Expertise types and detection logic created</done>
</task>

<task type="auto">
  <name>Task 2: Create expertise hook and context</name>
  <files>src/hooks/useExpertise.ts, src/components/ExpertiseContext.tsx</files>
  <action>
Create React hook and context for expertise:

```tsx
// src/components/ExpertiseContext.tsx
import { createContext, useContext, useState, useEffect, useCallback, ReactNode } from 'react';
import { invoke } from '@tauri-apps/api/core';
import type { ExpertiseLevel, ExpertiseProfile } from '@/types/expertise';

interface ExpertiseContextType {
  level: ExpertiseLevel;
  confidence: number;
  isManualOverride: boolean;
  setManualLevel: (level: ExpertiseLevel | null) => Promise<void>;
  recordSignal: (signal: string, value: number) => void;
}

const ExpertiseContext = createContext<ExpertiseContextType | undefined>(undefined);

export function ExpertiseProvider({ children }: { children: ReactNode }) {
  const [profile, setProfile] = useState<ExpertiseProfile>({
    currentLevel: 'standard',
    confidence: 50,
    signals: {},
    history: [],
    manualOverride: null,
  });

  // Load profile on mount
  useEffect(() => {
    invoke<ExpertiseProfile>('get_expertise_profile')
      .then(setProfile)
      .catch(console.error);
  }, []);

  const setManualLevel = useCallback(async (level: ExpertiseLevel | null) => {
    const newProfile = await invoke<ExpertiseProfile>('set_expertise_override', { level });
    setProfile(newProfile);
  }, []);

  const recordSignal = useCallback((signal: string, value: number) => {
    // Fire and forget - don't block UI
    invoke<ExpertiseProfile>('record_expertise_signal', { signalName: signal, value })
      .then(setProfile)
      .catch(console.error);
  }, []);

  return (
    <ExpertiseContext.Provider value={{
      level: profile.manualOverride || profile.currentLevel,
      confidence: profile.confidence,
      isManualOverride: !!profile.manualOverride,
      setManualLevel,
      recordSignal,
    }}>
      {children}
    </ExpertiseContext.Provider>
  );
}

export function useExpertise() {
  const context = useContext(ExpertiseContext);
  if (!context) {
    throw new Error('useExpertise must be used within ExpertiseProvider');
  }
  return context;
}
```

```tsx
// src/hooks/useExpertise.ts
import { useCallback, useEffect } from 'react';
import { useExpertise as useExpertiseContext } from '@/components/ExpertiseContext';

/**
 * Hook for tracking expertise signals.
 * Call these functions when users perform actions that indicate expertise.
 */
export function useExpertiseTracking() {
  const { recordSignal } = useExpertiseContext();

  // Track when user expands technical details
  const trackTechnicalExpand = useCallback(() => {
    recordSignal('expands_technical_details', 100);
  }, [recordSignal]);

  // Track when user enables investigation mode
  const trackInvestigationMode = useCallback(() => {
    recordSignal('uses_investigation_mode', 100);
  }, [recordSignal]);

  // Track keyboard shortcut usage
  const trackShortcut = useCallback(() => {
    recordSignal('uses_shortcuts', 100);
  }, [recordSignal]);

  // Track when user reads documentation
  const trackDocumentation = useCallback(() => {
    recordSignal('reads_documentation', 100);
  }, [recordSignal]);

  // Track session start
  const trackSession = useCallback(() => {
    recordSignal('sessions_count', 1);
  }, [recordSignal]);

  // Track optimization applied
  const trackOptimization = useCallback(() => {
    recordSignal('optimizations_applied', 1);
  }, [recordSignal]);

  return {
    trackTechnicalExpand,
    trackInvestigationMode,
    trackShortcut,
    trackDocumentation,
    trackSession,
    trackOptimization,
  };
}

/**
 * Get explanation content based on expertise level.
 */
export function useExpertiseContent() {
  const { level } = useExpertiseContext();

  const getExplanation = useCallback((content: {
    simple: string;
    standard: string;
    power: string;
  }) => {
    return content[level];
  }, [level]);

  const showTechnicalDetails = level === 'power';
  const showSimplifiedUI = level === 'simple';

  return {
    getExplanation,
    showTechnicalDetails,
    showSimplifiedUI,
    level,
  };
}
```
  </action>
  <verify>Hooks compile and provide correct API</verify>
  <done>Expertise hook and context created</done>
</task>

<task type="auto">
  <name>Task 3: Add MCP tools and Tauri commands</name>
  <files>mcp-server/src/opta_mcp/server.py, src-tauri/src/expertise.rs, src-tauri/src/lib.rs</files>
  <action>
Add MCP tools for expertise:

```python
# In server.py tools list
Tool(
    name="get_expertise_profile",
    description="Get current expertise profile with level and signals",
    inputSchema={"type": "object", "properties": {}}
),
Tool(
    name="record_expertise_signal",
    description="Record a behavioral signal for expertise detection",
    inputSchema={
        "type": "object",
        "properties": {
            "signal_name": {"type": "string"},
            "value": {"type": "number"}
        },
        "required": ["signal_name", "value"]
    }
),
Tool(
    name="set_expertise_override",
    description="Set or clear manual expertise level override",
    inputSchema={
        "type": "object",
        "properties": {
            "level": {"type": ["string", "null"]}
        }
    }
)

# In handle_call_tool
elif name == "get_expertise_profile":
    from .expertise import get_expertise_profile
    return [TextContent(type="text", text=json.dumps(get_expertise_profile()))]
elif name == "record_expertise_signal":
    from .expertise import record_signal
    result = record_signal(arguments["signal_name"], arguments["value"])
    return [TextContent(type="text", text=json.dumps(result))]
elif name == "set_expertise_override":
    from .expertise import set_manual_override
    result = set_manual_override(arguments.get("level"))
    return [TextContent(type="text", text=json.dumps(result))]
```

Create Tauri commands:
```rust
// src-tauri/src/expertise.rs
use crate::mcp::call_mcp_tool;
use serde_json::{json, Value};

#[tauri::command]
pub async fn get_expertise_profile() -> Result<Value, String> {
    call_mcp_tool("get_expertise_profile", json!({})).await
}

#[tauri::command]
pub async fn record_expertise_signal(signal_name: String, value: i32) -> Result<Value, String> {
    call_mcp_tool("record_expertise_signal", json!({
        "signal_name": signal_name,
        "value": value
    })).await
}

#[tauri::command]
pub async fn set_expertise_override(level: Option<String>) -> Result<Value, String> {
    call_mcp_tool("set_expertise_override", json!({
        "level": level
    })).await
}
```

Register in lib.rs.
  </action>
  <verify>Tauri commands callable from frontend</verify>
  <done>MCP tools and Tauri commands added</done>
</task>

<task type="auto">
  <name>Task 4: Integrate expertise into UI components</name>
  <files>src/components/LearnModeExplanation.tsx, src/pages/Settings.tsx</files>
  <action>
Update components to use expertise level:

```tsx
// Update LearnModeExplanation.tsx to adapt to expertise
import { useExpertiseContent } from '@/hooks/useExpertise';

export function LearnModeExplanation({
  title,
  simple,
  standard,
  power,
  type = 'info',
}: LearnModeExplanationProps) {
  const { isLearnMode } = useLearnMode();
  const { getExplanation, showTechnicalDetails } = useExpertiseContent();

  if (!isLearnMode) return null;

  const description = getExplanation({ simple, standard, power });

  return (
    <motion.div className={cn("rounded-lg border p-3 my-2", colors)}>
      <div className="flex items-start gap-2">
        <Icon className="w-4 h-4 mt-0.5 flex-shrink-0" />
        <div>
          <div className="font-medium text-sm">{title}</div>
          <div className="text-sm opacity-80">{description}</div>
          {showTechnicalDetails && power !== standard && (
            <div className="text-xs mt-1 opacity-60 italic">
              Technical: {power}
            </div>
          )}
        </div>
      </div>
    </motion.div>
  );
}
```

Add expertise selector in Settings.tsx:
```tsx
// In Settings page
<section>
  <h3 className="text-lg font-semibold mb-4">Experience Level</h3>
  <p className="text-sm text-muted-foreground mb-4">
    Opta adapts explanations based on your expertise.
    {!isManualOverride && ` Currently auto-detected: ${level} (${confidence}% confident)`}
  </p>

  <div className="grid grid-cols-3 gap-3">
    {[
      { value: 'simple', label: 'Simple', desc: 'Plain language, safer options' },
      { value: 'standard', label: 'Standard', desc: 'Balanced explanations' },
      { value: 'power', label: 'Power User', desc: 'Full technical details' },
    ].map((option) => (
      <button
        key={option.value}
        className={cn(
          "p-4 glass-subtle rounded-xl text-left transition-colors",
          level === option.value && "ring-2 ring-primary"
        )}
        onClick={() => setManualLevel(option.value)}
      >
        <div className="font-medium">{option.label}</div>
        <div className="text-xs text-muted-foreground">{option.desc}</div>
      </button>
    ))}
  </div>

  {isManualOverride && (
    <Button
      variant="ghost"
      size="sm"
      className="mt-2"
      onClick={() => setManualLevel(null)}
    >
      Reset to auto-detect
    </Button>
  )}
</section>
```
  </action>
  <verify>UI adapts to expertise level, selector works in Settings</verify>
  <done>Expertise integrated into UI</done>
</task>

<task type="auto">
  <name>Task 5: Add expertise signal tracking throughout app</name>
  <files>src/App.tsx, src/components/InvestigationPanel.tsx, src/components/LearnModeExplanation.tsx</files>
  <action>
Add tracking calls throughout the app:

```tsx
// In App.tsx - track session on mount
useEffect(() => {
  trackSession();
}, []);

// In InvestigationPanel.tsx - track when opened
useEffect(() => {
  trackInvestigationMode();
}, []);

// In LearnModeExplanation.tsx - track when technical details expanded
const handleExpandDetails = () => {
  setExpanded(true);
  trackTechnicalExpand();
};

// In optimization flow - track when optimization applied
const handleApplyOptimization = async () => {
  await applyOptimization();
  trackOptimization();
};

// Add keyboard shortcut tracking
useEffect(() => {
  const handleKeyDown = (e: KeyboardEvent) => {
    if (e.metaKey || e.ctrlKey) {
      trackShortcut();
    }
  };
  window.addEventListener('keydown', handleKeyDown);
  return () => window.removeEventListener('keydown', handleKeyDown);
}, []);
```

This creates a feedback loop:
1. User behavior is tracked
2. Expertise level adjusts automatically
3. UI adapts to new level
4. User sees appropriate complexity
  </action>
  <verify>Signals are recorded, expertise level updates over time</verify>
  <done>Expertise signal tracking integrated</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Expertise detection algorithm implemented
- [ ] Three levels work: simple, standard, power
- [ ] Auto-detection from behavioral signals
- [ ] Manual override in Settings
- [ ] LearnModeExplanation adapts to level
- [ ] Signal tracking integrated throughout app
- [ ] Profile persists across sessions
- [ ] `npm run build` succeeds
</verification>

<success_criteria>
- All tasks completed
- Simple users see plain language, fewer options
- Standard users see balanced explanations
- Power users see full technical details
- Auto-detection works from real behavior
- Users can manually override their level
- Expertise persists and evolves over time
</success_criteria>

<output>
After completion, create `.planning/phases/10-polish-launch/10-07-SUMMARY.md`
</output>
