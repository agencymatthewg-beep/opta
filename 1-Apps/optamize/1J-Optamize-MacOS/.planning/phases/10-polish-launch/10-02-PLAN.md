---
phase: 10-polish-launch
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [src/App.tsx, src/components/*.tsx, src/index.css, src-tauri/tauri.conf.json]
autonomous: true
---

<objective>
UX polish and performance optimization for launch readiness.

Purpose: Ensure the app feels professional, responsive, and polished. This includes animation refinement, loading states, error handling, accessibility improvements, and performance optimization.

Output: Polished UI with smooth animations, proper loading states, and optimized bundle size.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/10-polish-launch/10-CONTEXT.md
@DESIGN_SYSTEM.md
@src/App.tsx
@src/index.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Audit and refine animations</name>
  <files>src/components/*.tsx, src/lib/animations.ts</files>
  <action>
Audit all components for animation consistency and refinement:

1. **Create animation presets** in `src/lib/animations.ts`:
```typescript
import { Variants } from 'framer-motion';

export const fadeIn: Variants = {
  initial: { opacity: 0 },
  animate: { opacity: 1 },
  exit: { opacity: 0 },
};

export const slideUp: Variants = {
  initial: { opacity: 0, y: 12 },
  animate: { opacity: 1, y: 0 },
  exit: { opacity: 0, y: -12 },
};

export const scaleIn: Variants = {
  initial: { opacity: 0, scale: 0.95 },
  animate: { opacity: 1, scale: 1 },
  exit: { opacity: 0, scale: 0.95 },
};

export const staggerContainer: Variants = {
  animate: {
    transition: {
      staggerChildren: 0.05,
    },
  },
};

export const transition = {
  fast: { duration: 0.15, ease: [0.4, 0, 0.2, 1] },
  medium: { duration: 0.25, ease: [0.4, 0, 0.2, 1] },
  slow: { duration: 0.4, ease: [0.4, 0, 0.2, 1] },
};
```

2. **Update components to use presets**:
   - Dashboard cards: Use `slideUp` with stagger
   - Page transitions: Use `fadeIn`
   - Modals: Use `scaleIn`
   - Lists: Use stagger container

3. **Add micro-interactions**:
   - Button hover: subtle scale (1.02)
   - Card hover: subtle lift (translateY -2px)
   - Success states: check icon with draw animation
   - Score changes: counting animation
  </action>
  <verify>Animations feel smooth and consistent across all pages</verify>
  <done>Animation system refined with consistent presets</done>
</task>

<task type="auto">
  <name>Task 2: Add loading states and skeletons</name>
  <files>src/components/ui/skeleton.tsx, src/components/*.tsx</files>
  <action>
Create skeleton loading components and add loading states:

1. **Create Skeleton component** if not exists:
```tsx
// src/components/ui/skeleton.tsx
import { cn } from "@/lib/utils";
import { motion } from "framer-motion";

export function Skeleton({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <motion.div
      className={cn("bg-muted/50 rounded-md", className)}
      animate={{ opacity: [0.5, 0.8, 0.5] }}
      transition={{ duration: 1.5, repeat: Infinity }}
      {...props}
    />
  );
}

export function TelemetryCardSkeleton() {
  return (
    <div className="glass p-4 rounded-xl">
      <Skeleton className="h-4 w-20 mb-2" />
      <Skeleton className="h-8 w-16 mb-4" />
      <Skeleton className="h-24 w-24 mx-auto rounded-full" />
    </div>
  );
}

export function ProcessListSkeleton() {
  return (
    <div className="space-y-2">
      {[...Array(5)].map((_, i) => (
        <Skeleton key={i} className="h-12 w-full" />
      ))}
    </div>
  );
}
```

2. **Add loading states to pages**:
   - Dashboard: Show skeletons while telemetry loads
   - Games: Show skeletons while game list loads
   - Score: Show skeleton while score calculates

3. **Add error states**:
   - Connection error: "Unable to connect to system monitor"
   - Game detection error: "No games found - try scanning again"
   - Score error: "Unable to calculate score"
  </action>
  <verify>Loading states appear during data fetching, error states show gracefully</verify>
  <done>Loading skeletons and error states implemented</done>
</task>

<task type="auto">
  <name>Task 3: Performance optimization</name>
  <files>package.json, vite.config.ts, src/*.tsx</files>
  <action>
Optimize bundle size and runtime performance:

1. **Analyze bundle**:
```bash
npm run build -- --report
```

2. **Lazy load heavy components**:
```tsx
// src/App.tsx
import { lazy, Suspense } from 'react';

const Games = lazy(() => import('./pages/Games'));
const Score = lazy(() => import('./pages/Score'));
const Settings = lazy(() => import('./pages/Settings'));

// In render:
<Suspense fallback={<PageSkeleton />}>
  {page === 'games' && <Games />}
</Suspense>
```

3. **Optimize re-renders**:
   - Wrap expensive components with `React.memo`
   - Use `useMemo` for computed values
   - Use `useCallback` for event handlers passed as props

4. **Optimize images/assets**:
   - Ensure all icons use Lucide (tree-shaken)
   - No large image assets in bundle
   - Fonts subset if possible

5. **Update vite.config.ts for production**:
```typescript
export default defineConfig({
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          'framer-motion': ['framer-motion'],
          'lucide': ['lucide-react'],
        },
      },
    },
    minify: 'terser',
    terserOptions: {
      compress: {
        drop_console: true,
      },
    },
  },
});
```
  </action>
  <verify>Bundle size reasonable (<2MB), no console.logs in production, fast initial load</verify>
  <done>Performance optimized for production</done>
</task>

<task type="auto">
  <name>Task 4: Accessibility improvements</name>
  <files>src/components/*.tsx</files>
  <action>
Audit and improve accessibility:

1. **Keyboard navigation**:
   - All interactive elements focusable
   - Focus ring visible (already in design system)
   - Tab order logical
   - Escape closes modals

2. **ARIA labels**:
```tsx
// Meters
<div role="meter" aria-valuenow={value} aria-valuemin={0} aria-valuemax={100} aria-label="CPU usage">

// Buttons
<Button aria-label="Close dialog" onClick={onClose}>
  <X className="h-4 w-4" />
</Button>

// Status indicators
<Badge aria-label="Status: Running">Running</Badge>
```

3. **Screen reader support**:
   - Announce score changes with aria-live
   - Proper heading hierarchy (h1 -> h2 -> h3)
   - Alt text for any images

4. **Color contrast**:
   - Verify text meets WCAG AA (4.5:1)
   - Success/warning/error colors distinguishable

5. **Reduced motion**:
```tsx
// Add to animation components
const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

const transition = prefersReducedMotion
  ? { duration: 0 }
  : { duration: 0.25 };
```
  </action>
  <verify>Keyboard navigation works, screen reader announces key content</verify>
  <done>Accessibility improved for launch</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Animations consistent and smooth
- [ ] Loading states for all async operations
- [ ] Error states for failure scenarios
- [ ] Bundle size optimized (<2MB)
- [ ] Keyboard navigation works
- [ ] ARIA labels on key elements
- [ ] `npm run build` succeeds
</verification>

<success_criteria>
- All tasks completed
- Animation presets centralized and consistent
- Loading skeletons for Dashboard, Games, Score
- Error states handle failures gracefully
- Bundle size reasonable for desktop app
- Basic accessibility requirements met
</success_criteria>

<output>
After completion, create `.planning/phases/10-polish-launch/10-02-SUMMARY.md`
</output>
