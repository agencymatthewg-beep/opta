# Plan 60-02: Render Pipeline Foundation

## Wave: 1 (Can run parallel with 60-01)

## Objective

Implement basic wgpu render pipeline with vertex/fragment shaders for geometry rendering.

## Execution Context

**Reference Documents:**
- `Gemini Deep Research/Hardware & Platform Knowledge/wgpu-SwiftUI-iOS-macOS-Integration.md`
- wgpu render pipeline documentation

**Key Insights from Research:**
- TBDR optimization: Always use LoadOp::Clear for color, StoreOp::Discard for depth
- Apple Silicon SIMD width is 32 (workgroup sizes should be multiples of 32)
- Use physical pixels, not logical points

## Context

**Depends on:** Plan 60-01 (GpuContext, RenderSurface)

**Pattern:** Basic 2D rendering pipeline for UI components

## Tasks

### Task 1: Create vertex and index buffer types

**File:** `opta-native/opta-render/src/buffer.rs`

```rust
pub struct VertexBuffer {
    buffer: wgpu::Buffer,
    vertex_count: u32,
}

pub struct IndexBuffer {
    buffer: wgpu::Buffer,
    index_count: u32,
    format: wgpu::IndexFormat,
}

#[repr(C)]
#[derive(Copy, Clone, bytemuck::Pod, bytemuck::Zeroable)]
pub struct Vertex2D {
    pub position: [f32; 2],
    pub tex_coords: [f32; 2],
    pub color: [f32; 4],
}

impl Vertex2D {
    pub fn desc() -> wgpu::VertexBufferLayout<'static>;
}
```

### Task 2: Create basic WGSL shader

**File:** `opta-native/opta-render/shaders/basic.wgsl`

```wgsl
struct VertexInput {
    @location(0) position: vec2<f32>,
    @location(1) tex_coords: vec2<f32>,
    @location(2) color: vec4<f32>,
}

struct VertexOutput {
    @builtin(position) clip_position: vec4<f32>,
    @location(0) tex_coords: vec2<f32>,
    @location(1) color: vec4<f32>,
}

struct Uniforms {
    view_proj: mat4x4<f32>,
    time: f32,
    _padding: vec3<f32>,
}

@group(0) @binding(0) var<uniform> uniforms: Uniforms;

@vertex
fn vs_main(in: VertexInput) -> VertexOutput {
    var out: VertexOutput;
    out.clip_position = uniforms.view_proj * vec4<f32>(in.position, 0.0, 1.0);
    out.tex_coords = in.tex_coords;
    out.color = in.color;
    return out;
}

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
    return in.color;
}
```

### Task 3: Implement render pipeline

**File:** `opta-native/opta-render/src/pipeline.rs`

```rust
pub struct RenderPipeline2D {
    pipeline: wgpu::RenderPipeline,
    bind_group_layout: wgpu::BindGroupLayout,
    uniform_buffer: wgpu::Buffer,
    bind_group: wgpu::BindGroup,
}

impl RenderPipeline2D {
    pub fn new(device: &wgpu::Device, surface_format: wgpu::TextureFormat) -> Self;

    pub fn update_uniforms(&self, queue: &wgpu::Queue, uniforms: &Uniforms);

    pub fn begin_render_pass<'a>(
        &'a self,
        encoder: &'a mut wgpu::CommandEncoder,
        view: &'a wgpu::TextureView,
        clear_color: wgpu::Color,
    ) -> wgpu::RenderPass<'a>;
}

#[repr(C)]
#[derive(Copy, Clone, bytemuck::Pod, bytemuck::Zeroable)]
pub struct Uniforms {
    pub view_proj: [[f32; 4]; 4],
    pub time: f32,
    pub _padding: [f32; 3],
}
```

### Task 4: Implement depth buffer (optional)

**File:** `opta-native/opta-render/src/depth.rs`

```rust
pub struct DepthBuffer {
    texture: wgpu::Texture,
    view: wgpu::TextureView,
}

impl DepthBuffer {
    pub const FORMAT: wgpu::TextureFormat = wgpu::TextureFormat::Depth32Float;

    pub fn new(device: &wgpu::Device, width: u32, height: u32) -> Self;

    pub fn resize(&mut self, device: &wgpu::Device, width: u32, height: u32);

    pub fn view(&self) -> &wgpu::TextureView;
}
```

### Task 5: Implement command encoder wrapper

**File:** `opta-native/opta-render/src/encoder.rs`

```rust
pub struct FrameEncoder {
    encoder: wgpu::CommandEncoder,
}

impl FrameEncoder {
    pub fn new(device: &wgpu::Device) -> Self;

    pub fn begin_render_pass(
        &mut self,
        color_view: &wgpu::TextureView,
        depth_view: Option<&wgpu::TextureView>,
        clear_color: wgpu::Color,
    ) -> wgpu::RenderPass;

    pub fn finish(self) -> wgpu::CommandBuffer;
}
```

### Task 6: Add bytemuck dependency

**File:** `opta-native/opta-render/Cargo.toml`

```toml
[dependencies]
bytemuck = { version = "1.20", features = ["derive"] }
```

### Task 7: Wire up module exports

**File:** `opta-native/opta-render/src/lib.rs`

```rust
mod buffer;
mod depth;
mod encoder;
mod ffi;
mod instance;
mod pipeline;
mod surface;

pub use buffer::{IndexBuffer, Vertex2D, VertexBuffer};
pub use depth::DepthBuffer;
pub use encoder::FrameEncoder;
pub use instance::{GpuCapabilities, GpuContext};
pub use pipeline::{RenderPipeline2D, Uniforms};
pub use surface::RenderSurface;
```

## Verification

```bash
cd opta-native
cargo check -p opta-render
cargo clippy -p opta-render -- -D warnings

# Verify shader compiles
cargo build -p opta-render
```

## Success Criteria

- [ ] Vertex2D struct with proper memory layout
- [ ] WGSL shader compiles without errors
- [ ] RenderPipeline2D creates valid wgpu pipeline
- [ ] TBDR-optimized LoadOp/StoreOp configuration
- [ ] All types properly exported from crate

## Output

- Complete 2D render pipeline for UI rendering
- WGSL shader for basic geometry
- Buffer management utilities
- Ready for frame timing integration (Plan 60-03)
