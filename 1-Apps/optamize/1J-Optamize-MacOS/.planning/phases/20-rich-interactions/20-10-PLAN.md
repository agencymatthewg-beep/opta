# Plan 20-10: Menu Bar Extra - State Sync

**Phase:** 20 - Rich Interactions
**Feature:** Real-Time State Synchronization with Binary IPC
**Scope:** Medium (2-3 days)
**Dependencies:** 20-08 (Swift Plugin), 20-09 (Popover UI)

---

## Summary

Implement high-performance state synchronization between the Rust backend and Swift Menu Bar using FlatBuffers binary serialization. Enables 25Hz+ data streaming without CPU spike, supporting real-time metrics updates for the Holographic System View and Momentum Border.

---

## Why This Matters

- **25Hz data streaming** - FlatBuffers zero-copy enables real-time updates
- **CPU efficiency** - Binary serialization prevents device heating
- **Momentum Border sync** - Border color/speed reflects live system state
- **Consistent state** - Menu Bar and main app share single source of truth
- **Native performance** - Direct memory access without JSON parsing

---

## Gemini Research Context

From Gemini Improvements (Critical):
- "Using JSON strings over the Rustâ†”Swift bridge for high-frequency data (25Hz tracking) causes massive serialization overhead and device heating"
- "FlatBuffers enables 'Zero-Copy' access - Rust writes coordinates to memory, Swift reads directly without parsing text"
- "This is the only way to achieve the '16ms Rule' while rendering live tracking data"

From Native Capability Across Platforms:
- "Local source of truth: UI observes local DB, never waits for network"
- "UI renders at 60/120Hz regardless of network jitter"
- "Background serialization: Parse data on dedicated threads, never main thread"

---

## Implementation Tasks

### Task 1: Install FlatBuffers in Rust backend
**Files:** `src-tauri/Cargo.toml`, `schemas/system_metrics.fbs`

**Actions:**
1. Add flatbuffers crate to Cargo.toml
2. Install flatc compiler for code generation
3. Create FlatBuffers schema for system metrics
4. Generate Rust code from schema

**Cargo.toml:**
```toml
[dependencies]
flatbuffers = "24.3"

[build-dependencies]
flatc-rust = "0.2"
```

**Schema (defined in 20-08, referenced here):**
```flatbuffers
// schemas/system_metrics.fbs
namespace Opta.Metrics;

table SystemMetrics {
  cpu_usage: float;
  memory_usage: float;
  memory_total: ulong;
  disk_usage: float;
  temperature: float;
  timestamp: ulong;
  top_processes: [ProcessInfo];
  momentum: MomentumState;
}

table ProcessInfo {
  pid: uint;
  name: string;
  cpu_percent: float;
  memory_mb: float;
}

table MomentumState {
  intensity: float;      // 0-1
  color: MomentumColor;
  rotation_speed: float;
}

enum MomentumColor : byte { Idle = 0, Active = 1, Critical = 2 }

root_type SystemMetrics;
```

**Build script addition:**
```rust
// build.rs
fn main() {
    flatc_rust::run(flatc_rust::Args {
        inputs: &[PathBuf::from("schemas/system_metrics.fbs")],
        out_dir: PathBuf::from("src/generated"),
        ..Default::default()
    }).expect("flatc failed");
}
```

**Verification:** `cargo build` generates Rust FlatBuffers code

---

### Task 2: Create FlatBuffers serialization in Rust
**File:** `src-tauri/src/ipc/flatbuffers_bridge.rs`

**Actions:**
1. Create serialization functions for SystemMetrics
2. Implement zero-copy buffer management
3. Add thread-safe buffer pool for reuse
4. Create momentum state calculation

**Code:**
```rust
// src-tauri/src/ipc/flatbuffers_bridge.rs
use flatbuffers::{FlatBufferBuilder, WIPOffset};
use crate::generated::system_metrics_generated::*;
use crate::telemetry::SystemMetrics as RawMetrics;

const BUFFER_SIZE: usize = 4096;

pub struct FlatBuffersSerializer {
    builder: FlatBufferBuilder<'static>,
}

impl FlatBuffersSerializer {
    pub fn new() -> Self {
        Self {
            builder: FlatBufferBuilder::with_capacity(BUFFER_SIZE),
        }
    }

    /// Serialize system metrics to binary FlatBuffer
    pub fn serialize_metrics(&mut self, metrics: &RawMetrics) -> &[u8] {
        self.builder.reset();

        // Serialize processes
        let processes: Vec<WIPOffset<ProcessInfo>> = metrics
            .top_processes
            .iter()
            .take(10) // Limit to top 10 for performance
            .map(|p| {
                let name = self.builder.create_string(&p.name);
                ProcessInfo::create(&mut self.builder, &ProcessInfoArgs {
                    pid: p.pid,
                    name: Some(name),
                    cpu_percent: p.cpu_percent,
                    memory_mb: p.memory_mb,
                })
            })
            .collect();

        let processes_vec = self.builder.create_vector(&processes);

        // Calculate momentum state from metrics
        let momentum = self.calculate_momentum(metrics);
        let momentum_offset = MomentumState::create(&mut self.builder, &MomentumStateArgs {
            intensity: momentum.0,
            color: momentum.1,
            rotation_speed: momentum.2,
        });

        // Create root table
        let system_metrics = SystemMetrics::create(&mut self.builder, &SystemMetricsArgs {
            cpu_usage: metrics.cpu_usage,
            memory_usage: metrics.memory_usage,
            memory_total: metrics.memory_total,
            disk_usage: metrics.disk_usage,
            temperature: metrics.temperature,
            timestamp: metrics.timestamp,
            top_processes: Some(processes_vec),
            momentum: Some(momentum_offset),
        });

        self.builder.finish(system_metrics, None);
        self.builder.finished_data()
    }

    /// Calculate momentum state from raw metrics
    /// Returns (intensity, color, rotation_speed)
    fn calculate_momentum(&self, metrics: &RawMetrics) -> (f32, MomentumColor, f32) {
        let cpu = metrics.cpu_usage;
        let memory = metrics.memory_usage;

        if cpu > 90.0 || memory > 85.0 {
            (1.0, MomentumColor::Critical, 3.0)
        } else if cpu > 60.0 || memory > 60.0 {
            (0.7, MomentumColor::Active, 1.5)
        } else {
            (0.3, MomentumColor::Idle, 0.5)
        }
    }
}

// Thread-safe wrapper for concurrent access
use std::sync::{Arc, Mutex};
use once_cell::sync::Lazy;

pub static SERIALIZER: Lazy<Arc<Mutex<FlatBuffersSerializer>>> =
    Lazy::new(|| Arc::new(Mutex::new(FlatBuffersSerializer::new())));
```

**Verification:** Serialization produces valid FlatBuffer data

---

### Task 3: Create Unix socket IPC server in Rust
**File:** `src-tauri/src/ipc/socket_server.rs`

**Actions:**
1. Create Unix socket listener for Menu Bar connection
2. Implement 25Hz data streaming loop
3. Handle connection lifecycle (connect/disconnect/reconnect)
4. Add graceful shutdown

**Code:**
```rust
// src-tauri/src/ipc/socket_server.rs
use std::os::unix::net::{UnixListener, UnixStream};
use std::io::Write;
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::time::Duration;
use tokio::sync::broadcast;

const SOCKET_PATH: &str = "/tmp/opta-metrics.sock";
const UPDATE_INTERVAL_MS: u64 = 40; // 25Hz

pub struct MetricsSocketServer {
    shutdown: Arc<AtomicBool>,
    metrics_rx: broadcast::Receiver<Vec<u8>>,
}

impl MetricsSocketServer {
    pub fn new(metrics_rx: broadcast::Receiver<Vec<u8>>) -> Self {
        Self {
            shutdown: Arc::new(AtomicBool::new(false)),
            metrics_rx,
        }
    }

    pub fn start(&self) {
        let shutdown = self.shutdown.clone();
        let mut metrics_rx = self.metrics_rx.resubscribe();

        std::thread::spawn(move || {
            // Remove existing socket file
            let _ = std::fs::remove_file(SOCKET_PATH);

            let listener = match UnixListener::bind(SOCKET_PATH) {
                Ok(l) => l,
                Err(e) => {
                    eprintln!("Failed to bind socket: {}", e);
                    return;
                }
            };

            // Set socket permissions
            let _ = std::fs::set_permissions(
                SOCKET_PATH,
                std::fs::Permissions::from_mode(0o666)
            );

            listener.set_nonblocking(true).ok();

            while !shutdown.load(Ordering::SeqCst) {
                // Accept new connections
                if let Ok((stream, _)) = listener.accept() {
                    Self::handle_client(stream, &mut metrics_rx, &shutdown);
                }

                std::thread::sleep(Duration::from_millis(100));
            }

            // Cleanup
            let _ = std::fs::remove_file(SOCKET_PATH);
        });
    }

    fn handle_client(
        mut stream: UnixStream,
        metrics_rx: &mut broadcast::Receiver<Vec<u8>>,
        shutdown: &Arc<AtomicBool>,
    ) {
        stream.set_write_timeout(Some(Duration::from_millis(100))).ok();

        while !shutdown.load(Ordering::SeqCst) {
            match metrics_rx.try_recv() {
                Ok(data) => {
                    // Write length prefix (4 bytes, big-endian)
                    let len = (data.len() as u32).to_be_bytes();
                    if stream.write_all(&len).is_err() {
                        break;
                    }
                    // Write FlatBuffer data
                    if stream.write_all(&data).is_err() {
                        break;
                    }
                }
                Err(broadcast::error::TryRecvError::Empty) => {
                    std::thread::sleep(Duration::from_millis(UPDATE_INTERVAL_MS));
                }
                Err(_) => break,
            }
        }
    }

    pub fn stop(&self) {
        self.shutdown.store(true, Ordering::SeqCst);
    }
}
```

**Verification:** Socket server accepts connections, streams data at 25Hz

---

### Task 4: Create metrics broadcast system
**File:** `src-tauri/src/ipc/metrics_broadcaster.rs`

**Actions:**
1. Create broadcast channel for metrics updates
2. Subscribe telemetry collector to broadcast
3. Serialize and broadcast at 25Hz rate limit
4. Handle backpressure gracefully

**Code:**
```rust
// src-tauri/src/ipc/metrics_broadcaster.rs
use tokio::sync::broadcast;
use std::time::{Duration, Instant};
use crate::telemetry::SystemMetrics;
use crate::ipc::flatbuffers_bridge::SERIALIZER;

const BROADCAST_RATE_HZ: u64 = 25;
const MIN_INTERVAL: Duration = Duration::from_millis(1000 / BROADCAST_RATE_HZ);

pub struct MetricsBroadcaster {
    tx: broadcast::Sender<Vec<u8>>,
    last_broadcast: Instant,
}

impl MetricsBroadcaster {
    pub fn new() -> (Self, broadcast::Receiver<Vec<u8>>) {
        let (tx, rx) = broadcast::channel(16); // Buffer 16 frames
        (
            Self {
                tx,
                last_broadcast: Instant::now(),
            },
            rx,
        )
    }

    /// Called when new metrics are available
    pub fn broadcast(&mut self, metrics: &SystemMetrics) {
        // Rate limit to 25Hz
        let elapsed = self.last_broadcast.elapsed();
        if elapsed < MIN_INTERVAL {
            return;
        }

        // Serialize to FlatBuffer
        let data = {
            let mut serializer = SERIALIZER.lock().unwrap();
            serializer.serialize_metrics(metrics).to_vec()
        };

        // Broadcast (ignore errors if no receivers)
        let _ = self.tx.send(data);
        self.last_broadcast = Instant::now();
    }

    /// Get a new receiver for the broadcast
    pub fn subscribe(&self) -> broadcast::Receiver<Vec<u8>> {
        self.tx.subscribe()
    }
}
```

**Verification:** Metrics broadcast at 25Hz, no backpressure issues

---

### Task 5: Update Swift FlatBuffers bridge
**File:** `src-tauri/swift-plugin/Sources/OptaMenuBar/FlatBuffersBridge.swift`

**Actions:**
1. Implement FlatBuffers deserialization in Swift
2. Handle length-prefixed message parsing
3. Create Swift types matching schema
4. Support zero-copy access where possible

**Code:**
```swift
// FlatBuffersBridge.swift (expanded from 20-08)
import Foundation
import FlatBuffers

final class FlatBuffersBridge {
    private var buffer: ByteBuffer?

    /// Parse length-prefixed binary message from socket
    func parseMessage(data: Data) -> SystemMetrics? {
        guard data.count >= 4 else { return nil }

        // Read length prefix (big-endian u32)
        let length = data.withUnsafeBytes { ptr -> UInt32 in
            ptr.load(fromByteOffset: 0, as: UInt32.self).bigEndian
        }

        guard data.count >= 4 + Int(length) else { return nil }

        // Extract FlatBuffer payload
        let payload = data.subdata(in: 4..<(4 + Int(length)))

        return parseMetrics(data: payload)
    }

    /// Parse FlatBuffer data to SystemMetrics
    func parseMetrics(data: Data) -> SystemMetrics? {
        var byteBuffer = ByteBuffer(data: data)
        return getRoot(byteBuffer: &byteBuffer)
    }

    /// Zero-copy accessor for CPU usage
    func getCPUUsage(from metrics: SystemMetrics) -> Float {
        return metrics.cpuUsage
    }

    /// Zero-copy accessor for memory usage
    func getMemoryUsage(from metrics: SystemMetrics) -> Float {
        return metrics.memoryUsage
    }

    /// Get momentum state for UI binding
    func getMomentumState(from metrics: SystemMetrics) -> MomentumState {
        guard let fb_momentum = metrics.momentum else {
            return MomentumState(intensity: 0.3, color: .idle, rotationSpeed: 0.5)
        }

        let color: MomentumColor = {
            switch fb_momentum.color {
            case .Critical: return .critical
            case .Active: return .active
            default: return .idle
            }
        }()

        return MomentumState(
            intensity: fb_momentum.intensity,
            color: color,
            rotationSpeed: fb_momentum.rotationSpeed
        )
    }

    /// Get top processes for Holographic View
    func getTopProcesses(from metrics: SystemMetrics) -> [ProcessInfo] {
        guard let count = metrics.topProcessesCount else { return [] }

        return (0..<count).compactMap { i in
            metrics.topProcesses(at: i)
        }.map { fb_process in
            ProcessInfo(
                pid: fb_process.pid,
                name: fb_process.name ?? "Unknown",
                cpuPercent: fb_process.cpuPercent,
                memoryMb: fb_process.memoryMb
            )
        }
    }
}

// Swift data types (matching FlatBuffers schema)
struct ProcessInfo: Identifiable {
    let pid: UInt32
    let name: String
    let cpuPercent: Float
    let memoryMb: Float

    var id: UInt32 { pid }
}

struct MomentumState {
    let intensity: Float
    let color: MomentumColor
    let rotationSpeed: Float
}

enum MomentumColor {
    case idle, active, critical

    var swiftUIColor: Color {
        switch self {
        case .idle: return .purple.opacity(0.5)
        case .active: return .cyan
        case .critical: return .red
        }
    }
}
```

**Verification:** Swift correctly deserializes FlatBuffer data

---

### Task 6: Update IPCHandler for streaming
**File:** `src-tauri/swift-plugin/Sources/OptaMenuBar/IPCHandler.swift`

**Actions:**
1. Connect to Unix socket on startup
2. Read length-prefixed messages continuously
3. Parse with FlatBuffersBridge
4. Update MetricsStore on main thread

**Code:**
```swift
// IPCHandler.swift (expanded from 20-08)
import Foundation

final class IPCHandler {
    static let shared = IPCHandler()

    private let socketPath = "/tmp/opta-metrics.sock"
    private var socket: FileHandle?
    private var readBuffer = Data()
    private let bridge = FlatBuffersBridge()

    var onMetricsUpdate: ((SystemMetrics) -> Void)?

    private init() {}

    func start() {
        connect()
    }

    private func connect() {
        DispatchQueue.global(qos: .userInitiated).async { [weak self] in
            guard let self = self else { return }

            // Create socket
            let socketFD = socket(AF_UNIX, SOCK_STREAM, 0)
            guard socketFD >= 0 else {
                self.scheduleReconnect()
                return
            }

            // Connect to server
            var addr = sockaddr_un()
            addr.sun_family = sa_family_t(AF_UNIX)
            self.socketPath.withCString { ptr in
                withUnsafeMutablePointer(to: &addr.sun_path.0) { dest in
                    strcpy(dest, ptr)
                }
            }

            let result = withUnsafePointer(to: &addr) { ptr in
                ptr.withMemoryRebound(to: sockaddr.self, capacity: 1) { sockPtr in
                    Darwin.connect(socketFD, sockPtr, socklen_t(MemoryLayout<sockaddr_un>.size))
                }
            }

            if result == 0 {
                self.socket = FileHandle(fileDescriptor: socketFD, closeOnDealloc: true)
                self.startReading()
            } else {
                close(socketFD)
                self.scheduleReconnect()
            }
        }
    }

    private func startReading() {
        socket?.readabilityHandler = { [weak self] handle in
            guard let self = self else { return }

            let data = handle.availableData
            if data.isEmpty {
                self.scheduleReconnect()
                return
            }

            self.readBuffer.append(data)
            self.processBuffer()
        }
    }

    private func processBuffer() {
        // Process all complete messages in buffer
        while readBuffer.count >= 4 {
            // Read length prefix
            let length = readBuffer.withUnsafeBytes { ptr -> UInt32 in
                ptr.load(fromByteOffset: 0, as: UInt32.self).bigEndian
            }

            let messageSize = 4 + Int(length)
            guard readBuffer.count >= messageSize else { break }

            // Extract complete message
            let messageData = readBuffer.prefix(messageSize)

            // Parse and notify
            if let metrics = bridge.parseMessage(data: Data(messageData)) {
                DispatchQueue.main.async { [weak self] in
                    self?.onMetricsUpdate?(metrics)
                }
            }

            // Remove processed message from buffer
            readBuffer.removeFirst(messageSize)
        }
    }

    private func scheduleReconnect() {
        socket?.readabilityHandler = nil
        socket = nil
        readBuffer.removeAll()

        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) { [weak self] in
            self?.connect()
        }
    }

    /// Invoke command on Rust backend (for actions)
    func invoke(_ command: String, params: [String: Any]? = nil, completion: @escaping (Result<Data, Error>) -> Void) {
        // Use Tauri invoke for commands (separate from metrics stream)
        // This handles Quick Actions, Settings changes, etc.
    }
}
```

**Verification:** Continuous streaming works, reconnects on disconnect

---

### Task 7: Update MetricsStore for reactive updates
**File:** `src-tauri/swift-plugin/Sources/OptaMenuBar/MetricsStore.swift`

**Actions:**
1. Subscribe to IPC updates
2. Update published properties reactively
3. Throttle UI updates if needed
4. Calculate derived state (system state, momentum)

**Code:**
```swift
// MetricsStore.swift
import SwiftUI
import Combine

@MainActor
final class MetricsStore: ObservableObject {
    @Published var currentMetrics: SystemMetrics?
    @Published var momentum: MomentumState = MomentumState(intensity: 0.3, color: .idle, rotationSpeed: 0.5)
    @Published var systemState: SystemState = .idle
    @Published var topProcesses: [ProcessInfo] = []

    private let bridge = FlatBuffersBridge()
    private var cancellables = Set<AnyCancellable>()

    init() {
        setupIPC()
    }

    private func setupIPC() {
        IPCHandler.shared.onMetricsUpdate = { [weak self] metrics in
            self?.handleMetricsUpdate(metrics)
        }
        IPCHandler.shared.start()
    }

    private func handleMetricsUpdate(_ metrics: SystemMetrics) {
        // Update raw metrics
        currentMetrics = metrics

        // Update derived state
        momentum = bridge.getMomentumState(from: metrics)
        topProcesses = bridge.getTopProcesses(from: metrics)
        systemState = SystemState.from(
            cpu: metrics.cpuUsage,
            memory: metrics.memoryUsage
        )
    }
}

// Chromatic aberration integration for loading states
extension MetricsStore {
    /// Check if system is under heavy load (trigger chromatic effect)
    var isUnderHeavyLoad: Bool {
        systemState == .critical
    }

    /// Intensity for chromatic aberration effect based on system load
    var chromaticIntensity: Float {
        switch systemState {
        case .critical: return 0.8
        case .busy: return 0.4
        case .idle: return 0.0
        }
    }
}
```

**Verification:** UI updates reactively at 25Hz, no dropped frames

---

### Task 8: Performance testing and optimization
**File:** Various

**Actions:**
1. Profile IPC latency (target <1ms)
2. Measure CPU usage during streaming (target <2%)
3. Verify no thermal throttling during sustained operation
4. Test reconnection reliability
5. Verify chromatic aberration triggers correctly on system state changes

**Performance targets (per Gemini):**
- IPC latency: <1ms (vs ~5ms for JSON)
- CPU usage: <2% during 25Hz streaming
- No thermal throttling during sustained operation
- Reconnection within 2 seconds of disconnect

**Verification commands:**
```bash
# Monitor CPU usage
top -pid $(pgrep -f OptaMenuBar)

# Profile IPC latency
instruments -t "Time Profiler" -D /tmp/opta-ipc.trace -p $(pgrep -f OptaMenuBar)

# Check thermal state
pmset -g thermlog
```

**Verification:** All performance targets met

---

## Verification Checklist

- [ ] FlatBuffers generates Rust and Swift code
- [ ] Serialization produces valid binary data
- [ ] Unix socket server binds successfully
- [ ] Swift client connects to socket
- [ ] **Chromatic aberration triggers on critical system state**
- [ ] Data streams at 25Hz without drops
- [ ] IPC latency <1ms
- [ ] CPU usage <2% during streaming
- [ ] No thermal throttling during sustained operation
- [ ] Reconnection works reliably
- [ ] Momentum state syncs to UI correctly
- [ ] Holographic View receives process data
- [ ] Memory usage stable (no leaks)
- [ ] `cargo build` passes
- [ ] `swift build` passes

---

## Files Created/Modified

| File | Action |
|------|--------|
| `src-tauri/Cargo.toml` | Add flatbuffers dependency |
| `src-tauri/build.rs` | Add flatc generation |
| `schemas/system_metrics.fbs` | Create (shared with 20-08) |
| `src-tauri/src/generated/` | Generated FlatBuffers code |
| `src-tauri/src/ipc/mod.rs` | Create IPC module |
| `src-tauri/src/ipc/flatbuffers_bridge.rs` | Create |
| `src-tauri/src/ipc/socket_server.rs` | Create |
| `src-tauri/src/ipc/metrics_broadcaster.rs` | Create |
| `src-tauri/swift-plugin/Sources/OptaMenuBar/FlatBuffersBridge.swift` | Expand |
| `src-tauri/swift-plugin/Sources/OptaMenuBar/IPCHandler.swift` | Expand |
| `src-tauri/swift-plugin/Sources/OptaMenuBar/MetricsStore.swift` | Create |

---

## Research Reference

From Gemini Improvements:
- "FlatBuffers for IPC - Zero-Copy access"
- "Binary serialization prevents device heating at 25Hz"
- "Only way to achieve 16ms Rule while rendering live tracking data"

From Native Capability:
- "Local source of truth pattern"
- "UI renders at 60/120Hz regardless of network jitter"
- "Background serialization on dedicated threads"

---

## Platform Notes

- **Unix sockets** - macOS only (Windows would need named pipes)
- **FlatBuffers Swift** - Uses nicklockwood/FlatBuffersSwift package
- **Zero-copy** - Requires careful buffer management
- **Thread safety** - Serializer uses mutex for concurrent access

---

*Plan created: 2026-01-17*
*Ready for execution: yes*
*Execute after: 20-08 (Swift Plugin), 20-09 (Popover UI)*
