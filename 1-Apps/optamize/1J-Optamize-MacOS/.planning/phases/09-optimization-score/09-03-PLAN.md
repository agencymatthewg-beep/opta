---
phase: 09-optimization-score
plan: 03
type: execute
wave: 2
depends_on: ["09-01"]
files_modified: [src/components/Leaderboard.tsx, src/components/HardwareTierFilter.tsx, src/components/MilestoneBadges.tsx, src/components/BadgeCard.tsx, src/types/badges.ts, mcp-server/src/opta_mcp/badges.py, mcp-server/src/opta_mcp/server.py, src/hooks/useBadges.ts, src/pages/Score.tsx]
autonomous: true
---

<objective>
Implement leaderboard with hardware tier filtering and milestone badge system.

Purpose: Create comparison features that drive engagement and viral sharing. Users can see how they rank against similar hardware, different tiers, or globally. Milestone badges provide professional achievements that users can share.

Output: Leaderboard component with filtering, badge system with achievement tracking, integration into Score page.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/MUST_HAVE.md
@DESIGN_SYSTEM.md

# Scoring types from 09-01:
@src/types/scoring.ts

# UI patterns:
@src/components/OptaScoreCard.tsx (from 09-02)
@src/pages/Score.tsx (from 09-02)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define badge types</name>
  <files>src/types/badges.ts</files>
  <action>
Create TypeScript types for the milestone badge system:

```typescript
/**
 * Milestone badge types from MUST_HAVE.md
 */

export type BadgeCategory =
  | 'performance'    // FPS gains, optimization wins
  | 'consistency'    // Long-term usage
  | 'ranking'        // Percentile achievements
  | 'exploration';   // Trying features, games

export type BadgeRarity = 'common' | 'rare' | 'epic' | 'legendary';

export interface Badge {
  id: string;
  name: string;
  description: string;
  category: BadgeCategory;
  rarity: BadgeRarity;
  icon: string;           // Lucide icon name
  requirement: string;    // Human-readable requirement
  progress: number;       // 0-100 current progress
  unlockedAt: number | null;  // Timestamp when earned
  isNew: boolean;         // Just unlocked, not yet seen
}

export interface BadgeDefinition {
  id: string;
  name: string;
  description: string;
  category: BadgeCategory;
  rarity: BadgeRarity;
  icon: string;
  requirement: string;
  checkProgress: (stats: UserStats) => number;  // Returns 0-100
}

export interface UserStats {
  totalFpsGained: number;
  totalOptimizations: number;
  gamesOptimized: number;
  daysActive: number;
  percentileRank: number;
  streakDays: number;  // Consecutive days optimizing
  hardwareTier: string;
}

// Badge definitions from MUST_HAVE.md
export const BADGE_DEFINITIONS: BadgeDefinition[] = [
  // Performance badges
  {
    id: 'first-10-fps',
    name: 'First Boost',
    description: 'Your first 10 FPS gained across all games',
    category: 'performance',
    rarity: 'common',
    icon: 'Zap',
    requirement: 'Gain 10 total FPS',
    checkProgress: (stats) => Math.min(100, (stats.totalFpsGained / 10) * 100)
  },
  {
    id: 'fps-50',
    name: 'Frame Hunter',
    description: 'Gained 50 FPS total across all games',
    category: 'performance',
    rarity: 'rare',
    icon: 'Flame',
    requirement: 'Gain 50 total FPS',
    checkProgress: (stats) => Math.min(100, (stats.totalFpsGained / 50) * 100)
  },
  {
    id: 'fps-100',
    name: 'Frame Master',
    description: 'Gained 100 FPS total - you are optimized',
    category: 'performance',
    rarity: 'epic',
    icon: 'Crown',
    requirement: 'Gain 100 total FPS',
    checkProgress: (stats) => Math.min(100, (stats.totalFpsGained / 100) * 100)
  },

  // Consistency badges
  {
    id: 'optimized-30-days',
    name: 'Steady State',
    description: 'System optimized for 30 days',
    category: 'consistency',
    rarity: 'rare',
    icon: 'Shield',
    requirement: 'Stay optimized for 30 days',
    checkProgress: (stats) => Math.min(100, (stats.daysActive / 30) * 100)
  },

  // Ranking badges
  {
    id: 'top-50-percent',
    name: 'Above Average',
    description: 'In the top 50% of your hardware tier',
    category: 'ranking',
    rarity: 'common',
    icon: 'TrendingUp',
    requirement: 'Reach top 50% in your tier',
    checkProgress: (stats) => stats.percentileRank >= 50 ? 100 : (stats.percentileRank / 50) * 100
  },
  {
    id: 'top-10-percent',
    name: 'Elite Optimizer',
    description: 'In the top 10% of your hardware tier',
    category: 'ranking',
    rarity: 'epic',
    icon: 'Award',
    requirement: 'Reach top 10% in your tier',
    checkProgress: (stats) => stats.percentileRank >= 90 ? 100 : (stats.percentileRank / 90) * 100
  },
  {
    id: 'top-1-percent',
    name: 'Legendary',
    description: 'In the top 1% globally',
    category: 'ranking',
    rarity: 'legendary',
    icon: 'Star',
    requirement: 'Reach top 1% globally',
    checkProgress: (stats) => stats.percentileRank >= 99 ? 100 : (stats.percentileRank / 99) * 100
  },

  // Exploration badges
  {
    id: 'games-5',
    name: 'Game Explorer',
    description: 'Optimized 5 different games',
    category: 'exploration',
    rarity: 'common',
    icon: 'Gamepad2',
    requirement: 'Optimize 5 games',
    checkProgress: (stats) => Math.min(100, (stats.gamesOptimized / 5) * 100)
  },
  {
    id: 'games-10',
    name: 'Library Master',
    description: 'Optimized 10 different games',
    category: 'exploration',
    rarity: 'rare',
    icon: 'Library',
    requirement: 'Optimize 10 games',
    checkProgress: (stats) => Math.min(100, (stats.gamesOptimized / 10) * 100)
  }
];

export interface BadgeResponse {
  badges: Badge[];
  newUnlocks: string[];  // Badge IDs just unlocked
  stats: UserStats;
}
```
  </action>
  <verify>npm run build passes with badge types</verify>
  <done>Badge types and definitions created for milestone achievement system</done>
</task>

<task type="auto">
  <name>Task 2: Create badge backend</name>
  <files>mcp-server/src/opta_mcp/badges.py, mcp-server/src/opta_mcp/server.py</files>
  <action>
Create Python badge module:

```python
"""
Milestone badge system for gamification.
"""
import json
import time
from pathlib import Path
from typing import Dict, List, Optional
from dataclasses import dataclass, asdict
from .scoring import get_all_scores, get_global_stats

BADGES_DIR = Path.home() / ".opta" / "badges"

# Badge definitions (mirrors TypeScript)
BADGE_DEFINITIONS = [
    {
        "id": "first-10-fps",
        "name": "First Boost",
        "category": "performance",
        "rarity": "common",
        "requirement_key": "totalFpsGained",
        "requirement_value": 10
    },
    {
        "id": "fps-50",
        "name": "Frame Hunter",
        "category": "performance",
        "rarity": "rare",
        "requirement_key": "totalFpsGained",
        "requirement_value": 50
    },
    {
        "id": "fps-100",
        "name": "Frame Master",
        "category": "performance",
        "rarity": "epic",
        "requirement_key": "totalFpsGained",
        "requirement_value": 100
    },
    {
        "id": "optimized-30-days",
        "name": "Steady State",
        "category": "consistency",
        "rarity": "rare",
        "requirement_key": "daysActive",
        "requirement_value": 30
    },
    {
        "id": "top-50-percent",
        "name": "Above Average",
        "category": "ranking",
        "rarity": "common",
        "requirement_key": "percentileRank",
        "requirement_value": 50
    },
    {
        "id": "top-10-percent",
        "name": "Elite Optimizer",
        "category": "ranking",
        "rarity": "epic",
        "requirement_key": "percentileRank",
        "requirement_value": 90
    },
    {
        "id": "games-5",
        "name": "Game Explorer",
        "category": "exploration",
        "rarity": "common",
        "requirement_key": "gamesOptimized",
        "requirement_value": 5
    },
    {
        "id": "games-10",
        "name": "Library Master",
        "category": "exploration",
        "rarity": "rare",
        "requirement_key": "gamesOptimized",
        "requirement_value": 10
    }
]


def get_user_stats() -> dict:
    """Calculate current user stats for badge evaluation."""
    all_scores = get_all_scores()
    global_stats = get_global_stats()

    # Calculate total FPS gained
    total_fps = sum(
        s.get('breakdown', {}).get('performance_score', 0) * 0.5
        for s in all_scores
    )

    # Days active (from first optimization to now)
    if all_scores:
        first_timestamp = min(s.get('calculated_at', time.time()) for s in all_scores)
        days_active = (time.time() - first_timestamp) / 86400
    else:
        days_active = 0

    # Percentile (use average score position)
    percentile = 50  # Default, will be calculated from actual data

    return {
        "totalFpsGained": int(total_fps),
        "totalOptimizations": global_stats.get("total_games_optimized", 0) * 3,  # Estimate
        "gamesOptimized": global_stats.get("total_games_optimized", 0),
        "daysActive": int(days_active),
        "percentileRank": percentile,
        "streakDays": 0,  # Future implementation
        "hardwareTier": "midrange"  # From profile
    }


def check_badges() -> dict:
    """Check all badges and return current state."""
    BADGES_DIR.mkdir(parents=True, exist_ok=True)
    badges_file = BADGES_DIR / "badges.json"

    # Load existing badges
    existing = {}
    if badges_file.exists():
        try:
            with open(badges_file, 'r') as f:
                existing = json.load(f)
        except Exception:
            existing = {}

    # Get current stats
    stats = get_user_stats()

    # Evaluate each badge
    badges = []
    new_unlocks = []

    for defn in BADGE_DEFINITIONS:
        badge_id = defn["id"]
        req_key = defn["requirement_key"]
        req_value = defn["requirement_value"]

        # Calculate progress
        current_value = stats.get(req_key, 0)
        progress = min(100, (current_value / req_value) * 100)
        is_unlocked = progress >= 100

        # Check if newly unlocked
        was_unlocked = existing.get(badge_id, {}).get("unlockedAt") is not None
        is_new = is_unlocked and not was_unlocked

        if is_new:
            new_unlocks.append(badge_id)

        badge = {
            "id": badge_id,
            "name": defn["name"],
            "category": defn["category"],
            "rarity": defn["rarity"],
            "progress": round(progress, 1),
            "unlockedAt": time.time() if is_unlocked else None,
            "isNew": is_new
        }
        badges.append(badge)

    # Save updated badges
    badges_dict = {b["id"]: b for b in badges}
    with open(badges_file, 'w') as f:
        json.dump(badges_dict, f, indent=2)

    return {
        "badges": badges,
        "newUnlocks": new_unlocks,
        "stats": stats
    }


def mark_badge_seen(badge_id: str) -> dict:
    """Mark a badge as seen (no longer new)."""
    badges_file = BADGES_DIR / "badges.json"
    if not badges_file.exists():
        return {"success": False, "error": "No badges file"}

    with open(badges_file, 'r') as f:
        badges = json.load(f)

    if badge_id in badges:
        badges[badge_id]["isNew"] = False
        with open(badges_file, 'w') as f:
            json.dump(badges, f, indent=2)
        return {"success": True}

    return {"success": False, "error": "Badge not found"}
```

Add MCP tools in server.py:
```python
Tool(
    name="check_badges",
    description="Check all badges and return current state with progress",
    inputSchema={"type": "object", "properties": {}}
),
Tool(
    name="mark_badge_seen",
    description="Mark a badge as seen (remove 'new' indicator)",
    inputSchema={
        "type": "object",
        "properties": {"badge_id": {"type": "string"}},
        "required": ["badge_id"]
    }
)
```
  </action>
  <verify>Python: `python -c "from opta_mcp.badges import check_badges"`</verify>
  <done>Badge backend with progress tracking and persistence implemented</done>
</task>

<task type="auto">
  <name>Task 3: Create HardwareTierFilter component</name>
  <files>src/components/HardwareTierFilter.tsx</files>
  <action>
Create filter component for leaderboard comparison:

```typescript
import { motion } from 'framer-motion';
import { Filter, Cpu, DollarSign, TrendingUp, Globe } from 'lucide-react';
import { cn } from '@/lib/utils';

export type FilterMode = 'similar' | 'price' | 'performance' | 'global';

interface HardwareTierFilterProps {
  currentFilter: FilterMode;
  onFilterChange: (filter: FilterMode) => void;
  hardwareTier?: string;  // User's detected tier for display
}

const filterOptions: Array<{
  value: FilterMode;
  label: string;
  description: string;
  icon: React.ComponentType<{ className?: string }>;
}> = [
  {
    value: 'similar',
    label: 'Similar Hardware',
    description: 'RTX 4070 + Ryzen 7 tier',
    icon: Cpu
  },
  {
    value: 'price',
    label: 'Price Tier',
    description: 'Mid-range ($800-1200)',
    icon: DollarSign
  },
  {
    value: 'performance',
    label: 'Performance Tier',
    description: 'Based on benchmark scores',
    icon: TrendingUp
  },
  {
    value: 'global',
    label: 'Global',
    description: 'All Opta users',
    icon: Globe
  }
];

export function HardwareTierFilter({
  currentFilter,
  onFilterChange,
  hardwareTier
}: HardwareTierFilterProps) {
  return (
    <div className="glass rounded-xl p-4 border border-border/30">
      <div className="flex items-center gap-2 mb-3">
        <Filter className="w-4 h-4 text-primary" />
        <span className="text-sm font-medium">Compare Against</span>
      </div>

      <div className="grid grid-cols-2 gap-2">
        {filterOptions.map((option) => {
          const Icon = option.icon;
          const isActive = currentFilter === option.value;

          return (
            <motion.button
              key={option.value}
              onClick={() => onFilterChange(option.value)}
              whileHover={{ scale: 1.02 }}
              whileTap={{ scale: 0.98 }}
              className={cn(
                'p-3 rounded-lg text-left transition-all',
                'border',
                isActive
                  ? 'glass border-primary/50 shadow-[0_0_12px_-4px_hsl(var(--glow-primary)/0.3)]'
                  : 'glass-subtle border-border/20 hover:border-border/40'
              )}
            >
              <div className="flex items-center gap-2 mb-1">
                <Icon className={cn(
                  'w-4 h-4',
                  isActive ? 'text-primary' : 'text-muted-foreground'
                )} />
                <span className={cn(
                  'text-sm font-medium',
                  isActive ? 'text-foreground' : 'text-muted-foreground'
                )}>
                  {option.label}
                </span>
              </div>
              <p className="text-xs text-muted-foreground/70">
                {option.value === 'similar' && hardwareTier
                  ? hardwareTier
                  : option.description}
              </p>
            </motion.button>
          );
        })}
      </div>
    </div>
  );
}
```

Implements MUST_HAVE "Flexible Hardware Comparison":
- Similar hardware: "RTX 4070 + Ryzen 7" tier (auto-detected)
- Price tier: Budget / Mid-range / High-end / Enthusiast
- Performance tier: Based on actual benchmark scores
- Global: Compare against all Opta users
  </action>
  <verify>npm run build passes, filter component renders</verify>
  <done>HardwareTierFilter provides four comparison modes from MUST_HAVE</done>
</task>

<task type="auto">
  <name>Task 4: Create Leaderboard component</name>
  <files>src/components/Leaderboard.tsx</files>
  <action>
Create leaderboard component with filtering:

```typescript
import { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Trophy, Medal, Award, User } from 'lucide-react';
import { cn } from '@/lib/utils';
import { HardwareTierFilter, FilterMode } from './HardwareTierFilter';
import type { LeaderboardEntry, HardwareTier } from '@/types/scoring';

interface LeaderboardProps {
  entries: LeaderboardEntry[];
  userRank?: number;
  userScore?: number;
  hardwareTier?: HardwareTier;
  loading?: boolean;
  onFilterChange?: (filter: FilterMode) => void;
}

export function Leaderboard({
  entries,
  userRank,
  userScore,
  hardwareTier,
  loading,
  onFilterChange
}: LeaderboardProps) {
  const [filter, setFilter] = useState<FilterMode>('similar');

  const handleFilterChange = (newFilter: FilterMode) => {
    setFilter(newFilter);
    onFilterChange?.(newFilter);
  };

  if (loading) {
    return <LeaderboardSkeleton />;
  }

  return (
    <motion.div
      initial={{ opacity: 0, y: 12 }}
      animate={{ opacity: 1, y: 0 }}
      className="space-y-4"
    >
      {/* Filter */}
      <HardwareTierFilter
        currentFilter={filter}
        onFilterChange={handleFilterChange}
        hardwareTier={hardwareTier?.signature}
      />

      {/* User's position highlight */}
      {userRank && userScore && (
        <motion.div
          initial={{ opacity: 0, scale: 0.95 }}
          animate={{ opacity: 1, scale: 1 }}
          className="glass rounded-xl p-4 border-2 border-primary/50"
        >
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-3">
              <div className="w-10 h-10 rounded-full glass flex items-center justify-center">
                <User className="w-5 h-5 text-primary" />
              </div>
              <div>
                <p className="text-sm font-medium">Your Position</p>
                <p className="text-xs text-muted-foreground">
                  Top {100 - Math.min(99, Math.round((userRank / entries.length) * 100))}%
                </p>
              </div>
            </div>
            <div className="text-right">
              <p className="text-2xl font-bold text-primary">#{userRank}</p>
              <p className="text-sm text-muted-foreground">{userScore} pts</p>
            </div>
          </div>
        </motion.div>
      )}

      {/* Leaderboard list */}
      <div className="glass rounded-xl border border-border/30 overflow-hidden">
        <div className="px-4 py-3 border-b border-border/20">
          <h3 className="text-sm font-semibold">Leaderboard</h3>
        </div>

        <div className="divide-y divide-border/10">
          <AnimatePresence mode="popLayout">
            {entries.slice(0, 10).map((entry, index) => (
              <LeaderboardRow
                key={entry.game_id}
                entry={entry}
                rank={index + 1}
                isUser={entry.rank === userRank}
              />
            ))}
          </AnimatePresence>
        </div>

        {entries.length === 0 && (
          <div className="py-12 text-center">
            <Trophy className="w-8 h-8 mx-auto text-muted-foreground/40 mb-3" />
            <p className="text-sm text-muted-foreground">
              No scores yet in this tier
            </p>
          </div>
        )}
      </div>
    </motion.div>
  );
}

function LeaderboardRow({
  entry,
  rank,
  isUser
}: {
  entry: LeaderboardEntry;
  rank: number;
  isUser: boolean;
}) {
  const RankIcon = rank === 1 ? Trophy : rank <= 3 ? Medal : Award;
  const rankColor = rank === 1 ? 'text-warning' : rank <= 3 ? 'text-muted-foreground' : 'text-muted-foreground/50';

  return (
    <motion.div
      initial={{ opacity: 0, x: -12 }}
      animate={{ opacity: 1, x: 0 }}
      exit={{ opacity: 0, x: 12 }}
      transition={{ delay: rank * 0.05 }}
      className={cn(
        'flex items-center gap-3 px-4 py-3 transition-colors',
        isUser && 'bg-primary/10'
      )}
    >
      {/* Rank */}
      <div className={cn('w-8 text-center font-bold', rankColor)}>
        {rank <= 3 ? (
          <RankIcon className="w-5 h-5 mx-auto" />
        ) : (
          <span>{rank}</span>
        )}
      </div>

      {/* Game/User info */}
      <div className="flex-1 min-w-0">
        <p className={cn(
          'text-sm font-medium truncate',
          isUser && 'text-primary'
        )}>
          {entry.game_name}
        </p>
        <p className="text-xs text-muted-foreground truncate">
          {entry.game_id}
        </p>
      </div>

      {/* Score */}
      <div className="text-right">
        <motion.p
          className="text-lg font-bold"
          initial={{ scale: 0.8 }}
          animate={{ scale: 1 }}
        >
          {entry.score}
        </motion.p>
      </div>
    </motion.div>
  );
}

function LeaderboardSkeleton() {
  return (
    <div className="space-y-4">
      <div className="h-32 rounded-xl bg-muted/30 animate-shimmer" />
      <div className="glass rounded-xl border border-border/30 divide-y divide-border/10">
        {[...Array(5)].map((_, i) => (
          <div key={i} className="flex items-center gap-3 px-4 py-3">
            <div className="w-8 h-8 rounded bg-muted/30 animate-shimmer" />
            <div className="flex-1 space-y-2">
              <div className="h-4 w-32 rounded bg-muted/30 animate-shimmer" />
              <div className="h-3 w-24 rounded bg-muted/30 animate-shimmer" />
            </div>
            <div className="h-6 w-12 rounded bg-muted/30 animate-shimmer" />
          </div>
        ))}
      </div>
    </div>
  );
}
```

Note: For v1, leaderboard shows local game scores. Friend comparison is a future feature placeholder.
  </action>
  <verify>npm run build passes, leaderboard renders with filter</verify>
  <done>Leaderboard component with hardware tier filtering implemented</done>
</task>

<task type="auto">
  <name>Task 5: Create BadgeCard and MilestoneBadges components</name>
  <files>src/components/BadgeCard.tsx, src/components/MilestoneBadges.tsx, src/hooks/useBadges.ts</files>
  <action>
1. Create useBadges hook (src/hooks/useBadges.ts):
```typescript
import { useState, useCallback, useEffect } from 'react';
import { invoke } from '@tauri-apps/api/core';
import type { Badge, BadgeResponse, UserStats } from '@/types/badges';

interface UseBadgesReturn {
  badges: Badge[];
  newUnlocks: string[];
  stats: UserStats | null;
  loading: boolean;
  refreshBadges: () => Promise<void>;
  markBadgeSeen: (badgeId: string) => Promise<void>;
}

export function useBadges(): UseBadgesReturn {
  const [badges, setBadges] = useState<Badge[]>([]);
  const [newUnlocks, setNewUnlocks] = useState<string[]>([]);
  const [stats, setStats] = useState<UserStats | null>(null);
  const [loading, setLoading] = useState(true);

  const refreshBadges = useCallback(async () => {
    setLoading(true);
    try {
      const result = await invoke<BadgeResponse>('check_badges');
      setBadges(result.badges);
      setNewUnlocks(result.newUnlocks);
      setStats(result.stats);
    } catch (e) {
      console.error('Failed to load badges:', e);
    } finally {
      setLoading(false);
    }
  }, []);

  const markBadgeSeen = useCallback(async (badgeId: string) => {
    try {
      await invoke('mark_badge_seen', { badgeId });
      setBadges(prev =>
        prev.map(b => b.id === badgeId ? { ...b, isNew: false } : b)
      );
      setNewUnlocks(prev => prev.filter(id => id !== badgeId));
    } catch (e) {
      console.error('Failed to mark badge seen:', e);
    }
  }, []);

  useEffect(() => {
    refreshBadges();
  }, [refreshBadges]);

  return { badges, newUnlocks, stats, loading, refreshBadges, markBadgeSeen };
}
```

2. Create BadgeCard component (src/components/BadgeCard.tsx):
```typescript
import { motion } from 'framer-motion';
import * as Icons from 'lucide-react';
import { cn } from '@/lib/utils';
import type { Badge } from '@/types/badges';

interface BadgeCardProps {
  badge: Badge;
  onClick?: () => void;
}

const rarityColors = {
  common: 'border-muted-foreground/30 text-muted-foreground',
  rare: 'border-primary/50 text-primary',
  epic: 'border-accent/50 text-accent',
  legendary: 'border-warning/50 text-warning'
};

const rarityGlows = {
  common: '',
  rare: 'shadow-[0_0_12px_-4px_hsl(var(--glow-primary)/0.3)]',
  epic: 'shadow-[0_0_16px_-4px_hsl(var(--accent)/0.4)]',
  legendary: 'shadow-[0_0_20px_-4px_hsl(var(--glow-warning)/0.5)]'
};

export function BadgeCard({ badge, onClick }: BadgeCardProps) {
  const IconComponent = (Icons as any)[badge.icon] || Icons.Award;
  const isUnlocked = badge.unlockedAt !== null;

  return (
    <motion.button
      onClick={onClick}
      whileHover={{ scale: 1.05, y: -2 }}
      whileTap={{ scale: 0.98 }}
      className={cn(
        'relative p-4 rounded-xl border-2 transition-all text-center',
        'glass',
        isUnlocked ? rarityColors[badge.rarity] : 'border-border/20 opacity-50',
        isUnlocked && rarityGlows[badge.rarity]
      )}
    >
      {/* New indicator */}
      {badge.isNew && (
        <motion.div
          initial={{ scale: 0 }}
          animate={{ scale: 1 }}
          className="absolute -top-1 -right-1 w-3 h-3 rounded-full bg-danger"
        />
      )}

      {/* Icon */}
      <div className={cn(
        'w-12 h-12 mx-auto mb-2 rounded-full flex items-center justify-center',
        isUnlocked ? 'glass' : 'bg-muted/20'
      )}>
        <IconComponent className={cn(
          'w-6 h-6',
          isUnlocked ? rarityColors[badge.rarity].split(' ')[1] : 'text-muted-foreground/30'
        )} />
      </div>

      {/* Name */}
      <p className={cn(
        'text-sm font-medium mb-1',
        !isUnlocked && 'text-muted-foreground/50'
      )}>
        {badge.name}
      </p>

      {/* Progress bar (if not unlocked) */}
      {!isUnlocked && (
        <div className="h-1 rounded-full bg-muted/30 overflow-hidden">
          <motion.div
            className="h-full bg-primary/50 rounded-full"
            initial={{ width: 0 }}
            animate={{ width: `${badge.progress}%` }}
          />
        </div>
      )}

      {/* Rarity label */}
      <p className="text-xs text-muted-foreground/50 mt-1 capitalize">
        {badge.rarity}
      </p>
    </motion.button>
  );
}
```

3. Create MilestoneBadges component (src/components/MilestoneBadges.tsx):
```typescript
import { motion, AnimatePresence } from 'framer-motion';
import { Award, Sparkles } from 'lucide-react';
import { cn } from '@/lib/utils';
import { BadgeCard } from './BadgeCard';
import { useBadges } from '@/hooks/useBadges';
import type { Badge, BadgeCategory } from '@/types/badges';

interface MilestoneBadgesProps {
  compact?: boolean;  // Show fewer badges
  category?: BadgeCategory;  // Filter by category
}

export function MilestoneBadges({ compact, category }: MilestoneBadgesProps) {
  const { badges, newUnlocks, loading, markBadgeSeen } = useBadges();

  const filteredBadges = category
    ? badges.filter(b => b.category === category)
    : badges;

  const displayBadges = compact
    ? filteredBadges.slice(0, 4)
    : filteredBadges;

  const unlockedCount = filteredBadges.filter(b => b.unlockedAt !== null).length;

  if (loading) {
    return <BadgesSkeleton compact={compact} />;
  }

  return (
    <motion.div
      initial={{ opacity: 0, y: 12 }}
      animate={{ opacity: 1, y: 0 }}
      className="glass rounded-xl p-4 border border-border/30"
    >
      {/* Header */}
      <div className="flex items-center justify-between mb-4">
        <div className="flex items-center gap-2">
          <Award className="w-5 h-5 text-primary" />
          <h3 className="text-sm font-semibold">Milestones</h3>
        </div>
        <span className="text-xs text-muted-foreground">
          {unlockedCount}/{filteredBadges.length} unlocked
        </span>
      </div>

      {/* New unlock notification */}
      <AnimatePresence>
        {newUnlocks.length > 0 && (
          <motion.div
            initial={{ opacity: 0, height: 0 }}
            animate={{ opacity: 1, height: 'auto' }}
            exit={{ opacity: 0, height: 0 }}
            className="mb-4 p-3 rounded-lg bg-success/10 border border-success/30"
          >
            <div className="flex items-center gap-2">
              <Sparkles className="w-4 h-4 text-success" />
              <span className="text-sm font-medium text-success">
                {newUnlocks.length} new badge{newUnlocks.length > 1 ? 's' : ''} unlocked!
              </span>
            </div>
          </motion.div>
        )}
      </AnimatePresence>

      {/* Badge grid */}
      <div className={cn(
        'grid gap-3',
        compact ? 'grid-cols-4' : 'grid-cols-3 sm:grid-cols-4'
      )}>
        {displayBadges.map((badge, index) => (
          <motion.div
            key={badge.id}
            initial={{ opacity: 0, scale: 0.8 }}
            animate={{ opacity: 1, scale: 1 }}
            transition={{ delay: index * 0.05 }}
          >
            <BadgeCard
              badge={badge}
              onClick={() => badge.isNew && markBadgeSeen(badge.id)}
            />
          </motion.div>
        ))}
      </div>
    </motion.div>
  );
}

function BadgesSkeleton({ compact }: { compact?: boolean }) {
  const count = compact ? 4 : 8;
  return (
    <div className="glass rounded-xl p-4 border border-border/30">
      <div className="h-6 w-32 rounded bg-muted/30 animate-shimmer mb-4" />
      <div className={cn(
        'grid gap-3',
        compact ? 'grid-cols-4' : 'grid-cols-3 sm:grid-cols-4'
      )}>
        {[...Array(count)].map((_, i) => (
          <div key={i} className="h-24 rounded-xl bg-muted/30 animate-shimmer" />
        ))}
      </div>
    </div>
  );
}
```

Implements MUST_HAVE "Milestone Badges":
- Achievement system for major accomplishments
- "First 10 FPS gained", "System Optimized for 30 days", "Top 10% in your hardware tier"
- Visible on profile, shareable with friends
- Professional (not streaks/challenges)
  </action>
  <verify>npm run build passes, badges display with progress and unlock states</verify>
  <done>Badge system with cards, progress tracking, and unlock notifications created</done>
</task>

<task type="auto">
  <name>Task 6: Integrate into Score page</name>
  <files>src/pages/Score.tsx</files>
  <action>
Update Score page to include leaderboard and badges:

```typescript
// Add imports
import { Leaderboard } from '@/components/Leaderboard';
import { MilestoneBadges } from '@/components/MilestoneBadges';
import { useScore } from '@/hooks/useScore';
import { useBadges } from '@/hooks/useBadges';

// In Score component, add:
const { badges, newUnlocks } = useBadges();

// Add sections after the score card and timeline:

{/* Two-column layout for leaderboard and badges */}
<div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
  {/* Leaderboard */}
  <Leaderboard
    entries={allScores}  // From useScore
    userRank={userRank}
    userScore={optaScore?.overall}
    hardwareTier={optaScore?.hardwareTier}
    onFilterChange={handleFilterChange}
  />

  {/* Milestones */}
  <MilestoneBadges />
</div>
```

Also add Tauri commands for badges in lib.rs:
```rust
.invoke_handler(tauri::generate_handler![
    // ... existing handlers
    badges::check_badges,
    badges::mark_badge_seen,
])
```

Create src-tauri/src/badges.rs with the badge commands.
  </action>
  <verify>npm run build passes, cargo build passes, Score page shows leaderboard and badges</verify>
  <done>Leaderboard and badges integrated into Score page</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `cargo build` succeeds without errors
- [ ] Badge types and definitions created
- [ ] Badge backend tracks progress and unlocks
- [ ] HardwareTierFilter provides all four comparison modes
- [ ] Leaderboard displays with user position highlighted
- [ ] BadgeCard shows locked/unlocked states with progress
- [ ] MilestoneBadges shows new unlock notifications
- [ ] Score page integrates all components
</verification>

<success_criteria>
- All tasks completed
- Leaderboard filters by similar hardware, price tier, performance tier, global
- User's position highlighted in leaderboard
- Badge system tracks 9+ milestone achievements
- Badges show progress toward unlock
- New badge unlocks show notification
- Rarity system (common, rare, epic, legendary) with visual distinction
- All components follow DESIGN_SYSTEM.md
</success_criteria>

<output>
After completion, create `.planning/phases/09-optimization-score/09-03-SUMMARY.md`
</output>
