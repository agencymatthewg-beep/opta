# Plan 64-03: Particle System

## Wave: 2 (Depends on 64-01)

## Objective

Create a GPU-instanced particle system for explosion effects, ambient particles, and energy bursts.

## Execution Context

**Reference Documents:**
- Phase 27 Ring Explosion Effect
- Phase 32 Particle Environment

**Key Insights:**
- GPU instancing for thousands of particles
- Particle pooling to avoid allocations
- Update particles on GPU via compute shader

## Context

**Depends on:**
- Phase 64-01 (Spring physics for particle behavior)
- Phase 60 (wgpu instance rendering)

**Builds foundation for:**
- Ring explosion effect
- Ambient atmosphere particles
- Data burst effects

## Tasks

### Task 1: Create particle system core

**File:** `opta-native/opta-render/src/animation/particles.rs`

```rust
//! GPU-instanced particle system.

use bytemuck::{Pod, Zeroable};
use wgpu::{Device, Queue, Buffer, RenderPipeline, BindGroup};
use rand::Rng;

/// Maximum particles per emitter.
pub const MAX_PARTICLES: usize = 2048;

/// Single particle data.
#[repr(C)]
#[derive(Debug, Clone, Copy, Pod, Zeroable)]
pub struct Particle {
    /// Position (x, y, z).
    pub position: [f32; 3],
    /// Remaining lifetime (0 = dead).
    pub life: f32,
    /// Velocity (x, y, z).
    pub velocity: [f32; 3],
    /// Size.
    pub size: f32,
    /// Color (r, g, b, a).
    pub color: [f32; 4],
}

impl Default for Particle {
    fn default() -> Self {
        Self {
            position: [0.0; 3],
            life: 0.0,
            velocity: [0.0; 3],
            size: 1.0,
            color: [1.0, 1.0, 1.0, 1.0],
        }
    }
}

/// Particle emitter configuration.
#[derive(Debug, Clone)]
pub struct EmitterConfig {
    /// Emission rate (particles per second).
    pub emission_rate: f32,
    /// Particle lifetime range (min, max) in seconds.
    pub lifetime: (f32, f32),
    /// Initial velocity range.
    pub velocity_min: [f32; 3],
    pub velocity_max: [f32; 3],
    /// Initial size range.
    pub size_min: f32,
    pub size_max: f32,
    /// Gravity acceleration.
    pub gravity: [f32; 3],
    /// Color at birth.
    pub color_start: [f32; 4],
    /// Color at death.
    pub color_end: [f32; 4],
    /// Size multiplier over lifetime.
    pub size_over_life: f32,
    /// Damping (velocity reduction per second).
    pub damping: f32,
}

impl Default for EmitterConfig {
    fn default() -> Self {
        Self {
            emission_rate: 50.0,
            lifetime: (1.0, 2.0),
            velocity_min: [-1.0, -1.0, -1.0],
            velocity_max: [1.0, 1.0, 1.0],
            size_min: 0.01,
            size_max: 0.02,
            gravity: [0.0, -0.5, 0.0],
            color_start: [1.0, 1.0, 1.0, 1.0],
            color_end: [1.0, 1.0, 1.0, 0.0],
            size_over_life: 0.5,
            damping: 0.98,
        }
    }
}

impl EmitterConfig {
    /// Explosion burst preset.
    pub fn explosion() -> Self {
        Self {
            emission_rate: 0.0, // Burst mode
            lifetime: (0.3, 0.8),
            velocity_min: [-3.0, -3.0, -3.0],
            velocity_max: [3.0, 3.0, 3.0],
            size_min: 0.02,
            size_max: 0.05,
            gravity: [0.0, 0.0, 0.0],
            color_start: [1.0, 0.8, 1.0, 1.0],
            color_end: [0.5, 0.2, 1.0, 0.0],
            size_over_life: 0.0,
            damping: 0.95,
        }
    }

    /// Ambient floating particles preset.
    pub fn ambient() -> Self {
        Self {
            emission_rate: 20.0,
            lifetime: (3.0, 5.0),
            velocity_min: [-0.1, 0.05, -0.1],
            velocity_max: [0.1, 0.15, 0.1],
            size_min: 0.002,
            size_max: 0.005,
            gravity: [0.0, 0.0, 0.0],
            color_start: [0.5, 0.3, 1.0, 0.3],
            color_end: [0.5, 0.3, 1.0, 0.0],
            size_over_life: 1.0,
            damping: 1.0,
        }
    }

    /// Energy spark preset.
    pub fn sparks() -> Self {
        Self {
            emission_rate: 100.0,
            lifetime: (0.2, 0.5),
            velocity_min: [-2.0, 0.0, -2.0],
            velocity_max: [2.0, 3.0, 2.0],
            size_min: 0.005,
            size_max: 0.015,
            gravity: [0.0, -5.0, 0.0],
            color_start: [1.0, 0.9, 0.5, 1.0],
            color_end: [1.0, 0.3, 0.1, 0.0],
            size_over_life: 0.2,
            damping: 0.99,
        }
    }
}

/// Particle emitter managing a pool of particles.
pub struct ParticleEmitter {
    config: EmitterConfig,
    particles: Vec<Particle>,
    active_count: usize,
    emission_accumulator: f32,
    position: [f32; 3],
    is_emitting: bool,
}

impl ParticleEmitter {
    pub fn new(config: EmitterConfig) -> Self {
        Self {
            config,
            particles: vec![Particle::default(); MAX_PARTICLES],
            active_count: 0,
            emission_accumulator: 0.0,
            position: [0.0; 3],
            is_emitting: true,
        }
    }

    /// Set emitter position.
    pub fn set_position(&mut self, position: [f32; 3]) {
        self.position = position;
    }

    /// Start emitting particles.
    pub fn start(&mut self) {
        self.is_emitting = true;
    }

    /// Stop emitting particles.
    pub fn stop(&mut self) {
        self.is_emitting = false;
    }

    /// Emit a burst of particles.
    pub fn burst(&mut self, count: usize) {
        let mut rng = rand::thread_rng();
        for _ in 0..count.min(MAX_PARTICLES - self.active_count) {
            self.spawn_particle(&mut rng);
        }
    }

    /// Get active particle data for rendering.
    pub fn active_particles(&self) -> &[Particle] {
        &self.particles[..self.active_count]
    }

    /// Update all particles.
    pub fn update(&mut self, dt: f32) {
        let mut rng = rand::thread_rng();

        // Continuous emission
        if self.is_emitting && self.config.emission_rate > 0.0 {
            self.emission_accumulator += self.config.emission_rate * dt;
            while self.emission_accumulator >= 1.0 && self.active_count < MAX_PARTICLES {
                self.spawn_particle(&mut rng);
                self.emission_accumulator -= 1.0;
            }
        }

        // Update existing particles
        let mut write_idx = 0;
        for read_idx in 0..self.active_count {
            let particle = &mut self.particles[read_idx];

            // Update lifetime
            particle.life -= dt;

            if particle.life > 0.0 {
                // Physics update
                particle.velocity[0] += self.config.gravity[0] * dt;
                particle.velocity[1] += self.config.gravity[1] * dt;
                particle.velocity[2] += self.config.gravity[2] * dt;

                particle.velocity[0] *= self.config.damping.powf(dt);
                particle.velocity[1] *= self.config.damping.powf(dt);
                particle.velocity[2] *= self.config.damping.powf(dt);

                particle.position[0] += particle.velocity[0] * dt;
                particle.position[1] += particle.velocity[1] * dt;
                particle.position[2] += particle.velocity[2] * dt;

                // Color interpolation
                let t = 1.0 - particle.life / self.config.lifetime.1;
                for i in 0..4 {
                    particle.color[i] = lerp(
                        self.config.color_start[i],
                        self.config.color_end[i],
                        t,
                    );
                }

                // Size over lifetime
                let base_size = particle.size;
                particle.size = base_size * (1.0 - t * (1.0 - self.config.size_over_life));

                // Keep particle
                if write_idx != read_idx {
                    self.particles[write_idx] = *particle;
                }
                write_idx += 1;
            }
        }

        self.active_count = write_idx;
    }

    fn spawn_particle(&mut self, rng: &mut impl Rng) {
        if self.active_count >= MAX_PARTICLES {
            return;
        }

        let particle = &mut self.particles[self.active_count];
        particle.position = self.position;
        particle.life = rng.gen_range(self.config.lifetime.0..self.config.lifetime.1);

        particle.velocity = [
            rng.gen_range(self.config.velocity_min[0]..self.config.velocity_max[0]),
            rng.gen_range(self.config.velocity_min[1]..self.config.velocity_max[1]),
            rng.gen_range(self.config.velocity_min[2]..self.config.velocity_max[2]),
        ];

        particle.size = rng.gen_range(self.config.size_min..self.config.size_max);
        particle.color = self.config.color_start;

        self.active_count += 1;
    }
}

fn lerp(a: f32, b: f32, t: f32) -> f32 {
    a + (b - a) * t
}

/// GPU particle renderer using instancing.
pub struct ParticleRenderer {
    pipeline: RenderPipeline,
    instance_buffer: Buffer,
    bind_group: BindGroup,
    quad_vertex_buffer: Buffer,
}

impl ParticleRenderer {
    pub fn new(device: &Device, format: wgpu::TextureFormat) -> Self {
        todo!("Implement GPU particle renderer")
    }

    /// Upload particle data to GPU.
    pub fn upload(&self, queue: &Queue, particles: &[Particle]) {
        queue.write_buffer(&self.instance_buffer, 0, bytemuck::cast_slice(particles));
    }

    /// Render particles.
    pub fn render<'a>(&'a self, render_pass: &mut wgpu::RenderPass<'a>, count: u32) {
        render_pass.set_pipeline(&self.pipeline);
        render_pass.set_bind_group(0, &self.bind_group, &[]);
        render_pass.set_vertex_buffer(0, self.quad_vertex_buffer.slice(..));
        render_pass.set_vertex_buffer(1, self.instance_buffer.slice(..));
        render_pass.draw(0..6, 0..count);
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_particle_burst() {
        let mut emitter = ParticleEmitter::new(EmitterConfig::explosion());
        emitter.burst(100);
        assert_eq!(emitter.active_count, 100);
    }

    #[test]
    fn test_particle_lifetime() {
        let mut emitter = ParticleEmitter::new(EmitterConfig {
            lifetime: (0.1, 0.1),
            ..EmitterConfig::default()
        });
        emitter.burst(10);
        assert_eq!(emitter.active_count, 10);

        // Update past lifetime
        emitter.update(0.2);
        assert_eq!(emitter.active_count, 0);
    }

    #[test]
    fn test_continuous_emission() {
        let mut emitter = ParticleEmitter::new(EmitterConfig {
            emission_rate: 100.0,
            lifetime: (1.0, 1.0),
            ..EmitterConfig::default()
        });

        emitter.update(0.1); // Should emit ~10 particles
        assert!(emitter.active_count >= 9 && emitter.active_count <= 11);
    }
}
```

### Task 2: Create particle shader

**File:** `opta-native/opta-render/shaders/particles.wgsl`

```wgsl
// Particle rendering shader with billboarding

struct CameraUniforms {
    view_proj: mat4x4<f32>,
    view: mat4x4<f32>,
    proj: mat4x4<f32>,
}

@group(0) @binding(0)
var<uniform> camera: CameraUniforms;

struct Particle {
    position: vec3<f32>,
    life: f32,
    velocity: vec3<f32>,
    size: f32,
    color: vec4<f32>,
}

struct ParticleInput {
    @location(0) quad_pos: vec2<f32>,
    @location(1) position: vec3<f32>,
    @location(2) life: f32,
    @location(3) velocity: vec3<f32>,
    @location(4) size: f32,
    @location(5) color: vec4<f32>,
}

struct VertexOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv: vec2<f32>,
    @location(1) color: vec4<f32>,
}

@vertex
fn vs_main(input: ParticleInput) -> VertexOutput {
    var output: VertexOutput;

    // Billboard: get camera right and up vectors from view matrix
    let right = vec3<f32>(camera.view[0][0], camera.view[1][0], camera.view[2][0]);
    let up = vec3<f32>(camera.view[0][1], camera.view[1][1], camera.view[2][1]);

    // Offset quad position
    let world_pos = input.position
        + right * input.quad_pos.x * input.size
        + up * input.quad_pos.y * input.size;

    output.position = camera.view_proj * vec4<f32>(world_pos, 1.0);
    output.uv = input.quad_pos * 0.5 + 0.5;
    output.color = input.color;

    return output;
}

@fragment
fn fs_main(input: VertexOutput) -> @location(0) vec4<f32> {
    // Soft circle particle
    let dist = length(input.uv - 0.5) * 2.0;
    let alpha = 1.0 - smoothstep(0.8, 1.0, dist);

    // Add glow
    let glow = exp(-dist * 2.0) * 0.5;

    var color = input.color;
    color.a *= alpha + glow;

    return color;
}
```

### Task 3: Update animation module

**Update:** `opta-native/opta-render/src/animation/mod.rs`

```rust
mod spring;
mod state_machine;
mod particles;

pub use spring::{Spring, Spring2D, Spring3D, SpringColor, SpringConfig};
pub use state_machine::{
    AnimationState, AnimationStateMachine, StateId, Transition,
    ring_states,
};
pub use particles::{
    Particle, ParticleEmitter, ParticleRenderer, EmitterConfig,
    MAX_PARTICLES,
};

pub const DT_60HZ: f32 = 1.0 / 60.0;
pub const DT_120HZ: f32 = 1.0 / 120.0;
```

## Verification

```bash
cd opta-native
cargo check -p opta-render
cargo test -p opta-render -- particles
```

## Success Criteria

- [ ] Particle emitter spawns and updates particles
- [ ] Burst mode works for explosions
- [ ] Continuous emission works for ambient
- [ ] Particles fade and shrink over lifetime
- [ ] GPU instancing renders efficiently

## Output

- CPU particle simulation
- GPU instanced particle renderer
- Pre-built presets (explosion, ambient, sparks)
