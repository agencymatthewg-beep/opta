# Plan 63-01: Opta Ring Component Migration

## Wave: 1 (Independent)

## Objective

Port the Opta Ring 3D component from React Three Fiber to native wgpu/WGSL rendering.

## Execution Context

**Reference Documents:**
- Existing React Three Fiber ring implementation
- Phase 61 WGSL shader library (SDF, glass, plasma)
- Phase 25-28 ring shader and state machine specs

**Key Insights:**
- Ring uses torus geometry with glass material
- Internal plasma animation via noise shaders
- State machine: dormant → waking → active → exploding
- Fresnel effect for edge glow

## Context

**Depends on:**
- Phase 61 (WGSL shader system with SDF, glass, noise)
- Phase 62-01 (SwiftUI shell with render surface)

**Builds foundation for:**
- Plan 63-02 (Glass panel system)
- Plan 63-03 (Telemetry visualizations)

## Tasks

### Task 1: Create ring geometry generator

**File:** `opta-native/opta-render/src/components/ring.rs`

```rust
//! Opta Ring 3D component with glass material and plasma interior.

use crate::buffer::{IndexBuffer, Vertex2D, VertexBuffer};
use crate::pipeline::Uniforms;
use crate::shader::ShaderLibrary;
use bytemuck::{Pod, Zeroable};
use wgpu::{Device, Queue, RenderPipeline, BindGroup};

/// Ring vertex with position, normal, and UV.
#[repr(C)]
#[derive(Debug, Clone, Copy, Pod, Zeroable)]
pub struct RingVertex {
    pub position: [f32; 3],
    pub normal: [f32; 3],
    pub uv: [f32; 2],
}

impl RingVertex {
    pub const ATTRIBS: [wgpu::VertexAttribute; 3] = wgpu::vertex_attr_array![
        0 => Float32x3,
        1 => Float32x3,
        2 => Float32x2,
    ];

    pub fn desc() -> wgpu::VertexBufferLayout<'static> {
        wgpu::VertexBufferLayout {
            array_stride: std::mem::size_of::<RingVertex>() as wgpu::BufferAddress,
            step_mode: wgpu::VertexStepMode::Vertex,
            attributes: &Self::ATTRIBS,
        }
    }
}

/// Ring state for animation.
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum RingState {
    Dormant,
    Waking,
    Active,
    Processing,
    Exploding,
    Recovering,
}

/// Ring uniforms for shader.
#[repr(C)]
#[derive(Debug, Clone, Copy, Pod, Zeroable)]
pub struct RingUniforms {
    pub model_matrix: [[f32; 4]; 4],
    pub view_proj_matrix: [[f32; 4]; 4],
    pub time: f32,
    pub energy_level: f32,        // 0.0 = dormant, 1.0 = full active
    pub plasma_intensity: f32,
    pub fresnel_power: f32,
    pub ring_rotation: f32,       // Y-axis rotation in radians
    pub tilt_angle: f32,          // X-axis tilt (15° dormant, 0° active)
    pub _padding: [f32; 2],
}

/// Configuration for ring appearance.
#[derive(Debug, Clone)]
pub struct RingConfig {
    /// Major radius (center to tube center)
    pub major_radius: f32,
    /// Minor radius (tube radius)
    pub minor_radius: f32,
    /// Segments around the major circle
    pub major_segments: u32,
    /// Segments around the tube
    pub minor_segments: u32,
    /// Glass index of refraction
    pub ior: f32,
    /// Glass tint color
    pub tint: [f32; 3],
}

impl Default for RingConfig {
    fn default() -> Self {
        Self {
            major_radius: 1.0,
            minor_radius: 0.3,
            major_segments: 64,
            minor_segments: 32,
            ior: 1.5,
            tint: [0.9, 0.95, 1.0], // Slight blue tint
        }
    }
}

/// Opta Ring component.
pub struct OptaRing {
    vertex_buffer: wgpu::Buffer,
    index_buffer: wgpu::Buffer,
    index_count: u32,
    uniform_buffer: wgpu::Buffer,
    bind_group: BindGroup,
    pipeline: RenderPipeline,
    state: RingState,
    config: RingConfig,
    uniforms: RingUniforms,
}

impl OptaRing {
    /// Create a new Opta Ring.
    pub fn new(
        device: &Device,
        format: wgpu::TextureFormat,
        shader_library: &mut ShaderLibrary,
    ) -> Self {
        let config = RingConfig::default();
        let (vertices, indices) = generate_torus_geometry(&config);

        let vertex_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("Ring Vertex Buffer"),
            contents: bytemuck::cast_slice(&vertices),
            usage: wgpu::BufferUsages::VERTEX,
        });

        let index_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("Ring Index Buffer"),
            contents: bytemuck::cast_slice(&indices),
            usage: wgpu::BufferUsages::INDEX,
        });

        let uniforms = RingUniforms {
            model_matrix: identity_matrix(),
            view_proj_matrix: identity_matrix(),
            time: 0.0,
            energy_level: 0.0,
            plasma_intensity: 0.3,
            fresnel_power: 5.0,
            ring_rotation: 0.0,
            tilt_angle: 0.26, // ~15 degrees
            _padding: [0.0; 2],
        };

        let uniform_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("Ring Uniforms"),
            contents: bytemuck::bytes_of(&uniforms),
            usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
        });

        // Create bind group layout and pipeline
        let bind_group_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
            label: Some("Ring Bind Group Layout"),
            entries: &[wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStages::VERTEX | wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Uniform,
                    has_dynamic_offset: false,
                    min_binding_size: None,
                },
                count: None,
            }],
        });

        let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
            label: Some("Ring Bind Group"),
            layout: &bind_group_layout,
            entries: &[wgpu::BindGroupEntry {
                binding: 0,
                resource: uniform_buffer.as_entire_binding(),
            }],
        });

        // Load shader (uses #include for glass, noise, etc.)
        let shader_source = include_str!("../../shaders/ring.wgsl");
        let shader = shader_library
            .load_shader(device, "ring", shader_source)
            .expect("Failed to load ring shader");

        let pipeline_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Ring Pipeline Layout"),
            bind_group_layouts: &[&bind_group_layout],
            push_constant_ranges: &[],
        });

        let pipeline = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
            label: Some("Ring Pipeline"),
            layout: Some(&pipeline_layout),
            vertex: wgpu::VertexState {
                module: shader,
                entry_point: Some("vs_main"),
                buffers: &[RingVertex::desc()],
                compilation_options: Default::default(),
            },
            fragment: Some(wgpu::FragmentState {
                module: shader,
                entry_point: Some("fs_main"),
                targets: &[Some(wgpu::ColorTargetState {
                    format,
                    blend: Some(wgpu::BlendState::ALPHA_BLENDING),
                    write_mask: wgpu::ColorWrites::ALL,
                })],
                compilation_options: Default::default(),
            }),
            primitive: wgpu::PrimitiveState {
                topology: wgpu::PrimitiveTopology::TriangleList,
                cull_mode: None, // Glass is see-through
                ..Default::default()
            },
            depth_stencil: Some(wgpu::DepthStencilState {
                format: wgpu::TextureFormat::Depth32Float,
                depth_write_enabled: true,
                depth_compare: wgpu::CompareFunction::Less,
                stencil: wgpu::StencilState::default(),
                bias: wgpu::DepthBiasState::default(),
            }),
            multisample: wgpu::MultisampleState::default(),
            multiview: None,
            cache: None,
        });

        Self {
            vertex_buffer,
            index_buffer,
            index_count: indices.len() as u32,
            uniform_buffer,
            bind_group,
            pipeline,
            state: RingState::Dormant,
            config,
            uniforms,
        }
    }

    /// Set the ring state.
    pub fn set_state(&mut self, state: RingState) {
        self.state = state;
    }

    /// Update ring animation.
    pub fn update(&mut self, queue: &Queue, dt: f32) {
        self.uniforms.time += dt;

        // Update based on state
        match self.state {
            RingState::Dormant => {
                self.uniforms.energy_level = lerp(self.uniforms.energy_level, 0.0, dt * 2.0);
                self.uniforms.tilt_angle = lerp(self.uniforms.tilt_angle, 0.26, dt * 2.0);
                self.uniforms.ring_rotation += dt * 0.1; // Slow spin
            }
            RingState::Waking => {
                self.uniforms.energy_level = lerp(self.uniforms.energy_level, 0.5, dt * 3.0);
                self.uniforms.tilt_angle = lerp(self.uniforms.tilt_angle, 0.0, dt * 3.0);
                self.uniforms.ring_rotation += dt * 0.5;
            }
            RingState::Active => {
                self.uniforms.energy_level = lerp(self.uniforms.energy_level, 1.0, dt * 4.0);
                self.uniforms.tilt_angle = lerp(self.uniforms.tilt_angle, 0.0, dt * 4.0);
                self.uniforms.ring_rotation += dt * 1.0;
            }
            RingState::Processing => {
                self.uniforms.energy_level = 0.8 + 0.2 * (self.uniforms.time * 4.0).sin();
                self.uniforms.ring_rotation += dt * 2.0;
            }
            RingState::Exploding => {
                self.uniforms.energy_level = 2.0; // Bloom
                self.uniforms.plasma_intensity = 1.0;
            }
            RingState::Recovering => {
                self.uniforms.energy_level = lerp(self.uniforms.energy_level, 1.0, dt * 5.0);
                self.uniforms.plasma_intensity = lerp(self.uniforms.plasma_intensity, 0.3, dt * 5.0);
            }
        }

        // Upload uniforms
        queue.write_buffer(&self.uniform_buffer, 0, bytemuck::bytes_of(&self.uniforms));
    }

    /// Render the ring.
    pub fn render<'a>(&'a self, render_pass: &mut wgpu::RenderPass<'a>) {
        render_pass.set_pipeline(&self.pipeline);
        render_pass.set_bind_group(0, &self.bind_group, &[]);
        render_pass.set_vertex_buffer(0, self.vertex_buffer.slice(..));
        render_pass.set_index_buffer(self.index_buffer.slice(..), wgpu::IndexFormat::Uint16);
        render_pass.draw_indexed(0..self.index_count, 0, 0..1);
    }
}

/// Generate torus (donut) geometry.
fn generate_torus_geometry(config: &RingConfig) -> (Vec<RingVertex>, Vec<u16>) {
    let mut vertices = Vec::new();
    let mut indices = Vec::new();

    let major_step = std::f32::consts::TAU / config.major_segments as f32;
    let minor_step = std::f32::consts::TAU / config.minor_segments as f32;

    for i in 0..=config.major_segments {
        let theta = i as f32 * major_step;
        let cos_theta = theta.cos();
        let sin_theta = theta.sin();

        for j in 0..=config.minor_segments {
            let phi = j as f32 * minor_step;
            let cos_phi = phi.cos();
            let sin_phi = phi.sin();

            // Position on torus surface
            let x = (config.major_radius + config.minor_radius * cos_phi) * cos_theta;
            let y = config.minor_radius * sin_phi;
            let z = (config.major_radius + config.minor_radius * cos_phi) * sin_theta;

            // Normal (points outward from tube center)
            let nx = cos_phi * cos_theta;
            let ny = sin_phi;
            let nz = cos_phi * sin_theta;

            // UV coordinates
            let u = i as f32 / config.major_segments as f32;
            let v = j as f32 / config.minor_segments as f32;

            vertices.push(RingVertex {
                position: [x, y, z],
                normal: [nx, ny, nz],
                uv: [u, v],
            });
        }
    }

    // Generate indices
    for i in 0..config.major_segments {
        for j in 0..config.minor_segments {
            let current = i * (config.minor_segments + 1) + j;
            let next = current + config.minor_segments + 1;

            indices.push(current as u16);
            indices.push(next as u16);
            indices.push(current as u16 + 1);

            indices.push(current as u16 + 1);
            indices.push(next as u16);
            indices.push(next as u16 + 1);
        }
    }

    (vertices, indices)
}

fn identity_matrix() -> [[f32; 4]; 4] {
    [
        [1.0, 0.0, 0.0, 0.0],
        [0.0, 1.0, 0.0, 0.0],
        [0.0, 0.0, 1.0, 0.0],
        [0.0, 0.0, 0.0, 1.0],
    ]
}

fn lerp(a: f32, b: f32, t: f32) -> f32 {
    a + (b - a) * t.min(1.0)
}
```

### Task 2: Create ring shader

**File:** `opta-native/opta-render/shaders/ring.wgsl`

```wgsl
// Opta Ring shader with glass material and plasma interior

#include "math.wgsl"
#include "noise.wgsl"
#include "glass.wgsl"
#include "color.wgsl"

struct Uniforms {
    model_matrix: mat4x4<f32>,
    view_proj_matrix: mat4x4<f32>,
    time: f32,
    energy_level: f32,
    plasma_intensity: f32,
    fresnel_power: f32,
    ring_rotation: f32,
    tilt_angle: f32,
    _padding: vec2<f32>,
}

@group(0) @binding(0)
var<uniform> uniforms: Uniforms;

struct VertexInput {
    @location(0) position: vec3<f32>,
    @location(1) normal: vec3<f32>,
    @location(2) uv: vec2<f32>,
}

struct VertexOutput {
    @builtin(position) clip_position: vec4<f32>,
    @location(0) world_position: vec3<f32>,
    @location(1) world_normal: vec3<f32>,
    @location(2) uv: vec2<f32>,
    @location(3) view_dir: vec3<f32>,
}

@vertex
fn vs_main(input: VertexInput) -> VertexOutput {
    var output: VertexOutput;

    // Apply rotation
    let c = cos(uniforms.ring_rotation);
    let s = sin(uniforms.ring_rotation);
    var pos = input.position;
    pos = vec3<f32>(
        pos.x * c - pos.z * s,
        pos.y,
        pos.x * s + pos.z * c
    );

    // Apply tilt
    let ct = cos(uniforms.tilt_angle);
    let st = sin(uniforms.tilt_angle);
    pos = vec3<f32>(
        pos.x,
        pos.y * ct - pos.z * st,
        pos.y * st + pos.z * ct
    );

    let world_pos = (uniforms.model_matrix * vec4<f32>(pos, 1.0)).xyz;
    output.world_position = world_pos;
    output.clip_position = uniforms.view_proj_matrix * vec4<f32>(world_pos, 1.0);

    // Transform normal
    var normal = input.normal;
    normal = vec3<f32>(
        normal.x * c - normal.z * s,
        normal.y,
        normal.x * s + normal.z * c
    );
    normal = vec3<f32>(
        normal.x,
        normal.y * ct - normal.z * st,
        normal.y * st + normal.z * ct
    );
    output.world_normal = normalize(normal);

    output.uv = input.uv;

    // Assume camera at origin looking at ring
    output.view_dir = normalize(-world_pos);

    return output;
}

@fragment
fn fs_main(input: VertexOutput) -> @location(0) vec4<f32> {
    let normal = normalize(input.world_normal);
    let view_dir = normalize(input.view_dir);

    // Fresnel effect (edge glow)
    let n_dot_v = max(dot(normal, view_dir), 0.0);
    let fresnel = pow(1.0 - n_dot_v, uniforms.fresnel_power);

    // Base glass color (slight blue tint)
    let glass_tint = vec3<f32>(0.9, 0.95, 1.0);

    // Internal plasma effect
    let plasma_uv = input.uv * 4.0 + vec2<f32>(uniforms.time * 0.2, uniforms.time * 0.15);
    let plasma_noise = fbm(plasma_uv, 4);
    let plasma_color = vec3<f32>(0.5, 0.2, 0.8) * plasma_noise * uniforms.plasma_intensity * uniforms.energy_level;

    // Rim lighting (purple glow at edges)
    let rim_color = vec3<f32>(0.6, 0.3, 1.0);
    let rim = fresnel * uniforms.energy_level;

    // Combine layers
    var color = glass_tint * 0.1; // Base translucency
    color += plasma_color;         // Internal plasma
    color += rim_color * rim;      // Edge glow

    // Energy bloom (for explosion state)
    if (uniforms.energy_level > 1.0) {
        let bloom = (uniforms.energy_level - 1.0) * vec3<f32>(1.0, 0.8, 1.0);
        color += bloom;
    }

    // Alpha based on fresnel (more opaque at edges)
    let alpha = 0.3 + fresnel * 0.5 + uniforms.energy_level * 0.2;

    return vec4<f32>(linear_to_srgb(color), saturate(alpha));
}
```

### Task 3: Create components module

**File:** `opta-native/opta-render/src/components/mod.rs`

```rust
//! UI components rendered with wgpu.

mod ring;

pub use ring::{OptaRing, RingConfig, RingState, RingUniforms, RingVertex};
```

### Task 4: Update lib.rs exports

**Update:** `opta-native/opta-render/src/lib.rs`

```rust
pub mod components;

pub use components::{OptaRing, RingConfig, RingState};
```

### Task 5: Add integration test

**File:** `opta-native/opta-render/tests/ring_test.rs`

```rust
//! Tests for Opta Ring component.

#[test]
fn test_ring_config_default() {
    let config = opta_render::RingConfig::default();
    assert_eq!(config.major_radius, 1.0);
    assert_eq!(config.minor_radius, 0.3);
    assert_eq!(config.major_segments, 64);
    assert_eq!(config.minor_segments, 32);
}

#[test]
fn test_ring_state_transitions() {
    // Test state values
    use opta_render::RingState;

    let state = RingState::Dormant;
    assert_eq!(state, RingState::Dormant);

    let state = RingState::Active;
    assert_eq!(state, RingState::Active);
}
```

## Verification

```bash
cd opta-native
cargo check -p opta-render
cargo clippy -p opta-render -- -D warnings
cargo test -p opta-render
```

## Success Criteria

- [ ] Torus geometry generates correctly
- [ ] Ring shader compiles with includes
- [ ] State machine affects animation
- [ ] Glass material with fresnel effect
- [ ] Internal plasma animation visible
- [ ] All tests pass

## Output

- OptaRing component ready for SwiftUI integration
- Ring shader with glass, plasma, and fresnel effects
- State-driven animation system
