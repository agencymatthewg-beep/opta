# Plan: Crux App Trait Compliance

```yaml
phase: 59
plan: 02
name: crux-app-trait-compliance
wave: 1
depends_on: []
files_modified:
  - opta-native/opta-core/src/app.rs
  - opta-native/opta-core/src/effect.rs
  - opta-native/opta-core/src/lib.rs
autonomous: true
estimated_context: 45%
```

## Objective

Refactor `OptaApp` to properly implement the `crux_core::App` trait, ensuring compatibility with the official Crux framework patterns. Enable type generation for cross-language FFI.

## Context

Current state of `opta-core/src/app.rs`:
```rust
pub struct OptaApp;

impl OptaApp {
    pub fn update(&self, model: Model, event: Event) -> (Model, Vec<Effect>) { ... }
}
```

This is Crux-like but doesn't implement the official `App` trait:
```rust
impl App for Counter {
    type Event = Event;
    type Model = Model;
    type ViewModel = String;
    type Capabilities = ();
    type Effect = Effect;

    fn update(&self, event: Event, model: &mut Model, _caps: &()) -> Command<Effect, Event> { ... }
    fn view(&self, model: &Model) -> Self::ViewModel { ... }
}
```

Key differences:
1. Official trait takes `&mut Model` not owned `Model`
2. Returns `Command<Effect, Event>` not `(Model, Vec<Effect>)`
3. Requires associated types and `view()` function
4. Uses `#[effect(typegen)]` for Effect enum

## Tasks

### Task 1: Refactor OptaApp to Implement crux_core::App Trait

Update `opta-core/src/app.rs`:

```rust
use crux_core::{App, Command, render::{self, RenderOperation}};

impl App for OptaApp {
    type Event = Event;
    type Model = Model;
    type ViewModel = ViewModel;  // Create this type
    type Capabilities = Capabilities;  // Define or use ()
    type Effect = Effect;

    fn update(&self, event: Self::Event, model: &mut Self::Model, caps: &Self::Capabilities) -> Command<Self::Effect, Self::Event> {
        // Refactor existing match logic
        // Replace Vec<Effect> returns with Command::batch()
        match event {
            Event::AppStarted => {
                Command::batch([
                    Effect::LoadSettings { id: Effect::generate_id() }.into(),
                    Effect::CollectTelemetry { id: Effect::generate_id() }.into(),
                    // ...
                ])
            }
            // ... other events
        }
    }

    fn view(&self, model: &Self::Model) -> Self::ViewModel {
        // Create view model from model
        ViewModel::from(model)
    }
}
```

**Verification:** `cargo check` passes with App trait implemented.

### Task 2: Update Effect Enum with Type Generation

Update `opta-core/src/effect.rs`:

```rust
use crux_core::macros::effect;
use crux_core::render::RenderOperation;
use serde::{Deserialize, Serialize};

#[effect(typegen)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Effect {
    Render(RenderOperation),

    CollectTelemetry {
        id: String,
    },

    LoadSettings {
        id: String,
    },

    SaveSettings {
        id: String,
        settings: String,  // JSON serialized
    },

    PlayHaptic {
        id: String,
        pattern: HapticPattern,
    },

    // ... other effects
}
```

Key changes:
- Add `#[effect(typegen)]` attribute for cross-language type generation
- Ensure all variants are serializable
- Add `Render(RenderOperation)` for Crux render capability

**Verification:** `cargo build --features typegen` generates type files.

### Task 3: Create ViewModel and Capabilities Types

1. Create `opta-core/src/view_model.rs`:
```rust
use serde::{Deserialize, Serialize};

/// The view model exposed to the UI shell
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct ViewModel {
    pub current_page: String,
    pub optimization_score: u8,
    pub ring_state: String,
    pub telemetry_summary: TelemetrySummary,
    // Minimal data needed for UI rendering
}

impl From<&Model> for ViewModel {
    fn from(model: &Model) -> Self {
        ViewModel {
            current_page: format!("{:?}", model.navigation.current_page),
            optimization_score: model.score.current,
            ring_state: format!("{:?}", model.ring.state),
            telemetry_summary: TelemetrySummary::from(&model.telemetry),
        }
    }
}
```

2. Define Capabilities (can be empty initially):
```rust
#[derive(Default)]
pub struct Capabilities;
```

3. Update `lib.rs` to export new types.

**Verification:** Full `cargo build` succeeds, types are exported.

## Success Criteria

- [ ] `OptaApp` implements `crux_core::App` trait
- [ ] Effect enum has `#[effect(typegen)]` attribute
- [ ] ViewModel type created and populated from Model
- [ ] `cargo build` succeeds
- [ ] `cargo build --features typegen` generates type definitions
- [ ] All existing tests pass (if any)

## Output

- Refactored `app.rs` with proper Crux App trait implementation
- Updated `effect.rs` with type generation support
- New `view_model.rs` with ViewModel type
- Updated `lib.rs` exports
