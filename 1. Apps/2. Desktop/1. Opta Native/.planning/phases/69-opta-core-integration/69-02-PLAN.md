---
phase: 69-opta-core-integration
plan: 02
type: execute
wave: 2
depends_on: ["69-01"]
files_modified:
  - opta-native/OptaApp/OptaApp/Managers/OptaCoreManager.swift
  - opta-native/OptaApp/OptaApp/Models/OptaViewModel.swift
  - opta-native/OptaApp/OptaApp/Models/OptaEffects.swift
  - opta-native/OptaApp/OptaApp/Bridge/EffectExecutor.swift
autonomous: true
---

<objective>
Create OptaCoreManager.swift wrapping the UniFFI OptaCore for SwiftUI, enabling reactive state management via the Crux architecture.

Purpose: Connect SwiftUI views to Crux state management with event dispatch, ViewModel subscriptions, and Effect execution bridging.
Output: Complete SwiftUI integration layer that:
- Wraps OptaCore in @Observable pattern
- Dispatches events from SwiftUI to Crux
- Subscribes views to ViewModel changes
- Executes Effects (haptics, sound, navigation)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Prior plan output:**
@.planning/phases/69-opta-core-integration/69-01-SUMMARY.md

**Rust types for reference:**
@opta-native/opta-core/src/view_model.rs
@opta-native/opta-core/src/effect.rs
@opta-native/opta-core/src/event.rs

**Existing SwiftUI infrastructure:**
@opta-native/OptaApp/OptaApp/Haptics/HapticsManager.swift
@opta-native/OptaApp/OptaApp/ContentView.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create OptaCoreManager with @Observable pattern</name>
  <files>opta-native/OptaApp/OptaApp/Managers/OptaCoreManager.swift</files>
  <action>
Create the main SwiftUI integration manager:

```swift
import Foundation
import Observation

@Observable
final class OptaCoreManager {
    // MARK: - Properties

    /// The underlying Rust OptaCore instance
    private let core: OptaCore

    /// Current view model (updated after each event)
    private(set) var viewModel: OptaViewModel

    /// Whether the core is ready
    var isReady: Bool { core.isReady() }

    // MARK: - Dependencies

    private let effectExecutor: EffectExecutor

    // MARK: - Initialization

    init() {
        // Initialize Rust core
        optaInit()
        self.core = OptaCore()
        self.viewModel = OptaViewModel()
        self.effectExecutor = EffectExecutor()

        // Fetch initial view model
        refreshViewModel()
    }

    // MARK: - Event Dispatch

    /// Send an event to Crux and process resulting effects
    func dispatch(_ event: OptaEvent) {
        let eventJson = event.toJson()
        let effectsJson = core.processEvent(eventJson: eventJson)

        // Refresh view model after state change
        refreshViewModel()

        // Execute all effects
        for effectJson in effectsJson {
            effectExecutor.execute(effectJson: effectJson) { [weak self] resultEvent in
                // Effect results become new events
                self?.dispatch(resultEvent)
            }
        }
    }

    /// Convenience: dispatch app started event
    func appStarted() {
        dispatch(.appStarted)
    }

    // MARK: - View Model

    private func refreshViewModel() {
        let json = core.getViewModelJson()
        if let vm = OptaViewModel.from(json: json) {
            self.viewModel = vm
        }
    }

    /// Get a specific model slice for efficient updates
    func getModelSlice(_ slice: ModelSlice) -> String {
        core.getModelSlice(sliceName: slice.rawValue)
    }
}
```

Key design decisions:
- Use @Observable (macOS 14+) for modern SwiftUI reactivity
- Crux pattern: dispatch event → get effects → execute effects → effect results become events
- Thread safety via main actor (SwiftUI updates must be on main thread)
- Weak self in callbacks to prevent retain cycles
  </action>
  <verify>
```bash
grep -l "@Observable" opta-native/OptaApp/OptaApp/Managers/OptaCoreManager.swift
grep -l "func dispatch" opta-native/OptaApp/OptaApp/Managers/OptaCoreManager.swift
```
Expected: Both patterns found
  </verify>
  <done>OptaCoreManager.swift created with event dispatch and ViewModel subscription</done>
</task>

<task type="auto">
  <name>Task 2: Create Swift ViewModel and Event types</name>
  <files>opta-native/OptaApp/OptaApp/Models/OptaViewModel.swift</files>
  <action>
Create Swift structs mirroring the Rust ViewModel for type-safe decoding:

```swift
import Foundation

/// Swift representation of Crux ViewModel
struct OptaViewModel: Codable {
    // Navigation
    var currentPage: PageViewModel = .dashboard
    var canGoBack: Bool = false
    var selectedGameId: String? = nil
    var sidebarExpanded: Bool = true

    // Telemetry
    var cpuUsage: Float = 0
    var memoryUsage: Float = 0
    var gpuUsage: Float? = nil
    var thermalState: ThermalStateViewModel = .nominal
    var memoryPressure: MemoryPressureViewModel = .normal
    var telemetryActive: Bool = false

    // Scoring
    var optaScore: UInt8 = 0
    var scoreGrade: String = "F"
    var scoreCalculating: Bool = false

    // Ring
    var ring: RingViewModel = RingViewModel()

    // UI
    var loading: Bool = false
    var error: ErrorViewModel? = nil

    // Settings
    var hapticsEnabled: Bool = true
    var spatialAudioEnabled: Bool = true

    // Decode from JSON
    static func from(json: String) -> OptaViewModel? {
        guard let data = json.data(using: .utf8) else { return nil }
        return try? JSONDecoder().decode(OptaViewModel.self, from: data)
    }
}

enum PageViewModel: String, Codable {
    case dashboard = "Dashboard"
    case optimize = "Optimize"
    case games = "Games"
    case gameDetail = "GameDetail"
    case processes = "Processes"
    case settings = "Settings"
    case chess = "Chess"
    case aiChat = "AiChat"
}

enum ThermalStateViewModel: String, Codable {
    case nominal = "Nominal"
    case fair = "Fair"
    case serious = "Serious"
    case critical = "Critical"
}

enum MemoryPressureViewModel: String, Codable {
    case normal = "Normal"
    case warning = "Warning"
    case critical = "Critical"
}

struct RingViewModel: Codable {
    var phase: RingPhaseViewModel = .idle
    var progress: Float = 0
    var energy: Float = 0
    var expanded: Bool = false
}

enum RingPhaseViewModel: String, Codable {
    case idle = "Idle"
    case wakingUp = "WakingUp"
    case active = "Active"
    case optimizing = "Optimizing"
    case celebrating = "Celebrating"
    case sleeping = "Sleeping"
}

struct ErrorViewModel: Codable {
    var title: String
    var message: String
    var recoverable: Bool
    var action: String?
}
```

Also create OptaEvent enum:
```swift
/// Events that can be dispatched to Crux
enum OptaEvent {
    case appStarted
    case navigate(page: PageViewModel)
    case goBack
    case refreshTelemetry
    case selectGame(id: String)
    case optimizeGame(id: String)
    case toggleHaptics
    case toggleSpatialAudio

    func toJson() -> String {
        switch self {
        case .appStarted:
            return "\"AppStarted\""
        case .navigate(let page):
            return "{\"Navigate\":{\"page\":\"\(page.rawValue)\"}}"
        case .goBack:
            return "\"GoBack\""
        case .refreshTelemetry:
            return "\"RefreshTelemetry\""
        case .selectGame(let id):
            return "{\"SelectGame\":{\"game_id\":\"\(id)\"}}"
        case .optimizeGame(let id):
            return "{\"OptimizeGame\":{\"game_id\":\"\(id)\"}}"
        case .toggleHaptics:
            return "\"ToggleHaptics\""
        case .toggleSpatialAudio:
            return "\"ToggleSpatialAudio\""
        }
    }
}

/// Model slices for efficient partial updates
enum ModelSlice: String {
    case navigation
    case telemetry
    case processes
    case games
    case scoring
    case settings
    case ui
    case loading
    case error
}
```
  </action>
  <verify>
```bash
grep -l "struct OptaViewModel" opta-native/OptaApp/OptaApp/Models/OptaViewModel.swift
grep -l "enum OptaEvent" opta-native/OptaApp/OptaApp/Models/OptaViewModel.swift
```
Expected: Both found
  </verify>
  <done>Swift ViewModel, Event, and supporting types created</done>
</task>

<task type="auto">
  <name>Task 3: Create EffectExecutor for bridging Crux effects to Swift</name>
  <files>opta-native/OptaApp/OptaApp/Bridge/EffectExecutor.swift</files>
  <action>
Create the effect execution bridge that maps Crux Effects to native Swift actions:

```swift
import Foundation

/// Executes Crux Effects on the native platform
final class EffectExecutor {
    private let hapticsManager = HapticsManager.shared

    /// Execute an effect from JSON and call completion with result event
    func execute(effectJson: String, completion: @escaping (OptaEvent) -> Void) {
        guard let data = effectJson.data(using: .utf8),
              let effect = try? JSONDecoder().decode(EffectWrapper.self, from: data) else {
            print("[EffectExecutor] Failed to decode effect: \(effectJson)")
            return
        }

        switch effect {
        case .playHaptic(let id, let pattern):
            executeHaptic(pattern: pattern)
            // Haptics don't produce result events

        case .playSpatialAudio(let id, let sound, let position):
            executeSpatialAudio(sound: sound, position: position)
            // Audio doesn't produce result events

        case .collectTelemetry(let id):
            // Telemetry collection handled by existing TelemetryService
            // Result event dispatched when telemetry arrives
            break

        case .scheduleTimer(let id, let delayMs, let event):
            executeTimer(delayMs: delayMs, event: event, completion: completion)

        case .showNotification(let id, let title, let body):
            executeNotification(title: title, body: body)

        case .copyToClipboard(let id, let text):
            executeCopyToClipboard(text: text)

        case .openUrl(let id, let url):
            executeOpenUrl(url: url)

        default:
            print("[EffectExecutor] Unhandled effect: \(effect)")
        }
    }

    // MARK: - Effect Implementations

    private func executeHaptic(pattern: HapticPatternWrapper) {
        let ffiPattern: FfiHapticPattern
        switch pattern {
        case .light: ffiPattern = .light
        case .medium: ffiPattern = .medium
        case .heavy: ffiPattern = .heavy
        case .success: ffiPattern = .success
        case .warning: ffiPattern = .warning
        case .error: ffiPattern = .error
        case .optimizingPulse: ffiPattern = .optimizingPulse
        case .scoreCelebration: ffiPattern = .scoreCelebration
        }
        hapticsManager.play(ffiPattern)
    }

    private func executeSpatialAudio(sound: SoundEffectWrapper, position: AudioPositionWrapper?) {
        // TODO: Implement spatial audio in Phase 70
        print("[EffectExecutor] Spatial audio: \(sound)")
    }

    private func executeTimer(delayMs: UInt64, event: String, completion: @escaping (OptaEvent) -> Void) {
        DispatchQueue.main.asyncAfter(deadline: .now() + .milliseconds(Int(delayMs))) {
            // Parse the stored event JSON and convert to OptaEvent
            // For now, handle common timer events
            if event.contains("RefreshTelemetry") {
                completion(.refreshTelemetry)
            }
        }
    }

    private func executeNotification(title: String, body: String) {
        // Use UNUserNotificationCenter
        let content = UNMutableNotificationContent()
        content.title = title
        content.body = body
        let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: nil)
        UNUserNotificationCenter.current().add(request)
    }

    private func executeCopyToClipboard(text: String) {
        #if os(macOS)
        NSPasteboard.general.clearContents()
        NSPasteboard.general.setString(text, forType: .string)
        #endif
    }

    private func executeOpenUrl(url: String) {
        guard let url = URL(string: url) else { return }
        #if os(macOS)
        NSWorkspace.shared.open(url)
        #endif
    }
}

// MARK: - Effect Wrapper Types for JSON Decoding

enum EffectWrapper: Decodable {
    case playHaptic(id: String, pattern: HapticPatternWrapper)
    case playSpatialAudio(id: String, sound: SoundEffectWrapper, position: AudioPositionWrapper?)
    case collectTelemetry(id: String)
    case scheduleTimer(id: String, delayMs: UInt64, event: String)
    case showNotification(id: String, title: String, body: String)
    case copyToClipboard(id: String, text: String)
    case openUrl(id: String, url: String)
    case unknown

    // Custom decoding for Rust enum serialization format
    // ...
}

enum HapticPatternWrapper: String, Codable {
    case light = "Light"
    case medium = "Medium"
    case heavy = "Heavy"
    case success = "Success"
    case warning = "Warning"
    case error = "Error"
    case optimizingPulse = "OptimizingPulse"
    case scoreCelebration = "ScoreCelebration"
}

enum SoundEffectWrapper: String, Codable {
    case click = "Click"
    case transition = "Transition"
    case optimizeStart = "OptimizeStart"
    case optimizeComplete = "OptimizeComplete"
    case scoreUp = "ScoreUp"
    case alert = "Alert"
    case ringWake = "RingWake"
    case ringSleep = "RingSleep"
}

struct AudioPositionWrapper: Codable {
    var x: Float
    var y: Float
    var z: Float
}
```
  </action>
  <verify>
```bash
grep -l "class EffectExecutor" opta-native/OptaApp/OptaApp/Bridge/EffectExecutor.swift
grep -l "executeHaptic" opta-native/OptaApp/OptaApp/Bridge/EffectExecutor.swift
```
Expected: Both found
  </verify>
  <done>EffectExecutor.swift created with haptic, audio, timer, and notification bridging</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] OptaCoreManager.swift exists with @Observable and dispatch method
- [ ] OptaViewModel.swift contains all ViewModel types matching Rust
- [ ] OptaEvent enum covers common user actions
- [ ] EffectExecutor.swift handles haptic, timer, notification effects
- [ ] `xcodebuild` compiles without errors
- [ ] OptaCoreManager can be instantiated in preview
</verification>

<success_criteria>
- SwiftUI views can access viewModel via OptaCoreManager
- Events dispatched from SwiftUI flow to Crux and back
- Haptic effects trigger native feedback via HapticsManager
- Timer effects work for periodic updates
- All types compile without errors
</success_criteria>

<output>
After completion, create `.planning/phases/69-opta-core-integration/69-02-SUMMARY.md`
</output>
