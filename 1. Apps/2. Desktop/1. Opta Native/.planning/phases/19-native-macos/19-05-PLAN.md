---
phase: 19-native-macos
plan: 05
type: execute
wave: 3
depends_on: ["19-02"]
files_modified: [OptaNative/Services/TelemetryService.swift, OptaNative/ViewModels/TelemetryViewModel.swift, OptaNative/Services/ProcessService.swift]
autonomous: true
---

<objective>
Create hardware telemetry services using @Observable pattern for real-time monitoring.

Purpose: Provide live CPU/GPU temperatures, memory usage, and process data to UI components with automatic SwiftUI updates.
Output: TelemetryService with background polling and TelemetryViewModel for views.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-native-macos/19-RESEARCH.md
@.planning/phases/19-native-macos/19-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TelemetryService with background polling</name>
  <files>OptaNative/Services/TelemetryService.swift</files>
  <action>
Create TelemetryService that aggregates all hardware readings:

```swift
import Foundation

actor TelemetryService {
    private let sensorReader = SensorReader()
    private var pollingTask: Task<Void, Never>?

    struct Snapshot {
        let cpuTemperature: Double?
        let gpuTemperature: Double?
        let cpuUsage: Double
        let memoryUsed: UInt64
        let memoryTotal: UInt64
        let fanSpeeds: [Int]
        let timestamp: Date
    }

    func startPolling(interval: TimeInterval = 1.0, onUpdate: @escaping (Snapshot) -> Void) {
        pollingTask = Task {
            while !Task.isCancelled {
                let snapshot = await collectSnapshot()
                onUpdate(snapshot)
                try? await Task.sleep(nanoseconds: UInt64(interval * 1_000_000_000))
            }
        }
    }

    func stopPolling() {
        pollingTask?.cancel()
    }

    private func collectSnapshot() async -> Snapshot {
        // Use SensorReader for temps
        // Use host_processor_info for CPU usage
        // Use host_statistics64 for memory
    }
}
```

CRITICAL: Use actor for thread safety. Dispatch SMC reads on background - never block main thread.
Poll at 1-second intervals (sufficient for monitoring, faster wastes CPU per research).
  </action>
  <verify>TelemetryService().startPolling() produces snapshots every second</verify>
  <done>Telemetry service polls and produces snapshots</done>
</task>

<task type="auto">
  <name>Task 2: Create TelemetryViewModel with @Observable</name>
  <files>OptaNative/ViewModels/TelemetryViewModel.swift</files>
  <action>
Create @Observable view model that bridges TelemetryService to SwiftUI:

```swift
import SwiftUI

@Observable
class TelemetryViewModel {
    var cpuTemperature: Double = 0
    var gpuTemperature: Double = 0
    var cpuUsage: Double = 0
    var memoryUsedGB: Double = 0
    var memoryTotalGB: Double = 0
    var memoryPercent: Double = 0
    var fanSpeeds: [Int] = []
    var isMonitoring: Bool = false
    var chipName: String = "Unknown"

    private let service = TelemetryService()

    func startMonitoring() async {
        chipName = ChipDetection.getChipGeneration()
        isMonitoring = true

        await service.startPolling { [weak self] snapshot in
            Task { @MainActor in
                self?.updateFromSnapshot(snapshot)
            }
        }
    }

    @MainActor
    private func updateFromSnapshot(_ snapshot: TelemetryService.Snapshot) {
        cpuTemperature = snapshot.cpuTemperature ?? 0
        gpuTemperature = snapshot.gpuTemperature ?? 0
        cpuUsage = snapshot.cpuUsage
        // etc.
    }
}
```

Use @Observable (macOS 14+) not ObservableObject - cleaner, better performance per research.
Ensure all UI updates happen on @MainActor.
  </action>
  <verify>TelemetryViewModel updates trigger SwiftUI view refreshes</verify>
  <done>View model updates UI automatically via @Observable</done>
</task>

<task type="auto">
  <name>Task 3: Create ProcessService for process listing</name>
  <files>OptaNative/Services/ProcessService.swift</files>
  <action>
Create ProcessService for non-privileged process operations:

```swift
import Foundation

struct ProcessInfo: Identifiable {
    let id: Int32  // PID
    let name: String
    let user: String
    let cpuUsage: Double
    let memoryMB: Double
    let isSystem: Bool
}

class ProcessService {
    func getRunningProcesses() -> [ProcessInfo] {
        var processes: [ProcessInfo] = []
        var pids = [pid_t](repeating: 0, count: 2048)
        let count = proc_listallpids(&pids, Int32(pids.count * MemoryLayout<pid_t>.size))

        for i in 0..<Int(count) {
            let pid = pids[i]
            guard pid > 0 else { continue }

            var info = proc_bsdinfo()
            let size = proc_pidinfo(pid, PROC_PIDTBSDINFO, 0, &info, Int32(MemoryLayout.size(ofValue: info)))

            if size > 0 {
                // Extract name, user, determine if system process
                // Add to processes array
            }
        }

        return processes.sorted { $0.cpuUsage > $1.cpuUsage }
    }

    func categorizeProcess(_ process: ProcessInfo) -> ProcessCategory {
        // Stealth Mode categories: essential, user, bloatware
    }
}
```

Use BSD proc_* APIs per research - don't hand-roll with sysctl.
Process termination is handled by HelperManager (privileged), not here.
  </action>
  <verify>ProcessService().getRunningProcesses() returns list of running processes</verify>
  <done>Process listing works, returns sorted by CPU usage</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `xcodebuild -scheme OptaNative build` succeeds
- [ ] TelemetryService polls at 1-second intervals
- [ ] TelemetryViewModel triggers UI updates
- [ ] CPU/GPU temperatures report sensible values
- [ ] ProcessService lists running processes
- [ ] No main thread blocking during monitoring
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Real-time telemetry flowing
- Process list available for Stealth Mode UI
- Foundation ready for MenuBar and Dashboard
</success_criteria>

<output>
After completion, create `.planning/phases/19-native-macos/19-05-SUMMARY.md`
</output>
