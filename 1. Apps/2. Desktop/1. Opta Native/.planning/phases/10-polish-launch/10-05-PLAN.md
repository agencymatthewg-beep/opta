---
phase: 10-polish-launch
plan: 05
type: execute
wave: 2
depends_on: [10-04]
files_modified: [src/components/visualizations/GpuPipelineViz.tsx, src/components/visualizations/MemoryHierarchyViz.tsx, src/components/visualizations/ThermalViz.tsx, src/components/visualizations/BeforeAfterDiff.tsx, src/components/visualizations/ImpactPrediction.tsx, src/components/visualizations/index.ts]
autonomous: true
---

<objective>
Create visual explanation components with diagrams and animations for hardware concepts.

Purpose: Help users understand complex optimization concepts through interactive visualizations. These components activate within Learn Mode to show GPU pipeline flow, memory hierarchy, thermal throttling, before/after diffs, and impact predictions.

Output: Reusable visualization components with Framer Motion animations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/MUST_HAVE.md
@.planning/phases/10-polish-launch/10-CONTEXT.md
@DESIGN_SYSTEM.md
@src/components/LearnModeContext.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: GPU Pipeline Visualization</name>
  <files>src/components/visualizations/GpuPipelineViz.tsx</files>
  <action>
Create an animated visualization of the GPU rendering pipeline:

```tsx
// src/components/visualizations/GpuPipelineViz.tsx
import { motion } from 'framer-motion';
import { useLearnMode } from '@/components/LearnModeContext';
import { cn } from '@/lib/utils';

interface GpuPipelineVizProps {
  resolution: { before: string; after: string };
  quality: { before: string; after: string };
  showComparison?: boolean;
}

export function GpuPipelineViz({ resolution, quality, showComparison = false }: GpuPipelineVizProps) {
  const { isLearnMode } = useLearnMode();

  if (!isLearnMode) return null;

  const stages = [
    { name: 'Geometry', desc: 'Vertices & triangles', icon: 'â–³' },
    { name: 'Rasterization', desc: 'Pixels to render', icon: 'â–¦' },
    { name: 'Shading', desc: 'Lighting & effects', icon: 'â˜€' },
    { name: 'Output', desc: 'Final frame', icon: 'ðŸ–¼' },
  ];

  return (
    <motion.div
      initial={{ opacity: 0, height: 0 }}
      animate={{ opacity: 1, height: 'auto' }}
      exit={{ opacity: 0, height: 0 }}
      className="glass-subtle rounded-xl p-4 my-4"
    >
      <h4 className="text-sm font-semibold mb-3">GPU Rendering Pipeline</h4>

      {/* Pipeline stages */}
      <div className="flex items-center gap-2 mb-4">
        {stages.map((stage, i) => (
          <motion.div
            key={stage.name}
            className="flex-1 text-center"
            initial={{ opacity: 0, y: 10 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: i * 0.1 }}
          >
            <div className="text-2xl mb-1">{stage.icon}</div>
            <div className="text-xs font-medium">{stage.name}</div>
            <div className="text-xs text-muted-foreground">{stage.desc}</div>
            {i < stages.length - 1 && (
              <motion.div
                className="absolute right-0 top-1/2 text-muted-foreground"
                animate={{ x: [0, 4, 0] }}
                transition={{ repeat: Infinity, duration: 1 }}
              >
                â†’
              </motion.div>
            )}
          </motion.div>
        ))}
      </div>

      {/* Resolution impact */}
      {showComparison && (
        <div className="grid grid-cols-2 gap-4 mt-4 pt-4 border-t border-border/30">
          <div>
            <div className="text-xs text-muted-foreground mb-1">Before</div>
            <div className="text-sm">{resolution.before}</div>
            <div className="text-xs text-muted-foreground">{quality.before} quality</div>
            <PixelGrid pixels={16} highlighted={16} label="All pixels rendered" />
          </div>
          <div>
            <div className="text-xs text-muted-foreground mb-1">After</div>
            <div className="text-sm text-success">{resolution.after}</div>
            <div className="text-xs text-muted-foreground">{quality.after} quality</div>
            <PixelGrid pixels={16} highlighted={9} label="Fewer pixels = faster" />
          </div>
        </div>
      )}

      <p className="text-xs text-muted-foreground mt-3">
        Lower resolution = fewer pixels to process = higher FPS. The GPU renders
        at lower resolution then upscales, trading some sharpness for speed.
      </p>
    </motion.div>
  );
}

function PixelGrid({ pixels, highlighted, label }: { pixels: number; highlighted: number; label: string }) {
  return (
    <div className="mt-2">
      <div className="grid grid-cols-4 gap-0.5 w-16 mx-auto">
        {[...Array(pixels)].map((_, i) => (
          <motion.div
            key={i}
            className={cn(
              "w-3 h-3 rounded-sm",
              i < highlighted ? "bg-primary" : "bg-muted"
            )}
            initial={{ scale: 0 }}
            animate={{ scale: 1 }}
            transition={{ delay: i * 0.02 }}
          />
        ))}
      </div>
      <div className="text-xs text-center mt-1 text-muted-foreground">{label}</div>
    </div>
  );
}
```
  </action>
  <verify>GPU pipeline visualization renders with animations</verify>
  <done>GPU Pipeline visualization created</done>
</task>

<task type="auto">
  <name>Task 2: Memory Hierarchy Visualization</name>
  <files>src/components/visualizations/MemoryHierarchyViz.tsx</files>
  <action>
Create a visualization of memory hierarchy and why RAM matters:

```tsx
// src/components/visualizations/MemoryHierarchyViz.tsx
import { motion } from 'framer-motion';
import { useLearnMode } from '@/components/LearnModeContext';
import { Cpu, HardDrive, MemoryStick } from 'lucide-react';

interface MemoryHierarchyVizProps {
  currentRamUsage: number;  // percentage
  recommendedHeadroom: number;  // percentage
}

export function MemoryHierarchyViz({ currentRamUsage, recommendedHeadroom }: MemoryHierarchyVizProps) {
  const { isLearnMode } = useLearnMode();

  if (!isLearnMode) return null;

  const layers = [
    { name: 'CPU Cache', speed: '~100GB/s', size: '64MB', icon: Cpu, color: 'bg-success' },
    { name: 'RAM', speed: '~50GB/s', size: '16-64GB', icon: MemoryStick, color: 'bg-primary' },
    { name: 'SSD/HDD', speed: '0.5-5GB/s', size: '500GB+', icon: HardDrive, color: 'bg-warning' },
  ];

  const isAtRisk = currentRamUsage > recommendedHeadroom;

  return (
    <motion.div
      initial={{ opacity: 0, height: 0 }}
      animate={{ opacity: 1, height: 'auto' }}
      exit={{ opacity: 0, height: 0 }}
      className="glass-subtle rounded-xl p-4 my-4"
    >
      <h4 className="text-sm font-semibold mb-3">Memory Hierarchy</h4>

      {/* Pyramid visualization */}
      <div className="flex flex-col items-center gap-1 mb-4">
        {layers.map((layer, i) => (
          <motion.div
            key={layer.name}
            className={cn(
              "flex items-center justify-center gap-2 rounded-lg px-3 py-2",
              layer.color,
              "text-white"
            )}
            style={{ width: `${60 + i * 30}%` }}
            initial={{ scaleX: 0 }}
            animate={{ scaleX: 1 }}
            transition={{ delay: i * 0.15 }}
          >
            <layer.icon className="w-4 h-4" />
            <span className="text-xs font-medium">{layer.name}</span>
            <span className="text-xs opacity-75">{layer.speed}</span>
          </motion.div>
        ))}
      </div>

      {/* Current state indicator */}
      <div className="flex items-center gap-2 mt-3 p-2 rounded-lg bg-card/50">
        <div className={cn(
          "w-2 h-2 rounded-full",
          isAtRisk ? "bg-warning animate-pulse" : "bg-success"
        )} />
        <span className="text-xs">
          {isAtRisk
            ? `RAM at ${currentRamUsage}% - may use slow disk swap`
            : `RAM at ${currentRamUsage}% - good headroom for gaming`
          }
        </span>
      </div>

      <p className="text-xs text-muted-foreground mt-3">
        Faster memory = faster data access. When RAM fills up, Windows uses your
        SSD/HDD as "virtual memory" which is 10-100x slower, causing stutters.
      </p>
    </motion.div>
  );
}
```
  </action>
  <verify>Memory hierarchy visualization renders correctly</verify>
  <done>Memory Hierarchy visualization created</done>
</task>

<task type="auto">
  <name>Task 3: Thermal Throttling Visualization</name>
  <files>src/components/visualizations/ThermalViz.tsx</files>
  <action>
Create a visualization showing thermal throttling:

```tsx
// src/components/visualizations/ThermalViz.tsx
import { motion } from 'framer-motion';
import { useLearnMode } from '@/components/LearnModeContext';
import { Thermometer, Flame, Snowflake } from 'lucide-react';

interface ThermalVizProps {
  currentTemp: number;  // Celsius
  throttleTemp: number;  // Celsius (typically 85-95)
  component: 'cpu' | 'gpu';
}

export function ThermalViz({ currentTemp, throttleTemp, component }: ThermalVizProps) {
  const { isLearnMode } = useLearnMode();

  if (!isLearnMode) return null;

  const percentage = Math.min((currentTemp / throttleTemp) * 100, 100);
  const isThrottling = currentTemp >= throttleTemp;
  const isWarning = currentTemp >= throttleTemp - 10;

  const zones = [
    { label: 'Cool', range: '< 60Â°C', color: 'bg-success', icon: Snowflake },
    { label: 'Normal', range: '60-75Â°C', color: 'bg-primary', icon: Thermometer },
    { label: 'Warm', range: '75-85Â°C', color: 'bg-warning', icon: Thermometer },
    { label: 'Throttle', range: '> 85Â°C', color: 'bg-danger', icon: Flame },
  ];

  return (
    <motion.div
      initial={{ opacity: 0, height: 0 }}
      animate={{ opacity: 1, height: 'auto' }}
      exit={{ opacity: 0, height: 0 }}
      className="glass-subtle rounded-xl p-4 my-4"
    >
      <h4 className="text-sm font-semibold mb-3">
        {component.toUpperCase()} Thermal State
      </h4>

      {/* Temperature gauge */}
      <div className="relative h-6 bg-card rounded-full overflow-hidden mb-3">
        <motion.div
          className={cn(
            "h-full rounded-full",
            isThrottling ? "bg-danger" : isWarning ? "bg-warning" : "bg-primary"
          )}
          initial={{ width: 0 }}
          animate={{ width: `${percentage}%` }}
          transition={{ duration: 0.8, ease: "easeOut" }}
        />
        <div className="absolute inset-0 flex items-center justify-center text-xs font-medium">
          {currentTemp}Â°C / {throttleTemp}Â°C
        </div>
      </div>

      {/* Zone legend */}
      <div className="grid grid-cols-4 gap-1 mb-3">
        {zones.map((zone) => (
          <div key={zone.label} className="text-center">
            <zone.icon className={cn("w-4 h-4 mx-auto", zone.color.replace('bg-', 'text-'))} />
            <div className="text-xs font-medium">{zone.label}</div>
            <div className="text-xs text-muted-foreground">{zone.range}</div>
          </div>
        ))}
      </div>

      {/* Throttling explanation */}
      {isThrottling && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          className="p-2 rounded-lg bg-danger/20 border border-danger/30"
        >
          <div className="text-xs text-danger font-medium">Thermal Throttling Active</div>
          <div className="text-xs text-danger/80">
            Your {component.toUpperCase()} is reducing clock speed to cool down.
            Performance is currently limited.
          </div>
        </motion.div>
      )}

      <p className="text-xs text-muted-foreground mt-3">
        Hardware reduces performance when too hot to prevent damage.
        Better cooling or undervolting can prevent throttling and maintain peak FPS.
      </p>
    </motion.div>
  );
}
```
  </action>
  <verify>Thermal visualization shows correct state and animations</verify>
  <done>Thermal Throttling visualization created</done>
</task>

<task type="auto">
  <name>Task 4: Before/After Diff Visualization</name>
  <files>src/components/visualizations/BeforeAfterDiff.tsx</files>
  <action>
Create a visual diff component for settings changes:

```tsx
// src/components/visualizations/BeforeAfterDiff.tsx
import { motion } from 'framer-motion';
import { useLearnMode } from '@/components/LearnModeContext';
import { ArrowRight, TrendingUp, TrendingDown, Minus } from 'lucide-react';
import { cn } from '@/lib/utils';

interface SettingChange {
  name: string;
  before: string;
  after: string;
  impact: 'positive' | 'negative' | 'neutral';
  fpsGain?: number;
  qualityLoss?: 'none' | 'minor' | 'moderate' | 'significant';
}

interface BeforeAfterDiffProps {
  changes: SettingChange[];
  totalFpsGain: number;
}

export function BeforeAfterDiff({ changes, totalFpsGain }: BeforeAfterDiffProps) {
  const { isLearnMode } = useLearnMode();

  if (!isLearnMode) return null;

  return (
    <motion.div
      initial={{ opacity: 0, height: 0 }}
      animate={{ opacity: 1, height: 'auto' }}
      exit={{ opacity: 0, height: 0 }}
      className="glass-subtle rounded-xl p-4 my-4"
    >
      <div className="flex items-center justify-between mb-3">
        <h4 className="text-sm font-semibold">What Changed</h4>
        <div className="text-sm font-medium text-success">
          +{totalFpsGain} FPS expected
        </div>
      </div>

      <div className="space-y-2">
        {changes.map((change, i) => (
          <motion.div
            key={change.name}
            className="flex items-center gap-2 p-2 rounded-lg bg-card/50"
            initial={{ opacity: 0, x: -10 }}
            animate={{ opacity: 1, x: 0 }}
            transition={{ delay: i * 0.05 }}
          >
            {/* Impact indicator */}
            <div className={cn(
              "w-6 h-6 rounded-full flex items-center justify-center",
              change.impact === 'positive' && "bg-success/20 text-success",
              change.impact === 'negative' && "bg-danger/20 text-danger",
              change.impact === 'neutral' && "bg-muted text-muted-foreground"
            )}>
              {change.impact === 'positive' && <TrendingUp className="w-3 h-3" />}
              {change.impact === 'negative' && <TrendingDown className="w-3 h-3" />}
              {change.impact === 'neutral' && <Minus className="w-3 h-3" />}
            </div>

            {/* Setting name */}
            <div className="flex-1">
              <div className="text-sm font-medium">{change.name}</div>
              {change.fpsGain && (
                <div className="text-xs text-success">+{change.fpsGain} FPS</div>
              )}
            </div>

            {/* Before/After values */}
            <div className="flex items-center gap-2 text-xs">
              <span className="text-muted-foreground line-through">{change.before}</span>
              <ArrowRight className="w-3 h-3 text-muted-foreground" />
              <span className="text-primary font-medium">{change.after}</span>
            </div>

            {/* Quality impact */}
            {change.qualityLoss && change.qualityLoss !== 'none' && (
              <div className={cn(
                "text-xs px-1.5 py-0.5 rounded",
                change.qualityLoss === 'minor' && "bg-success/20 text-success",
                change.qualityLoss === 'moderate' && "bg-warning/20 text-warning",
                change.qualityLoss === 'significant' && "bg-danger/20 text-danger"
              )}>
                {change.qualityLoss} quality impact
              </div>
            )}
          </motion.div>
        ))}
      </div>

      <p className="text-xs text-muted-foreground mt-3">
        Green arrows indicate performance gains. Each change shows expected FPS
        improvement and any visual quality trade-off.
      </p>
    </motion.div>
  );
}
```
  </action>
  <verify>Before/After diff renders with animations and correct indicators</verify>
  <done>Before/After Diff visualization created</done>
</task>

<task type="auto">
  <name>Task 5: Impact Prediction Visualization</name>
  <files>src/components/visualizations/ImpactPrediction.tsx</files>
  <action>
Create animated impact prediction before applying changes:

```tsx
// src/components/visualizations/ImpactPrediction.tsx
import { motion, AnimatePresence } from 'framer-motion';
import { useLearnMode } from '@/components/LearnModeContext';
import { Gauge, Eye, Zap, Clock } from 'lucide-react';
import { cn } from '@/lib/utils';

interface ImpactPredictionProps {
  predictedFps: { before: number; after: number };
  predictedQuality: { before: number; after: number };  // 0-100
  predictedThermal: { before: number; after: number };  // Celsius
  predictedLoadTime: { before: number; after: number };  // Seconds
  confidence: 'high' | 'medium' | 'low';
}

export function ImpactPrediction({
  predictedFps,
  predictedQuality,
  predictedThermal,
  predictedLoadTime,
  confidence,
}: ImpactPredictionProps) {
  const { isLearnMode } = useLearnMode();

  if (!isLearnMode) return null;

  const metrics = [
    {
      label: 'FPS',
      icon: Gauge,
      before: predictedFps.before,
      after: predictedFps.after,
      unit: '',
      higherIsBetter: true,
    },
    {
      label: 'Quality',
      icon: Eye,
      before: predictedQuality.before,
      after: predictedQuality.after,
      unit: '%',
      higherIsBetter: true,
    },
    {
      label: 'GPU Temp',
      icon: Zap,
      before: predictedThermal.before,
      after: predictedThermal.after,
      unit: 'Â°C',
      higherIsBetter: false,
    },
    {
      label: 'Load Time',
      icon: Clock,
      before: predictedLoadTime.before,
      after: predictedLoadTime.after,
      unit: 's',
      higherIsBetter: false,
    },
  ];

  return (
    <motion.div
      initial={{ opacity: 0, height: 0 }}
      animate={{ opacity: 1, height: 'auto' }}
      exit={{ opacity: 0, height: 0 }}
      className="glass-subtle rounded-xl p-4 my-4"
    >
      <div className="flex items-center justify-between mb-3">
        <h4 className="text-sm font-semibold">Predicted Impact</h4>
        <div className={cn(
          "text-xs px-2 py-0.5 rounded-full",
          confidence === 'high' && "bg-success/20 text-success",
          confidence === 'medium' && "bg-warning/20 text-warning",
          confidence === 'low' && "bg-muted text-muted-foreground"
        )}>
          {confidence} confidence
        </div>
      </div>

      <div className="grid grid-cols-2 gap-3">
        {metrics.map((metric, i) => {
          const diff = metric.after - metric.before;
          const isImprovement = metric.higherIsBetter ? diff > 0 : diff < 0;
          const displayDiff = metric.higherIsBetter ? diff : -diff;

          return (
            <motion.div
              key={metric.label}
              className="p-3 rounded-lg bg-card/50"
              initial={{ opacity: 0, scale: 0.95 }}
              animate={{ opacity: 1, scale: 1 }}
              transition={{ delay: i * 0.1 }}
            >
              <div className="flex items-center gap-2 mb-2">
                <metric.icon className="w-4 h-4 text-muted-foreground" />
                <span className="text-xs font-medium">{metric.label}</span>
              </div>

              {/* Animated number */}
              <div className="flex items-baseline gap-2">
                <motion.span
                  className="text-xl font-bold"
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                >
                  <CountUp from={metric.before} to={metric.after} duration={1} />
                  {metric.unit}
                </motion.span>
                <span className={cn(
                  "text-sm font-medium",
                  isImprovement ? "text-success" : diff === 0 ? "text-muted-foreground" : "text-warning"
                )}>
                  {displayDiff > 0 && '+'}{displayDiff}{metric.unit}
                </span>
              </div>

              {/* Progress bar animation */}
              <div className="mt-2 h-1.5 bg-muted rounded-full overflow-hidden">
                <motion.div
                  className={cn(
                    "h-full rounded-full",
                    isImprovement ? "bg-success" : "bg-warning"
                  )}
                  initial={{ width: `${(metric.before / Math.max(metric.before, metric.after)) * 100}%` }}
                  animate={{ width: `${(metric.after / Math.max(metric.before, metric.after)) * 100}%` }}
                  transition={{ duration: 1, ease: "easeOut" }}
                />
              </div>
            </motion.div>
          );
        })}
      </div>

      <p className="text-xs text-muted-foreground mt-3">
        Predictions based on similar hardware configurations. Actual results
        may vary. Run a benchmark after applying to confirm gains.
      </p>
    </motion.div>
  );
}

// Animated counter component
function CountUp({ from, to, duration }: { from: number; to: number; duration: number }) {
  const [value, setValue] = useState(from);

  useEffect(() => {
    const steps = 30;
    const increment = (to - from) / steps;
    let current = from;
    const interval = setInterval(() => {
      current += increment;
      if ((increment > 0 && current >= to) || (increment < 0 && current <= to)) {
        setValue(to);
        clearInterval(interval);
      } else {
        setValue(Math.round(current));
      }
    }, (duration * 1000) / steps);

    return () => clearInterval(interval);
  }, [from, to, duration]);

  return <>{value}</>;
}
```
  </action>
  <verify>Impact prediction shows animated transitions between before/after values</verify>
  <done>Impact Prediction visualization created</done>
</task>

<task type="auto">
  <name>Task 6: Create visualization index and integrate</name>
  <files>src/components/visualizations/index.ts, src/pages/Games.tsx</files>
  <action>
Create index file and integrate visualizations into Games page:

```tsx
// src/components/visualizations/index.ts
export { GpuPipelineViz } from './GpuPipelineViz';
export { MemoryHierarchyViz } from './MemoryHierarchyViz';
export { ThermalViz } from './ThermalViz';
export { BeforeAfterDiff } from './BeforeAfterDiff';
export { ImpactPrediction } from './ImpactPrediction';
```

In Games.tsx, add visualizations to the optimization preview:

```tsx
import {
  GpuPipelineViz,
  BeforeAfterDiff,
  ImpactPrediction
} from '@/components/visualizations';

// In optimization preview section:
<GpuPipelineViz
  resolution={{ before: '1440p', after: '1080p' }}
  quality={{ before: 'Ultra', after: 'High' }}
  showComparison
/>

<BeforeAfterDiff
  changes={optimizationChanges}
  totalFpsGain={estimatedFpsGain}
/>

<ImpactPrediction
  predictedFps={{ before: 60, after: 85 }}
  predictedQuality={{ before: 100, after: 85 }}
  predictedThermal={{ before: 82, after: 75 }}
  predictedLoadTime={{ before: 12, after: 10 }}
  confidence="medium"
/>
```

In Dashboard.tsx, add thermal and memory visualizations:

```tsx
import { ThermalViz, MemoryHierarchyViz } from '@/components/visualizations';

// Near GPU telemetry card:
<ThermalViz
  currentTemp={gpuTemp}
  throttleTemp={85}
  component="gpu"
/>

// Near Memory telemetry card:
<MemoryHierarchyViz
  currentRamUsage={memoryPercentage}
  recommendedHeadroom={80}
/>
```
  </action>
  <verify>Visualizations appear in Games and Dashboard when Learn Mode is on</verify>
  <done>Visualizations integrated into pages</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All 5 visualization components created
- [ ] Components only render when Learn Mode is on
- [ ] Animations are smooth and informative
- [ ] Visualizations integrated into Games page (optimization preview)
- [ ] Visualizations integrated into Dashboard (telemetry context)
- [ ] `npm run build` succeeds
</verification>

<success_criteria>
- All tasks completed
- GPU Pipeline shows rendering stages and resolution impact
- Memory Hierarchy shows speed/size tradeoffs
- Thermal Viz shows throttling zones and current state
- Before/After Diff shows settings changes with impact
- Impact Prediction shows animated metric transitions
- All visualizations match design system (glass, Framer Motion, colors)
</success_criteria>

<output>
After completion, create `.planning/phases/10-polish-launch/10-05-SUMMARY.md`
</output>
