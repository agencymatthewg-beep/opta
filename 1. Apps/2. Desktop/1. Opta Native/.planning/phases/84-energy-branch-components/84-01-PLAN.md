---
phase: 84-energy-branch-components
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - opta-native/opta-render/shaders/branch_meter.wgsl
  - opta-native/opta-render/shaders/branch_indicator.wgsl
  - opta-native/opta-render/shaders/branch_border.wgsl
  - opta-native/opta-render/src/components/branch_meter.rs
  - opta-native/opta-render/src/components/branch_indicator.rs
  - opta-native/opta-render/src/components/branch_border.rs
  - opta-native/opta-render/src/components/mod.rs
autonomous: true
---

<objective>
Create reusable branch-energy GPU components for telemetry meters, status indicators, and panel borders.

These are the v11.0 obsidian aesthetic's answer to progress bars, status dots, and panel decorations. Instead of flat linear fills, energy flows organically through branch veins — growing, pulsing, and responding to real-time telemetry data via tri-axis response (reach, width, brightness).

Purpose: Establish the branch-energy component library that Phase 85 (Dashboard Obsidian Refresh) will consume for telemetry cards, score displays, and quick actions.

Output: 3 new Rust GPU components with WGSL shaders — BranchMeter, BranchIndicator, BranchBorder — all rendering through the existing wgpu pipeline.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@opta-native/opta-render/shaders/includes/branch_energy.wgsl
@opta-native/opta-render/shaders/includes/edge_branch.wgsl
@opta-native/opta-render/src/components/mod.rs
@opta-native/opta-render/src/components/cpu_meter.rs
@opta-native/opta-render/src/components/glass_panel.rs
</context>

<tasks>
<task type="auto">
  <name>Task 1: BranchMeter WGSL shader</name>
  <files>opta-native/opta-render/shaders/branch_meter.wgsl</files>
  <action>
  Create a full-screen quad shader that renders a horizontal meter filled with branch energy veins.

  **Concept**: Replaces linear progress bars. Energy level (0-1) controls how far branches extend from left to right. At 0% = empty dark obsidian. At 100% = fully alive with pulsing violet branches.

  **Uniforms (BranchMeterUniforms)**:
  - `position`: vec2f — screen position (top-left corner, pixels)
  - `size`: vec2f — meter dimensions (width × height, pixels)
  - `corner_radius`: f32 — rounded corners (pixels)
  - `fill_level`: f32 — current value [0,1] (how far branches extend)
  - `energy`: f32 — overall energy/intensity [0,1] (controls branch brightness and pulse speed)
  - `time`: f32 — animation time (seconds)
  - `base_color`: vec3f — obsidian base (default: vec3(0.035, 0.035, 0.05))
  - `branch_speed`: f32 — pulse animation speed (default: 0.3)
  - `branch_density`: f32 — branches per unit (default: 6.0)
  - `quality_level`: u32 — 0=Low, 1=Medium, 2=High, 3=Ultra
  - `resolution`: vec2f — viewport resolution for coordinate mapping
  - Pad to 16-byte alignment (total: 112 bytes, 7 × vec4-aligned groups)

  **Vertex shader**: Full-screen quad (4 vertices, triangle strip). Pass UV coordinates to fragment.

  **Fragment shader logic**:
  1. Compute local position relative to meter bounds (position + size)
  2. SDF rounded rectangle for meter shape — discard fragments outside
  3. Compute horizontal fill: `fill_x = local.x / size.x`. If `fill_x > fill_level`, render only obsidian base (no branches)
  4. In the filled region, compute branch energy:
     - Map local position to UV space (x=[0,fill_level], y=[0,1])
     - Tri-axis response: reach = mix(0.1, 0.8, energy), width = mix(0.03, 0.15, energy), brightness = mix(0.3, 1.5, energy)
     - Branch pattern: Use cell-based approach from edge_branch.wgsl — `scaled_pos = uv.x * branch_density`, per-cell phase offset via `fract(sin(cell * 127.1) * 43758.5453) * TAU`
     - Pulse: `sin((scaled_pos + (time + phase) * branch_speed) * TAU) * 0.5 + 0.5`
     - Width mask: concentrate into veins with `1.0 - smoothstep(0.0, width, abs(cell_frac - 0.5))`
     - Vertical reach mask: branches strongest at center (y=0.5), fade toward top/bottom edges
  5. Fill edge: Soft transition at the fill boundary — `smoothstep(fill_level - 0.02, fill_level, fill_x)` fades branches to zero
  6. Branch color: Electric Violet base (#8B5CF6 = vec3(0.545, 0.361, 0.965)), blend toward white-hot at high intensity
  7. Final color: `mix(base_color, base_color + branch_emission, branch_intensity)`
  8. At quality_level 0 (Low): Skip branch animation, render flat fill with violet tint at fill_level
  9. At quality_level >= 2 (High+): Add subtle noise perturbation to branch positions for organic feel

  **Reduced motion**: When energy is exactly 0.0, freeze animation (treat time as 0.0). This allows Swift to pass energy=0 for reduced motion.

  Do NOT include edge_branch.wgsl or branch_energy.wgsl — this shader is self-contained with adapted branch logic for the rectangular meter context.
  </action>
  <verify>`cargo build --release -p opta-render` compiles without errors</verify>
  <done>branch_meter.wgsl exists with BranchMeterUniforms struct, vertex shader, and fragment shader implementing fill-level-gated branch energy</done>
</task>

<task type="auto">
  <name>Task 2: BranchIndicator WGSL shader</name>
  <files>opta-native/opta-render/shaders/branch_indicator.wgsl</files>
  <action>
  Create a shader for a circular status indicator that grows/shrinks branch veins radially.

  **Concept**: Replaces status dots. A small circle (typically 8-16px radius) with branches radiating outward. At idle = small dormant circle. At active = branches extend outward like a tiny star. Energy level controls branch reach and pulse intensity.

  **Uniforms (BranchIndicatorUniforms)**:
  - `center`: vec2f — screen center position (pixels)
  - `inner_radius`: f32 — solid core radius (pixels, typically 4-8)
  - `outer_radius`: f32 — maximum branch reach (pixels, typically 12-20)
  - `energy`: f32 — overall energy [0,1] (controls branch extension + brightness)
  - `time`: f32 — animation time
  - `base_color`: vec3f — obsidian core color
  - `branch_count`: f32 — number of radial branches (default: 6.0)
  - `branch_speed`: f32 — pulse speed
  - `quality_level`: u32
  - `resolution`: vec2f
  - Pad to 16-byte alignment (total: 80 bytes, 5 × vec4-aligned groups)

  **Vertex shader**: Quad covering `center ± outer_radius` with margin. Pass UV.

  **Fragment shader logic**:
  1. Compute distance from center: `dist = length(frag_pos - center)`
  2. If `dist > outer_radius + 1.0`: discard (anti-alias margin)
  3. Core circle: If `dist < inner_radius`, render solid obsidian with subtle violet tint at high energy
  4. Branch region (`inner_radius < dist < outer_radius`):
     - Compute angle: `theta = atan2(dy, dx)` → normalize to [0,1]
     - Radial reach: `max_reach = mix(inner_radius, outer_radius, energy)` — branches grow with energy
     - If dist > max_reach: transparent (branches haven't reached here)
     - Angular branch pattern: `cell = floor(theta * branch_count)`, per-cell phase offset
     - Width mask: angular concentration into thin radial veins
     - Pulse animation: per-branch phase-offset sine wave
     - Fade with distance: `1.0 - smoothstep(inner_radius, max_reach, dist)` — branches fade outward
  5. Branch color: Electric Violet, white-hot at tips when energy > 0.8
  6. Anti-alias outer edge: `smoothstep` at outer_radius boundary
  7. Quality_level 0: solid colored circle (no branches), just `inner_radius` dot with color based on energy
  8. Reduced motion (energy = 0): static branch positions (time treated as 0)
  </action>
  <verify>`cargo build --release -p opta-render` compiles without errors</verify>
  <done>branch_indicator.wgsl exists with radial branch pattern growing/shrinking with energy level</done>
</task>

<task type="auto">
  <name>Task 3: BranchBorder WGSL shader</name>
  <files>opta-native/opta-render/shaders/branch_border.wgsl</files>
  <action>
  Create a shader for rectangular panel borders with pulsing branch veins flowing along the edges.

  **Concept**: A standalone border decoration (no fill — the panel content is rendered separately). Branches flow continuously around the border perimeter, with per-branch phase offsets for organic pulsing. Energy controls how many branches are visible and how bright they pulse.

  **Uniforms (BranchBorderUniforms)**:
  - `position`: vec2f — panel top-left (pixels)
  - `size`: vec2f — panel dimensions (pixels)
  - `corner_radius`: f32 — rounded corners
  - `border_width`: f32 — how thick the branch band is (pixels, typically 2-6)
  - `energy`: f32 — overall energy [0,1]
  - `time`: f32 — animation time
  - `branch_speed`: f32 — flow speed along perimeter
  - `branch_density`: f32 — branches per 100px of edge
  - `quality_level`: u32
  - `resolution`: vec2f
  - Pad to 16-byte alignment (total: 96 bytes, 6 × vec4-aligned groups)

  **Vertex shader**: Quad covering panel bounds + border_width margin.

  **Fragment shader logic**:
  1. Compute SDF for rounded rectangle (panel bounds)
  2. Compute edge distance: `edge_dist = abs(sdf)` — distance from the panel edge (0 = on edge)
  3. Border mask: `1.0 - smoothstep(0.0, border_width, edge_dist)` — only render within border band
  4. If border_mask < 0.01: discard (not in border region)
  5. Compute perimeter coordinate using the same `edge_perimeter_coord` approach as edge_branch.wgsl:
     - `local_pos = frag_pos - panel_center`
     - `angle = atan2(local_pos.y / half_size.y, local_pos.x / half_size.x)`
     - Map to [0,1] continuous perimeter position
  6. Branch pattern along perimeter:
     - `scaled_pos = perimeter * perimeter_length * branch_density * 0.01`
     - Per-branch cell with phase offset (same hash as edge_branch.wgsl)
     - Pulse: `sin((scaled_pos + (time + phase) * branch_speed) * TAU) * 0.5 + 0.5`
     - Width concentration: thin veins within each cell
     - Threshold revelation: `threshold = 1.0 - energy * 0.8`, fewer branches at low energy
  7. Branch color: Electric Violet → white-hot at peaks
  8. Output alpha: `border_mask * branch_intensity` — transparent where no branches
  9. Quality_level 0: solid subtle violet border line (no animation)
  10. Quality_level >= 2: add secondary harmonic (half-density layer at 60% speed for depth)
  11. Reduced motion: freeze at time=0

  This is conceptually similar to edge_branch.wgsl but standalone — it doesn't need panel uniforms, just border parameters. The key difference: edge_branch is embedded inside the obsidian panel shader. BranchBorder is a composable overlay that can be placed around ANY element.
  </action>
  <verify>`cargo build --release -p opta-render` compiles without errors</verify>
  <done>branch_border.wgsl exists with perimeter-flowing branch energy border pattern</done>
</task>

<task type="auto">
  <name>Task 4: Rust components for BranchMeter, BranchIndicator, BranchBorder</name>
  <files>
    opta-native/opta-render/src/components/branch_meter.rs
    opta-native/opta-render/src/components/branch_indicator.rs
    opta-native/opta-render/src/components/branch_border.rs
    opta-native/opta-render/src/components/mod.rs
  </files>
  <action>
  Create Rust component structs following the CpuMeter/MemoryMeter pattern. Each component manages its own wgpu pipeline, vertex buffer, uniform buffer, and bind group.

  **Pattern to follow** (from cpu_meter.rs / memory_meter.rs):
  - `struct XxxConfig` with builder defaults
  - `struct XxxUniforms` with `#[repr(C)]` matching the WGSL uniform struct exactly (same field order, same sizes, same padding)
  - `struct Xxx` with fields: pipeline, vertex_buffer, index_buffer (if needed), uniform_buffer, bind_group, config
  - `impl Xxx`:
    - `pub fn new(device: &wgpu::Device, surface_format: wgpu::TextureFormat, width: u32, height: u32) -> Self`
    - `pub fn resize(&mut self, width: u32, height: u32)` — update resolution in config
    - `pub fn render(&self, queue: &wgpu::Queue, encoder: &mut wgpu::CommandEncoder, output_view: &wgpu::TextureView, uniforms: &XxxUniforms)` — write uniforms + draw
  - Vertex type: simple position + uv quad (reuse MeterVertex from cpu_meter if compatible, or define own)
  - Pipeline: single bind group with uniform buffer at binding 0
  - Shader: include via `include_str!("../../shaders/branch_xxx.wgsl")`
  - Primitive topology: TriangleList with 6 indices (quad)
  - Blend state: Alpha blending (`SrcAlpha`, `OneMinusSrcAlpha`) for BranchIndicator and BranchBorder (they have transparent regions). BranchMeter can use opaque since it fills its entire rect.

  **BranchMeter specifics**:
  - `BranchMeterConfig`: position, size, corner_radius, branch_speed, branch_density, base_color, quality_level
  - `BranchMeterUniforms`: 112 bytes (7 × 16-byte groups). Fields match WGSL exactly.
  - Opaque blend (meter fills its entire rounded rect)

  **BranchIndicator specifics**:
  - `BranchIndicatorConfig`: center, inner_radius, outer_radius, branch_count, branch_speed, base_color, quality_level
  - `BranchIndicatorUniforms`: 80 bytes (5 × 16-byte groups). Fields match WGSL exactly.
  - Alpha blend (circular with transparent outside)
  - Vertex quad sized to `outer_radius * 2 + 4` (with AA margin)

  **BranchBorder specifics**:
  - `BranchBorderConfig`: position, size, corner_radius, border_width, branch_speed, branch_density, quality_level
  - `BranchBorderUniforms`: 96 bytes (6 × 16-byte groups). Fields match WGSL exactly.
  - Alpha blend (only border band is visible)

  **mod.rs updates**:
  Add three new module declarations and pub use exports:
  ```rust
  mod branch_border;
  mod branch_indicator;
  mod branch_meter;
  ```
  Export: BranchMeter, BranchMeterConfig, BranchMeterUniforms, BranchIndicator, BranchIndicatorConfig, BranchIndicatorUniforms, BranchBorder, BranchBorderConfig, BranchBorderUniforms.

  **Tests**: Each component gets basic tests:
  - `test_xxx_config_default()` — verify default config values are reasonable
  - `test_xxx_uniforms_size()` — assert `std::mem::size_of::<XxxUniforms>()` matches expected byte count
  - `test_xxx_uniforms_alignment()` — assert 16-byte alignment with `std::mem::align_of`

  Do NOT add FFI exports yet — those come in a later phase when SwiftUI views are wired up.
  Do NOT add to the render pipeline composition — these are standalone components that Phase 85 will integrate.
  </action>
  <verify>`cargo build --release -p opta-render` succeeds AND `cargo test -p opta-render` passes all tests (including the new uniform size/alignment tests)</verify>
  <done>3 new Rust components compile, uniform sizes match WGSL, all tests pass</done>
</task>
</tasks>

<verification>
Before declaring phase complete:
- [ ] `cargo build --release -p opta-render` succeeds without warnings
- [ ] `cargo test -p opta-render` passes all tests (existing + new)
- [ ] 3 new WGSL shaders exist in `opta-native/opta-render/shaders/`
- [ ] 3 new Rust component files in `opta-native/opta-render/src/components/`
- [ ] mod.rs exports all new types
- [ ] Uniform struct sizes match documented byte counts (112, 80, 96)
- [ ] All components use alpha blending where appropriate
- [ ] Reduced motion path exists (energy=0 freezes animation)
</verification>

<success_criteria>
- BranchMeter renders horizontal branch-energy fill responding to fill_level and energy
- BranchIndicator renders radial branches growing/shrinking with energy
- BranchBorder renders perimeter-flowing branch veins along panel edges
- All components support quality_level fallback (Low = static/simple)
- All components support reduced motion via energy=0 freeze
- Tri-axis response (reach, width, brightness) scales with energy in all components
- No new warnings in release build
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/84-energy-branch-components/84-01-SUMMARY.md`
</output>
